var tracer_files = [

/* --------------------- JsInterpreter.js --------------------- */
  { file: 'JsInterpreter.js', contents: 'var JsInterpreter = (function() {\nwith (Datatypes) {\nwith (JsCommon) {\nwith (JsCommonAux) {\nwith (JsInit) {\nwith (JsInterpreterMonads) {\nwith (JsSyntax) {\nwith (JsSyntaxAux) {\nwith (LibList) {\nwith (LibOption) {\nwith (LibProd) {\nwith (Shared) {\n\nvar equality_test_for_same_type = function (ty, v1, v2) {\n  switch (ty.tag) {\n    case "Coq_type_undef":\n      return (true);\n    case "Coq_type_null":\n      return (true);\n    case "Coq_type_bool":\n      return (value_compare(v1, v2));\n    case "Coq_type_number":\n      switch (v1.tag) {\n        case "Coq_value_undef":\n          return (false);\n        case "Coq_value_null":\n          return (false);\n        case "Coq_value_bool":\n          var b = v1.value;\n          return (false);\n        case "Coq_value_string":\n          var s = v1.value;\n          return (false);\n        case "Coq_value_number":\n          var n1 = v1.value;\n          switch (v2.tag) {\n            case "Coq_value_undef":\n              return (false);\n            case "Coq_value_null":\n              return (false);\n            case "Coq_value_bool":\n              var b = v2.value;\n              return (false);\n            case "Coq_value_string":\n              var s = v2.value;\n              return (false);\n            case "Coq_value_number":\n              var n2 = v2.value;\n              if (JsNumber.isnan(n1)) {\n                return (false);\n              } else {\n                if (JsNumber.isnan(n2)) {\n                  return (false);\n                } else {\n                  if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n                    return (true);\n                  } else {\n                    if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n                      return (true);\n                    } else {\n                      return ((n1 === n2));\n                    }\n                  }\n                }\n              }\n            case "Coq_value_object":\n              var o = v2.value;\n              return (false);\n          }\n          \n        case "Coq_value_object":\n          var o = v1.value;\n          return (false);\n      }\n      \n    case "Coq_type_string":\n      return (value_compare(v1, v2));\n    case "Coq_type_object":\n      return (value_compare(v1, v2));\n  }\n  \n};\n\n\n\nvar strict_equality_test = function (v1, v2) {\n  var ty1 = type_of(v1);\n  var ty2 = type_of(v2);\n  if (type_compare(ty1, ty2)) {\n    return (equality_test_for_same_type(ty1, v1, v2));\n  } else {\n    return (false);\n  }\n};\n\n\n\nvar inequality_test_number = function (n1, n2) {\n  if ((JsNumber.isnan(n1) || JsNumber.isnan(n2))) {\n    return (Coq_value_undef());\n  } else {\n    if ((n1 === n2)) {\n      return (Coq_value_bool(false));\n    } else {\n      if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n        return (Coq_value_bool(false));\n      } else {\n        if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n          return (Coq_value_bool(false));\n        } else {\n          if ((n1 === JsNumber.infinity)) {\n            return (Coq_value_bool(false));\n          } else {\n            if ((n2 === JsNumber.infinity)) {\n              return (Coq_value_bool(true));\n            } else {\n              if ((n2 === JsNumber.neg_infinity)) {\n                return (Coq_value_bool(false));\n              } else {\n                if ((n1 === JsNumber.neg_infinity)) {\n                  return (Coq_value_bool(true));\n                } else {\n                  return (Coq_value_bool((n1 < n2)));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n\n\nvar inequality_test_string = function (s1, s2) {\n  return (string_lt(s1, s2));\n};\n\n\n\nvar typeof_prim = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_undef":\n      return ("undefined");\n    case "Coq_value_null":\n      return ("object");\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      return ("boolean");\n    case "Coq_value_number":\n      var n = _foo_.value;\n      return ("number");\n    case "Coq_value_string":\n      var s = _foo_.value;\n      return ("string");\n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar string_of_propname = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_propname_identifier":\n      var s = _foo_.value;\n      return (s);\n    case "Coq_propname_string":\n      var s = _foo_.value;\n      return (s);\n    case "Coq_propname_number":\n      var n = _foo_.value;\n      return (JsNumber.to_string(n));\n  }\n  \n};\n\nvar run_object_method = function (proj, s, l) {\n  return (LibOption.map(proj, object_binds_option(s, l)));\n};\n\n\n\n\n\nvar run_object_set_internal = function (prj, s, l, v) {\n  return (\n    LibOption.map(function (o) { return (object_write(s, l, prj(o, v)));},\n      object_binds_option(s, l)));\n};\n\n\n\nvar run_object_heap_set_extensible = function (b, s, l) {\n  return (run_object_set_internal(object_set_extensible, s, l, b));\n};\n\nvar build_error = function (s, c, vproto, vmsg) {\n  var o = object_new(vproto, "Error");\n  var _tuple_arg_1 = object_alloc(s, o);\n  var l = _tuple_arg_1[0], s_2 = _tuple_arg_1[1];\n  if (value_compare(vmsg, Coq_value_undef())) {\n    return (res_out(s_2, res_val(Coq_value_object(l))));\n  } else {\n    return (\n      if_value(to_string(s_2, vmsg), function(s_3, vstr) {\n          \n          var a = {\n            attributes_data_value: vstr,\n            attributes_data_writable: true,\n            attributes_data_enumerable: false,\n            attributes_data_configurable: true\n          };\n          return (\n            if_success(\n              object_define_own_prop(s_3, c, l, "message",\n                descriptor_of_attributes(Coq_attributes_data_of(a)),\n                throw_true), function(s_4, rv) {\n                \n                return (res_out(s_4, res_val(Coq_value_object(l))));}));}));\n  }\n};\n\nvar run_error = function (s, c, ne) {\n  return (\n    if_object(\n      build_error(s, c,\n        Coq_value_object(\n          Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))),\n        Coq_value_undef()), function(s_2, l) {\n        \n        return (\n          res_out(s_2, res_throw(Coq_resvalue_value(Coq_value_object(l)))));\n      }));\n};\n\nvar run_error_no_c = function (s, ne) {\n  var vproto = Coq_value_object(\n                 Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne)));\n  var o = object_new(vproto, "error");\n  var _tuple_arg_2 = object_alloc(s, o);\n  var l = _tuple_arg_2[0], s_2 = _tuple_arg_2[1];\n  return (res_out(s_2, res_throw(Coq_resvalue_value(Coq_value_object(l)))));\n};\n\nvar some_context = execution_ctx_initial(true);\n\nvar object_has_internal_slot = function (s, l, prj) {\n  var _switch_arg_3 = run_object_method(prj, s, l);\n  switch (_switch_arg_3.tag) {\n    case "None":\n      throw false;\n    case "Some":\n      var a = _switch_arg_3.value;\n      return (is_some(a));\n  }\n  \n};\n\nvar object_has_internal_method = function (s, l, prj) {\n  return (object_has_internal_slot(s, l, prj));\n};\n\nvar object_internal_get_prototype_of = function (s, o) {\n  return (\n    if_some(run_object_method(object_get_prototype_of_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_get_prototype_of_default":\n            return (ordinary_object_internal_get_prototype_of(s, o));\n          case "Coq_builtin_get_prototype_of_proxy":\n            return (proxy_object_internal_get_prototype_of(s, o));\n        }\n        }));\n};\n\nvar object_internal_set_prototype_of = function (s, o, v) {\n  return (\n    if_some(run_object_method(object_set_prototype_of_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_set_prototype_of_default":\n            return (ordinary_object_internal_set_prototype_of(s, o, v));\n          case "Coq_builtin_set_prototype_of_proxy":\n            return (proxy_object_internal_set_prototype_of(s, o, v));\n        }\n        }));\n};\n\nvar object_internal_is_extensible = function (s, o) {\n  return (\n    if_some(run_object_method(object_is_extensible_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_is_extensible_default":\n            return (ordinary_object_internal_is_extensible(s, o));\n          case "Coq_builtin_is_extensible_proxy":\n            return (proxy_object_internal_is_extensible(s, o));\n        }\n        }));\n};\n\nvar object_internal_prevent_extensions = function (s, o) {\n  return (\n    if_some(run_object_method(object_prevent_extensions_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_prevent_extensions_default":\n            return (ordinary_object_internal_prevent_extensions(s, o));\n          case "Coq_builtin_prevent_extensions_proxy":\n            return (proxy_object_internal_prevent_extensions(s, o));\n        }\n        }));\n};\n\nvar object_internal_get_own_property = function (s, o, p) {\n  return (\n    if_some(run_object_method(object_get_own_prop_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_get_own_prop_default":\n            return (ordinary_object_internal_get_own_property(s, o, p));\n          case "Coq_builtin_get_own_prop_args_obj":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_get_own_prop_string":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_get_own_prop_proxy":\n            return (proxy_object_internal_get_own_property(s, o, p));\n        }\n        }));\n};\n\nvar object_internal_define_own_property = function (s, o, p, desc) {\n  return (\n    if_some(run_object_method(object_define_own_prop_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_define_own_prop_default":\n            return (\n              ordinary_object_internal_define_own_property(s, o, p, desc));\n          case "Coq_builtin_define_own_prop_array":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_define_own_prop_args_obj":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_define_own_prop_proxy":\n            return (\n              ordinary_object_internal_define_own_property(s, o, p, desc));\n        }\n        }));\n};\n\nvar object_internal_has_property = function (s, o, p) {\n  return (\n    if_some(run_object_method(object_has_prop_, s, o), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_has_prop_default":\n            return (ordinary_object_internal_has_property(s, o, p));\n          case "Coq_builtin_has_prop_proxy":\n            return (proxy_object_internal_has_property(s, o, p));\n        }\n        }));\n};\n\nvar object_internal_get = function (s, o, p, receiver) {\n  return (\n    if_some(run_object_method(object_get_, s, o), function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_get_default":\n            return (ordinary_object_internal_get(s, o, p, receiver));\n          case "Coq_builtin_get_args_obj":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_get_proxy":\n            return (proxy_object_internal_get(s, o, p, receiver));\n        }\n        }));\n};\n\nvar object_internal_set = function (s, o, p, v, receiver) {\n  return (\n    if_some(run_object_method(object_set_, s, o), function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_set_default":\n            return (ordinary_object_internal_set(s, o, p, v, receiver));\n          case "Coq_builtin_set_proxy":\n            return (proxy_object_internal_set(s, o, p, v, receiver));\n        }\n        }));\n};\n\nvar object_put = function (s, c, l, p, v, str) {\n  return (\n    object_internal_set(s, l, Coq_value_string(p), v, Coq_value_object(l)));\n};\n\nvar object_internal_delete = function (s, o, p) {\n  return (\n    if_some(run_object_method(object_delete_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_delete_default":\n            return (ordinary_object_internal_delete(s, o, p));\n          case "Coq_builtin_delete_args_obj":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_delete_proxy":\n            return (proxy_object_internal_delete(s, o, p));\n        }\n        }));\n};\n\nvar object_delete_default = function (s, c, l, x, str) {\n  return (\n    if_bool(ordinary_object_internal_delete(s, l, Coq_value_string(x)),\n      function(s, b) {\n        \n        if ((str && !(b))) {\n          return (run_error_no_c(s, Coq_native_error_type()));\n        } else {\n          return (res_ter(s, res_val(Coq_value_bool(b))));\n        }}));\n};\n\nvar object_internal_own_property_keys = function (s, o) {\n  return (\n    if_some(run_object_method(object_own_property_keys_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_own_property_keys_default":\n            return (ordinary_object_internal_own_property_keys(s, o));\n          case "Coq_builtin_own_property_keys_proxy":\n            return (proxy_object_internal_own_property_keys(s, o));\n        }\n        }));\n};\n\nvar object_internal_call = function (s, o, thisArgument, argumentsList) {\n  return (\n    if_some(run_object_method(object_call_, s, o),\n      function(internal_method) {\n        \n        return (\n          if_some(internal_method, function(internal_method) {\n              \n              switch (internal_method.tag) {\n                case "Coq_call_default":\n                  return (\n                    run_call(s, some_context, o, thisArgument, argumentsList));\n                case "Coq_call_after_bind":\n                  return (\n                    run_call(s, some_context, o, thisArgument, argumentsList));\n                case "Coq_call_prealloc":\n                  return (\n                    run_call(s, some_context, o, thisArgument, argumentsList));\n                case "Coq_call_proxy":\n                  return (\n                    proxy_object_internal_call(s, o, thisArgument,\n                      argumentsList));\n              }\n              }));}));\n};\n\nvar object_internal_construct = function (s, o, argumentsList, newTarget) {\n  return (\n    if_some(run_object_method(object_construct_, s, o),\n      function(internal_method) {\n        \n        return (\n          if_some(internal_method, function(internal_method) {\n              \n              switch (internal_method.tag) {\n                case "Coq_construct_default":\n                  return (\n                    run_construct(s, some_context, internal_method, o,\n                      argumentsList));\n                case "Coq_construct_after_bind":\n                  return (\n                    run_construct(s, some_context, internal_method, o,\n                      argumentsList));\n                case "Coq_construct_prealloc":\n                  return (\n                    run_construct(s, some_context, internal_method, o,\n                      argumentsList));\n                case "Coq_construct_proxy":\n                  return (\n                    proxy_object_internal_construct(s, o, argumentsList,\n                      newTarget));\n              }\n              }));}));\n};\n\nvar get_base = ref_base;\n\nvar get_referenced_name = function (r) {\n  return (Coq_value_string(ref_name(r)));\n};\n\nvar is_strict_reference = ref_strict;\n\nvar has_primitive_base = function (r) {\n  return (\n    ref_kind_comparable(ref_kind_of(r), Coq_ref_kind_primitive_base()));\n};\n\nvar is_property_reference = function (r) {\n  return (\n    (_compare_JsCommon_ref_kind(ref_kind_of(r), Coq_ref_kind_object())\n    || has_primitive_base(r)));\n};\n\nvar is_unresolvable_reference = function (r) {\n  return (_compare_JsCommon_ref_kind(ref_kind_of(r), Coq_ref_kind_undef()));\n};\n\nvar is_super_reference = function (r) {\n  return (is_some(r.ref_this_value));\n};\n\nvar get_value = function (s, v) {\n  return (\n    if_success(v, function(_pat_any_6, v$) {\n        \n        if (!(\n              _compare_JsSyntax_resvalue_type(type_of_resvalue(v$),\n                Type_resvalue_ref()))) {\n          return (v);\n        } else {\n          var v = ref_of_resvalue(v$);\n          var base = get_base(v);\n          if (is_unresolvable_reference(v)) {\n            return (run_error_no_c(s, Coq_native_error_ref()));\n          } else {\n            if (is_property_reference(v)) {\n              var base = value_of_ref_base_type(base);\n              return (\n                let_ret((function () {\n                    if (has_primitive_base(v)) {\n                      return (\n                        check_assert_ret(\n                          !(\n                            (_compare_JsSyntax_value(base, Coq_value_undef())\n                            || _compare_JsSyntax_value(base,\n                                 Coq_value_null()))), function(_pat_any_4) {\n                            \n                            return (\n                              assert_object_ret(to_object(s, base),\n                                function(s, base) {\n                                  \n                                  return (Continue([s, base]));}));}));\n                    } else {\n                      return (Continue([s, loc_of_value(base)]));\n                    }}()), function(_tuple_arg_5) {\n                    var s = _tuple_arg_5[0], base = _tuple_arg_5[1];\n                    \n                    return (\n                      object_internal_get(s, base, get_referenced_name(v),\n                        get_this_value(v)));}));\n            } else {\n              var base = env_loc_of_ref_base_type(base);\n              return (\n                get_binding_value(s, base, get_referenced_name(v),\n                  is_strict_reference(v)));\n            }\n          }\n        }}));\n};\n\nvar put_value = function (s, c, v, w) {\n  return (\n    if_success(v, function(_pat_any_10, v) {\n        \n        return (\n          if_value(w, function(_pat_any_9, w) {\n              \n              if (!(\n                    _compare_JsSyntax_resvalue_type(type_of_resvalue(v),\n                      Type_resvalue_ref()))) {\n                return (run_error_no_c(s, Coq_native_error_ref()));\n              } else {\n                var v = ref_of_resvalue(v);\n                var base = get_base(v);\n                if (is_unresolvable_reference(v)) {\n                  if (is_strict_reference(v)) {\n                    return (run_error_no_c(s, Coq_native_error_ref()));\n                  } else {\n                    var globalObj = get_global_object(s, c);\n                    return (\n                      set(s, globalObj, get_referenced_name(v), w,\n                        Coq_value_bool(false)));\n                  }\n                } else {\n                  if (is_property_reference(v)) {\n                    var base = value_of_ref_base_type(base);\n                    return (\n                      let_ret((function () {\n                          if (has_primitive_base(v)) {\n                            return (\n                              check_assert_ret(\n                                !(\n                                  (_compare_JsSyntax_value(base,\n                                     Coq_value_null())\n                                  || _compare_JsSyntax_value(base,\n                                       Coq_value_undef()))),\n                                function(_pat_any_7) {\n                                  \n                                  return (\n                                    assert_object_ret(to_object(s, base),\n                                      function(s, base) {\n                                        \n                                        return (Continue([s, base]));}));}));\n                          } else {\n                            return (Continue([s, loc_of_value(base)]));\n                          }}()), function(_tuple_arg_8) {\n                          var s = _tuple_arg_8[0], base = _tuple_arg_8[1];\n                          \n                          return (\n                            if_bool(\n                              object_internal_set(s, base,\n                                get_referenced_name(v), w, get_this_value(v)),\n                              function(s, succeeded) {\n                                \n                                if ((!(succeeded) && is_strict_reference(v))) {\n                                  return (\n                                    run_error_no_c(s,\n                                      Coq_native_error_type()));\n                                } else {\n                                  return (res_void(s));\n                                }}));}));\n                  } else {\n                    var base = env_loc_of_ref_base_type(base);\n                    return (\n                      set_mutable_binding(s, base, get_referenced_name(v), w,\n                        Coq_value_bool(is_strict_reference(v))));\n                  }\n                }\n              }}));}));\n};\n\nvar get_this_value = function (v) {\n  throw is_property_reference(v);\n  if (is_super_reference(v)) {\n    return (ref_this_value(v));\n  } else {\n    return (value_of_ref_base_type(get_base(v)));\n  }\n};\n\nvar is_accessor_descriptor = function (desc) {\n  switch (desc.tag) {\n    case "Descriptor_undef":\n      return (false);\n    case "Descriptor":\n      var desc = desc.descriptor;\n      return (\n        !(\n          (option_compare(value_compare, desc.descriptor_get, None())\n          && option_compare(value_compare, desc.descriptor_set, None()))));\n  }\n  \n};\n\nvar is_data_descriptor = function (desc) {\n  switch (desc.tag) {\n    case "Descriptor_undef":\n      return (false);\n    case "Descriptor":\n      var desc = desc.descriptor;\n      return (\n        !(\n          (option_compare(value_compare, desc.descriptor_value, None())\n          && option_compare(bool_eq, desc.descriptor_writable, None()))));\n  }\n  \n};\n\nvar is_generic_descriptor = function (desc) {\n  switch (desc.tag) {\n    case "Descriptor_undef":\n      return (false);\n    case "Descriptor":\n      return (\n        (!(is_accessor_descriptor(desc)) && !(is_data_descriptor(desc))));\n  }\n  \n};\n\nvar from_property_descriptor = function (s, desc) {\n  if (_compare_JsSyntax_undef_descriptor(desc, Descriptor_undef())) {\n    return (res_ter(s, res_val(Coq_value_undef())));\n  } else {\n    var desc = descriptor_get_defined(desc);\n    return (\n      if_value(\n        object_create(s,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_object_proto())), None()),\n        function(s, obj) {\n          \n          return (\n            check_assert(\n              _compare_JsSyntax_coq_type(type_of(obj), Coq_type_object()),\n              function(_pat_any_17) {\n                \n                return (\n                  let_ret((function () {\n                      if (is_some(desc.descriptor_value)) {\n                        return (\n                          if_bool_ret(\n                            create_data_property(s, obj,\n                              Coq_value_string("value"),\n                              unsome_error(desc.descriptor_value)),\n                            function(s, result) {\n                              \n                              return (\n                                check_assert_ret(result,\n                                  function(_pat_any_11) {\n                                    \n                                    return (Continue(s));}));}));\n                      } else {\n                        return (Continue(s));\n                      }}()), function(s) {\n                      \n                      return (\n                        let_ret((function () {\n                            if (is_some(desc.descriptor_writable)) {\n                              return (\n                                if_bool_ret(\n                                  create_data_property(s, obj,\n                                    Coq_value_string("writable"),\n                                    Coq_value_bool(\n                                      unsome_error(desc.descriptor_writable))),\n                                  function(s, result) {\n                                    \n                                    return (\n                                      check_assert_ret(result,\n                                        function(_pat_any_12) {\n                                          \n                                          return (Continue(s));}));}));\n                            } else {\n                              return (Continue(s));\n                            }}()), function(s) {\n                            \n                            return (\n                              let_ret((function () {\n                                  if (is_some(desc.descriptor_get)) {\n                                    return (\n                                      if_bool_ret(\n                                        create_data_property(s, obj,\n                                          Coq_value_string("get"),\n                                          unsome_error(desc.descriptor_get)),\n                                        function(s, result) {\n                                          \n                                          return (\n                                            check_assert_ret(result,\n                                              function(_pat_any_13) {\n                                                \n                                                return (Continue(s));}));}));\n                                  } else {\n                                    return (Continue(s));\n                                  }}()), function(s) {\n                                  \n                                  return (\n                                    let_ret((function () {\n                                        if (is_some(desc.descriptor_set)) {\n                                          return (\n                                            if_bool_ret(\n                                              create_data_property(s, obj,\n                                                Coq_value_string("set"),\n                                                unsome_error(\n                                                  desc.descriptor_set)),\n                                              function(s, result) {\n                                                \n                                                return (\n                                                  check_assert_ret(result,\n                                                    function(_pat_any_14) {\n                                                      \n                                                      return (Continue(s));}));\n                                              }));\n                                        } else {\n                                          return (Continue(s));\n                                        }}()), function(s) {\n                                        \n                                        return (\n                                          let_ret((function () {\n                                              if (is_some(\n                                                    desc.descriptor_enumerable)) {\n                                                return (\n                                                  if_bool_ret(\n                                                    create_data_property(s,\n                                                      obj,\n                                                      Coq_value_string(\n                                                        "enumerable"),\n                                                      Coq_value_bool(\n                                                        unsome_error(\n                                                          desc.descriptor_enumerable))),\n                                                    function(s, result) {\n                                                      \n                                                      return (\n                                                        check_assert_ret(\n                                                          result,\n                                                          function(_pat_any_15) {\n                                                            \n                                                            return (\n                                                              Continue(s));}));\n                                                    }));\n                                              } else {\n                                                return (Continue(s));\n                                              }}()), function(s) {\n                                              \n                                              return (\n                                                let_ret((function () {\n                                                    if (is_some(\n                                                          desc.descriptor_configurable)) {\n                                                      return (\n                                                        if_bool_ret(\n                                                          create_data_property(\n                                                            s, obj,\n                                                            Coq_value_string(\n                                                              "configurable"),\n                                                            Coq_value_bool(\n                                                              unsome_error(\n                                                                desc.descriptor_configurable))),\n                                                          function(s,\n                                                          result) {\n                                                            \n                                                            return (\n                                                              check_assert_ret(\n                                                                result,\n                                                                function(_pat_any_16) {\n                                                                  \n                                                                  return (\n                                                                    Continue(\n                                                                    s));}));\n                                                          }));\n                                                    } else {\n                                                      return (Continue(s));\n                                                    }}()), function(s) {\n                                                    \n                                                    return (\n                                                      res_ter(s,\n                                                        res_val(obj)));}));}));\n                                      }));}));}));}));}));}));\n  }\n};\n\nvar to_property_descriptor = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_object":\n      var l = _foo_.value;\n      var desc = descriptor_intro_empty;\n      return (\n        if_bool(has_property(s, _foo_, Coq_value_string("enumerable")),\n          function(s, hasEnumerable) {\n            \n            return (\n              if_spec((function () {\n                  if (hasEnumerable) {\n                    return (\n                      if_value(get(s, _foo_, Coq_value_string("enumerable")),\n                        function(s, v) {\n                          \n                          var enum = to_boolean(v);\n                          return (\n                            res_spec(s,\n                              descriptor_with_enumerable(desc, Some(enum))));\n                        }));\n                  } else {\n                    return (res_spec(s, desc));\n                  }}()), function(s, desc) {\n                  \n                  return (\n                    if_bool(\n                      has_property(s, _foo_,\n                        Coq_value_string("configurable")), function(s,\n                      hasConfigurable) {\n                        \n                        return (\n                          if_spec((function () {\n                              if (hasConfigurable) {\n                                return (\n                                  if_value(\n                                    get(s, _foo_,\n                                      Coq_value_string("configurable")),\n                                    function(s, v) {\n                                      \n                                      var conf = to_boolean(v);\n                                      return (\n                                        res_spec(s,\n                                          descriptor_with_configurable(desc,\n                                            Some(conf))));}));\n                              } else {\n                                return (res_spec(s, desc));\n                              }}()), function(s, desc) {\n                              \n                              return (\n                                if_bool(\n                                  has_property(s, _foo_,\n                                    Coq_value_string("value")), function(s,\n                                  hasValue) {\n                                    \n                                    return (\n                                      if_spec((function () {\n                                          if (hasValue) {\n                                            return (\n                                              if_value(\n                                                get(s, _foo_,\n                                                  Coq_value_string("value")),\n                                                function(s, value) {\n                                                  \n                                                  return (\n                                                    res_spec(s,\n                                                      descriptor_with_value(\n                                                        desc, Some(value))));\n                                                }));\n                                          } else {\n                                            return (res_spec(s, desc));\n                                          }}()), function(s, desc) {\n                                          \n                                          return (\n                                            if_bool(\n                                              has_property(s, _foo_,\n                                                Coq_value_string("writable")),\n                                              function(s, hasWritable) {\n                                                \n                                                return (\n                                                  if_spec((function () {\n                                                      if (hasValue) {\n                                                        return (\n                                                          if_value(\n                                                            get(s, _foo_,\n                                                              Coq_value_string(\n                                                                "writable")),\n                                                            function(s, v) {\n                                                              \n                                                              var writable = \n                                                              to_boolean(v);\n                                                              return (\n                                                                res_spec(s,\n                                                                  descriptor_with_writable(\n                                                                    desc,\n                                                                    Some(\n                                                                    writable))));\n                                                            }));\n                                                      } else {\n                                                        return (\n                                                          res_spec(s, desc));\n                                                      }}()), function(s,\n                                                    desc) {\n                                                      \n                                                      return (\n                                                        if_bool(\n                                                          has_property(s,\n                                                            _foo_,\n                                                            Coq_value_string(\n                                                              "get")),\n                                                          function(s,\n                                                          hasGet) {\n                                                            \n                                                            return (\n                                                              if_spec(\n                                                                (function () {\n                                                                  if (hasGet) {\n                                                                    return (\n                                                                    if_value(\n                                                                    get(s,\n                                                                    _foo_,\n                                                                    Coq_value_string(\n                                                                    "get")),\n                                                                    function(s,\n                                                                    getter) {\n                                                                    \n                                                                    if (\n                                                                    (\n                                                                    !(\n                                                                    is_callable(\n                                                                    s,\n                                                                    getter))\n                                                                    && \n                                                                    !(\n                                                                    _compare_JsSyntax_coq_type(\n                                                                    type_of(\n                                                                    getter),\n                                                                    Coq_type_undef(\n                                                                    ))))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    descriptor_with_get(\n                                                                    desc,\n                                                                    Some(\n                                                                    getter))));\n                                                                    }}));\n                                                                  } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s, desc));\n                                                                  }}()),\n                                                                function(s,\n                                                                desc) {\n                                                                  \n                                                                  return (\n                                                                    if_bool(\n                                                                    has_property(\n                                                                    s, _foo_,\n                                                                    Coq_value_string(\n                                                                    "set")),\n                                                                    function(s,\n                                                                    hasSet) {\n                                                                    \n                                                                    return (\n                                                                    if_spec(\n                                                                    (function () {\n                                                                    if (hasSet) {\n                                                                    return (\n                                                                    if_value(\n                                                                    get(s,\n                                                                    _foo_,\n                                                                    Coq_value_string(\n                                                                    "set")),\n                                                                    function(s,\n                                                                    setter) {\n                                                                    \n                                                                    if (\n                                                                    (\n                                                                    !(\n                                                                    is_callable(\n                                                                    s,\n                                                                    setter))\n                                                                    && \n                                                                    !(\n                                                                    _compare_JsSyntax_coq_type(\n                                                                    type_of(\n                                                                    setter),\n                                                                    Coq_type_undef(\n                                                                    ))))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    descriptor_with_set(\n                                                                    desc,\n                                                                    Some(\n                                                                    setter))));\n                                                                    }}));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s, desc));\n                                                                    }}()),\n                                                                    function(s,\n                                                                    desc) {\n                                                                    \n                                                                    if (\n                                                                    (\n                                                                    (\n                                                                    !(\n                                                                    _compare_option(\n                                                                    desc.descriptor_get,\n                                                                    None()))\n                                                                    || \n                                                                    !(\n                                                                    _compare_option(\n                                                                    desc.descriptor_set,\n                                                                    None())))\n                                                                    && \n                                                                    (\n                                                                    !(\n                                                                    _compare_option(\n                                                                    desc.descriptor_value,\n                                                                    None()))\n                                                                    || \n                                                                    !(\n                                                                    _compare_option(\n                                                                    desc.descriptor_writable,\n                                                                    None()))))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s, desc));\n                                                                    }}));}));\n                                                                }));}));}));\n                                              }));}));}));}));}));}));}));\n    default:\n      return (throw_result(run_error_no_c(s, Coq_native_error_type())));\n  }\n  \n};\n\nvar complete_property_descriptor = function (desc) {\n  var desc = descriptor_get_defined(desc);\n  var like = {\n    descriptor_value: Some(Coq_value_undef()),\n    descriptor_writable: Some(false),\n    descriptor_get: Some(Coq_value_undef()),\n    descriptor_set: Some(Coq_value_undef()),\n    descriptor_enumerable: Some(false),\n    descriptor_configurable: Some(false)\n  };\n  if ((is_generic_descriptor(Descriptor(desc))\n      || is_data_descriptor(Descriptor(desc)))) {\n    var desc = descriptor_with_value(desc, like.descriptor_value);\n    var desc = descriptor_with_writable(desc, like.descriptor_writable);\n  } else {\n    var desc = descriptor_with_get(desc, like.descriptor_get);\n    var desc = descriptor_with_set(desc, like.descriptor_set);\n  }\n  if (option_compare(bool_eq, desc.descriptor_enumerable, None())) {\n    var desc = descriptor_with_enumerable(desc, like.descriptor_enumerable);\n  } else {\n    var desc = desc;\n  }\n  if (option_compare(bool_eq, desc.descriptor_configurable, None())) {\n    var desc = descriptor_with_configurable(desc,\n                 like.descriptor_configurable);\n  } else {\n    var desc = desc;\n  }\n  return (desc);\n};\n\nvar to_primitive = function (s, input, preferredType) {\n  switch (input.tag) {\n    case "Coq_value_undef":\n      return (res_out(s, res_val(input)));\n    case "Coq_value_null":\n      return (res_out(s, res_val(input)));\n    case "Coq_value_bool":\n      return (res_out(s, res_val(input)));\n    case "Coq_value_number":\n      return (res_out(s, res_val(input)));\n    case "Coq_value_string":\n      return (res_out(s, res_val(input)));\n    case "Coq_value_object":\n      var l = input.value;\n      return (\n        if_prim(object_default_value(s, some_context, l, preferredType),\n          function(s0, r) { \n                            return (res_ter(s0, res_val(r)));}));\n  }\n  \n};\n\nvar to_boolean = function (argument) {\n  switch (argument.tag) {\n    case "Coq_value_undef":\n      return (false);\n    case "Coq_value_null":\n      return (false);\n    case "Coq_value_bool":\n      var b = argument.value;\n      return (b);\n    case "Coq_value_number":\n      var n = argument.value;\n      if ((JsNumber.isposzero(n)\n          || (JsNumber.isnegzero(n) || JsNumber.isnan(n)))) {\n        return (false);\n      } else {\n        return (true);\n      }\n    case "Coq_value_string":\n      var s = argument.value;\n      if (string_eq(s, "")) {\n        return (false);\n      } else {\n        return (true);\n      }\n    case "Coq_value_object":\n      var o = argument.value;\n      return (true);\n  }\n  \n};\n\nvar to_number = function (s, argument) {\n  switch (argument.tag) {\n    case "Coq_value_undef":\n      return (res_ter(s, res_val(Coq_value_number(JsNumber.nan))));\n    case "Coq_value_null":\n      return (res_ter(s, res_val(Coq_value_number(JsNumber.zero))));\n    case "Coq_value_bool":\n      var b = argument.value;\n      if (b) {\n        return (res_ter(s, res_val(Coq_value_number(JsNumber.one))));\n      } else {\n        return (res_ter(s, res_val(Coq_value_number(JsNumber.zero))));\n      }\n    case "Coq_value_number":\n      var n = argument.value;\n      return (res_ter(s, res_val(Coq_value_number(n))));\n    case "Coq_value_string":\n      var x = argument.value;\n      return (res_ter(s, res_val(Coq_value_number(to_number_string(x)))));\n    case "Coq_value_object":\n      var l = argument.value;\n      return (\n        if_value(to_primitive(s, argument, Some(Coq_preftype_number())),\n          function(s, primValue) { \n                                   return (to_number(s, primValue));}));\n  }\n  \n};\n\nvar to_number_string = function (s) {\n  return (JsNumber.from_string(s));\n};\n\nvar to_integer = function (s, argument) {\n  return (\n    if_number(to_number(s, argument), function(s, number) {\n        \n        if (JsNumber.isnan(number)) {\n          return (res_ter(s, res_val(Coq_value_number(JsNumber.zero))));\n        } else {\n          if ((JsNumber.isposzero(number)\n              || (JsNumber.isnegzero(number)\n                 || ((number === JsNumber.infinity)\n                    || (number === JsNumber.neg_infinity))))) {\n            return (res_ter(s, res_val(Coq_value_number(number))));\n          } else {\n            return (\n              res_ter(s,\n                res_val(\n                  Coq_value_number(\n                    (JsNumber.sign(number)\n                    * JsNumber.floor(JsNumber.absolute(number)))))));\n          }\n        }}));\n};\n\nvar to_string = function (s, argument) {\n  switch (argument.tag) {\n    case "Coq_value_undef":\n      return (res_out(s, res_val(Coq_value_string("undefined"))));\n    case "Coq_value_null":\n      return (res_out(s, res_val(Coq_value_string("null"))));\n    case "Coq_value_bool":\n      var b = argument.value;\n      switch (b) {\n        case true:\n          return (res_out(s, res_val(Coq_value_string("true"))));\n        case false:\n          return (res_out(s, res_val(Coq_value_string("false"))));\n      }\n      \n    case "Coq_value_number":\n      var n = argument.value;\n      return (res_out(s, res_val(Coq_value_string(to_string_number(n)))));\n    case "Coq_value_string":\n      return (res_out(s, res_val(argument)));\n    case "Coq_value_object":\n      var o = argument.value;\n      return (\n        if_value(to_primitive(s, argument, Some(Coq_preftype_string())),\n          function(s, primValue) { \n                                   return (to_string(s, primValue));}));\n  }\n  \n};\n\nvar to_string_number = JsNumber.to_string;\n\nvar to_length = function (s, argument) {\n  return (\n    if_number(to_integer(s, argument), function(s, len) {\n        \n        if ((len <= 0.)) {\n          return (res_ter(s, res_val(Coq_value_number(0.))));\n        } else {\n          return (\n            res_ter(s,\n              res_val(\n                Coq_value_number(\n                  JsNumber.min(len, (JsNumber.pow(2., 53.) - 1.))))));\n        }}));\n};\n\nvar require_object_coercible = function (s, argument) {\n  switch (argument.tag) {\n    case "Coq_value_undef":\n      return (run_error_no_c(s, Coq_native_error_type()));\n    case "Coq_value_null":\n      return (run_error_no_c(s, Coq_native_error_type()));\n    case "Coq_value_bool":\n      return (res_ter(s, res_val(argument)));\n    case "Coq_value_number":\n      return (res_ter(s, res_val(argument)));\n    case "Coq_value_string":\n      return (res_ter(s, res_val(argument)));\n    case "Coq_value_object":\n      return (res_ter(s, res_val(argument)));\n  }\n  \n};\n\nvar is_callable = function (s, argument) {\n  if (!(_compare_JsSyntax_coq_type(type_of(argument), Coq_type_object()))) {\n    return (false);\n  } else {\n    return (\n      object_has_internal_method(s, loc_of_value(argument), object_call_));\n  }\n};\n\nvar is_constructor = function (s, argument) {\n  if (!(_compare_JsSyntax_coq_type(type_of(argument), Coq_type_object()))) {\n    return (false);\n  } else {\n    return (\n      object_has_internal_method(s, loc_of_value(argument),\n        object_construct_));\n  }\n};\n\nvar is_extensible = function (s, o) {\n  return (\n    check_assert((function () {\n        var _switch_arg_18 = type_of(o);\n        switch (_switch_arg_18.tag) {\n          case "Coq_type_object":\n            return (true);\n          default:\n            return (false);\n        }\n        }()), function(_pat_any_19) {\n        \n        switch (o.tag) {\n          case "Coq_value_object":\n            var l = o.value;\n            return (object_internal_is_extensible(s, l));\n          default:\n            throw false;\n        }\n        }));\n};\n\nvar is_property_key = function (argument) {\n  return (_compare_JsSyntax_coq_type(type_of(argument), Coq_type_string()));\n};\n\nvar same_value = function (x, y) {\n  if (!(type_compare(type_of(x), type_of(y)))) {\n    return (false);\n  } else {\n    var _switch_arg_20 = type_of(x);\n    switch (_switch_arg_20.tag) {\n      case "Coq_type_number":\n        switch (x.tag) {\n          case "Coq_value_number":\n            var n_x = x.value;\n            switch (y.tag) {\n              case "Coq_value_number":\n                var n_y = y.value;\n                if ((JsNumber.isnan(n_x) && JsNumber.isnan(n_y))) {\n                  return (true);\n                } else {\n                  if ((JsNumber.isposzero(n_x) && JsNumber.isnegzero(n_y))) {\n                    return (true);\n                  } else {\n                    if ((JsNumber.isnegzero(n_x) && JsNumber.isposzero(n_y))) {\n                      return (true);\n                    } else {\n                      return ((n_x === n_y));\n                    }\n                  }\n                }\n              default:\n                throw false;\n            }\n            \n          default:\n            throw false;\n        }\n        \n      default:\n        return (same_value_non_number(x, y));\n    }\n    \n  }\n};\n\nvar same_value_non_number = function (x, y) {\n  throw !(type_compare(type_of(x), Coq_type_number()));\n  throw type_compare(type_of(x), type_of(y));\n  switch (x.tag) {\n    case "Coq_value_undef":\n      return (true);\n    case "Coq_value_null":\n      return (true);\n    case "Coq_value_string":\n      var s_x = x.value;\n      switch (y.tag) {\n        case "Coq_value_string":\n          var s_y = y.value;\n          return (string_eq(s_x, s_y));\n        default:\n          throw false;\n      }\n      \n    case "Coq_value_bool":\n      var b_x = x.value;\n      switch (y.tag) {\n        case "Coq_value_bool":\n          var b_y = y.value;\n          return (bool_eq(b_x, b_y));\n        default:\n          throw false;\n      }\n      \n    case "Coq_value_object":\n      var l_x = x.value;\n      switch (y.tag) {\n        case "Coq_value_object":\n          var l_y = y.value;\n          return (object_loc_compare(l_x, l_y));\n        default:\n          throw false;\n      }\n      \n    default:\n      throw false;\n  }\n  \n};\n\nvar get = function (s, o, p) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_22) {\n        \n        return (\n          check_assert(is_property_key(p), function(_pat_any_21) {\n              \n              switch (o.tag) {\n                case "Coq_value_object":\n                  var l = o.value;\n                  return (object_internal_get(s, l, p, o));\n                default:\n                  throw false;\n              }\n              }));}));\n};\n\nvar get_v = function (s, v, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_23) {\n        \n        return (\n          if_object(to_object(s, v), function(s1, l) {\n              \n              return (object_internal_get(s1, l, p, v));}));}));\n};\n\nvar set = function (s, o, p, v, throw) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_26) {\n        \n        var l = loc_of_value(o);\n        return (\n          check_assert(is_property_key(p), function(_pat_any_25) {\n              \n              return (\n                check_assert(\n                  _compare_JsSyntax_coq_type(type_of(throw), Coq_type_bool()),\n                  function(_pat_any_24) {\n                    \n                    var throw = bool_of_value(throw);\n                    return (\n                      if_bool(object_internal_set(s, l, p, v, o), function(s,\n                        success) {\n                          \n                          if ((!(success) && throw)) {\n                            return (\n                              run_error_no_c(s, Coq_native_error_type()));\n                          } else {\n                            return (\n                              res_ter(s, res_val(Coq_value_bool(success))));\n                          }}));}));}));}));\n};\n\nvar create_data_property = function (s, o, p, v) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_28) {\n        \n        var o = loc_of_value(o);\n        return (\n          check_assert(is_property_key(p), function(_pat_any_27) {\n              \n              var newDesc = descriptor_intro_data(v, true, true, true);\n              return (object_internal_define_own_property(s, o, p, newDesc));\n            }));}));\n};\n\nvar define_property_or_throw = function (s, o, p, desc) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_30) {\n        \n        var o = loc_of_value(o);\n        return (\n          check_assert(is_property_key(p), function(_pat_any_29) {\n              \n              return (\n                if_bool(object_internal_define_own_property(s, o, p, desc),\n                  function(s, success) {\n                    \n                    if (!(success)) {\n                      return (run_error_no_c(s, Coq_native_error_type()));\n                    } else {\n                      return (res_ter(s, res_val(Coq_value_bool(success))));\n                    }}));}));}));\n};\n\nvar get_method = function (s, v, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_32) {\n        \n        return (\n          if_value(get_v(s, v, p), function(s1, func) {\n              \n              var _switch_arg_31 = type_of(func);\n              switch (_switch_arg_31.tag) {\n                case "Coq_type_undef":\n                  return (res_out(s1, res_val(Coq_value_undef())));\n                case "Coq_type_null":\n                  return (res_out(s1, res_val(Coq_value_undef())));\n                default:\n                  var callable = is_callable(s1, func);\n                  if (!(callable)) {\n                    return (run_error_no_c(s1, Coq_native_error_type()));\n                  } else {\n                    return (res_out(s1, res_val(func)));\n                  }\n              }\n              }));}));\n};\n\nvar has_property = function (s, o, p) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_34) {\n        \n        return (\n          check_assert(is_property_key(p), function(_pat_any_33) {\n              \n              switch (o.tag) {\n                case "Coq_value_object":\n                  var l = o.value;\n                  return (object_internal_has_property(s, l, p));\n                default:\n                  throw false;\n              }\n              }));}));\n};\n\nvar call = function (s, f, v, argumentList) {\n  return (\n    if_some_or_apply_default(argumentList, mk_nil(),\n      function (argumentList) {\n        var callable = is_callable(s, f);\n        if (!(callable)) {\n          return (run_error_no_c(s, Coq_native_error_type()));\n        } else {\n          switch (f.tag) {\n            case "Coq_value_object":\n              var l = f.value;\n              return (object_internal_call(s, l, v, argumentList));\n            default:\n              throw false;\n          }\n          \n        }}));\n};\n\nvar construct = function (s, f, argumentsList, newTarget) {\n  var newTarget = unsome_default(f, newTarget);\n  var argumentsList = unsome_default(mk_nil(), argumentsList);\n  return (\n    check_assert(is_constructor(s, f), function(_pat_any_36) {\n        \n        return (\n          check_assert(is_constructor(s, newTarget), function(_pat_any_35) {\n              \n              return (\n                object_internal_construct(s, loc_of_value(f), argumentsList,\n                  newTarget));}));}));\n};\n\nvar set_integrity_level = function (s, o, level) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_38) {\n        \n        var o = loc_of_value(o);\n        return (\n          check_assert(((level === "sealed") || (level === "frozen")),\n            function(_pat_any_37) {\n              \n              return (\n                if_bool(object_internal_prevent_extensions(s, o), function(s,\n                  status) {\n                    \n                    if (!(status)) {\n                      return (res_ter(s, res_val(Coq_value_bool(false))));\n                    } else {\n                      return (\n                        if_spec(object_internal_own_property_keys(s, o),\n                          function(s, keys) {\n                            \n                            return (\n                              let_ret((function () {\n                                  if ((level === "sealed")) {\n                                    return (\n                                      Return(\n                                        Coq_result_not_yet_implemented()));\n                                  } else {\n                                    return (\n                                      Return(\n                                        Coq_result_not_yet_implemented()));\n                                  }}()), function(s) {\n                                  \n                                  return (\n                                    res_ter(s, res_val(Coq_value_bool(true))));\n                                }));}));\n                    }}));}));}));\n};\n\nvar test_integrity_level = function (s, o, level) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_40) {\n        \n        return (\n          check_assert(((level === "sealed") || (level === "frozen")),\n            function(_pat_any_39) {\n              \n              return (\n                if_bool(is_extensible(s, o), function(s, status) {\n                    \n                    if (status) {\n                      return (res_ter(s, res_val(Coq_value_bool(false))));\n                    } else {\n                      return (\n                        if_spec(\n                          object_internal_own_property_keys(s,\n                            loc_of_value(o)), function(s, keys) {\n                            \n                            return (Coq_result_not_yet_implemented());}));\n                    }}));}));}));\n};\n\nvar create_array_from_list = function (s, elements) {\n  return (\n    if_value(array_create(s, Coq_value_number(0.), None()), function(s,\n      array) {\n        \n        var n = 0.;\n        return (\n          let_ret(\n            iterate(elements, [s, n], function (e, acc) {\n                var s = acc[0], n = acc[1];\n                return (\n                  assert_value_ret(to_string(s, Coq_value_number(n)),\n                    function(s, tempVar) {\n                      \n                      return (\n                        assert_bool_ret(\n                          create_data_property(s, array, tempVar, e),\n                          function(s, status) {\n                            \n                            return (\n                              check_assert_ret(status,\n                                function(_pat_any_41) {\n                                  \n                                  return (Continue([s, (n + 1.)]));}));}));}));\n              }), function(_tuple_arg_42) {\n              var s = _tuple_arg_42[0], n = _tuple_arg_42[1];\n              \n              return (res_out(s, res_val(array)));}));}));\n};\n\nvar create_list_from_array_like = function (s, obj, elementTypes) {\n  var elementTypes = unsome_default(\n                       mk_cons(Coq_type_undef(),\n                         mk_cons(Coq_type_null(),\n                           mk_cons(Coq_type_bool(),\n                             mk_cons(Coq_type_string(),\n                               mk_cons(Coq_type_number(),\n                                 mk_cons(Coq_type_object(), mk_nil())))))),\n                       elementTypes);\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(obj), Coq_type_object()),\n      function(_pat_any_44) {\n        \n        return (\n          if_value(get(s, obj, Coq_value_string("length")), function(s,\n            tempVar) {\n              \n              return (\n                if_number(to_length(s, tempVar), function(s, len) {\n                    \n                    var list = mk_nil();\n                    var index = 0.;\n                    return (\n                      let_ret(\n                        repeat(function (acc) {\n                            var index = acc[1];\n                            return ((index < len));}, [s, index, list],\n                          function (acc) {\n                            var s = acc[0], index = acc[1], list = acc[2];\n                            return (\n                              assert_value_ret(\n                                to_string(s, Coq_value_number(index)),\n                                function(s, indexName) {\n                                  \n                                  return (\n                                    if_value_ret(get(s, obj, indexName),\n                                      function(s, next) {\n                                        \n                                        if (!(\n                                              mem_decide(===, type_of(next),\n                                                elementTypes))) {\n                                          return (\n                                            Return(\n                                              run_error_no_c(s,\n                                                Coq_native_error_type())));\n                                        } else {\n                                          var list = append(list,\n                                                       mk_cons(next,\n                                                         mk_nil()));\n                                          var index = (index + 1.);\n                                          return (\n                                            Continue([s, index, list]));\n                                        }}));}));}),\n                        function(_tuple_arg_43) {\n                          var s = _tuple_arg_43[0], index = _tuple_arg_43[1],\n                            list = _tuple_arg_43[2];\n                          \n                          return (res_spec(s, list));}));}));}));}));\n};\n\nvar set_mutable_binding = function (s, l, n, v, str) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var e = e.value;\n            return (decl_env_record_set_mutable_binding(s, l, e, n, v, str));\n          case "Coq_env_record_object":\n            var l = e.value, this = e.provide_this;\n            return (\n              object_env_record_set_mutable_binding(s, Coq_value_object(l),\n                this, n, v, str));\n        }\n        }));\n};\n\nvar get_binding_value = function (s, l, n, str) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var e = e.value;\n            return (decl_env_record_get_binding_value(s, e, n, str));\n          case "Coq_env_record_object":\n            var l = e.value, this = e.provide_this;\n            return (\n              object_env_record_get_binding_value(s, Coq_value_object(l),\n                this, n, str));\n        }\n        }));\n};\n\nvar binding_is_uninitialized = function (binding) {\n  var mutability = binding[0], unused = binding[1];\n  return (\n    mutability_compare(mutability, Coq_mutability_uninitialized_immutable()));\n};\n\nvar binding_is_mutable = function (binding) {\n  var mutability = binding[0], unused = binding[1];\n  return (\n    (_compare_JsSyntax_mutability(mutability, Coq_mutability_nondeletable())\n    || _compare_JsSyntax_mutability(mutability, Coq_mutability_deletable())));\n};\n\nvar decl_env_record_create_mutable_binding = function (s, l, envRec, n$, d) {\n  var n = string_of_value(n$);\n  var d = bool_of_value(d);\n  return (\n    check_assert(!(HeapStr.indom_dec(envRec, n)), function(_pat_any_45) {\n        \n        var s = env_record_write_decl_env(s, l, n, mutability_of_bool(d),\n                  Coq_value_undef());\n        return (res_void(s));}));\n};\n\nvar decl_env_record_initialize_binding = function (s, l, envRec, n$, v) {\n  var n = string_of_value(n$);\n  return (\n    if_some(HeapStr.read_option(envRec, n), function(binding) {\n        \n        var mutability = binding[0], unused = binding[1];\n        return (\n          check_assert(binding_is_uninitialized(binding),\n            function(_pat_any_46) {\n              \n              var s = env_record_write_decl_env(s, l, n, mutability, v);\n              return (res_void(s));}));}));\n};\n\nvar decl_env_record_set_mutable_binding = function (s, l, envRec, n$, v, str) {\n  var n = string_of_value(n$);\n  var str = bool_of_value(str);\n  if (!(HeapStr.indom_dec(envRec, n))) {\n    if (str) {\n      return (run_error_no_c(s, Coq_native_error_ref()));\n    } else {\n      return (\n        if_success(\n          decl_env_record_create_mutable_binding(s, l, envRec, n$,\n            Coq_value_bool(true)), function(s, _pat_any_48) {\n            \n            return (\n              if_success(\n                decl_env_record_initialize_binding(s, l, envRec, n$, v),\n                function(s, _pat_any_47) { \n                                           return (res_void(s));}));}));\n    }\n  } else {\n    return (\n      if_some(HeapStr.read_option(envRec, n), function(binding) {\n          \n          var mutability = binding[0], unused = binding[1];\n          if (binding_is_uninitialized(binding)) {\n            return (run_error_no_c(s, Coq_native_error_ref()));\n          } else {\n            return (\n              let_ret((function () {\n                  if (binding_is_mutable(binding)) {\n                    return (\n                      Continue(\n                        env_record_write_decl_env(s, l, n, mutability, v)));\n                  } else {\n                    if (str) {\n                      return (\n                        Return(run_error_no_c(s, Coq_native_error_type())));\n                    } else {\n                      return (Continue(s));\n                    }\n                  }}()), function(s) { \n                                       return (res_void(s));}));\n          }}));\n  }\n};\n\nvar decl_env_record_get_binding_value = function (s, envRec, n, str) {\n  var n = string_of_value(n);\n  return (\n    check_assert(HeapStr.indom_dec(envRec, n), function(_pat_any_49) {\n        \n        return (\n          if_some(HeapStr.read_option(envRec, n), function(binding) {\n              \n              var mutability = binding[0], v = binding[1];\n              if (mutability_compare(mutability,\n                    Coq_mutability_uninitialized_immutable())) {\n                return (run_error_no_c(s, Coq_native_error_ref()));\n              } else {\n                return (res_ter(s, res_val(v)));\n              }}));}));\n};\n\nvar object_env_record_set_mutable_binding = function (s, bindings, this, n, v, str) {\n  return (set(s, bindings, n, v, str));\n};\n\nvar object_env_record_get_binding_value = function (s, bindings, this, n, str) {\n  return (\n    if_bool(has_property(s, bindings, n), function(s, value) {\n        \n        if (!(value)) {\n          if (!(str)) {\n            return (res_ter(s, res_val(Coq_value_undef())));\n          } else {\n            return (run_error_no_c(s, Coq_native_error_ref()));\n          }\n        } else {\n          return (get(s, bindings, n));\n        }}));\n};\n\nvar get_global_object = function (s, ctx) {\n  var e = unsome_error(env_record_binds_option(s, env_loc_global_env_record));\n  switch (e.tag) {\n    case "Coq_env_record_object":\n      var l = e.value, this = e.provide_this;\n      return (Coq_value_object(l));\n    default:\n      throw false;\n  }\n  \n};\n\nvar ordinary_object_internal_get_prototype_of = function (s, o) {\n  return (\n    if_value(ordinary_get_prototype_of(s, o), function(s1, v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_get_prototype_of = function (s, o) {\n  return (\n    if_some(run_object_method(object_proto_, s, o), function(v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_object_internal_set_prototype_of = function (s, o, v) {\n  return (\n    if_value(ordinary_set_prototype_of(s, o, v), function(s1, v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_set_prototype_of = function (s, o, v) {\n  return (\n    check_assert((function () {\n        var _switch_arg_50 = type_of(v);\n        switch (_switch_arg_50.tag) {\n          case "Coq_type_object":\n            return (true);\n          case "Coq_type_null":\n            return (true);\n          default:\n            return (false);\n        }\n        }()), function(_pat_any_51) {\n        \n        return (\n          if_some(run_object_method(object_extensible_, s, o),\n            function(extensible) {\n              \n              return (\n                if_some(run_object_method(object_prototype_, s, o),\n                  function(current) {\n                    \n                    var sv = same_value(v, current);\n                    if (sv) {\n                      return (res_out(s, res_val(Coq_value_bool(true))));\n                    } else {\n                      if (!(extensible)) {\n                        return (res_out(s, res_val(Coq_value_bool(false))));\n                      } else {\n                        var repeat = function (p, done_) {\n                          if (!(done_)) {\n                            switch (p.tag) {\n                              case "Coq_value_null":\n                                return (repeat(p, true));\n                              case "Coq_value_object":\n                                var p_l = p.value;\n                                if (same_value(p, Coq_value_object(o))) {\n                                  return (\n                                    res_out(s,\n                                      res_val(Coq_value_bool(false))));\n                                } else {\n                                  return (\n                                    if_some(\n                                      run_object_method(\n                                        object_get_prototype_of_, s, p_l),\n                                      function(gpo) {\n                                        \n                                        switch (gpo.tag) {\n                                          case "Coq_builtin_get_prototype_of_default":\n                                            return (\n                                              if_some(\n                                                run_object_method(\n                                                  object_prototype_, s, p_l),\n                                                function(prototype) {\n                                                  \n                                                  return (\n                                                    repeat(prototype, false));\n                                                }));\n                                          default:\n                                            return (repeat(p, true));\n                                        }\n                                        }));\n                                }\n                              default:\n                                throw false;\n                            }\n                            \n                          } else {\n                            return (\n                              if_some(\n                                run_object_set_internal(object_set_proto, s,\n                                  o, v), function(s$) {\n                                  \n                                  return (\n                                    res_spec(s$,\n                                      res_val(Coq_value_bool(true))));}));\n                          }\n                        };\n                        return (repeat(v, false));\n                      }\n                    }}));}));}));\n};\n\nvar ordinary_object_internal_is_extensible = function (s, o) {\n  return (\n    if_value(ordinary_is_extensible(s, o), function(s1, v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_is_extensible = function (s, o) {\n  return (\n    if_some(run_object_method(object_extensible_, s, o), function(b) {\n        \n        return (res_out(s, res_val(Coq_value_bool(b))));}));\n};\n\nvar ordinary_object_internal_prevent_extensions = function (s, o) {\n  return (\n    if_value(ordinary_prevent_extensions(s, o), function(s1, v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_prevent_extensions = function (s, o) {\n  return (\n    if_some(run_object_set_internal(object_set_extensible, s, o, false),\n      function(s$) { \n                     return (res_ter(s, res_val(Coq_value_bool(true))));}));\n};\n\nvar ordinary_object_internal_get_own_property = function (s, o, p) {\n  return (\n    if_spec(ordinary_get_own_property(s, o, p), function(s, d) {\n        \n        return (res_spec(s, d));}));\n};\n\nvar ordinary_get_own_property = function (s, o, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_52) {\n        \n        var p = string_of_value(p);\n        if (!(object_property_exists(s, o, p))) {\n          return (res_spec(s, Descriptor_undef()));\n        } else {\n          var d = descriptor_intro_empty;\n          return (\n            if_some(object_retrieve_property(s, o, p), function(x) {\n                \n                switch (x.tag) {\n                  case "Coq_attributes_data_of":\n                    var x = x.value;\n                    var d = Object.assign({}, d, {\n                                descriptor_value: Some(\n                                                    x.attributes_data_value),\n                                descriptor_writable: Some(\n                                                       x.attributes_data_writable)\n                              });\n                    break;\n                  case "Coq_attributes_accessor_of":\n                    var x = x.value;\n                    var d = Object.assign({}, d, {\n                                descriptor_get: Some(\n                                                  x.attributes_accessor_get),\n                                descriptor_set: Some(\n                                                  x.attributes_accessor_set)\n                              });\n                    break;\n                }\n                \n                var d = Object.assign({}, d, {\n                            descriptor_enumerable: Some(\n                                                     attributes_enumerable(x))\n                          });\n                var d = Object.assign({}, d, {\n                            descriptor_configurable: Some(\n                                                       attributes_configurable(\n                                                         x))});\n                return (res_spec(s, Descriptor(d)));}));\n        }}));\n};\n\nvar ordinary_object_internal_define_own_property = function (s, o, p, desc) {\n  return (ordinary_define_own_property(s, o, p, desc));\n};\n\nvar ordinary_define_own_property = function (s, o, p, desc) {\n  return (\n    if_spec(object_internal_get_own_property(s, o, p), function(s, current) {\n        \n        return (\n          if_some(run_object_method(object_extensible_, s, o),\n            function(extensible) {\n              \n              return (\n                validate_and_apply_property_descriptor(s,\n                  Coq_value_object(o), p, extensible, desc, current));}));}));\n};\n\nvar is_compatible_property_descriptor = function (s, extensible, desc, current) {\n  return (\n    validate_and_apply_property_descriptor(s, Coq_value_undef(),\n      Coq_value_undef(), extensible, desc, current));\n};\n\nvar validate_and_apply_property_descriptor = function (s, o, p, extensible, desc, current) {\n  return (\n    check_assert((value_compare(o, Coq_value_undef()) || is_property_key(p)),\n      function(_pat_any_54) {\n        \n        var p = string_of_value(p);\n        switch (current.tag) {\n          case "Descriptor_undef":\n            if (!(extensible)) {\n              return (res_out(s, res_val(Coq_value_bool(false))));\n            } else {\n              return (\n                check_assert(extensible, function(_pat_any_53) {\n                    \n                    return (\n                      if_some((function () {\n                          switch (o.tag) {\n                            case "Coq_value_object":\n                              var l = o.value;\n                              if ((is_generic_descriptor(Descriptor(desc))\n                                  || is_data_descriptor(Descriptor(desc)))) {\n                                return (\n                                  object_set_property(s, l, p,\n                                    Coq_attributes_data_of(\n                                      attributes_data_of_descriptor(desc))));\n                              } else {\n                                return (\n                                  object_set_property(s, l, p,\n                                    Coq_attributes_accessor_of(\n                                      attributes_accessor_of_descriptor(desc))));\n                              }\n                            case "Coq_value_undef":\n                              return (Some(s));\n                            default:\n                              return (None());\n                          }\n                          }()), function(s) {\n                          \n                          return (res_ter(s, res_val(Coq_value_bool(true))));\n                        }));}));\n            }\n          case "Descriptor":\n            var current = current.descriptor;\n            return (\n              let_ret((function () {\n                  if (descriptor_is_empty(desc)) {\n                    return (\n                      Return(res_ter(s, res_val(Coq_value_bool(true)))));\n                  } else {\n                    return (Continue(s));\n                  }}()), function(s) {\n                  \n                  return (\n                    let_ret((function () {\n                        if (descriptor_contained_by(desc, current,\n                              same_value)) {\n                          return (\n                            Return(res_ter(s, res_val(Coq_value_bool(true)))));\n                        } else {\n                          return (Continue(s));\n                        }}()), function(s) {\n                        \n                        return (\n                          let_ret((function () {\n                              if (option_compare(bool_eq,\n                                    current.descriptor_configurable,\n                                    Some(false))) {\n                                if (option_compare(bool_eq,\n                                      desc.descriptor_configurable,\n                                      Some(true))) {\n                                  return (\n                                    Return(\n                                      res_ter(s,\n                                        res_val(Coq_value_bool(false)))));\n                                } else {\n                                  if ((is_some(desc.descriptor_enumerable)\n                                      && !(\n                                           some_compare(bool_eq,\n                                             current.descriptor_enumerable,\n                                             desc.descriptor_enumerable)))) {\n                                    return (\n                                      Return(\n                                        res_ter(s,\n                                          res_val(Coq_value_bool(false)))));\n                                  } else {\n                                    return (Continue(s));\n                                  }\n                                }\n                              } else {\n                                return (Continue(s));\n                              }}()), function(s) {\n                              \n                              return (\n                                let_ret((function () {\n                                    if (is_generic_descriptor(\n                                          Descriptor(desc))) {\n                                      return (Continue(s));\n                                    } else {\n                                      if (!(\n                                            bool_eq(\n                                              is_data_descriptor(\n                                                Descriptor(current)),\n                                              is_data_descriptor(\n                                                Descriptor(desc))))) {\n                                        if (option_compare(bool_eq,\n                                              current.descriptor_configurable,\n                                              Some(false))) {\n                                          return (\n                                            Return(\n                                              res_ter(s,\n                                                res_val(\n                                                  Coq_value_bool(false)))));\n                                        } else {\n                                          if (is_data_descriptor(\n                                                Descriptor(current))) {\n                                            var s = unsome_default(s,\n                                                      (function () {\n                                                        switch (o.tag) {\n                                                          case "Coq_value_object":\n                                                            var l = o.value;\n                                                            return (\n                                                              object_map_property(\n                                                                s, l, p,\n                                                                attributes_accessor_of_attributes_data));\n                                                          default:\n                                                            return (Some(s));\n                                                        }\n                                                        }()));\n                                            return (Continue(s));\n                                          } else {\n                                            var s = unsome_default(s,\n                                                      (function () {\n                                                        switch (o.tag) {\n                                                          case "Coq_value_object":\n                                                            var l = o.value;\n                                                            return (\n                                                              object_map_property(\n                                                                s, l, p,\n                                                                attributes_data_of_attributes_accessor));\n                                                          default:\n                                                            return (Some(s));\n                                                        }\n                                                        }()));\n                                            return (Continue(s));\n                                          }\n                                        }\n                                      } else {\n                                        if ((is_data_descriptor(\n                                               Descriptor(current))\n                                            && is_data_descriptor(\n                                                 Descriptor(desc)))) {\n                                          if (option_compare(bool_eq,\n                                                current.descriptor_configurable,\n                                                Some(false))) {\n                                            if ((option_compare(bool_eq,\n                                                   current.descriptor_writable,\n                                                   Some(false))\n                                                && option_compare(bool_eq,\n                                                     desc.descriptor_writable,\n                                                     Some(true)))) {\n                                              return (\n                                                Return(\n                                                  res_ter(s,\n                                                    res_val(\n                                                      Coq_value_bool(false)))));\n                                            } else {\n                                              if (option_compare(bool_eq,\n                                                    current.descriptor_writable,\n                                                    Some(false))) {\n                                                if ((is_some(\n                                                       desc.descriptor_value)\n                                                    && !(\n                                                         option_compare(\n                                                           same_value,\n                                                           desc.descriptor_value,\n                                                           current.descriptor_value)))) {\n                                                  return (\n                                                    Return(\n                                                      res_ter(s,\n                                                        res_val(\n                                                          Coq_value_bool(\n                                                            false)))));\n                                                } else {\n                                                  return (Continue(s));\n                                                }\n                                              } else {\n                                                return (Continue(s));\n                                              }\n                                            }\n                                          } else {\n                                            if (!(\n                                                  option_compare(bool_eq,\n                                                    current.descriptor_configurable,\n                                                    Some(true)))) {\n                                              return (\n                                                Return(\n                                                  spec_assertion_failure({})));\n                                            } else {\n                                              return (Continue(s));\n                                            }\n                                          }\n                                        } else {\n                                          if (!(\n                                                (is_accessor_descriptor(\n                                                   Descriptor(current))\n                                                && is_accessor_descriptor(\n                                                     Descriptor(desc))))) {\n                                            return (\n                                              Return(\n                                                spec_assertion_failure({})));\n                                          } else {\n                                            if (option_compare(bool_eq,\n                                                  current.descriptor_configurable,\n                                                  Some(false))) {\n                                              if ((is_some(\n                                                     desc.descriptor_set)\n                                                  && !(\n                                                       option_compare(\n                                                         same_value,\n                                                         desc.descriptor_set,\n                                                         current.descriptor_set)))) {\n                                                return (\n                                                  Return(\n                                                    res_ter(s,\n                                                      res_val(\n                                                        Coq_value_bool(false)))));\n                                              } else {\n                                                if ((is_some(\n                                                       desc.descriptor_get)\n                                                    && !(\n                                                         option_compare(\n                                                           same_value,\n                                                           desc.descriptor_get,\n                                                           current.descriptor_get)))) {\n                                                  return (\n                                                    Return(\n                                                      res_ter(s,\n                                                        res_val(\n                                                          Coq_value_bool(\n                                                            false)))));\n                                                } else {\n                                                  return (Continue(s));\n                                                }\n                                              }\n                                            } else {\n                                              return (Continue(s));\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }}()), function(s) {\n                                    \n                                    return (\n                                      if_some((function () {\n                                          switch (o.tag) {\n                                            case "Coq_value_object":\n                                              var l = o.value;\n                                              return (\n                                                object_map_property(s, l, p,\n                                                  function (a) {\n                                                    return (\n                                                      attributes_update(a,\n                                                        desc));}));\n                                            default:\n                                              return (Some(s));\n                                          }\n                                          }()), function(s) {\n                                          \n                                          return (\n                                            res_ter(s,\n                                              res_val(Coq_value_bool(true))));\n                                        }));}));}));}));}));\n        }\n        }));\n};\n\nvar ordinary_object_internal_has_property = function (s, o, p) {\n  return (ordinary_has_property(s, o, p));\n};\n\nvar ordinary_has_property = function (s, o, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_55) {\n        \n        return (\n          if_spec(object_internal_get_own_property(s, o, p), function(s,\n            hasOwn) {\n              \n              if (!(\n                    _compare_JsSyntax_undef_descriptor(hasOwn,\n                      Descriptor_undef()))) {\n                return (res_ter(s, res_val(Coq_value_bool(true))));\n              } else {\n                return (\n                  if_value(object_internal_get_prototype_of(s, o),\n                    function(s, parent) {\n                      \n                      if (!(\n                            _compare_JsSyntax_value(parent, Coq_value_null()))) {\n                        return (\n                          object_internal_has_property(s,\n                            loc_of_value(parent), p));\n                      } else {\n                        return (res_ter(s, res_val(Coq_value_bool(false))));\n                      }}));\n              }}));}));\n};\n\nvar ordinary_object_internal_get = function (s, o, p, receiver) {\n  return (ordinary_get(s, o, p, receiver));\n};\n\nvar ordinary_get = function (s, o, p, receiver) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_57) {\n        \n        return (\n          if_spec(object_internal_get_own_property(s, o, p), function(s,\n            desc) {\n              \n              if (_compare_JsSyntax_undef_descriptor(desc,\n                    Descriptor_undef())) {\n                return (\n                  if_value(object_internal_get_prototype_of(s, o),\n                    function(s, parent) {\n                      \n                      if (_compare_JsSyntax_value(parent, Coq_value_null())) {\n                        return (res_ter(s, res_val(Coq_value_undef())));\n                      } else {\n                        var parent = loc_of_value(parent);\n                        return (object_internal_get(s, parent, p, receiver));\n                      }}));\n              } else {\n                if (is_data_descriptor(desc)) {\n                  var desc = descriptor_get_defined(desc);\n                  return (\n                    if_some(descriptor_value(desc), function(value) {\n                        \n                        return (res_ter(s, res_val(value)));}));\n                } else {\n                  return (\n                    check_assert(is_accessor_descriptor(desc),\n                      function(_pat_any_56) {\n                        \n                        var desc = descriptor_get_defined(desc);\n                        return (\n                          if_some(descriptor_get(desc), function(getter) {\n                              \n                              if (_compare_JsSyntax_value(getter,\n                                    Coq_value_undef())) {\n                                return (\n                                  res_ter(s, res_val(Coq_value_undef())));\n                              } else {\n                                return (call(s, getter, receiver, None()));\n                              }}));}));\n                }\n              }}));}));\n};\n\nvar ordinary_object_internal_set = function (s, o, p, v, receiver) {\n  return (ordinary_set(s, o, p, v, receiver));\n};\n\nvar ordinary_set = function (s, o, p, v, receiver) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_60) {\n        \n        return (\n          if_spec(object_internal_get_own_property(s, o, p), function(s,\n            ownDesc) {\n              \n              return (\n                let_ret((function () {\n                    if (_compare_JsSyntax_undef_descriptor(ownDesc,\n                          Descriptor_undef())) {\n                      return (\n                        if_value_ret(object_internal_get_prototype_of(s, o),\n                          function(s, parent) {\n                            \n                            if (!(\n                                  _compare_JsSyntax_value(parent,\n                                    Coq_value_null()))) {\n                              var parent = loc_of_value(parent);\n                              return (\n                                Return(\n                                  object_internal_set(s, parent, p, v,\n                                    receiver)));\n                            } else {\n                              return (\n                                Continue(\n                                  Descriptor({\n                                      descriptor_value: Some(\n                                                          Coq_value_undef()),\n                                      descriptor_writable: Some(false),\n                                      descriptor_get: None(),\n                                      descriptor_set: None(),\n                                      descriptor_enumerable: Some(true),\n                                      descriptor_configurable: Some(true)})));\n                            }}));\n                    } else {\n                      return (Continue(ownDesc));\n                    }}()), function(ownDesc) {\n                    \n                    if (is_data_descriptor(ownDesc)) {\n                      var ownDesc = descriptor_get_defined(ownDesc);\n                      return (\n                        if_some(ownDesc.descriptor_writable,\n                          function(writable) {\n                            \n                            if (!(writable)) {\n                              return (\n                                res_ter(s, res_val(Coq_value_bool(false))));\n                            } else {\n                              if (!(\n                                    _compare_JsSyntax_coq_type(\n                                      type_of(receiver), Coq_type_object()))) {\n                                return (\n                                  res_ter(s, res_val(Coq_value_bool(false))));\n                              } else {\n                                var receiver = loc_of_value(receiver);\n                                return (\n                                  if_spec(\n                                    object_internal_get_own_property(s,\n                                      receiver, p), function(s,\n                                    existingDescriptor) {\n                                      \n                                      if (!(\n                                            _compare_JsSyntax_undef_descriptor(\n                                              existingDescriptor,\n                                              Descriptor_undef()))) {\n                                        if (is_accessor_descriptor(\n                                              existingDescriptor)) {\n                                          return (\n                                            res_ter(s,\n                                              res_val(Coq_value_bool(false))));\n                                        } else {\n                                          var existingDescriptor = descriptor_get_defined(\n                                                                    existingDescriptor);\n                                          return (\n                                            if_some(\n                                              existingDescriptor.descriptor_writable,\n                                              function(w) {\n                                                \n                                                if (!(w)) {\n                                                  return (\n                                                    res_ter(s,\n                                                      res_val(\n                                                        Coq_value_bool(false))));\n                                                } else {\n                                                  var valueDesc = descriptor_with_value(\n                                                                    descriptor_intro_empty,\n                                                                    Some(v));\n                                                  return (\n                                                    object_internal_define_own_property(\n                                                      s, receiver, p,\n                                                      valueDesc));\n                                                }}));\n                                        }\n                                      } else {\n                                        return (\n                                          create_data_property(s,\n                                            Coq_value_object(receiver), p, v));\n                                      }}));\n                              }\n                            }}));\n                    } else {\n                      return (\n                        check_assert(is_accessor_descriptor(ownDesc),\n                          function(_pat_any_59) {\n                            \n                            var ownDesc = descriptor_get_defined(ownDesc);\n                            return (\n                              if_some(ownDesc.descriptor_set,\n                                function(setter) {\n                                  \n                                  if (_compare_JsSyntax_value(setter,\n                                        Coq_value_undef())) {\n                                    return (\n                                      res_ter(s,\n                                        res_val(Coq_value_bool(false))));\n                                  } else {\n                                    return (\n                                      if_spec(\n                                        call(s, setter, receiver,\n                                          Some(mk_cons(v, mk_nil()))),\n                                        function(s, _pat_any_58) {\n                                          \n                                          return (\n                                            res_ter(s,\n                                              res_val(Coq_value_bool(true))));\n                                        }));\n                                  }}));}));\n                    }}));}));}));\n};\n\nvar ordinary_object_internal_delete = function (s, o, p) {\n  return (ordinary_delete(s, o, p));\n};\n\nvar ordinary_delete = function (s, o, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_61) {\n        \n        return (\n          if_spec(object_internal_get_own_property(s, o, p), function(s,\n            desc) {\n              \n              if (_compare_JsSyntax_undef_descriptor(desc,\n                    Descriptor_undef())) {\n                return (res_ter(s, res_val(Coq_value_bool(true))));\n              } else {\n                var desc = descriptor_get_defined(desc);\n                if (some_compare(===, descriptor_configurable(desc),\n                      Some(true))) {\n                  var p = string_of_value(p);\n                  return (\n                    if_some(\n                      run_object_heap_map_properties(s, o, function (props) {\n                          return (HeapStr.rem(props, p));}), function(s) {\n                        \n                        return (res_ter(s, res_val(Coq_value_bool(true))));}));\n                } else {\n                  return (res_ter(s, res_val(Coq_value_bool(false))));\n                }\n              }}));}));\n};\n\nvar ordinary_object_internal_own_property_keys = function (s, o) {\n  return (\n    if_spec(ordinary_own_property_keys(s, o), function(s, k) {\n        \n        return (res_spec(s, k));}));\n};\n\nvar ordinary_own_property_keys = function (s, o) {\n  return (\n    if_some(object_properties_keys_as_list_option(s, o), function(keys) {\n        \n        var keys = LibList.map(function (key) {\n                       return (Coq_value_string(key));}, keys);\n        return (res_spec(s, keys));}));\n};\n\nvar object_create = function (s, proto, internalSlotsList) {\n  var internalSlotsList = unsome_default(mk_nil(), internalSlotsList);\n  var obj = object_new(proto, "");\n  var _tuple_arg_62 = object_alloc(s, obj);\n  var l = _tuple_arg_62[0], s = _tuple_arg_62[1];\n  return (res_ter(s, res_val(Coq_value_object(l))));\n};\n\nvar add_restricted_function_properties = function (s, f, realm) {\n  var thrower = Coq_value_object(\n                  Coq_object_loc_prealloc(Coq_prealloc_throw_type_error()));\n  return (\n    assert_success(\n      define_property_or_throw(s, f, Coq_value_string("caller"),\n        Object.assign({}, descriptor_intro_empty, {\n            descriptor_get: Some(thrower),\n            descriptor_set: Some(thrower),\n            descriptor_enumerable: Some(false),\n            descriptor_configurable: Some(true)})), function(s,\n      _pat_any_63) {\n        \n        return (\n          assert_success(\n            define_property_or_throw(s, f, Coq_value_string("arguments"),\n              Object.assign({}, descriptor_intro_empty, {\n                  descriptor_get: Some(thrower),\n                  descriptor_set: Some(thrower),\n                  descriptor_enumerable: Some(false),\n                  descriptor_configurable: Some(true)})), function(s, rv) {\n              \n              return (res_ter(s, res_normal(rv)));}));}));\n};\n\nvar builtin_throw_type_error = function (s, c, thisArgument, argumentsList, newTarget) {\n  return (run_error(s, c, Coq_native_error_type()));\n};\n\nvar array_create = function (s, length, proto) {\n  return (\n    run_construct_prealloc(s, some_context, Coq_prealloc_array(),\n      mk_cons(length, mk_nil())));\n};\n\nvar is_proxy_exotic_object = function (s, l) {\n  return (object_has_internal_slot(s, l, object_proxy_handler_));\n};\n\nvar proxy_object_internal_get_prototype_of = function (s, o) {\n  return (\n    if_some(run_object_method(object_proxy_handler_, s, o),\n      function(handler) {\n        \n        return (\n          if_some(handler, function(handler) {\n              \n              if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                return (run_error_no_c(s, Coq_native_error_type()));\n              } else {\n                return (\n                  check_assert(\n                    _compare_JsSyntax_coq_type(type_of(handler),\n                      Coq_type_object()), function(_pat_any_64) {\n                      \n                      return (\n                        if_some(\n                          run_object_method(object_proxy_target_, s, o),\n                          function(target) {\n                            \n                            return (\n                              if_some(target, function(target) {\n                                  \n                                  return (\n                                    if_value(\n                                      get_method(s, handler,\n                                        Coq_value_string("getPrototypeOf")),\n                                      function(s, trap) {\n                                        \n                                        if (_compare_JsSyntax_value(trap,\n                                              Coq_value_undef())) {\n                                          return (\n                                            object_internal_get_prototype_of(\n                                              s, loc_of_value(target)));\n                                        } else {\n                                          return (\n                                            if_value(\n                                              call(s, trap, handler,\n                                                Some(\n                                                  mk_cons(target, mk_nil()))),\n                                              function(s, handlerProto) {\n                                                \n                                                if (!(\n                                                      (_compare_JsSyntax_coq_type(\n                                                         type_of(\n                                                           handlerProto),\n                                                         Coq_type_object())\n                                                      || _compare_JsSyntax_value(\n                                                           handlerProto,\n                                                           Coq_value_null())))) {\n                                                  return (\n                                                    run_error_no_c(s,\n                                                      Coq_native_error_type()));\n                                                } else {\n                                                  return (\n                                                    if_bool(\n                                                      is_extensible(s,\n                                                        target), function(s,\n                                                      extensibleTarget) {\n                                                        \n                                                        if (extensibleTarget) {\n                                                          return (\n                                                            res_ter(s,\n                                                              res_val(\n                                                                handlerProto)));\n                                                        } else {\n                                                          return (\n                                                            if_value(\n                                                              object_internal_get_prototype_of(\n                                                                s,\n                                                                loc_of_value(\n                                                                  target)),\n                                                              function(s,\n                                                              targetProto) {\n                                                                \n                                                                if (!(\n                                                                    same_value(\n                                                                    handlerProto,\n                                                                    targetProto))) {\n                                                                  return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                } else {\n                                                                  return (\n                                                                    res_ter(\n                                                                    s,\n                                                                    res_val(\n                                                                    handlerProto)));\n                                                                }}));\n                                                        }}));\n                                                }}));\n                                        }}));}));}));}));\n              }}));}));\n};\n\nvar proxy_object_internal_set_prototype_of = function (s, o, v) {\n  return (\n    check_assert(\n      (_compare_JsSyntax_coq_type(type_of(v), Coq_type_object())\n      || _compare_JsSyntax_coq_type(type_of(v), Coq_type_null())),\n      function(_pat_any_66) {\n        \n        return (\n          if_some(run_object_method(object_proxy_handler_, s, o),\n            function(handler) {\n              \n              return (\n                if_some(handler, function(handler) {\n                    \n                    if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                      return (run_error_no_c(s, Coq_native_error_type()));\n                    } else {\n                      return (\n                        check_assert(\n                          _compare_JsSyntax_coq_type(type_of(handler),\n                            Coq_type_object()), function(_pat_any_65) {\n                            \n                            return (\n                              if_some(\n                                run_object_method(object_proxy_target_, s, o),\n                                function(target) {\n                                  \n                                  return (\n                                    if_some(target, function(target) {\n                                        \n                                        return (\n                                          if_value(\n                                            get_method(s, handler,\n                                              Coq_value_string("")),\n                                            function(s, trap) {\n                                              \n                                              if (_compare_JsSyntax_value(\n                                                    trap, Coq_value_undef())) {\n                                                return (\n                                                  object_internal_set_prototype_of(\n                                                    s, loc_of_value(target),\n                                                    v));\n                                              } else {\n                                                return (\n                                                  if_value(\n                                                    call(s, trap, handler,\n                                                      Some(\n                                                        mk_cons(target,\n                                                          mk_cons(v,\n                                                            mk_nil())))),\n                                                    function(s, tempVal) {\n                                                      \n                                                      var booleanTrapResult = \n                                                      to_boolean(tempVal);\n                                                      if (!(\n                                                            booleanTrapResult)) {\n                                                        return (\n                                                          res_ter(s,\n                                                            res_val(\n                                                              Coq_value_bool(\n                                                                false))));\n                                                      } else {\n                                                        return (\n                                                          if_bool(\n                                                            is_extensible(s,\n                                                              target),\n                                                            function(s,\n                                                            extensibleTarget) {\n                                                              \n                                                              if (extensibleTarget) {\n                                                                return (\n                                                                  res_ter(s,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    true))));\n                                                              } else {\n                                                                return (\n                                                                  if_value(\n                                                                    object_internal_get_prototype_of(\n                                                                    s,\n                                                                    loc_of_value(\n                                                                    target)),\n                                                                    function(s,\n                                                                    targetProto) {\n                                                                    \n                                                                    if (\n                                                                    !(\n                                                                    same_value(\n                                                                    v,\n                                                                    targetProto))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_ter(\n                                                                    s,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    true))));\n                                                                    }}));\n                                                              }}));\n                                                      }}));\n                                              }}));}));}));}));\n                    }}));}));}));\n};\n\nvar proxy_object_internal_is_extensible = function (s, o) {\n  return (\n    if_some(run_object_method(object_proxy_handler_, s, o),\n      function(handler) {\n        \n        return (\n          if_some(handler, function(handler) {\n              \n              if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                return (run_error_no_c(s, Coq_native_error_type()));\n              } else {\n                return (\n                  check_assert(\n                    _compare_JsSyntax_coq_type(type_of(handler),\n                      Coq_type_object()), function(_pat_any_67) {\n                      \n                      return (\n                        if_some(\n                          run_object_method(object_proxy_target_, s, o),\n                          function(target) {\n                            \n                            return (\n                              if_some(target, function(target) {\n                                  \n                                  return (\n                                    if_value(\n                                      get_method(s, handler,\n                                        Coq_value_string("isExtensible")),\n                                      function(s, trap) {\n                                        \n                                        if (_compare_JsSyntax_value(trap,\n                                              Coq_value_undef())) {\n                                          return (\n                                            object_internal_is_extensible(s,\n                                              loc_of_value(target)));\n                                        } else {\n                                          return (\n                                            if_value(\n                                              call(s, trap, handler,\n                                                Some(\n                                                  mk_cons(target, mk_nil()))),\n                                              function(s, tempVal) {\n                                                \n                                                var booleanTrapResult = \n                                                to_boolean(tempVal);\n                                                return (\n                                                  if_value(\n                                                    object_internal_is_extensible(\n                                                      s,\n                                                      loc_of_value(target)),\n                                                    function(s,\n                                                    targetResult) {\n                                                      \n                                                      if (!(\n                                                            same_value(\n                                                              Coq_value_bool(\n                                                                booleanTrapResult),\n                                                              targetResult))) {\n                                                        return (\n                                                          run_error_no_c(s,\n                                                            Coq_native_error_type(\n                                                              )));\n                                                      } else {\n                                                        return (\n                                                          res_ter(s,\n                                                            res_val(\n                                                              Coq_value_bool(\n                                                                booleanTrapResult))));\n                                                      }}));}));\n                                        }}));}));}));}));\n              }}));}));\n};\n\nvar proxy_object_internal_prevent_extensions = function (s, o) {\n  return (\n    if_some(run_object_method(object_proxy_handler_, s, o),\n      function(handler) {\n        \n        return (\n          if_some(handler, function(handler) {\n              \n              if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                return (run_error_no_c(s, Coq_native_error_type()));\n              } else {\n                return (\n                  check_assert(\n                    _compare_JsSyntax_coq_type(type_of(handler),\n                      Coq_type_object()), function(_pat_any_68) {\n                      \n                      return (\n                        if_some(\n                          run_object_method(object_proxy_target_, s, o),\n                          function(target) {\n                            \n                            return (\n                              if_some(target, function(target) {\n                                  \n                                  return (\n                                    if_value(\n                                      get_method(s, handler,\n                                        Coq_value_string("preventExtensions")),\n                                      function(s, trap) {\n                                        \n                                        if (_compare_JsSyntax_value(trap,\n                                              Coq_value_undef())) {\n                                          return (\n                                            object_internal_prevent_extensions(\n                                              s, loc_of_value(target)));\n                                        } else {\n                                          return (\n                                            if_value(\n                                              call(s, trap, handler,\n                                                Some(\n                                                  mk_cons(target, mk_nil()))),\n                                              function(s, tempVal) {\n                                                \n                                                var booleanTrapResult = \n                                                to_boolean(tempVal);\n                                                return (\n                                                  let_ret((function () {\n                                                      if (booleanTrapResult) {\n                                                        return (\n                                                          if_bool_ret(\n                                                            object_internal_is_extensible(\n                                                              s,\n                                                              loc_of_value(\n                                                                target)),\n                                                            function(s,\n                                                            targetIsExtensible) {\n                                                              \n                                                              if (targetIsExtensible) {\n                                                                return (\n                                                                  Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                              } else {\n                                                                return (\n                                                                  Continue(s));\n                                                              }}));\n                                                      } else {\n                                                        return (Continue(s));\n                                                      }}()), function(s) {\n                                                      \n                                                      return (\n                                                        res_ter(s,\n                                                          res_val(\n                                                            Coq_value_bool(\n                                                              booleanTrapResult))));\n                                                    }));}));\n                                        }}));}));}));}));\n              }}));}));\n};\n\nvar proxy_object_internal_get_own_property = function (s, o, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_70) {\n        \n        return (\n          if_some(run_object_method(object_proxy_handler_, s, o),\n            function(handler) {\n              \n              return (\n                if_some(handler, function(handler) {\n                    \n                    if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                      return (run_error_no_c(s, Coq_native_error_type()));\n                    } else {\n                      return (\n                        check_assert(\n                          _compare_JsSyntax_coq_type(type_of(handler),\n                            Coq_type_object()), function(_pat_any_69) {\n                            \n                            return (\n                              if_some(\n                                run_object_method(object_proxy_target_, s, o),\n                                function(target) {\n                                  \n                                  return (\n                                    if_some(target, function(target) {\n                                        \n                                        return (\n                                          if_value(\n                                            get_method(s, handler,\n                                              Coq_value_string(\n                                                "getOwnPropertyDescriptor")),\n                                            function(s, trap) {\n                                              \n                                              if (_compare_JsSyntax_value(\n                                                    trap, Coq_value_undef())) {\n                                                return (\n                                                  object_internal_get_own_property(\n                                                    s, o, p));\n                                              } else {\n                                                return (\n                                                  if_value(\n                                                    call(s, trap, handler,\n                                                      Some(\n                                                        mk_cons(target,\n                                                          mk_cons(p,\n                                                            mk_nil())))),\n                                                    function(s,\n                                                    trapResultObj) {\n                                                      \n                                                      if (!(\n                                                            (_compare_JsSyntax_coq_type(\n                                                               type_of(\n                                                                 trapResultObj),\n                                                               Coq_type_object(\n                                                                 ))\n                                                            || _compare_JsSyntax_value(\n                                                                 trapResultObj,\n                                                                 Coq_value_undef(\n                                                                   ))))) {\n                                                        return (\n                                                          throw_result(\n                                                            run_error_no_c(s,\n                                                              Coq_native_error_type(\n                                                                ))));\n                                                      } else {\n                                                        return (\n                                                          if_spec(\n                                                            object_internal_get_own_property(\n                                                              s,\n                                                              loc_of_value(\n                                                                target), p),\n                                                            function(s,\n                                                            targetDesc) {\n                                                              \n                                                              if (_compare_JsSyntax_value(\n                                                                    trapResultObj,\n                                                                    Coq_value_undef(\n                                                                    ))) {\n                                                                if (_compare_JsSyntax_undef_descriptor(\n                                                                    targetDesc,\n                                                                    Descriptor_undef(\n                                                                    ))) {\n                                                                  return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    Descriptor_undef(\n                                                                    )));\n                                                                } else {\n                                                                  var targetDesc = \n                                                                  descriptor_get_defined(\n                                                                    targetDesc);\n                                                                  if (\n                                                                  _compare_option(\n                                                                    descriptor_configurable(\n                                                                    targetDesc),\n                                                                    Some(\n                                                                    false))) {\n                                                                    return (\n                                                                    throw_result(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                  } else {\n                                                                    return (\n                                                                    if_bool(\n                                                                    is_extensible(\n                                                                    s,\n                                                                    target),\n                                                                    function(s,\n                                                                    extensibleTarget) {\n                                                                    \n                                                                    if (\n                                                                    !(\n                                                                    extensibleTarget)) {\n                                                                    return (\n                                                                    throw_result(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    Descriptor_undef(\n                                                                    )));\n                                                                    }}));\n                                                                  }\n                                                                }\n                                                              } else {\n                                                                return (\n                                                                  if_bool(\n                                                                    is_extensible(\n                                                                    s,\n                                                                    target),\n                                                                    function(s,\n                                                                    extensibleTarget) {\n                                                                    \n                                                                    return (\n                                                                    if_spec(\n                                                                    to_property_descriptor(\n                                                                    s,\n                                                                    trapResultObj),\n                                                                    function(s,\n                                                                    resultDesc) {\n                                                                    \n                                                                    var resultDesc = \n                                                                    complete_property_descriptor(\n                                                                    Descriptor(\n                                                                    resultDesc));\n                                                                    return (\n                                                                    if_bool(\n                                                                    is_compatible_property_descriptor(\n                                                                    s,\n                                                                    extensibleTarget,\n                                                                    resultDesc,\n                                                                    targetDesc),\n                                                                    function(s,\n                                                                    valid) {\n                                                                    \n                                                                    if (\n                                                                    !(valid)) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    if (\n                                                                    (\n                                                                    _compare_option(\n                                                                    descriptor_configurable(\n                                                                    resultDesc),\n                                                                    Some(\n                                                                    true))\n                                                                    && \n                                                                    (\n                                                                    _compare_JsSyntax_undef_descriptor(\n                                                                    targetDesc,\n                                                                    Descriptor_undef(\n                                                                    ))\n                                                                    || \n                                                                    _compare_option(\n                                                                    descriptor_configurable(\n                                                                    descriptor_get_defined(\n                                                                    targetDesc)),\n                                                                    Some(\n                                                                    true))))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    Descriptor(\n                                                                    resultDesc)));\n                                                                    }\n                                                                    }}));}));\n                                                                    }));\n                                                              }}));\n                                                      }}));\n                                              }}));}));}));}));\n                    }}));}));}));\n};\n\nvar proxy_object_internal_define_own_property = function (s, o, p, desc) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_72) {\n        \n        return (\n          if_some(run_object_method(object_proxy_handler_, s, o),\n            function(handler) {\n              \n              return (\n                if_some(handler, function(handler) {\n                    \n                    if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                      return (run_error_no_c(s, Coq_native_error_type()));\n                    } else {\n                      return (\n                        check_assert(\n                          _compare_JsSyntax_coq_type(type_of(handler),\n                            Coq_type_object()), function(_pat_any_71) {\n                            \n                            return (\n                              if_some(\n                                run_object_method(object_proxy_target_, s, o),\n                                function(target) {\n                                  \n                                  return (\n                                    if_some(target, function(target) {\n                                        \n                                        return (\n                                          if_value(\n                                            get_method(s, handler,\n                                              Coq_value_string(\n                                                "defineProperty")),\n                                            function(s, trap) {\n                                              \n                                              if (_compare_JsSyntax_value(\n                                                    trap, Coq_value_undef())) {\n                                                return (\n                                                  object_internal_define_own_property(\n                                                    s, loc_of_value(target),\n                                                    p, desc));\n                                              } else {\n                                                return (\n                                                  if_value(\n                                                    from_property_descriptor(\n                                                      s, Descriptor(desc)),\n                                                    function(s, descObj) {\n                                                      \n                                                      return (\n                                                        if_value(\n                                                          call(s, trap,\n                                                            handler,\n                                                            Some(\n                                                              mk_cons(target,\n                                                                mk_cons(p,\n                                                                  mk_cons(\n                                                                    descObj,\n                                                                    mk_nil()))))),\n                                                          function(s,\n                                                          tempVar) {\n                                                            \n                                                            var booleanTrapResult = \n                                                            to_boolean(\n                                                              tempVar);\n                                                            if (!(\n                                                                  booleanTrapResult)) {\n                                                              return (\n                                                                res_ter(s,\n                                                                  res_val(\n                                                                    Coq_value_bool(\n                                                                    false))));\n                                                            } else {\n                                                              return (\n                                                                if_spec(\n                                                                  object_internal_get_own_property(\n                                                                    s,\n                                                                    loc_of_value(\n                                                                    target),\n                                                                    p),\n                                                                  function(s,\n                                                                  targetDesc) {\n                                                                    \n                                                                    return (\n                                                                    if_bool(\n                                                                    is_extensible(\n                                                                    s,\n                                                                    target),\n                                                                    function(s,\n                                                                    extensibleTarget) {\n                                                                    \n                                                                    var settingConfigFalse = \n                                                                    (\n                                                                    is_some(\n                                                                    desc.descriptor_configurable)\n                                                                    && \n                                                                    _compare_option(\n                                                                    desc.descriptor_configurable,\n                                                                    Some(\n                                                                    false)));\n                                                                    return (\n                                                                    let_ret(\n                                                                    (function () {\n                                                                    if (\n                                                                    _compare_JsSyntax_undef_descriptor(\n                                                                    targetDesc,\n                                                                    Descriptor_undef(\n                                                                    ))) {\n                                                                    if (\n                                                                    !(\n                                                                    extensibleTarget)) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    if (settingConfigFalse) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }\n                                                                    }\n                                                                    } else {\n                                                                    return (\n                                                                    if_bool_ret(\n                                                                    is_compatible_property_descriptor(\n                                                                    s,\n                                                                    extensibleTarget,\n                                                                    desc,\n                                                                    targetDesc),\n                                                                    function(s,\n                                                                    tempVal) {\n                                                                    \n                                                                    var targetDesc = \n                                                                    descriptor_get_defined(\n                                                                    targetDesc);\n                                                                    if (\n                                                                    !(\n                                                                    tempVal)) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    if (\n                                                                    (settingConfigFalse\n                                                                    && \n                                                                    _compare_option(\n                                                                    targetDesc.descriptor_configurable,\n                                                                    Some(\n                                                                    true)))) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }\n                                                                    }}));\n                                                                    }}()),\n                                                                    function(s) {\n                                                                    \n                                                                    return (\n                                                                    res_ter(\n                                                                    s,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    true))));\n                                                                    }));}));\n                                                                  }));\n                                                            }}));}));\n                                              }}));}));}));}));\n                    }}));}));}));\n};\n\nvar proxy_object_internal_has_property = function (s, o, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_74) {\n        \n        return (\n          if_some(run_object_method(object_proxy_handler_, s, o),\n            function(handler) {\n              \n              return (\n                if_some(handler, function(handler) {\n                    \n                    if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                      return (run_error_no_c(s, Coq_native_error_type()));\n                    } else {\n                      return (\n                        check_assert(\n                          _compare_JsSyntax_coq_type(type_of(handler),\n                            Coq_type_object()), function(_pat_any_73) {\n                            \n                            return (\n                              if_some(\n                                run_object_method(object_proxy_target_, s, o),\n                                function(target) {\n                                  \n                                  return (\n                                    if_some(target, function(target) {\n                                        \n                                        return (\n                                          if_value(\n                                            get_method(s, handler,\n                                              Coq_value_string("has")),\n                                            function(s, trap) {\n                                              \n                                              if (_compare_JsSyntax_value(\n                                                    trap, Coq_value_undef())) {\n                                                return (\n                                                  object_internal_has_property(\n                                                    s, loc_of_value(target),\n                                                    p));\n                                              } else {\n                                                return (\n                                                  if_value(\n                                                    call(s, trap, handler,\n                                                      Some(\n                                                        mk_cons(target,\n                                                          mk_cons(p,\n                                                            mk_nil())))),\n                                                    function(s, tempVar) {\n                                                      \n                                                      var booleanTrapResult = \n                                                      to_boolean(tempVar);\n                                                      return (\n                                                        let_ret(\n                                                          (function () {\n                                                            if (!(\n                                                                  booleanTrapResult)) {\n                                                              return (\n                                                                if_spec_ret(\n                                                                  object_internal_get_own_property(\n                                                                    s,\n                                                                    loc_of_value(\n                                                                    target),\n                                                                    p),\n                                                                  function(s,\n                                                                  targetDesc) {\n                                                                    \n                                                                    if (\n                                                                    !(\n                                                                    _compare_JsSyntax_undef_descriptor(\n                                                                    targetDesc,\n                                                                    Descriptor_undef(\n                                                                    )))) {\n                                                                    var targetDesc = \n                                                                    descriptor_get_defined(\n                                                                    targetDesc);\n                                                                    if (\n                                                                    _compare_option(\n                                                                    targetDesc.descriptor_configurable,\n                                                                    Some(\n                                                                    false))) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    if_bool_ret(\n                                                                    is_extensible(\n                                                                    s,\n                                                                    target),\n                                                                    function(s,\n                                                                    extensibleTarget) {\n                                                                    \n                                                                    if (\n                                                                    !(\n                                                                    extensibleTarget)) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }}));\n                                                                    }\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }}));\n                                                            } else {\n                                                              return (\n                                                                Continue(s));\n                                                            }}()),\n                                                          function(s) {\n                                                            \n                                                            return (\n                                                              res_ter(s,\n                                                                res_val(\n                                                                  Coq_value_bool(\n                                                                    booleanTrapResult))));\n                                                          }));}));\n                                              }}));}));}));}));\n                    }}));}));}));\n};\n\nvar proxy_object_internal_get = function (s, o, p, receiver) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_76) {\n        \n        return (\n          if_some(run_object_method(object_proxy_handler_, s, o),\n            function(handler) {\n              \n              return (\n                if_some(handler, function(handler) {\n                    \n                    if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                      return (run_error_no_c(s, Coq_native_error_type()));\n                    } else {\n                      return (\n                        check_assert(\n                          _compare_JsSyntax_coq_type(type_of(handler),\n                            Coq_type_object()), function(_pat_any_75) {\n                            \n                            return (\n                              if_some(\n                                run_object_method(object_proxy_target_, s, o),\n                                function(target) {\n                                  \n                                  return (\n                                    if_some(target, function(target) {\n                                        \n                                        return (\n                                          if_value(\n                                            get_method(s, handler,\n                                              Coq_value_string("get")),\n                                            function(s, trap) {\n                                              \n                                              if (_compare_JsSyntax_value(\n                                                    trap, Coq_value_undef())) {\n                                                return (\n                                                  object_internal_get(s,\n                                                    loc_of_value(target), p,\n                                                    receiver));\n                                              } else {\n                                                return (\n                                                  if_value(\n                                                    call(s, trap, handler,\n                                                      Some(\n                                                        mk_cons(target,\n                                                          mk_cons(p,\n                                                            mk_cons(receiver,\n                                                              mk_nil()))))),\n                                                    function(s, trapResult) {\n                                                      \n                                                      return (\n                                                        if_spec(\n                                                          object_internal_get_own_property(\n                                                            s,\n                                                            loc_of_value(\n                                                              target), p),\n                                                          function(s,\n                                                          targetDesc) {\n                                                            \n                                                            return (\n                                                              let_ret(\n                                                                (function () {\n                                                                  if (\n                                                                  !(\n                                                                    _compare_JsSyntax_undef_descriptor(\n                                                                    targetDesc,\n                                                                    Descriptor_undef(\n                                                                    )))) {\n                                                                    var targetDesc$ = \n                                                                    descriptor_get_defined(\n                                                                    targetDesc);\n                                                                    return (\n                                                                    let_ret_ret(\n                                                                    (function () {\n                                                                    if (\n                                                                    (\n                                                                    is_data_descriptor(\n                                                                    targetDesc)\n                                                                    && \n                                                                    (\n                                                                    _compare_option(\n                                                                    targetDesc$.descriptor_configurable,\n                                                                    Some(\n                                                                    false))\n                                                                    && \n                                                                    _compare_option(\n                                                                    targetDesc$.descriptor_writable,\n                                                                    Some(\n                                                                    false))))) {\n                                                                    if (\n                                                                    !(\n                                                                    same_value(\n                                                                    trapResult,\n                                                                    unsome_error(\n                                                                    targetDesc$.descriptor_value)))) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }}()),\n                                                                    function(s) {\n                                                                    \n                                                                    return (\n                                                                    let_ret_ret(\n                                                                    (function () {\n                                                                    if (\n                                                                    (\n                                                                    is_accessor_descriptor(\n                                                                    targetDesc)\n                                                                    && \n                                                                    (\n                                                                    _compare_option(\n                                                                    targetDesc$.descriptor_configurable,\n                                                                    Some(\n                                                                    false))\n                                                                    && \n                                                                    _compare_option(\n                                                                    targetDesc$.descriptor_get,\n                                                                    Some(\n                                                                    Coq_value_undef(\n                                                                    )))))) {\n                                                                    if (\n                                                                    !(\n                                                                    _compare_JsSyntax_value(\n                                                                    trapResult,\n                                                                    Coq_value_undef(\n                                                                    )))) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }}()),\n                                                                    function(s) {\n                                                                    \n                                                                    return (\n                                                                    Continue(\n                                                                    s));}));\n                                                                    }));\n                                                                  } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                  }}()),\n                                                                function(s) {\n                                                                  \n                                                                  return (\n                                                                    res_ter(\n                                                                    s,\n                                                                    res_val(\n                                                                    trapResult)));\n                                                                }));}));}));\n                                              }}));}));}));}));\n                    }}));}));}));\n};\n\nvar proxy_object_internal_set = function (s, o, p, v, receiver) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_78) {\n        \n        return (\n          if_some(run_object_method(object_proxy_handler_, s, o),\n            function(handler) {\n              \n              return (\n                if_some(handler, function(handler) {\n                    \n                    if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                      return (run_error_no_c(s, Coq_native_error_type()));\n                    } else {\n                      return (\n                        check_assert(\n                          _compare_JsSyntax_coq_type(type_of(handler),\n                            Coq_type_object()), function(_pat_any_77) {\n                            \n                            return (\n                              if_some(\n                                run_object_method(object_proxy_target_, s, o),\n                                function(target) {\n                                  \n                                  return (\n                                    if_some(target, function(target) {\n                                        \n                                        return (\n                                          if_value(\n                                            get_method(s, handler,\n                                              Coq_value_string("set")),\n                                            function(s, trap) {\n                                              \n                                              if (_compare_JsSyntax_value(\n                                                    trap, Coq_value_undef())) {\n                                                return (\n                                                  object_internal_set(s,\n                                                    loc_of_value(target), p,\n                                                    v, receiver));\n                                              } else {\n                                                return (\n                                                  if_value(\n                                                    call(s, trap, handler,\n                                                      Some(\n                                                        mk_cons(target,\n                                                          mk_cons(p,\n                                                            mk_cons(v,\n                                                              mk_cons(\n                                                                receiver,\n                                                                mk_nil())))))),\n                                                    function(s, tempVar) {\n                                                      \n                                                      var booleanTrapResult = \n                                                      to_boolean(tempVar);\n                                                      if (!(\n                                                            booleanTrapResult)) {\n                                                        return (\n                                                          res_ter(s,\n                                                            res_val(\n                                                              Coq_value_bool(\n                                                                false))));\n                                                      } else {\n                                                        return (\n                                                          if_spec(\n                                                            object_internal_get_own_property(\n                                                              s,\n                                                              loc_of_value(\n                                                                target), p),\n                                                            function(s,\n                                                            targetDesc) {\n                                                              \n                                                              return (\n                                                                let_ret(\n                                                                  (function () {\n                                                                    if (\n                                                                    !(\n                                                                    _compare_JsSyntax_undef_descriptor(\n                                                                    targetDesc,\n                                                                    Descriptor_undef(\n                                                                    )))) {\n                                                                    var targetDesc$ = \n                                                                    descriptor_get_defined(\n                                                                    targetDesc);\n                                                                    return (\n                                                                    let_ret_ret(\n                                                                    (function () {\n                                                                    if (\n                                                                    (\n                                                                    is_data_descriptor(\n                                                                    targetDesc)\n                                                                    && \n                                                                    (\n                                                                    _compare_option(\n                                                                    targetDesc$.descriptor_configurable,\n                                                                    Some(\n                                                                    false))\n                                                                    && \n                                                                    _compare_option(\n                                                                    targetDesc$.descriptor_writable,\n                                                                    Some(\n                                                                    false))))) {\n                                                                    if (\n                                                                    !(\n                                                                    same_value(\n                                                                    v,\n                                                                    unsome_error(\n                                                                    targetDesc$.descriptor_value)))) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }}()),\n                                                                    function(s) {\n                                                                    \n                                                                    return (\n                                                                    let_ret_ret(\n                                                                    (function () {\n                                                                    if (\n                                                                    (\n                                                                    is_accessor_descriptor(\n                                                                    targetDesc)\n                                                                    && \n                                                                    _compare_option(\n                                                                    targetDesc$.descriptor_configurable,\n                                                                    Some(\n                                                                    false)))) {\n                                                                    if (\n                                                                    _compare_option(\n                                                                    targetDesc$.descriptor_set,\n                                                                    Some(\n                                                                    Coq_value_undef(\n                                                                    )))) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }}()),\n                                                                    function(s) {\n                                                                    \n                                                                    return (\n                                                                    Continue(\n                                                                    s));}));\n                                                                    }));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    s));\n                                                                    }}()),\n                                                                  function(s) {\n                                                                    \n                                                                    return (\n                                                                    res_ter(\n                                                                    s,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    true))));\n                                                                  }));}));\n                                                      }}));\n                                              }}));}));}));}));\n                    }}));}));}));\n};\n\nvar proxy_object_internal_delete = function (s, o, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_80) {\n        \n        return (\n          if_some(run_object_method(object_proxy_handler_, s, o),\n            function(handler) {\n              \n              return (\n                if_some(handler, function(handler) {\n                    \n                    if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                      return (run_error_no_c(s, Coq_native_error_type()));\n                    } else {\n                      return (\n                        check_assert(\n                          _compare_JsSyntax_coq_type(type_of(handler),\n                            Coq_type_object()), function(_pat_any_79) {\n                            \n                            return (\n                              if_some(\n                                run_object_method(object_proxy_target_, s, o),\n                                function(target) {\n                                  \n                                  return (\n                                    if_some(target, function(target) {\n                                        \n                                        return (\n                                          if_value(\n                                            get_method(s, handler,\n                                              Coq_value_string(\n                                                "deleteProperty")),\n                                            function(s, trap) {\n                                              \n                                              if (_compare_JsSyntax_value(\n                                                    trap, Coq_value_undef())) {\n                                                return (\n                                                  object_internal_delete(s,\n                                                    loc_of_value(target), p));\n                                              } else {\n                                                return (\n                                                  if_value(\n                                                    call(s, trap, handler,\n                                                      Some(\n                                                        mk_cons(target,\n                                                          mk_cons(p,\n                                                            mk_nil())))),\n                                                    function(s, tempVar) {\n                                                      \n                                                      var booleanTrapResult = \n                                                      to_boolean(tempVar);\n                                                      if (!(\n                                                            booleanTrapResult)) {\n                                                        return (\n                                                          res_ter(s,\n                                                            res_val(\n                                                              Coq_value_bool(\n                                                                false))));\n                                                      } else {\n                                                        return (\n                                                          if_spec(\n                                                            object_internal_get_own_property(\n                                                              s,\n                                                              loc_of_value(\n                                                                target), p),\n                                                            function(s,\n                                                            targetDesc) {\n                                                              \n                                                              if (_compare_JsSyntax_undef_descriptor(\n                                                                    targetDesc,\n                                                                    Descriptor_undef(\n                                                                    ))) {\n                                                                return (\n                                                                  res_ter(s,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    true))));\n                                                              } else {\n                                                                var targetDesc = \n                                                                descriptor_get_defined(\n                                                                  targetDesc);\n                                                                if (_compare_option(\n                                                                    targetDesc.descriptor_configurable,\n                                                                    Some(\n                                                                    false))) {\n                                                                  return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                } else {\n                                                                  return (\n                                                                    res_ter(\n                                                                    s,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    true))));\n                                                                }\n                                                              }}));\n                                                      }}));\n                                              }}));}));}));}));\n                    }}));}));}));\n};\n\nvar proxy_object_internal_own_property_keys = function (s, o) {\n  return (\n    if_some(run_object_method(object_proxy_handler_, s, o),\n      function(handler) {\n        \n        return (\n          if_some(handler, function(handler) {\n              \n              if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                return (run_error_no_c(s, Coq_native_error_type()));\n              } else {\n                return (\n                  check_assert(\n                    _compare_JsSyntax_coq_type(type_of(handler),\n                      Coq_type_object()), function(_pat_any_84) {\n                      \n                      return (\n                        if_some(\n                          run_object_method(object_proxy_target_, s, o),\n                          function(target) {\n                            \n                            return (\n                              if_some(target, function(target) {\n                                  \n                                  return (\n                                    if_value(\n                                      get_method(s, handler,\n                                        Coq_value_string("ownKeys")),\n                                      function(s, trap) {\n                                        \n                                        if (_compare_JsSyntax_value(trap,\n                                              Coq_value_undef())) {\n                                          return (\n                                            object_internal_own_property_keys(\n                                              s, loc_of_value(target)));\n                                        } else {\n                                          return (\n                                            if_value(\n                                              call(s, trap, handler,\n                                                Some(\n                                                  mk_cons(target, mk_nil()))),\n                                              function(s, trapResultArray) {\n                                                \n                                                return (\n                                                  if_spec(\n                                                    create_list_from_array_like(\n                                                      s, trapResultArray,\n                                                      Some(\n                                                        mk_cons(\n                                                          Coq_type_string(),\n                                                          mk_nil()))),\n                                                    function(s, trapResult) {\n                                                      \n                                                      return (\n                                                        if_bool(\n                                                          is_extensible(s,\n                                                            target),\n                                                          function(s,\n                                                          extensibleTarget) {\n                                                            \n                                                            return (\n                                                              if_spec(\n                                                                object_internal_own_property_keys(\n                                                                  s,\n                                                                  loc_of_value(\n                                                                    target)),\n                                                                function(s,\n                                                                targetKeys) {\n                                                                  \n                                                                  var targetConfigurableKeys = \n                                                                  mk_nil();\n                                                                  var targetNonconfigurableKeys = \n                                                                  mk_nil();\n                                                                  return (\n                                                                    let_ret(\n                                                                    iterate(\n                                                                    targetKeys,\n                                                                    [s, targetConfigurableKeys, targetNonconfigurableKeys],\n                                                                    function (key, acc) {\n                                                                    var s = acc[0],\n                                                                    targetConfigurableKeys = acc[1],\n                                                                    targetNonconfigurableKeys = acc[2];\n                                                                    return (\n                                                                    if_spec_ret(\n                                                                    object_internal_get_own_property(\n                                                                    s,\n                                                                    loc_of_value(\n                                                                    target),\n                                                                    key),\n                                                                    function(s,\n                                                                    desc) {\n                                                                    \n                                                                    if (\n                                                                    (\n                                                                    !(\n                                                                    _compare_JsSyntax_undef_descriptor(\n                                                                    desc,\n                                                                    Descriptor_undef(\n                                                                    )))\n                                                                    && \n                                                                    _compare_option(\n                                                                    descriptor_get_defined(\n                                                                    desc).descriptor_configurable,\n                                                                    Some(\n                                                                    false)))) {\n                                                                    return (\n                                                                    Continue(\n                                                                    [s, targetConfigurableKeys, \n                                                                    append(\n                                                                    targetNonconfigurableKeys,\n                                                                    mk_cons(\n                                                                    key,\n                                                                    mk_nil()))]));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    [s, \n                                                                    append(\n                                                                    targetConfigurableKeys,\n                                                                    mk_cons(\n                                                                    key,\n                                                                    mk_nil())), targetNonconfigurableKeys]));\n                                                                    }}));}),\n                                                                    function(_tuple_arg_83) {\n                                                                    var s = _tuple_arg_83[0],\n                                                                    targetConfigurableKeys = _tuple_arg_83[1],\n                                                                    targetNonconfigurableKeys = _tuple_arg_83[2];\n                                                                    \n                                                                    if (\n                                                                    (extensibleTarget\n                                                                    && \n                                                                    is_empty(\n                                                                    targetNonconfigurableKeys))) {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    trapResult));\n                                                                    } else {\n                                                                    var uncheckedResultKeys = trapResult;\n                                                                    return (\n                                                                    let_ret(\n                                                                    iterate(\n                                                                    targetNonconfigurableKeys,\n                                                                    [s, uncheckedResultKeys],\n                                                                    function (key, acc) {\n                                                                    var s = acc[0],\n                                                                    uncheckedResultKeys = acc[1];\n                                                                    if (\n                                                                    !(\n                                                                    mem_decide(\n                                                                    ===, key,\n                                                                    uncheckedResultKeys))) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    [s, \n                                                                    filter(\n                                                                    function (x) {\n                                                                    return (\n                                                                    !(\n                                                                    _compare_JsSyntax_value(\n                                                                    x, key)));\n                                                                    },\n                                                                    uncheckedResultKeys)]));\n                                                                    }}),\n                                                                    function(_tuple_arg_82) {\n                                                                    var s = _tuple_arg_82[0],\n                                                                    uncheckedResultKeys = _tuple_arg_82[1];\n                                                                    \n                                                                    if (extensibleTarget) {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    trapResult));\n                                                                    } else {\n                                                                    return (\n                                                                    let_ret(\n                                                                    iterate(\n                                                                    targetConfigurableKeys,\n                                                                    [s, uncheckedResultKeys],\n                                                                    function (key, acc) {\n                                                                    var s = acc[0],\n                                                                    uncheckedResultKeys = acc[1];\n                                                                    if (\n                                                                    !(\n                                                                    mem_decide(\n                                                                    ===, key,\n                                                                    uncheckedResultKeys))) {\n                                                                    return (\n                                                                    Return(\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    ))));\n                                                                    } else {\n                                                                    return (\n                                                                    Continue(\n                                                                    [s, \n                                                                    filter(\n                                                                    function (x) {\n                                                                    return (\n                                                                    !(\n                                                                    _compare_JsSyntax_value(\n                                                                    x, key)));\n                                                                    },\n                                                                    uncheckedResultKeys)]));\n                                                                    }}),\n                                                                    function(_tuple_arg_81) {\n                                                                    var s = _tuple_arg_81[0],\n                                                                    uncheckedResultKeys = _tuple_arg_81[1];\n                                                                    \n                                                                    if (\n                                                                    !(\n                                                                    is_empty(\n                                                                    uncheckedResultKeys))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    trapResult));\n                                                                    }}));\n                                                                    }}));\n                                                                    }}));}));\n                                                          }));}));}));\n                                        }}));}));}));}));\n              }}));}));\n};\n\nvar proxy_object_internal_call = function (s, o, thisArgument, argumentsList) {\n  return (\n    if_some(run_object_method(object_proxy_handler_, s, o),\n      function(handler) {\n        \n        return (\n          if_some(handler, function(handler) {\n              \n              if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                return (run_error_no_c(s, Coq_native_error_type()));\n              } else {\n                return (\n                  check_assert(\n                    _compare_JsSyntax_coq_type(type_of(handler),\n                      Coq_type_object()), function(_pat_any_85) {\n                      \n                      return (\n                        if_some(\n                          run_object_method(object_proxy_target_, s, o),\n                          function(target) {\n                            \n                            return (\n                              if_some(target, function(target) {\n                                  \n                                  return (\n                                    if_value(\n                                      get_method(s, handler,\n                                        Coq_value_string("apply")),\n                                      function(s, trap) {\n                                        \n                                        if (_compare_JsSyntax_value(trap,\n                                              Coq_value_undef())) {\n                                          return (\n                                            call(s, target, thisArgument,\n                                              Some(argumentsList)));\n                                        } else {\n                                          return (\n                                            if_value(\n                                              create_array_from_list(s,\n                                                argumentsList), function(s,\n                                              argArray) {\n                                                \n                                                return (\n                                                  call(s, trap, handler,\n                                                    Some(\n                                                      mk_cons(target,\n                                                        mk_cons(thisArgument,\n                                                          mk_cons(argArray,\n                                                            mk_nil()))))));}));\n                                        }}));}));}));}));\n              }}));}));\n};\n\nvar proxy_object_internal_construct = function (s, o, argumentsList, newTarget) {\n  return (\n    if_some(run_object_method(object_proxy_handler_, s, o),\n      function(handler) {\n        \n        return (\n          if_some(handler, function(handler) {\n              \n              if (_compare_JsSyntax_value(handler, Coq_value_null())) {\n                return (run_error_no_c(s, Coq_native_error_type()));\n              } else {\n                return (\n                  check_assert(\n                    _compare_JsSyntax_coq_type(type_of(handler),\n                      Coq_type_object()), function(_pat_any_87) {\n                      \n                      return (\n                        if_some(\n                          run_object_method(object_proxy_target_, s, o),\n                          function(target) {\n                            \n                            return (\n                              if_some(target, function(target) {\n                                  \n                                  return (\n                                    if_value(\n                                      get_method(s, handler,\n                                        Coq_value_string("construct")),\n                                      function(s, trap) {\n                                        \n                                        if (_compare_JsSyntax_value(trap,\n                                              Coq_value_undef())) {\n                                          return (\n                                            check_assert(\n                                              object_has_internal_method(s,\n                                                loc_of_value(target),\n                                                object_construct_),\n                                              function(_pat_any_86) {\n                                                \n                                                return (\n                                                  construct(s, target,\n                                                    Some(argumentsList),\n                                                    Some(newTarget)));}));\n                                        } else {\n                                          return (\n                                            if_value(\n                                              create_array_from_list(s,\n                                                argumentsList), function(s,\n                                              argArray) {\n                                                \n                                                return (\n                                                  if_value(\n                                                    call(s, trap, handler,\n                                                      Some(\n                                                        mk_cons(target,\n                                                          mk_cons(argArray,\n                                                            mk_cons(\n                                                              newTarget,\n                                                              mk_nil()))))),\n                                                    function(s, newObj) {\n                                                      \n                                                      if (!(\n                                                            _compare_JsSyntax_coq_type(\n                                                              type_of(newObj),\n                                                              Coq_type_object(\n                                                                )))) {\n                                                        return (\n                                                          run_error_no_c(s,\n                                                            Coq_native_error_type(\n                                                              )));\n                                                      } else {\n                                                        return (\n                                                          res_ter(s,\n                                                            res_val(newObj)));\n                                                      }}));}));\n                                        }}));}));}));}));\n              }}));}));\n};\n\nvar proxy_create = function (s, target, handler) {\n  if (!(_compare_JsSyntax_coq_type(type_of(target), Coq_type_object()))) {\n    return (run_error_no_c(s, Coq_native_error_type()));\n  } else {\n    if ((is_proxy_exotic_object(s, loc_of_value(target))\n        && _compare_option(\n             run_object_method(object_proxy_handler_, s,\n               loc_of_value(target)), Some(Some(Coq_value_null()))))) {\n      return (run_error_no_c(s, Coq_native_error_type()));\n    } else {\n      if (!(_compare_JsSyntax_coq_type(type_of(handler), Coq_type_object()))) {\n        return (run_error_no_c(s, Coq_native_error_type()));\n      } else {\n        if ((is_proxy_exotic_object(s, loc_of_value(handler))\n            && _compare_option(\n                 run_object_method(object_proxy_handler_, s,\n                   loc_of_value(handler)), Some(Some(Coq_value_null()))))) {\n          return (run_error_no_c(s, Coq_native_error_type()));\n        } else {\n          var _tuple_arg_88 = proxy_object_new(s);\n          var p = _tuple_arg_88[0], s = _tuple_arg_88[1];\n          return (\n            let_ret((function () {\n                if (is_callable(s, target)) {\n                  return (\n                    if_some_ret(\n                      run_object_set_internal(object_set_call, s, p,\n                        Coq_call_proxy()), function(s) {\n                        \n                        if (object_has_internal_method(s,\n                              loc_of_value(target), object_construct_)) {\n                          return (\n                            if_some_ret(\n                              run_object_set_internal(object_set_construct,\n                                s, p, Coq_construct_proxy()), function(s) {\n                                \n                                return (Continue(s));}));\n                        } else {\n                          return (Continue(s));\n                        }}));\n                } else {\n                  return (Continue(s));\n                }}()), function(s) {\n                \n                return (\n                  if_some(\n                    run_object_set_internal(object_set_proxy_target, s, p,\n                      target), function(s) {\n                      \n                      return (\n                        if_some(\n                          run_object_set_internal(object_set_proxy_handler,\n                            s, p, handler), function(s) {\n                            \n                            return (\n                              res_ter(s, res_val(Coq_value_object(p))));}));\n                    }));}));\n        }\n      }\n    }\n  }\n};\n\nvar builtin_object_freeze = function (s, c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()))) {\n    return (res_ter(s, res_val(o)));\n  } else {\n    return (\n      if_bool(set_integrity_level(s, o, "frozen"), function(s, status) {\n          \n          if (!(status)) {\n            return (run_error_no_c(s, Coq_native_error_type()));\n          } else {\n            return (res_ter(s, res_val(o)));\n          }}));\n  }\n};\n\nvar builtin_object_get_prototype_of = function (s, c, f, this, newTarget, o) {\n  return (\n    if_object(to_object(s, o), function(s, obj) {\n        \n        return (object_internal_get_prototype_of(s, obj));}));\n};\n\nvar builtin_object_is_extensible = function (s, c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()))) {\n    return (res_ter(s, res_val(Coq_value_bool(false))));\n  } else {\n    return (is_extensible(s, o));\n  }\n};\n\nvar builtin_object_is_frozen = function (s, c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()))) {\n    return (res_ter(s, res_val(Coq_value_bool(true))));\n  } else {\n    return (test_integrity_level(s, o, "frozen"));\n  }\n};\n\nvar builtin_object_is_sealed = function (s, c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()))) {\n    return (res_ter(s, res_val(Coq_value_bool(true))));\n  } else {\n    return (test_integrity_level(s, o, "sealed"));\n  }\n};\n\nvar builtin_object_prevent_extensions = function (s, c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()))) {\n    return (res_ter(s, res_val(o)));\n  } else {\n    return (\n      if_bool(object_internal_prevent_extensions(s, loc_of_value(o)),\n        function(s, status) {\n          \n          if (!(status)) {\n            return (run_error_no_c(s, Coq_native_error_type()));\n          } else {\n            return (res_ter(s, res_val(o)));\n          }}));\n  }\n};\n\nvar builtin_object_seal = function (s, c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()))) {\n    return (res_ter(s, res_val(o)));\n  } else {\n    return (\n      if_bool(set_integrity_level(s, o, "sealed"), function(s, status) {\n          \n          if (!(status)) {\n            return (run_error_no_c(s, Coq_native_error_type()));\n          } else {\n            return (res_ter(s, res_val(o)));\n          }}));\n  }\n};\n\nvar builtin_object_set_prototype_of = function (s, c, f, this, newTarget, o, proto) {\n  return (\n    if_value(require_object_coercible(s, o), function(s, o) {\n        \n        if (!(\n              (_compare_JsSyntax_coq_type(type_of(proto), Coq_type_object())\n              || _compare_JsSyntax_value(proto, Coq_value_null())))) {\n          return (run_error_no_c(s, Coq_native_error_type()));\n        } else {\n          if (!(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()))) {\n            return (res_ter(s, res_val(o)));\n          } else {\n            return (\n              if_bool(\n                object_internal_set_prototype_of(s, loc_of_value(o), proto),\n                function(s, status) {\n                  \n                  if (!(status)) {\n                    return (run_error_no_c(s, Coq_native_error_type()));\n                  } else {\n                    return (res_ter(s, res_val(o)));\n                  }}));\n          }\n        }}));\n};\n\nvar builtin_proxy_constructor = function (s, c, f, this, newTarget, target, handler) {\n  if (_compare_JsSyntax_value(newTarget, Coq_value_undef())) {\n    return (run_error_no_c(s, Coq_native_error_type()));\n  } else {\n    return (proxy_create(s, target, handler));\n  }\n};\n\nvar builtin_proxy_revocable = function (s, c, f, this, newTarget, target, handler) {\n  return (\n    if_value(proxy_create(s, target, handler), function(s, p) {\n        \n        return (\n          if_object(proxy_revocation_function_create(s), function(s,\n            revoker) {\n              \n              return (\n                if_some(\n                  run_object_set_internal(object_set_revocable_proxy, s,\n                    revoker, p), function(s) {\n                    \n                    return (\n                      if_value(\n                        object_create(s,\n                          Coq_value_object(\n                            Coq_object_loc_prealloc(\n                              Coq_prealloc_object_proto())), None()),\n                        function(s, result) {\n                          \n                          return (\n                            if_bool(\n                              create_data_property(s, result,\n                                Coq_value_string("proxy"), p), function(s,\n                              _pat_any_90) {\n                                \n                                return (\n                                  if_bool(\n                                    create_data_property(s, result,\n                                      Coq_value_string("revoke"),\n                                      Coq_value_object(revoker)), function(s,\n                                    _pat_any_89) {\n                                      \n                                      return (res_ter(s, res_val(result)));}));\n                              }));}));}));}));}));\n};\n\nvar proxy_revocation_function_create = function (s) {\n  return (Coq_result_not_yet_implemented());\n};\n\nvar builtin_proxy_revocation_function = function (s, c, f, this, newTarget) {\n  return (\n    if_some(run_object_method(object_revocable_proxy_, s, f), function(p) {\n        \n        return (\n          if_some(p, function(p) {\n              \n              if (_compare_JsSyntax_value(p, Coq_value_null())) {\n                return (res_ter(s, res_val(Coq_value_undef())));\n              } else {\n                var p = loc_of_value(p);\n                return (\n                  if_some(\n                    run_object_set_internal(object_set_revocable_proxy, s, f,\n                      Coq_value_null()), function(s) {\n                      \n                      return (\n                        check_assert(is_proxy_exotic_object(s, p),\n                          function(_pat_any_91) {\n                            \n                            return (\n                              if_some(\n                                run_object_set_internal(\n                                  object_set_proxy_target, s, p,\n                                  Coq_value_null()), function(s) {\n                                  \n                                  return (\n                                    if_some(\n                                      run_object_set_internal(\n                                        object_set_proxy_handler, s, p,\n                                        Coq_value_null()), function(s) {\n                                        \n                                        return (\n                                          res_ter(s,\n                                            res_val(Coq_value_undef())));}));\n                                }));}));}));\n              }}));}));\n};\n\nvar object_has_prop = function (s, c, l, x) {\n  return (object_internal_has_property(s, l, Coq_value_string(x)));\n};\n\nvar out_error_or_void = function (s, c, str, ne) {\n  if (str) {\n    return (run_error(s, c, ne));\n  } else {\n    return (res_void(s));\n  }\n};\n\nvar out_error_or_cst = function (s, c, str, ne, v) {\n  if (str) {\n    return (run_error(s, c, ne));\n  } else {\n    return (res_out(s, res_val(v)));\n  }\n};\n\nvar object_get_builtin = function (s, c, b, vthis, l, x) {\n  var def = function (s0, l0) {\n    return (\n      if_spec(run_object_get_prop(s0, c, l0, x), function(s1, d) {\n          \n          switch (d.tag) {\n            case "Coq_full_descriptor_undef":\n              return (res_ter(s1, res_val(Coq_value_undef())));\n            case "Coq_full_descriptor_some":\n              var a = d.value;\n              switch (a.tag) {\n                case "Coq_attributes_data_of":\n                  var ad = a.value;\n                  return (res_ter(s1, res_val(ad.attributes_data_value)));\n                case "Coq_attributes_accessor_of":\n                  var aa = a.value;\n                  var _switch_arg_92 = aa.attributes_accessor_get;\n                  switch (_switch_arg_92.tag) {\n                    case "Coq_value_undef":\n                      return (res_ter(s1, res_val(Coq_value_undef())));\n                    case "Coq_value_null":\n                      return (Coq_result_impossible());\n                    case "Coq_value_bool":\n                      var b0 = _switch_arg_92.value;\n                      return (Coq_result_impossible());\n                    case "Coq_value_number":\n                      var n = _switch_arg_92.value;\n                      return (Coq_result_impossible());\n                    case "Coq_value_string":\n                      var s2 = _switch_arg_92.value;\n                      return (Coq_result_impossible());\n                    case "Coq_value_object":\n                      var lf = _switch_arg_92.value;\n                      return (run_call(s1, c, lf, vthis, mk_nil()));\n                  }\n                  \n              }\n              \n          }\n          }));\n  };\n  var function0 = function (s0) {\n    return (\n      if_value(def(s0, l), function(s_2, v) {\n          \n          if (spec_function_get_error_case_dec(s_2, x, v)) {\n            return (run_error(s_2, c, Coq_native_error_type()));\n          } else {\n            return (res_ter(s_2, res_val(v)));\n          }}));\n  };\n  switch (b.tag) {\n    case "Coq_builtin_get_default":\n      return (def(s, l));\n    case "Coq_builtin_get_args_obj":\n      return (\n        if_some(run_object_method(object_parameter_map_, s, l),\n          function(lmapo) {\n            \n            return (\n              if_some(lmapo, function(lmap) {\n                  \n                  return (\n                    if_spec(run_object_get_own_prop(s, c, lmap, x),\n                      function(s0, d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (function0(s0));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (run_object_get(s0, c, lmap, x));\n                        }\n                        }));}));}));\n    default:\n      return (Coq_result_not_yet_implemented());\n  }\n  \n};\n\nvar run_object_get = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_, s, l), function(b) {\n        \n        return (object_get_builtin(s, c, b, Coq_value_object(l), l, x));}));\n};\n\nvar run_object_get_prop = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_prop_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_get_prop_default":\n            return (\n              if_spec(run_object_get_own_prop(s, c, l, x), function(s1, d) {\n                  \n                  if (full_descriptor_compare(d, Coq_full_descriptor_undef())) {\n                    return (\n                      if_some(run_object_method(object_proto_, s1, l),\n                        function(proto) {\n                          \n                          switch (proto.tag) {\n                            case "Coq_value_null":\n                              return (\n                                res_spec(s1, Coq_full_descriptor_undef()));\n                            case "Coq_value_object":\n                              var lproto = proto.value;\n                              return (run_object_get_prop(s1, c, lproto, x));\n                            default:\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s1,\n                                  "Found a non-object or null value as a prototype in [run_object_get_prop]."));\n                          }\n                          }));\n                  } else {\n                    return (res_spec(s1, d));\n                  }}));\n        }\n        }));\n};\n\nvar object_proto_is_prototype_of = function (s, l0, l) {\n  return (\n    if_some(run_object_method(object_proto_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_value_null":\n            return (res_out(s, res_val(Coq_value_bool(false))));\n          case "Coq_value_object":\n            var l_2 = b.value;\n            if (object_loc_compare(l_2, l0)) {\n              return (res_out(s, res_val(Coq_value_bool(true))));\n            } else {\n              return (object_proto_is_prototype_of(s, l0, l_2));\n            }\n          default:\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[run_object_method] returned a non-object in [object_proto_is_prototype_of_body]."));\n        }\n        }));\n};\n\nvar object_default_value = function (s, c, l, prefo) {\n  return (\n    if_some(run_object_method(object_default_value_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_default_value_default":\n            var gpref = unsome_default(Coq_preftype_number(), prefo);\n            var lpref = other_preftypes(gpref);\n            var sub0 = function (s_2, x, k) {\n              return (\n                if_value(run_object_get(s_2, c, l, x), function(s1, vfo) {\n                    \n                    return (\n                      if_some(run_callable(s1, vfo), function(co) {\n                          \n                          switch (co.tag) {\n                            case "Some":\n                              var b0 = co.value;\n                              return (\n                                if_object(res_out(s1, res_val(vfo)),\n                                  function(s2, lfunc) {\n                                    \n                                    return (\n                                      if_value(\n                                        run_call(s2, c, lfunc,\n                                          Coq_value_object(l), mk_nil()),\n                                        function(s3, v) {\n                                          \n                                          switch (v.tag) {\n                                            case "Coq_value_object":\n                                              var l0 = v.value;\n                                              return (k(s3));\n                                            default:\n                                              return (\n                                                res_out(s3, res_val(v)));\n                                          }\n                                          }));}));\n                            case "None":\n                              return (k(s1));\n                          }\n                          }));}));\n            };\n            var gmeth = method_of_preftype(gpref);\n            return (\n              sub0(s, gmeth, function (s_2) {\n                  var lmeth = method_of_preftype(lpref);\n                  return (\n                    sub0(s_2, lmeth, function (s_3) {\n                        return (run_error(s_3, c, Coq_native_error_type()));\n                      }));}));\n        }\n        }));\n};\n\nvar to_int32 = function (s, c, v) {\n  return (\n    if_number(to_number(s, v), function(s_2, n) {\n        \n        return (res_spec(s_2, JsNumber.to_int32(n)));}));\n};\n\nvar to_uint32 = function (s, c, v) {\n  return (\n    if_number(to_number(s, v), function(s_2, n) {\n        \n        return (res_spec(s_2, JsNumber.to_uint32(n)));}));\n};\n\nvar run_object_define_own_prop_array_loop = function (s, c, l, newLen, oldLen, newLenDesc, newWritable, throwcont, def) {\n  if ((newLen < oldLen)) {\n    var oldLen_2 = (oldLen - 1.);\n    return (\n      if_string(to_string(s, Coq_value_number(oldLen_2)), function(s0,\n        slen) {\n          \n          return (\n            if_bool(object_delete(s0, c, l, slen, false), function(s1,\n              deleteSucceeded) {\n                \n                if (!(deleteSucceeded)) {\n                  var newLenDesc0 = descriptor_with_value(newLenDesc,\n                                      Some(Coq_value_number((oldLen_2 + 1.))));\n                  if (!(newWritable)) {\n                    var newLenDesc1 = descriptor_with_writable(newLenDesc0,\n                                        Some(false));\n                  } else {\n                    var newLenDesc1 = newLenDesc0;\n                  }\n                  return (\n                    if_bool(def(s1, "length", newLenDesc1, false),\n                      function(s2, x) {\n                        \n                        return (\n                          out_error_or_cst(s2, c, throwcont,\n                            Coq_native_error_type(), Coq_value_bool(false)));\n                      }));\n                } else {\n                  return (\n                    run_object_define_own_prop_array_loop(s1, c, l, newLen,\n                      oldLen_2, newLenDesc, newWritable, throwcont, def));\n                }}));}));\n  } else {\n    if (!(newWritable)) {\n      return (\n        def(s, "length", {\n            descriptor_value: None(),\n            descriptor_writable: Some(false),\n            descriptor_get: None(),\n            descriptor_set: None(),\n            descriptor_enumerable: None(),\n            descriptor_configurable: None()}, false));\n    } else {\n      return (res_ter(s, res_val(Coq_value_bool(true))));\n    }\n  }\n};\n\nvar object_define_own_prop = function (s, c, l, x, desc, throwcont) {\n  var reject = function (s0, throwcont0) {\n    return (\n      out_error_or_cst(s0, c, throwcont0, Coq_native_error_type(),\n        Coq_value_bool(false)));\n  };\n  var def = function (s, p, d, _pat_any_93) {\n    return (ordinary_define_own_property(s, l, Coq_value_string(p), d));\n  };\n  return (\n    if_some(run_object_method(object_define_own_prop_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_define_own_prop_default":\n            return (\n              object_internal_define_own_property(s, l, Coq_value_string(x),\n                desc));\n          case "Coq_builtin_define_own_prop_array":\n            return (\n              if_spec(run_object_get_own_prop(s, c, l, "length"),\n                function(s0, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (\n                        function (s, m) {\n                            Debug.impossible_with_heap_because(__LOC__, s, m);\n                            return (Coq_result_impossible());}(s0,\n                          "Array length property descriptor cannot be undefined."));\n                    case "Coq_full_descriptor_some":\n                      var attr = d.value;\n                      switch (attr.tag) {\n                        case "Coq_attributes_data_of":\n                          var a = attr.value;\n                          var oldLen = a.attributes_data_value;\n                          switch (oldLen.tag) {\n                            case "Coq_value_object":\n                              var l0 = oldLen.value;\n                              Debug.impossible_with_heap_because(__LOC__, s0,\n                                "Spec asserts length of array is number.");\n                              return (Coq_result_impossible());\n                            default:\n                              return (\n                                if_number(to_number(s0, oldLen), function(s0,\n                                  oldLen) {\n                                    \n                                    var oldLen0 = JsNumber.to_uint32(oldLen);\n                                    var descValueOpt = desc.descriptor_value;\n                                    if (string_eq(x, "length")) {\n                                      switch (descValueOpt.tag) {\n                                        case "Some":\n                                          var descValue = descValueOpt.value;\n                                          return (\n                                            if_spec(\n                                              to_uint32(s0, c, descValue),\n                                              function(s1, newLen) {\n                                                \n                                                return (\n                                                  if_number(\n                                                    to_number(s1, descValue),\n                                                    function(s2, newLenN) {\n                                                      \n                                                      if (!(\n                                                            (newLen\n                                                            === newLenN))) {\n                                                        return (\n                                                          run_error(s2, c,\n                                                            Coq_native_error_range(\n                                                              )));\n                                                      } else {\n                                                        var newLenDesc = \n                                                        descriptor_with_value(\n                                                          desc,\n                                                          Some(\n                                                            Coq_value_number(\n                                                              newLen)));\n                                                        if (le_int_decidable(\n                                                              oldLen0,\n                                                              newLen)) {\n                                                          return (\n                                                            def(s2, "length",\n                                                              newLenDesc,\n                                                              throwcont));\n                                                        } else {\n                                                          if (!(\n                                                                a.attributes_data_writable)) {\n                                                            return (\n                                                              reject(s2,\n                                                                throwcont));\n                                                          } else {\n                                                            var _switch_arg_94 = newLenDesc.descriptor_writable;\n                                                            switch (_switch_arg_94.tag) {\n                                                              case "Some":\n                                                                var b0 = _switch_arg_94.value;\n                                                                if (b0) {\n                                                                  var newWritable = true;\n                                                                } else {\n                                                                  var newWritable = false;\n                                                                }\n                                                                break;\n                                                              case "None":\n                                                                var newWritable = true;\n                                                                break;\n                                                            }\n                                                            \n                                                            if (!(\n                                                                  newWritable)) {\n                                                              var newLenDesc0 = \n                                                              descriptor_with_writable(\n                                                                newLenDesc,\n                                                                Some(true));\n                                                            } else {\n                                                              var newLenDesc0 = newLenDesc;\n                                                            }\n                                                            return (\n                                                              if_bool(\n                                                                def(s2,\n                                                                  "length",\n                                                                  newLenDesc0,\n                                                                  throwcont),\n                                                                function(s3,\n                                                                succ) {\n                                                                  \n                                                                  if (\n                                                                  !(succ)) {\n                                                                    return (\n                                                                    res_ter(\n                                                                    s3,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    false))));\n                                                                  } else {\n                                                                    return (\n                                                                    run_object_define_own_prop_array_loop(\n                                                                    s3, c, l,\n                                                                    newLen,\n                                                                    oldLen0,\n                                                                    newLenDesc0,\n                                                                    newWritable,\n                                                                    throwcont,\n                                                                    def));\n                                                                  }}));\n                                                          }\n                                                        }\n                                                      }}));}));\n                                        case "None":\n                                          return (\n                                            def(s0, "length", desc,\n                                              throwcont));\n                                      }\n                                      \n                                    } else {\n                                      return (\n                                        if_spec(\n                                          to_uint32(s0, c,\n                                            Coq_value_string(x)),\n                                          function(s1, ilen) {\n                                            \n                                            return (\n                                              if_string(\n                                                to_string(s1,\n                                                  Coq_value_number(ilen)),\n                                                function(s2, slen) {\n                                                  \n                                                  if ((string_eq(x, slen)\n                                                      && !(\n                                                           (ilen\n                                                           == 4294967295.)))) {\n                                                    return (\n                                                      if_spec(\n                                                        to_uint32(s2, c,\n                                                          Coq_value_string(x)),\n                                                        function(s3, index) {\n                                                          \n                                                          if ((le_int_decidable(\n                                                                 oldLen0,\n                                                                 index)\n                                                              && !(\n                                                                   a.attributes_data_writable))) {\n                                                            return (\n                                                              reject(s3,\n                                                                throwcont));\n                                                          } else {\n                                                            return (\n                                                              if_bool(\n                                                                def(s3, x,\n                                                                  desc,\n                                                                  false),\n                                                                function(s4,\n                                                                b0) {\n                                                                  \n                                                                  if (\n                                                                  !(b0)) {\n                                                                    return (\n                                                                    reject(\n                                                                    s4,\n                                                                    throwcont));\n                                                                  } else {\n                                                                    if (\n                                                                    le_int_decidable(\n                                                                    oldLen0,\n                                                                    index)) {\n                                                                    var a0 = \n                                                                    descriptor_with_value(\n                                                                    descriptor_of_attributes(\n                                                                    Coq_attributes_data_of(\n                                                                    a)),\n                                                                    Some(\n                                                                    Coq_value_number(\n                                                                    (index\n                                                                    + 1.))));\n                                                                    return (\n                                                                    def(s4,\n                                                                    "length",\n                                                                    a0,\n                                                                    false));\n                                                                    } else {\n                                                                    return (\n                                                                    res_ter(\n                                                                    s4,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    true))));\n                                                                    }\n                                                                  }}));\n                                                          }}));\n                                                  } else {\n                                                    return (\n                                                      def(s2, x, desc,\n                                                        throwcont));\n                                                  }}));}));\n                                    }}));\n                          }\n                          \n                        case "Coq_attributes_accessor_of":\n                          var a = attr.value;\n                          return (\n                            function (s, m) {\n                                Debug.impossible_with_heap_because(__LOC__,\n                                  s, m);\n                                return (Coq_result_impossible());}(s0,\n                              "Array length property descriptor cannot be accessor."));\n                      }\n                      \n                  }\n                  }));\n          case "Coq_builtin_define_own_prop_args_obj":\n            return (\n              if_some(run_object_method(object_parameter_map_, s, l),\n                function(lmapo) {\n                  \n                  return (\n                    if_some(lmapo, function(lmap) {\n                        \n                        return (\n                          if_spec(run_object_get_own_prop(s, c, lmap, x),\n                            function(s0, d) {\n                              \n                              return (\n                                if_bool(def(s0, x, desc, false), function(s1,\n                                  b0) {\n                                    \n                                    if (b0) {\n                                      var follow = function (s2) {\n                                        return (\n                                          res_ter(s2,\n                                            res_val(Coq_value_bool(true))));\n                                      };\n                                      switch (d.tag) {\n                                        case "Coq_full_descriptor_undef":\n                                          return (follow(s1));\n                                        case "Coq_full_descriptor_some":\n                                          var a = d.value;\n                                          if (is_accessor_descriptor(\n                                                Descriptor(desc))) {\n                                            return (\n                                              if_bool(\n                                                object_delete(s1, c, lmap, x,\n                                                  false), function(s2, x0) {\n                                                  \n                                                  return (follow(s2));}));\n                                          } else {\n                                            var follow0 = function (s2) {\n                                              if (option_compare(bool_eq,\n                                                    desc.descriptor_writable,\n                                                    Some(false))) {\n                                                return (\n                                                  if_bool(\n                                                    object_delete(s2, c,\n                                                      lmap, x, false),\n                                                    function(s3, x0) {\n                                                      \n                                                      return (follow(s3));}));\n                                              } else {\n                                                return (follow(s2));\n                                              }\n                                            };\n                                            var _switch_arg_95 = desc.descriptor_value;\n                                            switch (_switch_arg_95.tag) {\n                                              case "Some":\n                                                var v = _switch_arg_95.value;\n                                                return (\n                                                  if_void(\n                                                    object_put(s1, c, lmap,\n                                                      x, v, throwcont),\n                                                    function(s2) {\n                                                      \n                                                      return (follow0(s2));}));\n                                              case "None":\n                                                return (follow0(s1));\n                                            }\n                                            \n                                          }\n                                      }\n                                      \n                                    } else {\n                                      return (reject(s1, throwcont));\n                                    }}));}));}));}));\n          default:\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar prim_new_object = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      var o1 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_bool_proto())),\n                 "Boolean");\n      var o = object_with_primitive_value(o1, Coq_value_bool(b));\n      var _tuple_arg_96 = object_alloc(s, o);\n      var l = _tuple_arg_96[0], s1 = _tuple_arg_96[1];\n      return (res_out(s1, res_val(Coq_value_object(l))));\n    case "Coq_value_number":\n      var n = _foo_.value;\n      var o1 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_number_proto())),\n                 "Number");\n      var o = object_with_primitive_value(o1, Coq_value_number(n));\n      var _tuple_arg_97 = object_alloc(s, o);\n      var l = _tuple_arg_97[0], s1 = _tuple_arg_97[1];\n      return (res_out(s1, res_val(Coq_value_object(l))));\n    case "Coq_value_string":\n      var s0 = _foo_.value;\n      var o2 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_string_proto())),\n                 "String");\n      var o1 = object_with_get_own_property(o2,\n                 Coq_builtin_get_own_prop_string());\n      var o = object_with_primitive_value(o1, Coq_value_string(s0));\n      var _tuple_arg_98 = object_alloc(s, o);\n      var l = _tuple_arg_98[0], s1 = _tuple_arg_98[1];\n      return (\n        if_some(\n          run_object_heap_map_properties(s1, l, function (p) {\n              return (\n                HeapStr.write(p, "length",\n                  Coq_attributes_data_of(\n                    attributes_data_intro_constant(\n                      Coq_value_number(number_of_int(strlength(s0)))))));}),\n          function(s_2) {\n            \n            return (res_ter(s_2, res_val(Coq_value_object(l))));}));\n    default:\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "[prim_new_object] received an null or undef."));\n  }\n  \n};\n\nvar to_object = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_undef":\n      return (run_error_no_c(s, Coq_native_error_type()));\n    case "Coq_value_null":\n      return (run_error_no_c(s, Coq_native_error_type()));\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      return (prim_new_object(s, _foo_));\n    case "Coq_value_number":\n      var n = _foo_.value;\n      return (prim_new_object(s, _foo_));\n    case "Coq_value_string":\n      var s0 = _foo_.value;\n      return (prim_new_object(s, _foo_));\n    case "Coq_value_object":\n      var l = _foo_.value;\n      return (res_out(s, res_val(Coq_value_object(l))));\n  }\n  \n};\n\nvar run_object_prim_value = function (s, l) {\n  return (\n    if_some(run_object_method(object_prim_value_, s, l), function(ov) {\n        \n        return (\n          if_some(ov, function(v) { \n                                    return (res_ter(s, res_val(v)));}));}));\n};\n\nvar prim_value_get = function (s, c, v, x) {\n  return (\n    if_object(to_object(s, v), function(s_2, l) {\n        \n        return (\n          object_get_builtin(s_2, c, Coq_builtin_get_default(), v, l, x));}));\n};\n\nvar env_record_has_binding = function (s, c, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              res_out(s, res_val(Coq_value_bool(HeapStr.indom_dec(ed, x)))));\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (object_has_prop(s, c, l0, x));\n        }\n        }));\n};\n\nvar lexical_env_get_identifier_ref = function (s, c, x, x0, str) {\n  switch (x.tag) {\n    case "[]":\n      return (res_spec(s, ref_create_value(Coq_value_undef(), x0, str)));\n    case "::":\n      var l = x.head, x_2 = x.tail;\n      return (\n        if_bool(env_record_has_binding(s, c, l, x0), function(s1, has) {\n            \n            if (has) {\n              return (res_spec(s1, ref_create_env_loc(l, x0, str)));\n            } else {\n              return (lexical_env_get_identifier_ref(s1, c, x_2, x0, str));\n            }}));\n  }\n  \n};\n\nvar object_delete = function (s, c, l, x, str) {\n  return (\n    if_some(run_object_method(object_delete_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_delete_default":\n            return (object_delete_default(s, c, l, x, str));\n          case "Coq_builtin_delete_args_obj":\n            return (\n              if_some(run_object_method(object_parameter_map_, s, l),\n                function(mo) {\n                  \n                  return (\n                    if_some(mo, function(m) {\n                        \n                        return (\n                          if_spec(run_object_get_own_prop(s, c, m, x),\n                            function(s1, d) {\n                              \n                              return (\n                                if_bool(\n                                  object_delete_default(s1, c, l, x, str),\n                                  function(s2, b0) {\n                                    \n                                    if (b0) {\n                                      switch (d.tag) {\n                                        case "Coq_full_descriptor_undef":\n                                          return (\n                                            res_ter(s2,\n                                              res_val(Coq_value_bool(b0))));\n                                        case "Coq_full_descriptor_some":\n                                          var a = d.value;\n                                          return (\n                                            if_bool(\n                                              object_delete(s2, c, m, x,\n                                                false), function(s3, b_2) {\n                                                \n                                                return (\n                                                  res_ter(s3,\n                                                    res_val(\n                                                      Coq_value_bool(b0))));\n                                              }));\n                                      }\n                                      \n                                    } else {\n                                      return (\n                                        res_ter(s2,\n                                          res_val(Coq_value_bool(b0))));\n                                    }}));}));}));}));\n          default:\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar env_record_delete_binding = function (s, c, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            var _switch_arg_99 = HeapStr.read_option(ed, x);\n            switch (_switch_arg_99.tag) {\n              case "Some":\n                var p = _switch_arg_99.value;\n                var mu = p[0], v = p[1];\n                switch (mu.tag) {\n                  case "Coq_mutability_uninitialized_immutable":\n                    return (res_out(s, res_val(Coq_value_bool(false))));\n                  case "Coq_mutability_immutable":\n                    return (res_out(s, res_val(Coq_value_bool(false))));\n                  case "Coq_mutability_nondeletable":\n                    return (res_out(s, res_val(Coq_value_bool(false))));\n                  case "Coq_mutability_deletable":\n                    var s_2 = env_record_write(s, l,\n                                Coq_env_record_decl(\n                                  decl_env_record_rem(ed, x)));\n                    return (res_out(s_2, res_val(Coq_value_bool(true))));\n                }\n                \n              case "None":\n                return (res_out(s, res_val(Coq_value_bool(true))));\n            }\n            \n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (object_delete(s, c, l0, x, throw_false));\n        }\n        }));\n};\n\nvar env_record_implicit_this_value = function (s, l) {\n  return (\n    ifx_some_or_default(env_record_binds_option(s, l), None(), function (e) {\n        return (\n          Some((function () {\n              switch (e.tag) {\n                case "Coq_env_record_decl":\n                  var ed = e.value;\n                  return (Coq_value_undef());\n                case "Coq_env_record_object":\n                  var l0 = e.value, provide_this = e.provide_this;\n                  if (provide_this) {\n                    return (Coq_value_object(l0));\n                  } else {\n                    return (Coq_value_undef());\n                  }\n              }\n              }())));}));\n};\n\nvar identifier_resolution = function (s, c, x) {\n  var x0 = c.execution_ctx_lexical_env;\n  var str = c.execution_ctx_strict;\n  return (lexical_env_get_identifier_ref(s, c, x0, x, str));\n};\n\nvar env_record_get_binding_value = function (s, c, l, x, str) {\n  return (get_binding_value(s, l, Coq_value_string(x), str));\n};\n\nvar ref_get_value = function (s, c, _foo_) {\n  return (\n    if_value(get_value(s, res_ter(s, res_normal(_foo_))), function(s, v) {\n        \n        return (res_spec(s, v));}));\n};\n\nvar run_expr_get_value = function (s, c, e) {\n  var result = run_expr(s, c, e);\n  return (\n    if_ter(result, function(s, _pat_any_100) {\n        \n        return (\n          if_value(get_value(s, result), function(s, v) {\n              \n              return (res_spec(s, v));}));}));\n};\n\nvar env_record_set_mutable_binding = function (s, c, l, x, v, str) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              if_some(HeapStr.read_option(ed, x), function(rm) {\n                  \n                  var mu = rm[0], v_old = rm[1];\n                  if (!(mutability_compare(mu, Coq_mutability_immutable()))) {\n                    return (\n                      res_void(env_record_write_decl_env(s, l, x, mu, v)));\n                  } else {\n                    return (\n                      out_error_or_void(s, c, str, Coq_native_error_type()));\n                  }}));\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (\n              if_success(object_put(s, c, l0, x, v, str), function(s,\n                _pat_any_101) { \n                                return (res_void(s));}));\n        }\n        }));\n};\n\nvar ref_put_value = function (s, c, rv, v) {\n  return (\n    if_success(\n      put_value(s, c, res_ter(s, res_normal(rv)), res_ter(s, res_val(v))),\n      function(s, _pat_any_102) { \n                                  return (res_void(s));}));\n};\n\nvar env_record_create_mutable_binding = function (s, c, l, x, deletable_opt) {\n  var deletable = unsome_default(false, deletable_opt);\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            if (HeapStr.indom_dec(ed, x)) {\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Already declared environnment record in [env_record_create_mutable_binding]."));\n            } else {\n              var s_2 = env_record_write_decl_env(s, l, x,\n                          mutability_of_bool(deletable), Coq_value_undef());\n              return (res_void(s_2));\n            }\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (\n              if_bool(object_has_prop(s, c, l0, x), function(s1, has) {\n                  \n                  if (has) {\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s1,\n                        "Already declared binding in [env_record_create_mutable_binding]."));\n                  } else {\n                    var a = {\n                      attributes_data_value: Coq_value_undef(),\n                      attributes_data_writable: true,\n                      attributes_data_enumerable: true,\n                      attributes_data_configurable: deletable\n                    };\n                    return (\n                      if_success(\n                        object_define_own_prop(s1, c, l0, x,\n                          descriptor_of_attributes(Coq_attributes_data_of(a)),\n                          throw_true), function(s2, rv) {\n                          \n                          return (res_void(s2));}));\n                  }}));\n        }\n        }));\n};\n\nvar env_record_create_set_mutable_binding = function (s, c, l, x, deletable_opt, v, str) {\n  return (\n    if_void(env_record_create_mutable_binding(s, c, l, x, deletable_opt),\n      function(s0) {\n        \n        return (env_record_set_mutable_binding(s0, c, l, x, v, str));}));\n};\n\nvar env_record_create_immutable_binding = function (s, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            if (HeapStr.indom_dec(ed, x)) {\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Already declared environnment record in [env_record_create_immutable_binding]."));\n            } else {\n              return (\n                res_void(\n                  env_record_write_decl_env(s, l, x,\n                    Coq_mutability_uninitialized_immutable(),\n                    Coq_value_undef())));\n            }\n          case "Coq_env_record_object":\n            var o = e.value, p = e.provide_this;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[env_record_create_immutable_binding] received an environnment record object."));\n        }\n        }));\n};\n\nvar env_record_initialize_immutable_binding = function (s, l, x, v) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              if_some(decl_env_record_option(ed, x), function(evs) {\n                  \n                  if (prod_compare(mutability_compare, value_compare, evs,\n                        [Coq_mutability_uninitialized_immutable(), Coq_value_undef(\n                                                                    )])) {\n                    var s_2 = env_record_write_decl_env(s, l, x,\n                                Coq_mutability_immutable(), v);\n                    return (res_void(s_2));\n                  } else {\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s,\n                        "Non suitable binding in [env_record_initialize_immutable_binding]."));\n                  }}));\n          case "Coq_env_record_object":\n            var o = e.value, p = e.provide_this;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[env_record_initialize_immutable_binding] received an environnment record object."));\n        }\n        }));\n};\n\nvar call_object_new = function (s, c, v) {\n  var _switch_arg_103 = type_of(v);\n  switch (_switch_arg_103.tag) {\n    case "Coq_type_undef":\n      var o = object_new(\n                Coq_value_object(\n                  Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                "Object");\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      return (res_out(s_2, res_val(Coq_value_object(l))));\n    case "Coq_type_null":\n      var o = object_new(\n                Coq_value_object(\n                  Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                "Object");\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      return (res_out(s_2, res_val(Coq_value_object(l))));\n    case "Coq_type_bool":\n      return (to_object(s, v));\n    case "Coq_type_number":\n      return (to_object(s, v));\n    case "Coq_type_string":\n      return (to_object(s, v));\n    case "Coq_type_object":\n      return (res_out(s, res_val(v)));\n  }\n  \n};\n\nvar array_args_map_loop = function (s, c, l, args, ind) {\n  switch (args.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var h = args.head, rest = args.tail;\n      return (\n        if_some(\n          run_object_heap_map_properties(s, l, function (p) {\n              return (\n                HeapStr.write(p, JsNumber.to_string(ind),\n                  Coq_attributes_data_of(attributes_data_intro_all_true(h))));\n            }), function(s_2) {\n            \n            return (array_args_map_loop(s_2, c, l, rest, (ind + 1.)));}));\n  }\n  \n};\n\nvar run_construct_prealloc = function (s, c, b, args) {\n  switch (b.tag) {\n    case "Coq_prealloc_object":\n      var v = get_arg(0, args);\n      return (call_object_new(s, c, v));\n    case "Coq_prealloc_bool":\n      var v = get_arg(0, args);\n      var b0 = to_boolean(v);\n      var o1 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_bool_proto())),\n                 "Boolean");\n      var o = object_with_primitive_value(o1, Coq_value_bool(b0));\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      return (res_out(s_2, res_val(Coq_value_object(l))));\n    case "Coq_prealloc_number":\n      var follow = function (s_2, v) {\n        var o1 = object_new(\n                   Coq_value_object(\n                     Coq_object_loc_prealloc(Coq_prealloc_number_proto())),\n                   "Number");\n        var o = object_with_primitive_value(o1, v);\n        var _tuple_arg_104 = object_alloc(s_2, o);\n        var l = _tuple_arg_104[0], s1 = _tuple_arg_104[1];\n        return (res_out(s1, res_val(Coq_value_object(l))));\n      };\n      if (list_eq_nil_decidable(args)) {\n        return (follow(s, Coq_value_number(JsNumber.zero)));\n      } else {\n        var v = get_arg(0, args);\n        return (\n          if_number(to_number(s, v), function(x, x0) {\n              \n              return (follow(x, Coq_value_number(x0)));}));\n      }\n    case "Coq_prealloc_array":\n      var o_2 = object_new(\n                  Coq_value_object(\n                    Coq_object_loc_prealloc(Coq_prealloc_array_proto())),\n                  "Array");\n      var o = object_for_array(o_2, Coq_builtin_define_own_prop_array());\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      var follow = function (s_3, length0) {\n        return (\n          if_some(\n            run_object_heap_map_properties(s_3, l, function (p0) {\n                return (\n                  HeapStr.write(p0, "length",\n                    Coq_attributes_data_of({\n                        attributes_data_value: Coq_value_number(length0),\n                        attributes_data_writable: true,\n                        attributes_data_enumerable: false,\n                        attributes_data_configurable: false})));}),\n            function(s0) {\n              \n              return (res_ter(s0, res_val(Coq_value_object(l))));}));\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 1)) {\n        var v = get_arg(0, args);\n        switch (v.tag) {\n          case "Coq_value_undef":\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p1) {\n                    return (\n                      HeapStr.write(p1, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n          case "Coq_value_null":\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p1) {\n                    return (\n                      HeapStr.write(p1, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n          case "Coq_value_bool":\n            var b0 = v.value;\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p1) {\n                    return (\n                      HeapStr.write(p1, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n          case "Coq_value_number":\n            var vlen = v.value;\n            return (\n              if_spec(to_uint32(s_2, c, Coq_value_number(vlen)), function(s0,\n                ilen) {\n                  \n                  if ((ilen === vlen)) {\n                    return (follow(s0, ilen));\n                  } else {\n                    return (run_error(s0, c, Coq_native_error_range()));\n                  }}));\n          case "Coq_value_string":\n            var s0 = v.value;\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p1) {\n                    return (\n                      HeapStr.write(p1, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s1) { \n                               return (follow(s1, 1.0));}));\n          case "Coq_value_object":\n            var o0 = v.value;\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p0) {\n                    return (\n                      HeapStr.write(p0, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n        }\n        \n      } else {\n        return (\n          if_some(\n            run_object_heap_map_properties(s_2, l, function (p0) {\n                return (\n                  HeapStr.write(p0, "length",\n                    Coq_attributes_data_of({\n                        attributes_data_value: Coq_value_number(\n                                                 number_of_int(arg_len)),\n                        attributes_data_writable: true,\n                        attributes_data_enumerable: false,\n                        attributes_data_configurable: false})));}),\n            function(s0) {\n              \n              return (\n                if_void(array_args_map_loop(s0, c, l, args, 0.),\n                  function(s1) {\n                    \n                    return (res_ter(s1, res_val(Coq_value_object(l))));}));}));\n      }\n    case "Coq_prealloc_string":\n      var o2 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_string_proto())),\n                 "String");\n      var o1 = object_with_get_own_property(o2,\n                 Coq_builtin_get_own_prop_string());\n      var follow = function (s0, s1) {\n        var o = object_with_primitive_value(o1, Coq_value_string(s1));\n        var _tuple_arg_105 = object_alloc(s0, o);\n        var l = _tuple_arg_105[0], s2 = _tuple_arg_105[1];\n        var lenDesc = attributes_data_intro_constant(\n                        Coq_value_number(number_of_int(strlength(s1))));\n        return (\n          if_some(\n            run_object_heap_map_properties(s2, l, function (p) {\n                return (\n                  HeapStr.write(p, "length", Coq_attributes_data_of(lenDesc)));\n              }), function(s_2) {\n              \n              return (res_ter(s_2, res_val(Coq_value_object(l))));}));\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 0)) {\n        return (follow(s, ""));\n      } else {\n        var arg = get_arg(0, args);\n        return (\n          if_string(to_string(s, arg), function(s0, s1) {\n              \n              return (follow(s0, s1));}));\n      }\n    case "Coq_prealloc_error":\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_error_proto())), v));\n    case "Coq_prealloc_native_error":\n      var ne = b.error;\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))), v));\n    case "Coq_prealloc_proxy":\n      return (\n        builtin_proxy_constructor(s, c, {}, {},\n          Coq_value_object(Coq_object_loc_prealloc(Coq_prealloc_proxy())),\n          get_arg(0, args), get_arg(1, args)));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}(\n          strappend("Construct prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented."))));\n  }\n  \n};\n\nvar run_construct_default = function (s, c, l, args) {\n  return (\n    if_value(run_object_get(s, c, l, "prototype"), function(s1, v1) {\n        \n        if (type_compare(type_of(v1), Coq_type_object())) {\n          var vproto = v1;\n        } else {\n          var vproto = Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_object_proto()));\n        }\n        var o = object_new(vproto, "Object");\n        var p = object_alloc(s1, o);\n        var l_2 = p[0], s2 = p[1];\n        return (\n          if_value(run_call(s2, c, l, Coq_value_object(l_2), args),\n            function(s3, v2) {\n              \n              if (type_compare(type_of(v2), Coq_type_object())) {\n                var vr = v2;\n              } else {\n                var vr = Coq_value_object(l_2);\n              }\n              return (res_ter(s3, res_val(vr)));}));}));\n};\n\nvar run_construct = function (s, c, co, l, args) {\n  switch (co.tag) {\n    case "Coq_construct_default":\n      return (run_construct_default(s, c, l, args));\n    case "Coq_construct_after_bind":\n      return (\n        if_some(run_object_method(object_target_function_, s, l),\n          function(otrg) {\n            \n            return (\n              if_some(otrg, function(target) {\n                  \n                  return (\n                    if_some(run_object_method(object_construct_, s, target),\n                      function(oco) {\n                        \n                        switch (oco.tag) {\n                          case "Some":\n                            var co0 = oco.value;\n                            return (\n                              if_some(\n                                run_object_method(object_bound_args_, s, l),\n                                function(oarg) {\n                                  \n                                  return (\n                                    if_some(oarg, function(boundArgs) {\n                                        \n                                        var arguments_ = LibList.append(\n                                                           boundArgs, args);\n                                        return (\n                                          run_construct(s, c, co0, target,\n                                            arguments_));}));}));\n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));}));}));\n    case "Coq_construct_prealloc":\n      var b = co.prealloc;\n      return (run_construct_prealloc(s, c, b, args));\n    default:\n      return (Coq_result_not_yet_implemented());\n  }\n  \n};\n\nvar run_call_default = function (s, c, lf) {\n  var def = res_out(s, res_val(Coq_value_undef()));\n  return (\n    if_some(run_object_method(object_code_, s, lf), function(oC) {\n        \n        switch (oC.tag) {\n          case "Some":\n            var bd = oC.value;\n            if (list_eq_nil_decidable(prog_elements(funcbody_prog(bd)))) {\n              return (def);\n            } else {\n              return (\n                ifx_success_or_return(run_prog(s, c, funcbody_prog(bd)),\n                  function (s_2) {\n                    return (res_out(s_2, res_val(Coq_value_undef())));},\n                  function (s_2, rv) { return (res_out(s_2, res_normal(rv)));\n                  }));\n            }\n          case "None":\n            return (def);\n        }\n        }));\n};\n\nvar creating_function_object_proto = function (s, c, l) {\n  return (\n    if_object(run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n      function(s1, lproto) {\n        \n        var a1 = {\n          attributes_data_value: Coq_value_object(l),\n          attributes_data_writable: true,\n          attributes_data_enumerable: false,\n          attributes_data_configurable: true\n        };\n        return (\n          if_bool(\n            object_define_own_prop(s1, c, lproto, "constructor",\n              descriptor_of_attributes(Coq_attributes_data_of(a1)), false),\n            function(s2, b) {\n              \n              var a2 = {\n                attributes_data_value: Coq_value_object(lproto),\n                attributes_data_writable: true,\n                attributes_data_enumerable: false,\n                attributes_data_configurable: false\n              };\n              return (\n                object_define_own_prop(s2, c, l, "prototype",\n                  descriptor_of_attributes(Coq_attributes_data_of(a2)),\n                  false));}));}));\n};\n\nvar creating_function_object = function (s, c, names, bd, x, str) {\n  var o = object_new(\n            Coq_value_object(\n              Coq_object_loc_prealloc(Coq_prealloc_function_proto())),\n            "Function");\n  var o2 = object_with_invokation(o, Some(Coq_construct_default()),\n             Some(Coq_call_default()),\n             Some(Coq_builtin_has_instance_function()));\n  var o3 = object_with_details(o2, Some(x), Some(names), Some(bd), None(),\n             None(), None(), None());\n  var p = object_alloc(s, o3);\n  var l = p[0], s1 = p[1];\n  var a1 = {\n    attributes_data_value: Coq_value_number(\n                             number_of_int(LibList.length(names))),\n    attributes_data_writable: false,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  return (\n    if_bool(\n      object_define_own_prop(s1, c, l, "length",\n        descriptor_of_attributes(Coq_attributes_data_of(a1)), false),\n      function(s2, b2) {\n        \n        return (\n          if_bool(creating_function_object_proto(s2, c, l), function(s3,\n            b3) {\n              \n              if (!(str)) {\n                return (res_ter(s3, res_val(Coq_value_object(l))));\n              } else {\n                var vthrower = Coq_value_object(\n                                 Coq_object_loc_prealloc(\n                                   Coq_prealloc_throw_type_error()));\n                var a2 = {\n                  attributes_accessor_get: vthrower,\n                  attributes_accessor_set: vthrower,\n                  attributes_accessor_enumerable: false,\n                  attributes_accessor_configurable: false\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s3, c, l, "caller",\n                      descriptor_of_attributes(\n                        Coq_attributes_accessor_of(a2)), false), function(s4,\n                    b4) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s4, c, l, "arguments",\n                            descriptor_of_attributes(\n                              Coq_attributes_accessor_of(a2)), false),\n                          function(s5, b5) {\n                            \n                            return (\n                              res_ter(s5, res_val(Coq_value_object(l))));}));\n                    }));\n              }}));}));\n};\n\nvar binding_inst_formal_params = function (s, c, l, args, names, str) {\n  switch (names.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var argname = names.head, names_2 = names.tail;\n      var v = hd(Coq_value_undef(), args);\n      var args_2 = tl(args);\n      return (\n        if_bool(env_record_has_binding(s, c, l, argname), function(s1, hb) {\n            \n            var follow = function (s_2) {\n              return (\n                if_void(\n                  env_record_set_mutable_binding(s_2, c, l, argname, v, str),\n                  function(s_3) {\n                    \n                    return (\n                      binding_inst_formal_params(s_3, c, l, args_2, names_2,\n                        str));}));\n            };\n            if (hb) {\n              return (follow(s1));\n            } else {\n              return (\n                if_void(\n                  env_record_create_mutable_binding(s1, c, l, argname,\n                    None()), function(s2) { \n                                            return (follow(s2));}));\n            }}));\n  }\n  \n};\n\nvar binding_inst_function_decls = function (s, c, l, fds, str, bconfig) {\n  switch (fds.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var fd = fds.head, fds_2 = fds.tail;\n      var fbd = fd.funcdecl_body;\n      var str_fd = funcbody_is_strict(fbd);\n      var fparams = fd.funcdecl_parameters;\n      var fname = fd.funcdecl_name;\n      return (\n        if_object(\n          creating_function_object(s, c, fparams, fbd,\n            c.execution_ctx_variable_env, str_fd), function(s1, fo) {\n            \n            var follow = function (s2) {\n              return (\n                if_void(\n                  env_record_set_mutable_binding(s2, c, l, fname,\n                    Coq_value_object(fo), str), function(s3) {\n                    \n                    return (\n                      binding_inst_function_decls(s3, c, l, fds_2, str,\n                        bconfig));}));\n            };\n            return (\n              if_bool(env_record_has_binding(s1, c, l, fname), function(s2,\n                has) {\n                  \n                  if (has) {\n                    if (nat_eq(l, env_loc_global_env_record)) {\n                      return (\n                        if_spec(\n                          run_object_get_prop(s2, c,\n                            Coq_object_loc_prealloc(Coq_prealloc_global()),\n                            fname), function(s3, d) {\n                            \n                            switch (d.tag) {\n                              case "Coq_full_descriptor_undef":\n                                return (\n                                  function (s, m) {\n                                      Debug.impossible_with_heap_because(\n                                        __LOC__, s, m);\n                                      return (Coq_result_impossible());}(s3,\n                                    "Undefined full descriptor in [binding_inst_function_decls]."));\n                              case "Coq_full_descriptor_some":\n                                var a = d.value;\n                                if (attributes_configurable(a)) {\n                                  var a_2 = {\n                                    attributes_data_value: Coq_value_undef(),\n                                    attributes_data_writable: true,\n                                    attributes_data_enumerable: true,\n                                    attributes_data_configurable: bconfig\n                                  };\n                                  return (\n                                    if_bool(\n                                      object_define_own_prop(s3, c,\n                                        Coq_object_loc_prealloc(\n                                          Coq_prealloc_global()), fname,\n                                        descriptor_of_attributes(\n                                          Coq_attributes_data_of(a_2)), true),\n                                      function(s0, x) { \n                                                        return (follow(s0));\n                                      }));\n                                } else {\n                                  if ((is_accessor_descriptor(\n                                         Descriptor(\n                                           descriptor_of_attributes(a)))\n                                      || (!(attributes_writable(a))\n                                         || !(attributes_enumerable(a))))) {\n                                    return (\n                                      run_error(s3, c,\n                                        Coq_native_error_type()));\n                                  } else {\n                                    return (follow(s3));\n                                  }\n                                }\n                            }\n                            }));\n                    } else {\n                      return (follow(s2));\n                    }\n                  } else {\n                    return (\n                      if_void(\n                        env_record_create_mutable_binding(s2, c, l, fname,\n                          Some(bconfig)), function(s3) { \n                                                         return (follow(s3));\n                        }));\n                  }}));}));\n  }\n  \n};\n\nvar make_arg_getter = function (s, c, x, x0) {\n  var xbd = strappend("return ", strappend(x, ";"));\n  var bd = Coq_funcbody_intro(\n             Coq_prog_intro(true,\n               mk_cons(\n                 Coq_element_stat(\n                   Coq_stat_return(Some(Coq_expr_identifier(x)))), mk_nil())),\n             xbd);\n  return (creating_function_object(s, c, mk_nil(), bd, x0, true));\n};\n\nvar make_arg_setter = function (s, c, x, x0) {\n  var xparam = strappend(x, "_arg");\n  var xbd = strappend(x, strappend(" = ", strappend(xparam, ";")));\n  var bd = Coq_funcbody_intro(\n             Coq_prog_intro(true,\n               mk_cons(\n                 Coq_element_stat(\n                   Coq_stat_expr(\n                     Coq_expr_assign(Coq_expr_identifier(x), None(),\n                       Coq_expr_identifier(xparam)))), mk_nil())), xbd);\n  return (\n    creating_function_object(s, c, mk_cons(xparam, mk_nil()), bd, x0, true));\n};\n\nvar arguments_object_map_loop = function (s, c, l, xs, len, args, x, str, lmap, xsmap) {\n  return (\n    function (fO, fS, n) {\n        if (int_eq(n, 0)) {\n          return (fO({}));\n        } else {\n          return (fS((n - 1)));\n        }}(function (_pat_any_106) {\n        if (list_eq_nil_decidable(xsmap)) {\n          return (res_void(s));\n        } else {\n          return (\n            if_some(object_binds_option(s, l), function(o) {\n                \n                var o_2 = object_for_args_object(o, lmap,\n                            Coq_builtin_get_args_obj(),\n                            Coq_builtin_get_own_prop_args_obj(),\n                            Coq_builtin_define_own_prop_args_obj(),\n                            Coq_builtin_delete_args_obj());\n                return (res_void(object_write(s, l, o_2)));}));\n        }}, function (len_2) {\n        var tdl = take_drop_last(args);\n        var rmlargs = tdl[0], largs = tdl[1];\n        var arguments_object_map_loop_2 = function (s0, xsmap0) {\n          return (\n            arguments_object_map_loop(s0, c, l, xs, len_2, rmlargs, x, str,\n              lmap, xsmap0));\n        };\n        var a = attributes_data_intro_all_true(largs);\n        return (\n          if_string(to_string(s, Coq_value_number(number_of_int(len_2))),\n            function(s, tempVar) {\n              \n              return (\n                if_bool(\n                  object_define_own_prop(s, c, l, tempVar,\n                    descriptor_of_attributes(Coq_attributes_data_of(a)),\n                    false), function(s1, b) {\n                    \n                    if (ge_nat_decidable(len_2, LibList.length(xs))) {\n                      return (arguments_object_map_loop_2(s1, xsmap));\n                    } else {\n                      var dummy = "";\n                      var x0 = nth_def(dummy, len_2, xs);\n                      if ((str || mem_decide(string_eq, x0, xsmap))) {\n                        return (arguments_object_map_loop_2(s1, xsmap));\n                      } else {\n                        return (\n                          if_object(make_arg_getter(s1, c, x0, x),\n                            function(s2, lgetter) {\n                              \n                              return (\n                                if_object(make_arg_setter(s2, c, x0, x),\n                                  function(s3, lsetter) {\n                                    \n                                    var a_2 = {\n                                      attributes_accessor_get: Coq_value_object(\n                                                                 lgetter),\n                                      attributes_accessor_set: Coq_value_object(\n                                                                 lsetter),\n                                      attributes_accessor_enumerable: false,\n                                      attributes_accessor_configurable: true\n                                    };\n                                    return (\n                                      if_string(\n                                        to_string(s3,\n                                          Coq_value_number(\n                                            number_of_int(len_2))),\n                                        function(s3, tempVar) {\n                                          \n                                          return (\n                                            if_bool(\n                                              object_define_own_prop(s3, c,\n                                                lmap, tempVar,\n                                                descriptor_of_attributes(\n                                                  Coq_attributes_accessor_of(\n                                                    a_2)), false),\n                                              function(s4, b_2) {\n                                                \n                                                return (\n                                                  arguments_object_map_loop_2(\n                                                    s4, mk_cons(x0, xsmap)));\n                                              }));}));}));}));\n                      }\n                    }}));}));}, len));\n};\n\nvar arguments_object_map = function (s, c, l, xs, args, x, str) {\n  return (\n    if_object(run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n      function(s_2, lmap) {\n        \n        return (\n          arguments_object_map_loop(s_2, c, l, xs, LibList.length(args),\n            args, x, str, lmap, mk_nil()));}));\n};\n\nvar create_arguments_object = function (s, c, lf, xs, args, x, str) {\n  var o = object_create_builtin(\n            Coq_value_object(\n              Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n            "Arguments", Heap.empty);\n  var p = object_alloc(s, o);\n  var l = p[0], s_2 = p[1];\n  var a = {\n    attributes_data_value: Coq_value_number(\n                             number_of_int(LibList.length(args))),\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  return (\n    if_bool(\n      object_define_own_prop(s_2, c, l, "length",\n        descriptor_of_attributes(Coq_attributes_data_of(a)), false),\n      function(s1, b) {\n        \n        return (\n          if_void(arguments_object_map(s1, c, l, xs, args, x, str),\n            function(s2) {\n              \n              if (str) {\n                var vthrower = Coq_value_object(\n                                 Coq_object_loc_prealloc(\n                                   Coq_prealloc_throw_type_error()));\n                var a0 = {\n                  attributes_accessor_get: vthrower,\n                  attributes_accessor_set: vthrower,\n                  attributes_accessor_enumerable: false,\n                  attributes_accessor_configurable: false\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s2, c, l, "caller",\n                      descriptor_of_attributes(\n                        Coq_attributes_accessor_of(a0)), false), function(s3,\n                    b_2) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s3, c, l, "callee",\n                            descriptor_of_attributes(\n                              Coq_attributes_accessor_of(a0)), false),\n                          function(s4, b_3) {\n                            \n                            return (\n                              res_ter(s4, res_val(Coq_value_object(l))));}));\n                    }));\n              } else {\n                var a0 = {\n                  attributes_data_value: Coq_value_object(lf),\n                  attributes_data_writable: true,\n                  attributes_data_enumerable: false,\n                  attributes_data_configurable: true\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s2, c, l, "callee",\n                      descriptor_of_attributes(Coq_attributes_data_of(a0)),\n                      false), function(s3, b_2) {\n                      \n                      return (res_ter(s3, res_val(Coq_value_object(l))));}));\n              }}));}));\n};\n\nvar binding_inst_arg_obj = function (s, c, lf, p, xs, args, l) {\n  var arguments_ = "arguments";\n  var str = prog_intro_strictness(p);\n  return (\n    if_object(\n      create_arguments_object(s, c, lf, xs, args,\n        c.execution_ctx_variable_env, str), function(s1, largs) {\n        \n        if (str) {\n          return (\n            if_void(env_record_create_immutable_binding(s1, l, arguments_),\n              function(s2) {\n                \n                return (\n                  env_record_initialize_immutable_binding(s2, l, arguments_,\n                    Coq_value_object(largs)));}));\n        } else {\n          return (\n            env_record_create_set_mutable_binding(s1, c, l, arguments_,\n              None(), Coq_value_object(largs), false));\n        }}));\n};\n\nvar binding_inst_var_decls = function (s, c, l, vds, bconfig, str) {\n  switch (vds.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var vd = vds.head, vds_2 = vds.tail;\n      var bivd = function (s0) {\n        return (binding_inst_var_decls(s0, c, l, vds_2, bconfig, str));\n      };\n      return (\n        if_bool(env_record_has_binding(s, c, l, vd), function(s1, has) {\n            \n            if (has) {\n              return (bivd(s1));\n            } else {\n              return (\n                if_void(\n                  env_record_create_set_mutable_binding(s1, c, l, vd,\n                    Some(bconfig), Coq_value_undef(), str), function(s2) {\n                    \n                    return (bivd(s2));}));\n            }}));\n  }\n  \n};\n\nvar execution_ctx_binding_inst = function (s, c, ct, funco, p, args) {\n  var _switch_arg_107 = c.execution_ctx_variable_env;\n  switch (_switch_arg_107.tag) {\n    case "[]":\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst]."));\n    case "::":\n      var l = _switch_arg_107.head, l0 = _switch_arg_107.tail;\n      var str = prog_intro_strictness(p);\n      var follow = function (s_2, names) {\n        var bconfig = codetype_compare(ct, Coq_codetype_eval());\n        var fds = prog_funcdecl(p);\n        return (\n          if_void(binding_inst_function_decls(s_2, c, l, fds, str, bconfig),\n            function(s1) {\n              \n              return (\n                if_bool(env_record_has_binding(s1, c, l, "arguments"),\n                  function(s2, bdefined) {\n                    \n                    var follow2 = function (s10) {\n                      var vds = prog_vardecl(p);\n                      return (\n                        binding_inst_var_decls(s10, c, l, vds, bconfig, str));\n                    };\n                    switch (ct.tag) {\n                      case "Coq_codetype_func":\n                        switch (funco.tag) {\n                          case "Some":\n                            var func = funco.value;\n                            if (bdefined) {\n                              return (follow2(s2));\n                            } else {\n                              return (\n                                if_void(\n                                  binding_inst_arg_obj(s2, c, func, p, names,\n                                    args, l), function(s3) {\n                                    \n                                    return (follow2(s3));}));\n                            }\n                          case "None":\n                            if (bdefined) {\n                              return (follow2(s2));\n                            } else {\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s2,\n                                  "Weird `arguments\' object in [execution_ctx_binding_inst]."));\n                            }\n                        }\n                        \n                      case "Coq_codetype_global":\n                        return (follow2(s2));\n                      case "Coq_codetype_eval":\n                        return (follow2(s2));\n                    }\n                    }));}));\n      };\n      switch (ct.tag) {\n        case "Coq_codetype_func":\n          switch (funco.tag) {\n            case "Some":\n              var func = funco.value;\n              return (\n                if_some(\n                  run_object_method(object_formal_parameters_, s, func),\n                  function(nameso) {\n                    \n                    return (\n                      if_some(nameso, function(names) {\n                          \n                          return (\n                            if_void(\n                              binding_inst_formal_params(s, c, l, args,\n                                names, str), function(s_2) {\n                                \n                                return (follow(s_2, names));}));}));}));\n            case "None":\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent functionnal code type in [execution_ctx_binding_inst]."));\n          }\n          \n        case "Coq_codetype_global":\n          switch (funco.tag) {\n            case "Some":\n              var o = funco.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case "None":\n              return (follow(s, mk_nil()));\n          }\n          \n        case "Coq_codetype_eval":\n          switch (funco.tag) {\n            case "Some":\n              var o = funco.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case "None":\n              return (follow(s, mk_nil()));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar entering_func_code = function (s, c, lf, vthis, args) {\n  return (\n    if_some(run_object_method(object_code_, s, lf), function(bdo) {\n        \n        return (\n          if_some(bdo, function(bd) {\n              \n              var str = funcbody_is_strict(bd);\n              var follow = function (s_2, vthis_2) {\n                return (\n                  if_some(run_object_method(object_scope_, s_2, lf),\n                    function(lexo) {\n                      \n                      return (\n                        if_some(lexo, function(lex) {\n                            \n                            var p = lexical_env_alloc_decl(s_2, lex);\n                            var lex_2 = p[0], s1 = p[1];\n                            var c_2 = execution_ctx_intro_same(lex_2,\n                                        vthis_2, str);\n                            return (\n                              if_void(\n                                execution_ctx_binding_inst(s1, c_2,\n                                  Coq_codetype_func(), Some(lf),\n                                  funcbody_prog(bd), args), function(s2) {\n                                  \n                                  return (run_call_default(s2, c_2, lf));}));\n                          }));}));\n              };\n              if (str) {\n                return (follow(s, vthis));\n              } else {\n                switch (vthis.tag) {\n                  case "Coq_value_undef":\n                    return (\n                      follow(s,\n                        Coq_value_object(\n                          Coq_object_loc_prealloc(Coq_prealloc_global()))));\n                  case "Coq_value_null":\n                    return (\n                      follow(s,\n                        Coq_value_object(\n                          Coq_object_loc_prealloc(Coq_prealloc_global()))));\n                  case "Coq_value_bool":\n                    var b = vthis.value;\n                    return (\n                      if_value(to_object(s, vthis), function(s2, v) {\n                          \n                          return (follow(s2, v));}));\n                  case "Coq_value_number":\n                    var n = vthis.value;\n                    return (\n                      if_value(to_object(s, vthis), function(s2, v) {\n                          \n                          return (follow(s2, v));}));\n                  case "Coq_value_string":\n                    var s0 = vthis.value;\n                    return (\n                      if_value(to_object(s, vthis), function(s2, v) {\n                          \n                          return (follow(s2, v));}));\n                  case "Coq_value_object":\n                    var lthis = vthis.value;\n                    return (follow(s, vthis));\n                }\n                \n              }}));}));\n};\n\nvar run_object_get_own_prop = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_own_prop_, s, l), function(b) {\n        \n        var def = function (s_2) {\n          return (\n            if_some(run_object_method(object_properties_, s_2, l),\n              function(p) {\n                \n                return (\n                  res_spec(s_2,\n                    ifx_some_or_default(\n                      convert_option_attributes(HeapStr.read_option(p, x)),\n                      Coq_full_descriptor_undef(), function (x) { return (x);\n                      })));}));\n        };\n        switch (b.tag) {\n          case "Coq_builtin_get_own_prop_default":\n            return (def(s));\n          case "Coq_builtin_get_own_prop_args_obj":\n            return (\n              if_spec(def(s), function(s1, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (res_spec(s1, Coq_full_descriptor_undef()));\n                    case "Coq_full_descriptor_some":\n                      var a = d.value;\n                      return (\n                        if_some(\n                          run_object_method(object_parameter_map_, s1, l),\n                          function(lmapo) {\n                            \n                            return (\n                              if_some(lmapo, function(lmap) {\n                                  \n                                  return (\n                                    if_spec(\n                                      run_object_get_own_prop(s1, c, lmap, x),\n                                      function(s2, d0) {\n                                        \n                                        var follow = function (s_2, a0) {\n                                          return (\n                                            res_spec(s_2,\n                                              Coq_full_descriptor_some(a0)));\n                                        };\n                                        switch (d0.tag) {\n                                          case "Coq_full_descriptor_undef":\n                                            return (follow(s2, a));\n                                          case "Coq_full_descriptor_some":\n                                            var amap = d0.value;\n                                            return (\n                                              if_value(\n                                                run_object_get(s2, c, lmap,\n                                                  x), function(s3, v) {\n                                                  \n                                                  switch (a.tag) {\n                                                    case "Coq_attributes_data_of":\n                                                      var ad = a.value;\n                                                      return (\n                                                        follow(s3,\n                                                          Coq_attributes_data_of(\n                                                            attributes_data_with_value(\n                                                              ad, v))));\n                                                    case "Coq_attributes_accessor_of":\n                                                      var aa = a.value;\n                                                      Debug.impossible_with_heap_because(\n                                                        __LOC__, s3,\n                                                        "[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens.");\n                                                      return (\n                                                        Coq_result_impossible(\n                                                          ));\n                                                  }\n                                                  }));\n                                        }\n                                        }));}));}));\n                  }\n                  }));\n          case "Coq_builtin_get_own_prop_string":\n            return (\n              if_spec(def(s), function(s0, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (\n                        if_spec(to_int32(s0, c, Coq_value_string(x)),\n                          function(s1, k) {\n                            \n                            return (\n                              if_string(\n                                to_string(s1,\n                                  Coq_value_number(JsNumber.absolute(k))),\n                                function(s2, s3) {\n                                  \n                                  if (!(string_eq(x, s3))) {\n                                    return (\n                                      res_spec(s2,\n                                        Coq_full_descriptor_undef()));\n                                  } else {\n                                    return (\n                                      if_string(run_object_prim_value(s2, l),\n                                        function(s4, str) {\n                                          \n                                          return (\n                                            if_spec(\n                                              to_int32(s4, c,\n                                                Coq_value_string(x)),\n                                              function(s5, k0) {\n                                                \n                                                var len = number_of_int(\n                                                            strlength(str));\n                                                if (le_int_decidable(len, k0)) {\n                                                  return (\n                                                    res_spec(s5,\n                                                      Coq_full_descriptor_undef(\n                                                        )));\n                                                } else {\n                                                  var resultStr = string_sub(\n                                                                    str,\n                                                                    int_of_number(\n                                                                    k0), 1);\n                                                  var a = {\n                                                    attributes_data_value: \n                                                    Coq_value_string(\n                                                      resultStr),\n                                                    attributes_data_writable: false,\n                                                    attributes_data_enumerable: true,\n                                                    attributes_data_configurable: false\n                                                  };\n                                                  return (\n                                                    res_spec(s5,\n                                                      Coq_full_descriptor_some(\n                                                        Coq_attributes_data_of(\n                                                          a))));\n                                                }}));}));\n                                  }}));}));\n                    case "Coq_full_descriptor_some":\n                      var a = d.value;\n                      return (res_spec(s0, d));\n                  }\n                  }));\n          default:\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar run_function_has_instance = function (s, c, lv, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_object":\n      var lo = _foo_.value;\n      return (\n        if_some(run_object_method(object_proto_, s, lv), function(vproto) {\n            \n            switch (vproto.tag) {\n              case "Coq_value_null":\n                return (res_ter(s, res_val(Coq_value_bool(false))));\n              case "Coq_value_object":\n                var proto = vproto.value;\n                if (object_loc_compare(proto, lo)) {\n                  return (res_ter(s, res_val(Coq_value_bool(true))));\n                } else {\n                  return (\n                    run_function_has_instance(s, c, proto,\n                      Coq_value_object(lo)));\n                }\n              default:\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s,\n                    "Primitive found in the prototype chain in [run_object_has_instance_loop]."));\n            }\n            }));\n    default:\n      return (run_error(s, c, Coq_native_error_type()));\n  }\n  \n};\n\nvar run_object_has_instance = function (s, c, b, l, v) {\n  switch (b.tag) {\n    case "Coq_builtin_has_instance_function":\n      switch (v.tag) {\n        case "Coq_value_object":\n          var lv = v.value;\n          return (\n            if_value(run_object_get(s, c, l, "prototype"), function(s1,\n              vproto) {\n                \n                switch (vproto.tag) {\n                  case "Coq_value_object":\n                    var lproto = vproto.value;\n                    return (\n                      run_function_has_instance(s1, c, lv,\n                        Coq_value_object(lproto)));\n                  default:\n                    return (run_error(s1, c, Coq_native_error_type()));\n                }\n                }));\n        default:\n          return (res_out(s, res_val(Coq_value_bool(false))));\n      }\n      \n    case "Coq_builtin_has_instance_after_bind":\n      return (\n        if_some(run_object_method(object_target_function_, s, l),\n          function(ol) {\n            \n            return (\n              if_some(ol, function(l0) {\n                  \n                  return (\n                    if_some(run_object_method(object_has_instance_, s, l0),\n                      function(ob) {\n                        \n                        switch (ob.tag) {\n                          case "Some":\n                            var b0 = ob.value;\n                            return (\n                              run_object_has_instance(s, c, b0, l0, v));\n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));}));}));\n  }\n  \n};\n\nvar from_prop_descriptor = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_full_descriptor_undef":\n      return (res_out(s, res_val(Coq_value_undef())));\n    case "Coq_full_descriptor_some":\n      var a = _foo_.value;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n          function(s1, l) {\n            \n            var follow = function (s0, x) {\n              var a1 = attributes_data_intro_all_true(\n                         Coq_value_bool(attributes_enumerable(a)));\n              return (\n                if_bool(\n                  object_define_own_prop(s0, c, l, "enumerable",\n                    descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                    throw_false), function(s0_2, x0) {\n                    \n                    var a2 = attributes_data_intro_all_true(\n                               Coq_value_bool(attributes_configurable(a)));\n                    return (\n                      if_bool(\n                        object_define_own_prop(s0_2, c, l, "configurable",\n                          descriptor_of_attributes(\n                            Coq_attributes_data_of(a2)), throw_false),\n                        function(s_2, x1) {\n                          \n                          return (\n                            res_ter(s_2, res_val(Coq_value_object(l))));}));\n                  }));\n            };\n            switch (a.tag) {\n              case "Coq_attributes_data_of":\n                var ad = a.value;\n                var a1 = attributes_data_intro_all_true(\n                           ad.attributes_data_value);\n                return (\n                  if_bool(\n                    object_define_own_prop(s1, c, l, "value",\n                      descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                      throw_false), function(s2, x) {\n                      \n                      var a2 = attributes_data_intro_all_true(\n                                 Coq_value_bool(ad.attributes_data_writable));\n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, "writable",\n                            descriptor_of_attributes(\n                              Coq_attributes_data_of(a2)), throw_false),\n                          function(s3, v) { \n                                            return (follow(s3, v));}));}));\n              case "Coq_attributes_accessor_of":\n                var aa = a.value;\n                var a1 = attributes_data_intro_all_true(\n                           aa.attributes_accessor_get);\n                return (\n                  if_bool(\n                    object_define_own_prop(s1, c, l, "get",\n                      descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                      throw_false), function(s2, x) {\n                      \n                      var a2 = attributes_data_intro_all_true(\n                                 aa.attributes_accessor_set);\n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, "set",\n                            descriptor_of_attributes(\n                              Coq_attributes_data_of(a2)), throw_false),\n                          function(s3, v) { \n                                            return (follow(s3, v));}));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_equal = function (s, c, v1, v2) {\n  var conv_number = function (s0, v) {\n    return (to_number(s0, v));\n  };\n  var conv_primitive = function (s0, v) {\n    return (to_primitive(s0, v, None()));\n  };\n  var checkTypesThen = function (s0, v3, v4, k) {\n    var ty1 = type_of(v3);\n    var ty2 = type_of(v4);\n    if (type_compare(ty1, ty2)) {\n      return (\n        res_out(s0,\n          res_val(Coq_value_bool(equality_test_for_same_type(ty1, v3, v4)))));\n    } else {\n      return (k(ty1, ty2));\n    }\n  };\n  return (\n    checkTypesThen(s, v1, v2, function (ty1, ty2) {\n        var dc_conv = function (v3, f, v4) {\n          return (\n            if_value(f(s, v4), function(s0, v2_2) {\n                \n                return (run_equal(s0, c, v3, v2_2));}));\n        };\n        var so = function (b) {\n          return (res_out(s, res_val(Coq_value_bool(b))));\n        };\n        if ((type_compare(ty1, Coq_type_null())\n            && type_compare(ty2, Coq_type_undef()))) {\n          return (so(true));\n        } else {\n          if ((type_compare(ty1, Coq_type_undef())\n              && type_compare(ty2, Coq_type_null()))) {\n            return (so(true));\n          } else {\n            if ((type_compare(ty1, Coq_type_number())\n                && type_compare(ty2, Coq_type_string()))) {\n              return (dc_conv(v1, conv_number, v2));\n            } else {\n              if ((type_compare(ty1, Coq_type_string())\n                  && type_compare(ty2, Coq_type_number()))) {\n                return (dc_conv(v2, conv_number, v1));\n              } else {\n                if (type_compare(ty1, Coq_type_bool())) {\n                  return (dc_conv(v2, conv_number, v1));\n                } else {\n                  if (type_compare(ty2, Coq_type_bool())) {\n                    return (dc_conv(v1, conv_number, v2));\n                  } else {\n                    if (((type_compare(ty1, Coq_type_string())\n                         || type_compare(ty1, Coq_type_number()))\n                        && type_compare(ty2, Coq_type_object()))) {\n                      return (dc_conv(v1, conv_primitive, v2));\n                    } else {\n                      if ((type_compare(ty1, Coq_type_object())\n                          && (type_compare(ty2, Coq_type_string())\n                             || type_compare(ty2, Coq_type_number())))) {\n                        return (dc_conv(v2, conv_primitive, v1));\n                      } else {\n                        return (so(false));\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }}));\n};\n\nvar convert_twice = function (ifv, kC, s, v1, v2) {\n  return (\n    ifv(kC(s, v1), function (s1, vc1) {\n        return (\n          ifv(kC(s1, v2), function (s2, vc2) {\n              return (res_spec(s2, [vc1, vc2]));}));}));\n};\n\nvar convert_twice_primitive = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_prim, function (s0, v) {\n        return (to_primitive(s0, v, None()));}, s, v1, v2));\n};\n\nvar convert_twice_number = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_number, function (s0, v) { return (to_number(s0, v));},\n      s, v1, v2));\n};\n\nvar convert_twice_string = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_string, function (s0, v) { return (to_string(s0, v));},\n      s, v1, v2));\n};\n\nvar issome = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var t = _foo_.value;\n      return (true);\n    case "None":\n      return (false);\n  }\n  \n};\n\nvar run_binary_op_add = function (s, c, v1, v2) {\n  return (\n    if_spec(convert_twice_primitive(s, c, v1, v2), function(s1,\n      _tuple_arg_110) {\n        var w1 = _tuple_arg_110[0], w2 = _tuple_arg_110[1];\n        \n        if ((type_compare(type_of(w1), Coq_type_string())\n            || type_compare(type_of(w2), Coq_type_string()))) {\n          return (\n            if_spec(convert_twice_string(s1, c, w1, w2), function(s2,\n              _tuple_arg_109) {\n                var str1 = _tuple_arg_109[0], str2 = _tuple_arg_109[1];\n                \n                return (\n                  res_out(s2,\n                    res_val(Coq_value_string(strappend(str1, str2)))));}));\n        } else {\n          return (\n            if_spec(convert_twice_number(s1, c, w1, w2), function(s2,\n              _tuple_arg_108) {\n                var n1 = _tuple_arg_108[0], n2 = _tuple_arg_108[1];\n                \n                return (res_out(s2, res_val(Coq_value_number((n1 + n2)))));}));\n        }}));\n};\n\nvar run_binary_op_arith = function (mathop, s, c, v1, v2) {\n  return (\n    if_spec(convert_twice_number(s, c, v1, v2), function(s1, nn) {\n        \n        var n1 = nn[0], n2 = nn[1];\n        return (res_out(s1, res_val(Coq_value_number(mathop(n1, n2)))));}));\n};\n\nvar run_binary_op_shift = function (b_unsigned, mathop, s, c, v1, v2) {\n  if (b_unsigned) {\n    var conv = to_uint32;\n  } else {\n    var conv = to_int32;\n  }\n  return (\n    if_spec(conv(s, c, v1), function(s1, k1) {\n        \n        return (\n          if_spec(to_uint32(s1, c, v2), function(s2, k2) {\n              \n              var k2_2 = JsNumber.modulo_32(k2);\n              return (\n                res_ter(s2, res_val(Coq_value_number(mathop(k1, k2_2)))));}));\n      }));\n};\n\nvar run_binary_op_bitwise = function (mathop, s, c, v1, v2) {\n  return (\n    if_spec(to_int32(s, c, v1), function(s1, k1) {\n        \n        return (\n          if_spec(to_int32(s1, c, v2), function(s2, k2) {\n              \n              return (\n                res_ter(s2, res_val(Coq_value_number(mathop(k1, k2)))));}));\n      }));\n};\n\nvar run_binary_op_compare = function (b_swap, b_neg, s, c, v1, v2) {\n  return (\n    if_spec(convert_twice_primitive(s, c, v1, v2), function(s1, ww) {\n        \n        var w1 = ww[0], w2 = ww[1];\n        if (b_swap) {\n          var p = [w2, w1];\n        } else {\n          var p = [w1, w2];\n        }\n        var wa = p[0], wb = p[1];\n        return (\n          let_ret((function () {\n              if ((_compare_JsSyntax_coq_type(type_of(wa), Coq_type_string())\n                  && _compare_JsSyntax_coq_type(type_of(wb),\n                       Coq_type_string()))) {\n                return (\n                  Continue(\n                    [s, Coq_value_bool(\n                          inequality_test_string(string_of_value(wb),\n                            string_of_value(wb)))]));\n              } else {\n                return (\n                  if_number_ret(to_number(s1, wa), function(s, nx) {\n                      \n                      return (\n                        if_number_ret(to_number(s, wb), function(s, ny) {\n                            \n                            return (\n                              Continue([s, inequality_test_number(nx, ny)]));\n                          }));}));\n              }}()), function(_tuple_arg_111) {\n              var s = _tuple_arg_111[0], wr = _tuple_arg_111[1];\n              \n              if (value_compare(wr, Coq_value_undef())) {\n                return (res_out(s1, res_val(Coq_value_bool(false))));\n              } else {\n                if ((b_neg && value_compare(wr, Coq_value_bool(true)))) {\n                  return (res_out(s1, res_val(Coq_value_bool(false))));\n                } else {\n                  if ((b_neg && value_compare(wr, Coq_value_bool(false)))) {\n                    return (res_out(s1, res_val(Coq_value_bool(true))));\n                  } else {\n                    return (res_out(s1, res_val(wr)));\n                  }\n                }\n              }}));}));\n};\n\nvar run_binary_op_instanceof = function (s, c, v1, v2) {\n  switch (v2.tag) {\n    case "Coq_value_object":\n      var l = v2.value;\n      return (\n        if_some(run_object_method(object_has_instance_, s, l), function(b) {\n            \n            switch (b.tag) {\n              case "None":\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Some":\n                var has_instance_id = b.value;\n                return (\n                  run_object_has_instance(s, c, has_instance_id, l, v1));\n            }\n            }));\n    default:\n      return (run_error(s, c, Coq_native_error_type()));\n  }\n  \n};\n\nvar run_binary_op_in = function (s, c, v1, v2) {\n  switch (v2.tag) {\n    case "Coq_value_object":\n      var l = v2.value;\n      return (\n        if_string(to_string(s, v1), function(s2, x) {\n            \n            return (object_has_prop(s2, c, l, x));}));\n    default:\n      return (run_error(s, c, Coq_native_error_type()));\n  }\n  \n};\n\nvar run_binary_op = function (s, c, op, v1, v2) {\n  switch (op.tag) {\n    case "Coq_binary_op_mult":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x * y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_div":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x / y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_mod":\n      return (\n        run_binary_op_arith(function (x, y) { return (JsNumber.fmod(x, y));},\n          s, c, v1, v2));\n    case "Coq_binary_op_sub":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x - y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_lt":\n      return (run_binary_op_compare(false, false, s, c, v1, v2));\n    case "Coq_binary_op_gt":\n      return (run_binary_op_compare(true, false, s, c, v1, v2));\n    case "Coq_binary_op_le":\n      return (run_binary_op_compare(true, true, s, c, v1, v2));\n    case "Coq_binary_op_ge":\n      return (run_binary_op_compare(false, true, s, c, v1, v2));\n    case "Coq_binary_op_left_shift":\n      return (\n        run_binary_op_shift(false, JsNumber.int32_left_shift, s, c, v1, v2));\n    case "Coq_binary_op_right_shift":\n      return (\n        run_binary_op_shift(false, JsNumber.int32_right_shift, s, c, v1, v2));\n    case "Coq_binary_op_unsigned_right_shift":\n      return (\n        run_binary_op_shift(true, JsNumber.uint32_right_shift, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_and":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_and, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_or":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_or, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_xor":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_xor, s, c, v1, v2));\n    case "Coq_binary_op_add":\n      return (run_binary_op_add(s, c, v1, v2));\n    case "Coq_binary_op_instanceof":\n      return (run_binary_op_instanceof(s, c, v1, v2));\n    case "Coq_binary_op_in":\n      return (run_binary_op_in(s, c, v1, v2));\n    case "Coq_binary_op_equal":\n      return (run_equal(s, c, v1, v2));\n    case "Coq_binary_op_disequal":\n      return (\n        if_bool(run_equal(s, c, v1, v2), function(s0, b0) {\n            \n            return (res_ter(s0, res_val(Coq_value_bool(!(b0)))));}));\n    case "Coq_binary_op_strict_equal":\n      return (\n        res_out(s, res_val(Coq_value_bool(strict_equality_test(v1, v2)))));\n    case "Coq_binary_op_strict_disequal":\n      return (\n        res_out(s, res_val(Coq_value_bool(!(strict_equality_test(v1, v2))))));\n    case "Coq_binary_op_coma":\n      return (res_out(s, res_val(v2)));\n    case "Coq_binary_op_and":\n      return (Coq_result_impossible());\n    case "Coq_binary_op_or":\n      return (Coq_result_impossible());\n  }\n  \n};\n\nvar run_prepost_op = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_unary_op_delete":\n      return (None());\n    case "Coq_unary_op_void":\n      return (None());\n    case "Coq_unary_op_typeof":\n      return (None());\n    case "Coq_unary_op_post_incr":\n      return (Some([add_one, false]));\n    case "Coq_unary_op_post_decr":\n      return (Some([sub_one, false]));\n    case "Coq_unary_op_pre_incr":\n      return (Some([add_one, true]));\n    case "Coq_unary_op_pre_decr":\n      return (Some([sub_one, true]));\n    case "Coq_unary_op_add":\n      return (None());\n    case "Coq_unary_op_neg":\n      return (None());\n    case "Coq_unary_op_bitwise_not":\n      return (None());\n    case "Coq_unary_op_not":\n      return (None());\n  }\n  \n};\n\nvar run_typeof_value = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_object":\n      var l = _foo_.value;\n      if (is_callable_dec(s, Coq_value_object(l))) {\n        return ("function");\n      } else {\n        return ("object");\n      }\n    default:\n      return (typeof_prim(_foo_));\n  }\n  \n};\n\nvar run_unary_op = function (s, c, op, e) {\n  if (prepost_unary_op_dec(op)) {\n    return (\n      if_success(run_expr(s, c, e), function(s1, rv1) {\n          \n          return (\n            if_spec(ref_get_value(s1, c, rv1), function(s2, v2) {\n                \n                return (\n                  if_number(to_number(s2, v2), function(s3, n1) {\n                      \n                      return (\n                        if_some(run_prepost_op(op), function(po) {\n                            \n                            var number_op = po[0], is_pre = po[1];\n                            var n2 = number_op(n1);\n                            var v = Coq_value_number((function () {\n                                        if (is_pre) {\n                                          return (n2);\n                                        } else {\n                                          return (n1);\n                                        }}()));\n                            return (\n                              if_void(\n                                ref_put_value(s3, c, rv1,\n                                  Coq_value_number(n2)), function(s4) {\n                                  \n                                  return (res_out(s4, res_val(v)));}));}));}));\n              }));}));\n  } else {\n    switch (op.tag) {\n      case "Coq_unary_op_delete":\n        return (\n          if_success(run_expr(s, c, e), function(s0, rv) {\n              \n              switch (rv.tag) {\n                case "Coq_resvalue_empty":\n                  return (res_ter(s0, res_val(Coq_value_bool(true))));\n                case "Coq_resvalue_value":\n                  var v = rv.value;\n                  return (res_ter(s0, res_val(Coq_value_bool(true))));\n                case "Coq_resvalue_ref":\n                  var r = rv.ref;\n                  if (ref_kind_comparable(ref_kind_of(r),\n                        Coq_ref_kind_undef())) {\n                    if (r.ref_strict) {\n                      return (run_error(s0, c, Coq_native_error_syntax()));\n                    } else {\n                      return (res_ter(s0, res_val(Coq_value_bool(true))));\n                    }\n                  } else {\n                    var _switch_arg_112 = r.ref_base;\n                    switch (_switch_arg_112.tag) {\n                      case "Coq_ref_base_type_value":\n                        var v = _switch_arg_112.value;\n                        return (\n                          if_object(to_object(s0, v), function(s1, l) {\n                              \n                              return (\n                                object_delete(s1, c, l, r.ref_name,\n                                  r.ref_strict));}));\n                      case "Coq_ref_base_type_env_loc":\n                        var l = _switch_arg_112.value;\n                        if (r.ref_strict) {\n                          return (\n                            run_error(s0, c, Coq_native_error_syntax()));\n                        } else {\n                          return (\n                            env_record_delete_binding(s0, c, l, r.ref_name));\n                        }\n                    }\n                    \n                  }\n              }\n              }));\n      case "Coq_unary_op_typeof":\n        return (\n          if_success(run_expr(s, c, e), function(s1, rv) {\n              \n              switch (rv.tag) {\n                case "Coq_resvalue_empty":\n                  return (\n                    function (s, m) {\n                        Debug.impossible_with_heap_because(__LOC__, s, m);\n                        return (Coq_result_impossible());}(s1,\n                      "Empty result for a `typeof\' in [run_unary_op]."));\n                case "Coq_resvalue_value":\n                  var v = rv.value;\n                  return (\n                    res_ter(s1,\n                      res_val(Coq_value_string(run_typeof_value(s1, v)))));\n                case "Coq_resvalue_ref":\n                  var r = rv.ref;\n                  if (ref_kind_comparable(ref_kind_of(r),\n                        Coq_ref_kind_undef())) {\n                    return (\n                      res_ter(s1, res_val(Coq_value_string("undefined"))));\n                  } else {\n                    return (\n                      if_spec(ref_get_value(s1, c, Coq_resvalue_ref(r)),\n                        function(s2, v) {\n                          \n                          return (\n                            res_ter(s2,\n                              res_val(\n                                Coq_value_string(run_typeof_value(s2, v)))));\n                        }));\n                  }\n              }\n              }));\n      default:\n        return (\n          if_spec(run_expr_get_value(s, c, e), function(s1, v) {\n              \n              switch (op.tag) {\n                case "Coq_unary_op_void":\n                  return (res_ter(s1, res_val(Coq_value_undef())));\n                case "Coq_unary_op_add":\n                  return (to_number(s1, v));\n                case "Coq_unary_op_neg":\n                  return (\n                    if_number(to_number(s1, v), function(s2, n) {\n                        \n                        return (\n                          res_ter(s2,\n                            res_val(Coq_value_number(JsNumber.neg(n)))));}));\n                case "Coq_unary_op_bitwise_not":\n                  return (\n                    if_spec(to_int32(s1, c, v), function(s2, k) {\n                        \n                        return (\n                          res_ter(s2,\n                            res_val(\n                              Coq_value_number(JsNumber.int32_bitwise_not(k)))));\n                      }));\n                case "Coq_unary_op_not":\n                  return (\n                    res_ter(s1, res_val(Coq_value_bool(!(to_boolean(v))))));\n                default:\n                  return (\n                    function (s, m) {\n                        Debug.impossible_with_heap_because(__LOC__, s, m);\n                        return (Coq_result_impossible());}(s1,\n                      "Undealt regular operator in [run_unary_op]."));\n              }\n              }));\n    }\n    \n  }\n};\n\nvar create_new_function_in = function (s, c, args, bd) {\n  return (\n    creating_function_object(s, c, args, bd, c.execution_ctx_lexical_env,\n      c.execution_ctx_strict));\n};\n\nvar init_object = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_val(Coq_value_object(l))));\n    case "::":\n      var p = _foo_.head, pds_2 = _foo_.tail;\n      var pn = p[0], pb = p[1];\n      var x = string_of_propname(pn);\n      var follows = function (s1, desc) {\n        return (\n          if_success(object_define_own_prop(s1, c, l, x, desc, false),\n            function(s2, rv) { \n                               return (init_object(s2, c, l, pds_2));}));\n      };\n      switch (pb.tag) {\n        case "Coq_propbody_val":\n          var e0 = pb.expr;\n          return (\n            if_spec(run_expr_get_value(s, c, e0), function(s1, v0) {\n                \n                var desc = {\n                  descriptor_value: Some(v0),\n                  descriptor_writable: Some(true),\n                  descriptor_get: None(),\n                  descriptor_set: None(),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n        case "Coq_propbody_get":\n          var bd = pb.body;\n          return (\n            if_value(create_new_function_in(s, c, mk_nil(), bd), function(s1,\n              v0) {\n                \n                var desc = {\n                  descriptor_value: None(),\n                  descriptor_writable: None(),\n                  descriptor_get: Some(v0),\n                  descriptor_set: None(),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n        case "Coq_propbody_set":\n          var args = pb.names, bd = pb.body;\n          return (\n            if_value(create_new_function_in(s, c, args, bd), function(s1,\n              v0) {\n                \n                var desc = {\n                  descriptor_value: None(),\n                  descriptor_writable: None(),\n                  descriptor_get: None(),\n                  descriptor_set: Some(v0),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n      }\n      \n  }\n  \n};\n\nvar run_array_element_list = function (s, c, l, oes, n) {\n  switch (oes.tag) {\n    case "[]":\n      return (res_out(s, res_val(Coq_value_object(l))));\n    case "::":\n      var o = oes.head, oes_2 = oes.tail;\n      switch (o.tag) {\n        case "Some":\n          var e = o.value;\n          var loop_result = function (s0) {\n            return (run_array_element_list(s0, c, l, oes_2, 0.));\n          };\n          return (\n            if_spec(run_expr_get_value(s, c, e), function(s0, v) {\n                \n                return (\n                  if_value(run_object_get(s0, c, l, "length"), function(s1,\n                    vlen) {\n                      \n                      return (\n                        if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                            \n                            return (\n                              if_string(\n                                to_string(s2, Coq_value_number((ilen + n))),\n                                function(s3, slen) {\n                                  \n                                  var desc = {\n                                    attributes_data_value: v,\n                                    attributes_data_writable: true,\n                                    attributes_data_enumerable: true,\n                                    attributes_data_configurable: true\n                                  };\n                                  return (\n                                    if_bool(\n                                      object_define_own_prop(s3, c, l, slen,\n                                        descriptor_of_attributes(\n                                          Coq_attributes_data_of(desc)),\n                                        false), function(s4, x) {\n                                        \n                                        return (\n                                          if_object(loop_result(s4),\n                                            function(s5, l0) {\n                                              \n                                              return (\n                                                res_ter(s5,\n                                                  res_val(\n                                                    Coq_value_object(l0))));\n                                            }));}));}));}));}));}));\n        case "None":\n          var firstIndex = elision_head_count(mk_cons(None(), oes_2));\n          return (\n            run_array_element_list(s, c, l,\n              elision_head_remove(mk_cons(None(), oes_2)),\n              number_of_int(firstIndex)));\n      }\n      \n  }\n  \n};\n\nvar init_array = function (s, c, l, oes) {\n  var elementList = elision_tail_remove(oes);\n  var elisionLength = elision_tail_count(oes);\n  return (\n    if_object(run_array_element_list(s, c, l, elementList, 0.), function(s0,\n      l0) {\n        \n        return (\n          if_value(run_object_get(s0, c, l0, "length"), function(s1, vlen) {\n              \n              return (\n                if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                    \n                    return (\n                      if_spec(\n                        to_uint32(s2, c,\n                          Coq_value_number(\n                            (ilen + number_of_int(elisionLength)))),\n                        function(s3, len) {\n                          \n                          return (\n                            if_not_throw(\n                              object_put(s3, c, l0, "length",\n                                Coq_value_number(len), throw_false),\n                              function(s4, x) {\n                                \n                                return (\n                                  res_out(s4, res_val(Coq_value_object(l0))));\n                              }));}));}));}));}));\n};\n\nvar run_var_decl_item = function (s, c, x, _foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var e = _foo_.value;\n      return (\n        if_spec(identifier_resolution(s, c, x), function(s1, ir) {\n            \n            return (\n              if_spec(run_expr_get_value(s1, c, e), function(s2, v) {\n                  \n                  return (\n                    if_void(ref_put_value(s2, c, Coq_resvalue_ref(ir), v),\n                      function(s3) {\n                        \n                        return (res_out(s3, res_val(Coq_value_string(x))));}));\n                }));}));\n    case "None":\n      return (res_out(s, res_val(Coq_value_string(x))));\n  }\n  \n};\n\nvar run_var_decl = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_empty));\n    case "::":\n      var y = _foo_.head, xeos_2 = _foo_.tail;\n      var x = y[0], eo = y[1];\n      return (\n        if_value(run_var_decl_item(s, c, x, eo), function(s1, vname) {\n            \n            return (run_var_decl(s1, c, xeos_2));}));\n  }\n  \n};\n\nvar run_list_expr = function (s1, c, vs, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_spec(s1, rev(vs)));\n    case "::":\n      var e = _foo_.head, es_2 = _foo_.tail;\n      return (\n        if_spec(run_expr_get_value(s1, c, e), function(s2, v) {\n            \n            return (run_list_expr(s2, c, mk_cons(v, vs), es_2));}));\n  }\n  \n};\n\nvar run_block = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_ter(s, res_normal(Coq_resvalue_empty())));\n    case "::":\n      var t = _foo_.head, ts_rev_2 = _foo_.tail;\n      return (\n        if_success(run_block(s, c, ts_rev_2), function(s0, rv0) {\n            \n            return (\n              ifx_success_state(rv0, run_stat(s0, c, t), function (x, x0) {\n                  return (res_out(x, res_normal(x0)));}));}));\n  }\n  \n};\n\nvar run_binary_op_and = function (s, c, e1, e2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b1 = to_boolean(v1);\n        if (!(b1)) {\n          return (res_ter(s1, res_val(v1)));\n        } else {\n          return (\n            if_spec(run_expr_get_value(s1, c, e2), function(s2, v) {\n                \n                return (res_ter(s2, res_val(v)));}));\n        }}));\n};\n\nvar run_binary_op_or = function (s, c, e1, e2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b1 = to_boolean(v1);\n        if (b1) {\n          return (res_ter(s1, res_val(v1)));\n        } else {\n          return (\n            if_spec(run_expr_get_value(s1, c, e2), function(s2, v) {\n                \n                return (res_ter(s2, res_val(v)));}));\n        }}));\n};\n\nvar run_expr_binary_op = function (s, c, op, e1, e2) {\n  switch (op.tag) {\n    case "Coq_binary_op_and":\n      return (run_binary_op_and(s, c, e1, e2));\n    case "Coq_binary_op_or":\n      return (run_binary_op_or(s, c, e1, e2));\n    default:\n      return (\n        if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n            \n            return (\n              if_spec(run_expr_get_value(s1, c, e2), function(s2, v2) {\n                  \n                  return (run_binary_op(s2, c, op, v1, v2));}));}));\n  }\n  \n};\n\nvar run_expr_access = function (s, c, e1, e2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        return (\n          if_spec(run_expr_get_value(s1, c, e2), function(s2, v2) {\n              \n              if ((value_compare(v1, Coq_value_undef())\n                  || value_compare(v1, Coq_value_null()))) {\n                return (run_error(s2, c, Coq_native_error_type()));\n              } else {\n                return (\n                  if_string(to_string(s2, v2), function(s3, x) {\n                      \n                      return (\n                        res_ter(s3,\n                          res_ref(\n                            ref_create_value(v1, x, c.execution_ctx_strict))));\n                    }));\n              }}));}));\n};\n\nvar run_expr_assign = function (s, c, opo, e1, e2) {\n  return (\n    if_success(run_expr(s, c, e1), function(s1, rv1) {\n        \n        var follow = function (s0, rv_2) {\n          switch (rv_2.tag) {\n            case "Coq_resvalue_value":\n              var v = rv_2.value;\n              return (\n                if_void(ref_put_value(s0, c, rv1, v), function(s_2) {\n                    \n                    return (res_out(s_2, res_val(v)));}));\n            case "Coq_resvalue_empty":\n              Debug.impossible_with_heap_because(__LOC__, s0,\n                "Non-value result in [run_expr_assign].");\n              return (Coq_result_impossible());\n            case "Coq_resvalue_ref":\n              var r = rv_2.ref;\n              Debug.impossible_with_heap_because(__LOC__, s,\n                "Non-value result in [run_expr_assign].");\n              return (Coq_result_impossible());\n          }\n          \n        };\n        switch (opo.tag) {\n          case "Some":\n            var op = opo.value;\n            return (\n              if_spec(ref_get_value(s1, c, rv1), function(s2, v1) {\n                  \n                  return (\n                    if_spec(run_expr_get_value(s2, c, e2), function(s3, v2) {\n                        \n                        return (\n                          if_success(run_binary_op(s3, c, op, v1, v2),\n                            function(s4, v) { \n                                              return (follow(s4, v));}));}));\n                }));\n          case "None":\n            return (\n              if_spec(run_expr_get_value(s1, c, e2), function(x, x0) {\n                  \n                  return (follow(x, Coq_resvalue_value(x0)));}));\n        }\n        }));\n};\n\nvar run_expr_function = function (s, c, fo, args, bd) {\n  switch (fo.tag) {\n    case "Some":\n      var fn = fo.value;\n      var p = lexical_env_alloc_decl(s, c.execution_ctx_lexical_env);\n      var lex_2 = p[0], s_2 = p[1];\n      var follow = function (l) {\n        return (\n          if_some(env_record_binds_option(s_2, l), function(e) {\n              \n              return (\n                if_void(env_record_create_immutable_binding(s_2, l, fn),\n                  function(s1) {\n                    \n                    return (\n                      if_object(\n                        creating_function_object(s1, c, args, bd, lex_2,\n                          funcbody_is_strict(bd)), function(s2, l0) {\n                          \n                          return (\n                            if_void(\n                              env_record_initialize_immutable_binding(s2, l,\n                                fn, Coq_value_object(l0)), function(s3) {\n                                \n                                return (\n                                  res_out(s3, res_val(Coq_value_object(l0))));\n                              }));}));}));}));\n      };\n      return (\n        destr_list(lex_2, function (x) {\n            Debug.impossible_with_heap_because(__LOC__, s,\n              "Empty lexical environnment allocated in [run_expr_function].");\n            return (Coq_result_impossible());}, function (l, x) {\n            return (follow(l));}, {}));\n    case "None":\n      var lex = c.execution_ctx_lexical_env;\n      return (\n        creating_function_object(s, c, args, bd, lex, funcbody_is_strict(bd)));\n  }\n  \n};\n\nvar entering_eval_code = function (s, c, direct, bd, k) {\n  var str = (funcbody_is_strict(bd) || (direct && c.execution_ctx_strict));\n  if (direct) {\n    var c_2 = c;\n  } else {\n    var c_2 = execution_ctx_initial(str);\n  }\n  if (str) {\n    var p = lexical_env_alloc_decl(s, c_2.execution_ctx_lexical_env);\n  } else {\n    var p = [c_2.execution_ctx_lexical_env, s];\n  }\n  var lex = p[0], s_2 = p[1];\n  if (str) {\n    var c1 = execution_ctx_with_lex_same(c_2, lex);\n  } else {\n    var c1 = c_2;\n  }\n  var p0 = funcbody_prog(bd);\n  return (\n    if_void(\n      execution_ctx_binding_inst(s_2, c1, Coq_codetype_eval(), None(), p0,\n        mk_nil()), function(s1) { \n                                  return (k(s1, c1));}));\n};\n\nvar run_eval = function (s, c, is_direct_call, vs) {\n  var _switch_arg_113 = get_arg(0, vs);\n  switch (_switch_arg_113.tag) {\n    case "Coq_value_undef":\n      return (res_out(s, res_val(Coq_value_undef())));\n    case "Coq_value_null":\n      return (res_out(s, res_val(Coq_value_null())));\n    case "Coq_value_bool":\n      var b = _switch_arg_113.value;\n      return (res_out(s, res_val(Coq_value_bool(b))));\n    case "Coq_value_number":\n      var n = _switch_arg_113.value;\n      return (res_out(s, res_val(Coq_value_number(n))));\n    case "Coq_value_string":\n      var s0 = _switch_arg_113.value;\n      var str = (is_direct_call && c.execution_ctx_strict);\n      var _switch_arg_114 = parse_pickable(s0, str);\n      switch (_switch_arg_114.tag) {\n        case "Some":\n          var p0 = _switch_arg_114.value;\n          return (\n            entering_eval_code(s, c, is_direct_call,\n              Coq_funcbody_intro(p0, s0), function (s1, c_2) {\n                return (\n                  if_ter(run_prog(s1, c_2, p0), function(s2, r) {\n                      \n                      var _switch_arg_115 = r.res_type;\n                      switch (_switch_arg_115.tag) {\n                        case "Coq_restype_normal":\n                          return (\n                            ifx_empty_label(s2, r, function (x) {\n                                var _switch_arg_116 = r.res_value;\n                                switch (_switch_arg_116.tag) {\n                                  case "Coq_resvalue_empty":\n                                    return (\n                                      res_ter(s2, res_val(Coq_value_undef())));\n                                  case "Coq_resvalue_value":\n                                    var v = _switch_arg_116.value;\n                                    return (res_ter(s2, res_val(v)));\n                                  case "Coq_resvalue_ref":\n                                    var r0 = _switch_arg_116.ref;\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s2,\n                                      "Reference found in the result of an `eval\' in [run_eval].");\n                                    return (Coq_result_impossible());\n                                }\n                                }));\n                        case "Coq_restype_throw":\n                          return (res_ter(s2, res_throw(r.res_value)));\n                        default:\n                          Debug.impossible_with_heap_because(__LOC__, s2,\n                            "Forbidden result type returned by an `eval\' in [run_eval].");\n                          return (Coq_result_impossible());\n                      }\n                      }));}));\n        case "None":\n          return (run_error(s, c, Coq_native_error_syntax()));\n      }\n      \n    case "Coq_value_object":\n      var o = _switch_arg_113.value;\n      return (res_out(s, res_val(Coq_value_object(o))));\n  }\n  \n};\n\nvar run_expr_call = function (s, c, e1, e2s) {\n  var is_eval_direct = is_syntactic_eval(e1);\n  return (\n    if_success(run_expr(s, c, e1), function(s1, rv) {\n        \n        return (\n          if_spec(ref_get_value(s1, c, rv), function(s2, f) {\n              \n              return (\n                if_spec(run_list_expr(s2, c, mk_nil(), e2s), function(s3,\n                  vs) {\n                    \n                    switch (f.tag) {\n                      case "Coq_value_object":\n                        var l = f.value;\n                        if (is_callable_dec(s3, Coq_value_object(l))) {\n                          var follow = function (vthis) {\n                            if (object_loc_compare(l,\n                                  Coq_object_loc_prealloc(\n                                    Coq_prealloc_global_eval()))) {\n                              return (run_eval(s3, c, is_eval_direct, vs));\n                            } else {\n                              return (run_call(s3, c, l, vthis, vs));\n                            }\n                          };\n                          switch (rv.tag) {\n                            case "Coq_resvalue_empty":\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s3,\n                                  "[run_expr_call] unable to call an  empty result."));\n                            case "Coq_resvalue_value":\n                              var v = rv.value;\n                              return (follow(Coq_value_undef()));\n                            case "Coq_resvalue_ref":\n                              var r = rv.ref;\n                              var _switch_arg_117 = r.ref_base;\n                              switch (_switch_arg_117.tag) {\n                                case "Coq_ref_base_type_value":\n                                  var v = _switch_arg_117.value;\n                                  if ((ref_kind_comparable(ref_kind_of(r),\n                                         Coq_ref_kind_primitive_base())\n                                      || (ref_kind_comparable(ref_kind_of(r),\n                                            Coq_ref_kind_null())\n                                         || ref_kind_comparable(\n                                              ref_kind_of(r),\n                                              Coq_ref_kind_object())))) {\n                                    return (follow(v));\n                                  } else {\n                                    return (\n                                      function (s, m) {\n                                          Debug.impossible_with_heap_because(\n                                            __LOC__, s, m);\n                                          return (Coq_result_impossible());}(\n                                        s3,\n                                        "[run_expr_call] unable to call a non-property function."));\n                                  }\n                                case "Coq_ref_base_type_env_loc":\n                                  var l0 = _switch_arg_117.value;\n                                  return (\n                                    if_some(\n                                      env_record_implicit_this_value(s3, l0),\n                                      function(v) { \n                                                    return (follow(v));}));\n                              }\n                              \n                          }\n                          \n                        } else {\n                          return (run_error(s3, c, Coq_native_error_type()));\n                        }\n                      default:\n                        return (run_error(s3, c, Coq_native_error_type()));\n                    }\n                    }));}));}));\n};\n\nvar run_expr_conditionnal = function (s, c, e1, e2, e3) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = to_boolean(v1);\n        if (b) {\n          var e = e2;\n        } else {\n          var e = e3;\n        }\n        return (\n          if_spec(run_expr_get_value(s1, c, e), function(s0, r) {\n              \n              return (res_ter(s0, res_val(r)));}));}));\n};\n\nvar run_expr_new = function (s, c, e1, e2s) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v) {\n        \n        return (\n          if_spec(run_list_expr(s1, c, mk_nil(), e2s), function(s2, args) {\n              \n              switch (v.tag) {\n                case "Coq_value_object":\n                  var l = v.value;\n                  return (\n                    if_some(run_object_method(object_construct_, s2, l),\n                      function(coo) {\n                        \n                        switch (coo.tag) {\n                          case "Some":\n                            var co = coo.value;\n                            return (run_construct(s2, c, co, l, args));\n                          case "None":\n                            return (\n                              run_error(s2, c, Coq_native_error_type()));\n                        }\n                        }));\n                default:\n                  return (run_error(s2, c, Coq_native_error_type()));\n              }\n              }));}));\n};\n\nvar run_stat_label = function (s, c, lab, t) {\n  return (\n    if_break(run_stat(s, c, t), function(s1, r1) {\n        \n        return (\n          res_out(s1, (function () {\n              if (label_compare(r1.res_label, lab)) {\n                return (res_normal(r1.res_value));\n              } else {\n                return (r1);\n              }}())));}));\n};\n\nvar run_stat_with = function (s, c, e1, t2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        return (\n          if_object(to_object(s1, v1), function(s2, l) {\n              \n              var lex = c.execution_ctx_lexical_env;\n              var p = lexical_env_alloc_object(s2, lex, l, provide_this_true);\n              var lex_2 = p[0], s3 = p[1];\n              var c_2 = execution_ctx_with_lex(c, lex_2);\n              return (run_stat(s3, c_2, t2));}));}));\n};\n\nvar run_stat_if = function (s, c, e1, t2, to0) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = to_boolean(v1);\n        if (b) {\n          return (run_stat(s1, c, t2));\n        } else {\n          switch (to0.tag) {\n            case "Some":\n              var t3 = to0.value;\n              return (run_stat(s1, c, t3));\n            case "None":\n              return (res_out(s1, res_normal(Coq_resvalue_empty())));\n          }\n          \n        }}));\n};\n\nvar run_stat_while = function (s, c, rv, labs, e1, t2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = to_boolean(v1);\n        if (b) {\n          return (\n            if_ter(run_stat(s1, c, t2), function(s2, r) {\n                \n                if (!(resvalue_compare(r.res_value, Coq_resvalue_empty()))) {\n                  var rv_2 = r.res_value;\n                } else {\n                  var rv_2 = rv;\n                }\n                var loop = function (x) {\n                  return (run_stat_while(s2, c, rv_2, labs, e1, t2));\n                };\n                if ((!(restype_compare(r.res_type, Coq_restype_continue()))\n                    || !(res_label_in(r, labs)))) {\n                  if ((restype_compare(r.res_type, Coq_restype_break())\n                      && res_label_in(r, labs))) {\n                    return (res_ter(s2, res_normal(rv_2)));\n                  } else {\n                    if (!(restype_compare(r.res_type, Coq_restype_normal()))) {\n                      return (res_ter(s2, r));\n                    } else {\n                      return (loop({}));\n                    }\n                  }\n                } else {\n                  return (loop({}));\n                }}));\n        } else {\n          return (res_ter(s1, res_normal(rv)));\n        }}));\n};\n\nvar run_stat_switch_end = function (s, c, rv, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_normal(rv)));\n    case "::":\n      var y = _foo_.head, scs_2 = _foo_.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            ifx_success_state(rv, run_block(s, c, rev(ts)),\n              function (s1, rv1) {\n                return (run_stat_switch_end(s1, c, rv1, scs_2));}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_no_default = function (s, c, vi, rv, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_normal(rv)));\n    case "::":\n      var y = _foo_.head, scs_2 = _foo_.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n                \n                var b = strict_equality_test(v1, vi);\n                if (b) {\n                  return (\n                    if_success(run_block(s1, c, rev(ts)), function(s2, rv2) {\n                        \n                        return (run_stat_switch_end(s2, c, rv2, scs_2));}));\n                } else {\n                  return (run_stat_switch_no_default(s1, c, vi, rv, scs_2));\n                }}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_default = function (s, c, ts, scs) {\n  return (\n    if_success(run_block(s, c, rev(ts)), function(s1, rv) {\n        \n        return (run_stat_switch_end(s1, c, rv, scs));}));\n};\n\nvar run_stat_switch_with_default_B = function (s, c, vi, rv, ts0, scs) {\n  switch (scs.tag) {\n    case "[]":\n      return (run_stat_switch_with_default_default(s, c, ts0, scs));\n    case "::":\n      var y = scs.head, scs_2 = scs.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n                \n                var b = strict_equality_test(v1, vi);\n                if (b) {\n                  return (\n                    if_success(run_block(s1, c, rev(ts)), function(s2, rv2) {\n                        \n                        return (run_stat_switch_end(s2, c, rv2, scs_2));}));\n                } else {\n                  return (\n                    run_stat_switch_with_default_B(s1, c, vi, rv, ts0, scs_2));\n                }}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_A = function (s, c, found, vi, rv, scs1, ts0, scs2) {\n  switch (scs1.tag) {\n    case "[]":\n      if (found) {\n        return (run_stat_switch_with_default_default(s, c, ts0, scs2));\n      } else {\n        return (run_stat_switch_with_default_B(s, c, vi, rv, ts0, scs2));\n      }\n    case "::":\n      var y = scs1.head, scs_2 = scs1.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          var follow = function (s0) {\n            return (\n              ifx_success_state(rv, run_block(s0, c, rev(ts)),\n                function (s1, rv0) {\n                  return (\n                    run_stat_switch_with_default_A(s1, c, true, vi, rv0,\n                      scs_2, ts0, scs2));}));\n          };\n          if (found) {\n            return (follow(s));\n          } else {\n            return (\n              if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n                  \n                  var b = strict_equality_test(v1, vi);\n                  if (b) {\n                    return (follow(s1));\n                  } else {\n                    return (\n                      run_stat_switch_with_default_A(s1, c, false, vi, rv,\n                        scs_2, ts0, scs2));\n                  }}));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch = function (s, c, labs, e, sb) {\n  return (\n    if_spec(run_expr_get_value(s, c, e), function(s1, vi) {\n        \n        var follow = function (w) {\n          return (\n            if_success(\n              if_break(w, function(s2, r) {\n                  \n                  if (res_label_in(r, labs)) {\n                    return (res_out(s2, res_normal(r.res_value)));\n                  } else {\n                    return (res_out(s2, r));\n                  }}), function(s0, r) { \n                                         return (res_ter(s0, res_normal(r)));\n              }));\n        };\n        switch (sb.tag) {\n          case "Coq_switchbody_nodefault":\n            var scs = sb.clauses;\n            return (\n              follow(\n                run_stat_switch_no_default(s1, c, vi, Coq_resvalue_empty(),\n                  scs)));\n          case "Coq_switchbody_withdefault":\n            var scs1 = sb.clauses_before, ts = sb.clause_default,\n              scs2 = sb.clauses_after;\n            return (\n              follow(\n                run_stat_switch_with_default_A(s1, c, false, vi,\n                  Coq_resvalue_empty(), scs1, ts, scs2)));\n        }\n        }));\n};\n\nvar run_stat_do_while = function (s, c, rv, labs, e1, t2) {\n  return (\n    if_ter(run_stat(s, c, t2), function(s1, r) {\n        \n        if (resvalue_compare(r.res_value, Coq_resvalue_empty())) {\n          var rv_2 = rv;\n        } else {\n          var rv_2 = r.res_value;\n        }\n        var loop = function (x) {\n          return (\n            if_spec(run_expr_get_value(s1, c, e1), function(s2, v1) {\n                \n                var b = to_boolean(v1);\n                if (b) {\n                  return (run_stat_do_while(s2, c, rv_2, labs, e1, t2));\n                } else {\n                  return (res_ter(s2, res_normal(rv_2)));\n                }}));\n        };\n        if ((restype_compare(r.res_type, Coq_restype_continue())\n            && res_label_in(r, labs))) {\n          return (loop({}));\n        } else {\n          if ((restype_compare(r.res_type, Coq_restype_break())\n              && res_label_in(r, labs))) {\n            return (res_ter(s1, res_normal(rv_2)));\n          } else {\n            if (!(restype_compare(r.res_type, Coq_restype_normal()))) {\n              return (res_ter(s1, r));\n            } else {\n              return (loop({}));\n            }\n          }\n        }}));\n};\n\nvar run_stat_try = function (s, c, t1, t2o, t3o) {\n  var finallycont = function (s1, r) {\n    switch (t3o.tag) {\n      case "Some":\n        var t3 = t3o.value;\n        return (\n          if_success(run_stat(s1, c, t3), function(s2, rv_2) {\n              \n              return (res_ter(s2, r));}));\n      case "None":\n        return (res_ter(s1, r));\n    }\n    \n  };\n  return (\n    ifx_any_or_throw(run_stat(s, c, t1), finallycont, function (s1, v) {\n        switch (t2o.tag) {\n          case "Some":\n            var y = t2o.value;\n            var x = y[0], t2 = y[1];\n            var lex = c.execution_ctx_lexical_env;\n            var p = lexical_env_alloc_decl(s1, lex);\n            var lex_2 = p[0], s_2 = p[1];\n            switch (lex_2.tag) {\n              case "[]":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s_2,\n                    "Empty lexical environnment in [run_stat_try]."));\n              case "::":\n                var l = lex_2.head, oldlex = lex_2.tail;\n                return (\n                  if_void(\n                    env_record_create_set_mutable_binding(s_2, c, l, x,\n                      None(), v, throw_irrelevant), function(s2) {\n                      \n                      var c_2 = execution_ctx_with_lex(c, lex_2);\n                      return (\n                        if_ter(run_stat(s2, c_2, t2), function(s3, r) {\n                            \n                            return (finallycont(s3, r));}));}));\n            }\n            \n          case "None":\n            return (finallycont(s1, res_throw(Coq_resvalue_value(v))));\n        }\n        }));\n};\n\nvar run_stat_throw = function (s, c, e) {\n  return (\n    if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n        \n        return (res_ter(s1, res_throw(Coq_resvalue_value(v1))));}));\n};\n\nvar run_stat_return = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var e = _foo_.value;\n      return (\n        if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n            \n            return (res_ter(s1, res_return(Coq_resvalue_value(v1))));}));\n    case "None":\n      return (res_out(s, res_return(Coq_resvalue_value(Coq_value_undef()))));\n  }\n  \n};\n\nvar run_stat_for_loop = function (s, c, labs, rv, eo2, eo3, t) {\n  var follows = function (s0) {\n    return (\n      if_ter(run_stat(s0, c, t), function(s1, r) {\n          \n          if (!(resvalue_compare(r.res_value, Coq_resvalue_empty()))) {\n            var rv_2 = r.res_value;\n          } else {\n            var rv_2 = rv;\n          }\n          var loop = function (s2) {\n            return (run_stat_for_loop(s2, c, labs, rv_2, eo2, eo3, t));\n          };\n          if ((restype_compare(r.res_type, Coq_restype_break())\n              && res_label_in(r, labs))) {\n            return (res_ter(s1, res_normal(rv_2)));\n          } else {\n            if ((restype_compare(r.res_type, Coq_restype_normal())\n                || (restype_compare(r.res_type, Coq_restype_continue())\n                   && res_label_in(r, labs)))) {\n              switch (eo3.tag) {\n                case "Some":\n                  var e3 = eo3.value;\n                  return (\n                    if_spec(run_expr_get_value(s1, c, e3), function(s2, v3) {\n                        \n                        return (loop(s2));}));\n                case "None":\n                  return (loop(s1));\n              }\n              \n            } else {\n              return (res_ter(s1, r));\n            }\n          }}));\n  };\n  switch (eo2.tag) {\n    case "Some":\n      var e2 = eo2.value;\n      return (\n        if_spec(run_expr_get_value(s, c, e2), function(s0, v2) {\n            \n            var b = to_boolean(v2);\n            if (b) {\n              return (follows(s0));\n            } else {\n              return (res_ter(s0, res_normal(rv)));\n            }}));\n    case "None":\n      return (follows(s));\n  }\n  \n};\n\nvar run_stat_for = function (s, c, labs, eo1, eo2, eo3, t) {\n  var follows = function (s0) {\n    return (\n      run_stat_for_loop(s0, c, labs, Coq_resvalue_empty(), eo2, eo3, t));\n  };\n  switch (eo1.tag) {\n    case "Some":\n      var e1 = eo1.value;\n      return (\n        if_spec(run_expr_get_value(s, c, e1), function(s0, v1) {\n            \n            return (follows(s0));}));\n    case "None":\n      return (follows(s));\n  }\n  \n};\n\nvar run_stat_for_var = function (s, c, labs, ds, eo2, eo3, t) {\n  return (\n    if_ter(run_stat(s, c, Coq_stat_var_decl(ds)), function(s0, r) {\n        \n        return (\n          run_stat_for_loop(s0, c, labs, Coq_resvalue_empty(), eo2, eo3, t));\n      }));\n};\n\nvar run_expr = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_expr_this":\n      return (res_out(s, res_val(c.execution_ctx_this_binding)));\n    case "Coq_expr_identifier":\n      var x = _term_.name;\n      return (\n        if_spec(identifier_resolution(s, c, x), function(s0, r) {\n            \n            return (res_ter(s0, res_ref(r)));}));\n    case "Coq_expr_literal":\n      var i = _term_.value;\n      return (res_out(s, res_val(convert_literal_to_prim(i))));\n    case "Coq_expr_object":\n      var pds = _term_.fields;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n          function(s1, l) { \n                            return (init_object(s1, c, l, pds));}));\n    case "Coq_expr_array":\n      var oes = _term_.elements;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_array(), mk_nil()),\n          function(s1, l) { \n                            return (init_array(s1, c, l, oes));}));\n    case "Coq_expr_function":\n      var fo = _term_.func_name_opt, args = _term_.arg_names,\n        bd = _term_.body;\n      return (run_expr_function(s, c, fo, args, bd));\n    case "Coq_expr_access":\n      var e1 = _term_.obj, e2 = _term_.field;\n      return (run_expr_access(s, c, e1, e2));\n    case "Coq_expr_member":\n      var e1 = _term_.obj, f = _term_.field_name;\n      return (\n        run_expr(s, c,\n          Coq_expr_access(e1, Coq_expr_literal(Coq_literal_string(f)))));\n    case "Coq_expr_new":\n      var e1 = _term_.func, e2s = _term_.args;\n      return (run_expr_new(s, c, e1, e2s));\n    case "Coq_expr_call":\n      var e1 = _term_.func, e2s = _term_.args;\n      return (run_expr_call(s, c, e1, e2s));\n    case "Coq_expr_unary_op":\n      var op = _term_.op, e0 = _term_.arg;\n      return (run_unary_op(s, c, op, e0));\n    case "Coq_expr_binary_op":\n      var e1 = _term_.arg1, op = _term_.op, e2 = _term_.arg2;\n      return (run_expr_binary_op(s, c, op, e1, e2));\n    case "Coq_expr_conditional":\n      var e1 = _term_.cond, e2 = _term_.then_branch, e3 = _term_.else_branch;\n      return (run_expr_conditionnal(s, c, e1, e2, e3));\n    case "Coq_expr_assign":\n      var e1 = _term_.left_expr, opo = _term_.op_opt, e2 = _term_.right_expr;\n      return (run_expr_assign(s, c, opo, e1, e2));\n  }\n  \n};\n\nvar run_stat = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_stat_expr":\n      var e = _term_.expr;\n      return (\n        if_spec(run_expr_get_value(s, c, e), function(s0, r) {\n            \n            return (res_ter(s0, res_val(r)));}));\n    case "Coq_stat_label":\n      var lab = _term_.label, t0 = _term_.stat;\n      return (run_stat_label(s, c, Coq_label_string(lab), t0));\n    case "Coq_stat_block":\n      var ts = _term_.stats;\n      return (run_block(s, c, rev(ts)));\n    case "Coq_stat_var_decl":\n      var xeos = _term_.decls;\n      return (run_var_decl(s, c, xeos));\n    case "Coq_stat_if":\n      var e1 = _term_.cond, t2 = _term_.then_branch,\n        to0 = _term_.else_branch;\n      return (run_stat_if(s, c, e1, t2, to0));\n    case "Coq_stat_do_while":\n      var ls = _term_.labels, t1 = _term_.body, e2 = _term_.cond;\n      return (run_stat_do_while(s, c, Coq_resvalue_empty(), ls, e2, t1));\n    case "Coq_stat_while":\n      var ls = _term_.labels, e1 = _term_.cond, t2 = _term_.body;\n      return (run_stat_while(s, c, Coq_resvalue_empty(), ls, e1, t2));\n    case "Coq_stat_with":\n      var e1 = _term_.obj, t2 = _term_.stat;\n      return (run_stat_with(s, c, e1, t2));\n    case "Coq_stat_throw":\n      var e = _term_.arg;\n      return (run_stat_throw(s, c, e));\n    case "Coq_stat_return":\n      var eo = _term_.arg_opt;\n      return (run_stat_return(s, c, eo));\n    case "Coq_stat_break":\n      var so = _term_.label;\n      return (res_out(s, res_break(so)));\n    case "Coq_stat_continue":\n      var so = _term_.label;\n      return (res_out(s, res_continue(so)));\n    case "Coq_stat_try":\n      var t1 = _term_.body, t2o = _term_.catch_stats_opt,\n        t3o = _term_.finally_opt;\n      return (run_stat_try(s, c, t1, t2o, t3o));\n    case "Coq_stat_for":\n      var ls = _term_.labels, eo1 = _term_.init, eo2 = _term_.cond,\n        eo3 = _term_.step, s0 = _term_.body;\n      return (run_stat_for(s, c, ls, eo1, eo2, eo3, s0));\n    case "Coq_stat_for_var":\n      var ls = _term_.labels, ds = _term_.init, eo2 = _term_.cond,\n        eo3 = _term_.step, s0 = _term_.body;\n      return (run_stat_for_var(s, c, ls, ds, eo2, eo3, s0));\n    case "Coq_stat_for_in":\n      var ls = _term_.labels, e1 = _term_.id, e2 = _term_.obj,\n        s0 = _term_.body;\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}("stat_for_in"));\n    case "Coq_stat_for_in_var":\n      var ls = _term_.labels, x = _term_.id, e1o = _term_.init,\n        e2 = _term_.obj, s0 = _term_.body;\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}("stat_for_in_var"));\n    case "Coq_stat_debugger":\n      return (res_out(s, res_empty));\n    case "Coq_stat_switch":\n      var labs = _term_.labels, e = _term_.arg, sb = _term_.body;\n      return (run_stat_switch(s, c, labs, e, sb));\n  }\n  \n};\n\nvar run_elements = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_normal(Coq_resvalue_empty())));\n    case "::":\n      var el = _foo_.head, els_rev_2 = _foo_.tail;\n      return (\n        if_success(run_elements(s, c, els_rev_2), function(s0, rv0) {\n            \n            switch (el.tag) {\n              case "Coq_element_stat":\n                var t = el.stat;\n                return (\n                  if_ter(run_stat(s0, c, t), function(s1, r1) {\n                      \n                      var r2 = res_overwrite_value_if_empty(rv0, r1);\n                      return (res_out(s1, r2));}));\n              case "Coq_element_func_decl":\n                var name = el.func_name, args = el.arg_names, bd = el.body;\n                return (res_ter(s0, res_normal(rv0)));\n            }\n            }));\n  }\n  \n};\n\nvar run_prog = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_prog_intro":\n      var str = _term_.strictness, els = _term_.elements;\n      return (run_elements(s, c, rev(els)));\n  }\n  \n};\n\nvar push = function (s, c, l, args, ilen) {\n  var vlen = ilen;\n  switch (args.tag) {\n    case "[]":\n      return (\n        if_not_throw(\n          object_put(s, c, l, "length", Coq_value_number(vlen), throw_true),\n          function(s0, x) {\n            \n            return (res_out(s0, res_val(Coq_value_number(vlen))));}));\n    case "::":\n      var v = args.head, vs = args.tail;\n      return (\n        if_string(to_string(s, Coq_value_number(vlen)), function(s0, slen) {\n            \n            return (\n              if_not_throw(object_put(s0, c, l, slen, v, throw_true),\n                function(s1, x) { \n                                  return (push(s1, c, l, vs, (ilen + 1.)));}));\n          }));\n  }\n  \n};\n\nvar run_object_is_sealed = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_method(object_extensible_, s, l), function(ext) {\n            \n            return (res_ter(s, res_val(Coq_value_bool(!(ext)))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_spec(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if (attributes_configurable(a)) {\n                  return (res_ter(s0, res_val(Coq_value_bool(false))));\n                } else {\n                  return (run_object_is_sealed(s0, c, l, xs_2));\n                }\n            }\n            }));\n  }\n  \n};\n\nvar run_object_seal = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_heap_set_extensible(false, s, l), function(s0) {\n            \n            return (res_ter(s0, res_val(Coq_value_object(l))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_spec(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_seal]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if (attributes_configurable(a)) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: None(),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: Some(false)\n                  };\n                  var a_2 = attributes_update(a, desc);\n                } else {\n                  var a_2 = a;\n                }\n                return (\n                  if_bool(\n                    object_define_own_prop(s0, c, l, x,\n                      descriptor_of_attributes(a_2), true), function(s1,\n                    x0) { \n                          return (run_object_seal(s1, c, l, xs_2));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_object_freeze = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_heap_set_extensible(false, s, l), function(s0) {\n            \n            return (res_ter(s0, res_val(Coq_value_object(l))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_spec(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if ((attributes_is_data_dec(a) && attributes_writable(a))) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: Some(false),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: None()\n                  };\n                  var a_2 = attributes_update(a, desc);\n                } else {\n                  var a_2 = a;\n                }\n                if (attributes_configurable(a_2)) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: None(),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: Some(false)\n                  };\n                  var a_3 = attributes_update(a_2, desc);\n                } else {\n                  var a_3 = a_2;\n                }\n                return (\n                  if_bool(\n                    object_define_own_prop(s0, c, l, x,\n                      descriptor_of_attributes(a_3), true), function(s1,\n                    x0) { \n                          return (run_object_freeze(s1, c, l, xs_2));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_object_is_frozen = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_method(object_extensible_, s, l), function(ext) {\n            \n            return (res_ter(s, res_val(Coq_value_bool(!(ext)))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_spec(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            var check_configurable = function (a) {\n              if (attributes_configurable(a)) {\n                return (res_ter(s0, res_val(Coq_value_bool(false))));\n              } else {\n                return (run_object_is_frozen(s0, c, l, xs_2));\n              }\n            };\n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                switch (a.tag) {\n                  case "Coq_attributes_data_of":\n                    var ad = a.value;\n                    if (attributes_writable(Coq_attributes_data_of(ad))) {\n                      return (res_ter(s0, res_val(Coq_value_bool(false))));\n                    } else {\n                      return (\n                        check_configurable(Coq_attributes_data_of(ad)));\n                    }\n                  case "Coq_attributes_accessor_of":\n                    var aa = a.value;\n                    return (\n                      check_configurable(Coq_attributes_accessor_of(aa)));\n                }\n                \n            }\n            }));\n  }\n  \n};\n\nvar run_get_args_for_apply = function (s, c, l, index, n) {\n  if ((index < n)) {\n    return (\n      if_string(to_string(s, Coq_value_number(index)), function(s0, sindex) {\n          \n          return (\n            if_value(run_object_get(s0, c, l, sindex), function(s1, v) {\n                \n                var tail_args = run_get_args_for_apply(s1, c, l,\n                                  (index + 1.), n);\n                return (\n                  if_spec(tail_args, function(s2, tail) {\n                      \n                      return (res_spec(s2, mk_cons(v, tail)));}));}));}));\n  } else {\n    return (res_spec(s, mk_nil()));\n  }\n};\n\nvar valueToStringForJoin = function (s, c, l, k) {\n  return (\n    if_string(to_string(s, Coq_value_number(k)), function(s0, prop) {\n        \n        return (\n          if_value(run_object_get(s0, c, l, prop), function(s1, v) {\n              \n              switch (v.tag) {\n                case "Coq_value_undef":\n                  return (res_spec(s1, ""));\n                case "Coq_value_null":\n                  return (res_spec(s1, ""));\n                case "Coq_value_bool":\n                  var b = v.value;\n                  return (\n                    if_string(to_string(s1, v), function(s2, s3) {\n                        \n                        return (res_spec(s2, s3));}));\n                case "Coq_value_number":\n                  var n = v.value;\n                  return (\n                    if_string(to_string(s1, v), function(s2, s3) {\n                        \n                        return (res_spec(s2, s3));}));\n                case "Coq_value_string":\n                  var s2 = v.value;\n                  return (\n                    if_string(to_string(s1, v), function(s3, s4) {\n                        \n                        return (res_spec(s3, s4));}));\n                case "Coq_value_object":\n                  var o = v.value;\n                  return (\n                    if_string(to_string(s1, v), function(s2, s3) {\n                        \n                        return (res_spec(s2, s3));}));\n              }\n              }));}));\n};\n\nvar run_array_join_elements = function (s, c, l, k, length0, sep, sR) {\n  if ((k < length0)) {\n    var ss = strappend(sR, sep);\n    var sE = valueToStringForJoin(s, c, l, k);\n    return (\n      if_spec(sE, function(s0, element) {\n          \n          var sR0 = strappend(ss, element);\n          return (\n            run_array_join_elements(s0, c, l, (k + 1.), length0, sep, sR0));\n        }));\n  } else {\n    return (res_ter(s, res_val(Coq_value_string(sR))));\n  }\n};\n\nvar run_call_prealloc = function (s, c, b, vthis, args) {\n  switch (b.tag) {\n    case "Coq_prealloc_global_is_finite":\n      var v = get_arg(0, args);\n      return (\n        if_number(to_number(s, v), function(s0, n) {\n            \n            return (\n              res_ter(s0,\n                res_val(\n                  Coq_value_bool(\n                    !(\n                      (JsNumber.isnan(n)\n                      || ((n === JsNumber.infinity)\n                         || (n === JsNumber.neg_infinity))))))));}));\n    case "Coq_prealloc_global_is_nan":\n      var v = get_arg(0, args);\n      return (\n        if_number(to_number(s, v), function(s0, n) {\n            \n            return (res_ter(s0, res_val(Coq_value_bool(JsNumber.isnan(n)))));\n          }));\n    case "Coq_prealloc_object":\n      var value0 = get_arg(0, args);\n      switch (value0.tag) {\n        case "Coq_value_undef":\n          return (run_construct_prealloc(s, c, b, args));\n        case "Coq_value_null":\n          return (run_construct_prealloc(s, c, b, args));\n        case "Coq_value_bool":\n          var b0 = value0.value;\n          return (to_object(s, value0));\n        case "Coq_value_number":\n          var n = value0.value;\n          return (to_object(s, value0));\n        case "Coq_value_string":\n          var s0 = value0.value;\n          return (to_object(s, value0));\n        case "Coq_value_object":\n          var o = value0.value;\n          return (to_object(s, value0));\n      }\n      \n    case "Coq_prealloc_object_get_proto_of":\n      var v = get_arg(0, args);\n      return (builtin_object_get_prototype_of(s, c, {}, vthis, {}, v));\n    case "Coq_prealloc_object_get_own_prop_descriptor":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_string(to_string(s, get_arg(1, args)), function(s1, x) {\n                \n                return (\n                  if_spec(run_object_get_own_prop(s1, c, l, x), function(s2,\n                    d) { \n                         return (from_prop_descriptor(s2, c, d));}));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_define_prop":\n      var o = get_arg(0, args);\n      var p = get_arg(1, args);\n      var attr = get_arg(2, args);\n      switch (o.tag) {\n        case "Coq_value_object":\n          var l = o.value;\n          return (\n            if_string(to_string(s, p), function(s1, name) {\n                \n                return (\n                  if_spec(to_property_descriptor(s1, attr), function(s2,\n                    desc) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, name, desc, true),\n                          function(s3, x) {\n                            \n                            return (\n                              res_ter(s3, res_val(Coq_value_object(l))));}));\n                    }));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_seal":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_seal(s, c, l, _x_));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_freeze":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_freeze(s, c, l, _x_));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_prevent_extensions":\n      var v = get_arg(0, args);\n      return (builtin_object_prevent_extensions(s, c, {}, vthis, {}, v));\n    case "Coq_prealloc_object_is_sealed":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_is_sealed(s, c, l, _x_));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_is_frozen":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_is_frozen(s, c, l, _x_));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_is_extensible":\n      var v = get_arg(0, args);\n      return (builtin_object_is_extensible(s, c, {}, vthis, {}, v));\n    case "Coq_prealloc_object_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_undef":\n          return (\n            res_out(s, res_val(Coq_value_string("[object Undefined]"))));\n        case "Coq_value_null":\n          return (res_out(s, res_val(Coq_value_string("[object Null]"))));\n        case "Coq_value_bool":\n          var b0 = vthis.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s0) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_string(\n                              strappend("[object ", strappend(s0, "]"))))));\n                    }));}));\n        case "Coq_value_number":\n          var n = vthis.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s0) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_string(\n                              strappend("[object ", strappend(s0, "]"))))));\n                    }));}));\n        case "Coq_value_string":\n          var s0 = vthis.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s2) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_string(\n                              strappend("[object ", strappend(s2, "]"))))));\n                    }));}));\n        case "Coq_value_object":\n          var o = vthis.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s0) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_string(\n                              strappend("[object ", strappend(s0, "]"))))));\n                    }));}));\n      }\n      \n    case "Coq_prealloc_object_proto_value_of":\n      return (to_object(s, vthis));\n    case "Coq_prealloc_object_proto_has_own_prop":\n      var v = get_arg(0, args);\n      return (\n        if_string(to_string(s, v), function(s1, x) {\n            \n            return (\n              if_object(to_object(s1, vthis), function(s2, l) {\n                  \n                  return (\n                    if_spec(run_object_get_own_prop(s2, c, l, x),\n                      function(s3, d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (\n                              res_ter(s3, res_val(Coq_value_bool(false))));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (\n                              res_ter(s3, res_val(Coq_value_bool(true))));\n                        }\n                        }));}));}));\n    case "Coq_prealloc_object_proto_is_prototype_of":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, lo) {\n                \n                return (object_proto_is_prototype_of(s1, lo, l));}));\n        default:\n          return (res_out(s, res_val(Coq_value_bool(false))));\n      }\n      \n    case "Coq_prealloc_object_proto_prop_is_enumerable":\n      var v = get_arg(0, args);\n      return (\n        if_string(to_string(s, v), function(s1, x) {\n            \n            return (\n              if_object(to_object(s1, vthis), function(s2, l) {\n                  \n                  return (\n                    if_spec(run_object_get_own_prop(s2, c, l, x),\n                      function(s3, d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (\n                              res_ter(s3, res_val(Coq_value_bool(false))));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (\n                              res_ter(s3,\n                                res_val(\n                                  Coq_value_bool(attributes_enumerable(a)))));\n                        }\n                        }));}));}));\n    case "Coq_prealloc_function_proto":\n      return (res_out(s, res_val(Coq_value_undef())));\n    case "Coq_prealloc_function_proto_to_string":\n      if (is_callable_dec(s, vthis)) {\n        return (\n          function (s) {\n              Debug.not_yet_implemented_because(__LOC__, s);\n              return (Coq_result_not_yet_implemented());}(\n            "Function.prototype.toString() is implementation dependent."));\n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_apply":\n      var thisArg = get_arg(0, args);\n      var argArray = get_arg(1, args);\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            switch (argArray.tag) {\n              case "Coq_value_undef":\n                return (run_call(s, c, thisobj, thisArg, mk_nil()));\n              case "Coq_value_null":\n                return (run_call(s, c, thisobj, thisArg, mk_nil()));\n              case "Coq_value_bool":\n                var b0 = argArray.value;\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Coq_value_number":\n                var n = argArray.value;\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Coq_value_string":\n                var s0 = argArray.value;\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Coq_value_object":\n                var array = argArray.value;\n                return (\n                  if_value(run_object_get(s, c, array, "length"),\n                    function(s0, v) {\n                      \n                      return (\n                        if_spec(to_uint32(s0, c, v), function(s1, ilen) {\n                            \n                            return (\n                              if_spec(\n                                run_get_args_for_apply(s1, c, array, 0.,\n                                  ilen), function(s2, arguments_) {\n                                  \n                                  return (\n                                    run_call(s2, c, thisobj, thisArg,\n                                      arguments_));}));}));}));\n            }\n            \n          default:\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_call":\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            var _tuple_arg_118 = get_arg_first_and_rest(args);\n            var thisArg = _tuple_arg_118[0], a = _tuple_arg_118[1];\n            return (run_call(s, c, thisobj, thisArg, a));\n          default:\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_bind":\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            var _tuple_arg_119 = get_arg_first_and_rest(args);\n            var vthisArg = _tuple_arg_119[0], a = _tuple_arg_119[1];\n            var o1 = object_new(\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                       "Object");\n            var o2 = o1;\n            var o3 = object_with_details(o2, None(), None(), None(),\n                       Some(thisobj), Some(vthisArg), Some(a), None());\n            var o4 = object_set_class(o3, "Function");\n            var o5 = object_set_proto(o4,\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(\n                           Coq_prealloc_function_proto())));\n            var o6 = object_with_invokation(o5,\n                       Some(Coq_construct_after_bind()),\n                       Some(Coq_call_after_bind()),\n                       Some(Coq_builtin_has_instance_after_bind()));\n            var o7 = object_set_extensible(o6, true);\n            var _tuple_arg_120 = object_alloc(s, o7);\n            var l = _tuple_arg_120[0], s_2 = _tuple_arg_120[1];\n            var vlength = if_some(\n                            run_object_method(object_class_, s_2, thisobj),\n                            function(class0) {\n                              \n                              if (string_eq(class0, "Function")) {\n                                return (\n                                  if_number(\n                                    run_object_get(s_2, c, thisobj, "length"),\n                                    function(s10, n) {\n                                      \n                                      return (\n                                        if_spec(\n                                          to_int32(s10, c,\n                                            Coq_value_number(n)),\n                                          function(s11, ilen) {\n                                            \n                                            if ((ilen\n                                                < number_of_int(\n                                                    LibList.length(a)))) {\n                                              return (res_spec(s11, 0.));\n                                            } else {\n                                              return (\n                                                res_spec(s11,\n                                                  (ilen\n                                                  - number_of_int(\n                                                      LibList.length(a)))));\n                                            }}));}));\n                              } else {\n                                return (res_spec(s_2, 0.));\n                              }});\n            return (\n              if_spec(vlength, function(s10, length0) {\n                  \n                  var a0 = {\n                    attributes_data_value: Coq_value_number(length0),\n                    attributes_data_writable: false,\n                    attributes_data_enumerable: false,\n                    attributes_data_configurable: false\n                  };\n                  return (\n                    if_some(\n                      run_object_heap_map_properties(s10, l, function (p) {\n                          return (\n                            HeapStr.write(p, "length",\n                              Coq_attributes_data_of(a0)));}),\n                      function(s11) {\n                        \n                        var vthrower = Coq_value_object(\n                                         Coq_object_loc_prealloc(\n                                           Coq_prealloc_throw_type_error()));\n                        var a1 = {\n                          attributes_accessor_get: vthrower,\n                          attributes_accessor_set: vthrower,\n                          attributes_accessor_enumerable: false,\n                          attributes_accessor_configurable: false\n                        };\n                        return (\n                          if_bool(\n                            object_define_own_prop(s11, c, l, "caller",\n                              descriptor_of_attributes(\n                                Coq_attributes_accessor_of(a1)), false),\n                            function(s12, x) {\n                              \n                              return (\n                                if_bool(\n                                  object_define_own_prop(s12, c, l,\n                                    "arguments",\n                                    descriptor_of_attributes(\n                                      Coq_attributes_accessor_of(a1)), false),\n                                  function(s13, x0) {\n                                    \n                                    return (\n                                      res_ter(s13,\n                                        res_val(Coq_value_object(l))));}));}));\n                      }));}));\n          default:\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_bool":\n      var v = get_arg(0, args);\n      return (res_out(s, res_val(Coq_value_bool(to_boolean(v)))));\n    case "Coq_prealloc_bool_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_undef":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_null":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_bool":\n          var b0 = vthis.value;\n          return (\n            res_ter(s,\n              res_val(\n                Coq_value_string((function () {\n                    if (b0) {\n                      return ("true");\n                    } else {\n                      return ("false");\n                    }}())))));\n        case "Coq_value_number":\n          var n = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_string":\n          var s0 = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_undef":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_null":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_bool":\n                                var b0 = v.value;\n                                return (\n                                  res_ter(s,\n                                    res_val(\n                                      Coq_value_string((function () {\n                                          if (b0) {\n                                            return ("true");\n                                          } else {\n                                            return ("false");\n                                          }}())))));\n                              case "Coq_value_number":\n                                var n = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_string":\n                                var s1 = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_bool_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_undef":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_null":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_bool":\n          var b0 = vthis.value;\n          return (res_ter(s, res_val(Coq_value_bool(b0))));\n        case "Coq_value_number":\n          var n = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_string":\n          var s0 = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_undef":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_null":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_bool":\n                                var b0 = v.value;\n                                return (\n                                  res_ter(s, res_val(Coq_value_bool(b0))));\n                              case "Coq_value_number":\n                                var n = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_string":\n                                var s1 = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_number":\n      if (list_eq_nil_decidable(args)) {\n        return (res_out(s, res_val(Coq_value_number(JsNumber.zero))));\n      } else {\n        var v = get_arg(0, args);return (to_number(s, v));\n      }\n    case "Coq_prealloc_number_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_undef":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_null":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_bool":\n          var b0 = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_number":\n          var n = vthis.value;\n          return (res_ter(s, res_val(Coq_value_number(n))));\n        case "Coq_value_string":\n          var s0 = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Number")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_undef":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_null":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_bool":\n                                var b0 = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_number":\n                                var n = v.value;\n                                return (\n                                  res_ter(s, res_val(Coq_value_number(n))));\n                              case "Coq_value_string":\n                                var s1 = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_array":\n      return (run_construct_prealloc(s, c, Coq_prealloc_array(), args));\n    case "Coq_prealloc_array_is_array":\n      var arg = get_arg(0, args);\n      switch (arg.tag) {\n        case "Coq_value_object":\n          var arg0 = arg.value;\n          return (\n            if_some(run_object_method(object_class_, s, arg0),\n              function(class0) {\n                \n                if (string_eq(class0, "Array")) {\n                  return (res_ter(s, res_val(Coq_value_bool(true))));\n                } else {\n                  return (res_ter(s, res_val(Coq_value_bool(false))));\n                }}));\n        default:\n          return (res_ter(s, res_val(Coq_value_bool(false))));\n      }\n      \n    case "Coq_prealloc_array_proto_to_string":\n      return (\n        if_object(to_object(s, vthis), function(s0, array) {\n            \n            return (\n              if_value(run_object_get(s0, c, array, "join"), function(s1,\n                vfunc) {\n                  \n                  if (is_callable_dec(s1, vfunc)) {\n                    switch (vfunc.tag) {\n                      case "Coq_value_object":\n                        var func = vfunc.value;\n                        return (\n                          run_call(s1, c, func, Coq_value_object(array),\n                            mk_nil()));\n                      default:\n                        return (\n                          function (s, m) {\n                              Debug.impossible_with_heap_because(__LOC__, s,\n                                m);\n                              return (Coq_result_impossible());}(s1,\n                            "Value is callable, but isn\'t an object."));\n                    }\n                    \n                  } else {\n                    return (\n                      run_call_prealloc(s1, c,\n                        Coq_prealloc_object_proto_to_string(),\n                        Coq_value_object(array), mk_nil()));\n                  }}));}));\n    case "Coq_prealloc_array_proto_join":\n      var vsep = get_arg(0, args);\n      return (\n        if_object(to_object(s, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        if (!(value_compare(vsep, Coq_value_undef()))) {\n                          var rsep = vsep;\n                        } else {\n                          var rsep = Coq_value_string(",");\n                        }\n                        return (\n                          if_string(to_string(s2, rsep), function(s3, sep) {\n                              \n                              if ((ilen == 0.0)) {\n                                return (\n                                  res_ter(s3, res_val(Coq_value_string(""))));\n                              } else {\n                                var sR = valueToStringForJoin(s3, c, l, 0.);\n                                return (\n                                  if_spec(sR, function(s4, sR0) {\n                                      \n                                      return (\n                                        run_array_join_elements(s4, c, l, 1.,\n                                          ilen, sep, sR0));}));\n                              }}));}));}));}));\n    case "Coq_prealloc_array_proto_pop":\n      return (\n        if_object(to_object(s, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        if ((ilen == 0.0)) {\n                          return (\n                            if_not_throw(\n                              object_put(s2, c, l, "length",\n                                Coq_value_number(JsNumber.zero), throw_true),\n                              function(s3, x) {\n                                \n                                return (\n                                  res_out(s3, res_val(Coq_value_undef())));}));\n                        } else {\n                          return (\n                            if_string(\n                              to_string(s2, Coq_value_number((ilen - 1.))),\n                              function(s3, sindx) {\n                                \n                                return (\n                                  if_value(run_object_get(s3, c, l, sindx),\n                                    function(s4, velem) {\n                                      \n                                      return (\n                                        if_not_throw(\n                                          object_delete(s4, c, l, sindx,\n                                            throw_true), function(s5, x) {\n                                            \n                                            return (\n                                              if_not_throw(\n                                                object_put(s5, c, l,\n                                                  "length",\n                                                  Coq_value_string(sindx),\n                                                  throw_true), function(s6,\n                                                x0) {\n                                                  \n                                                  return (\n                                                    res_out(s6,\n                                                      res_val(velem)));}));}));\n                                    }));}));\n                        }}));}));}));\n    case "Coq_prealloc_array_proto_push":\n      return (\n        if_object(to_object(s, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        return (push(s2, c, l, args, ilen));}));}));}));\n    case "Coq_prealloc_string":\n      if (list_eq_nil_decidable(args)) {\n        return (res_ter(s, res_val(Coq_value_string(""))));\n      } else {\n        var value0 = get_arg(0, args);\n        return (\n          if_string(to_string(s, value0), function(s0, s1) {\n              \n              return (res_ter(s0, res_val(Coq_value_string(s1))));}));\n      }\n    case "Coq_prealloc_string_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            if_some(run_object_method(object_class_, s, l), function(s0) {\n                \n                if (string_eq(s0, "String")) {\n                  return (run_object_prim_value(s, l));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n        default:\n          if (type_compare(type_of(vthis), Coq_type_string())) {\n            return (res_ter(s, res_val(vthis)));\n          } else {\n            return (run_error(s, c, Coq_native_error_type()));\n          }\n      }\n      \n    case "Coq_prealloc_string_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            if_some(run_object_method(object_class_, s, l), function(s0) {\n                \n                if (string_eq(s0, "String")) {\n                  return (run_object_prim_value(s, l));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n        default:\n          if (type_compare(type_of(vthis), Coq_type_string())) {\n            return (res_ter(s, res_val(vthis)));\n          } else {\n            return (run_error(s, c, Coq_native_error_type()));\n          }\n      }\n      \n    case "Coq_prealloc_error":\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_error_proto())), v));\n    case "Coq_prealloc_native_error":\n      var ne = b.error;\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))), v));\n    case "Coq_prealloc_throw_type_error":\n      return (builtin_throw_type_error(s, c, {}, {}, {}));\n    case "Coq_prealloc_proxy":\n      return (\n        builtin_proxy_constructor(s, c, {}, {}, Coq_value_undef(),\n          get_arg(0, args), get_arg(1, args)));\n    case "Coq_prealloc_proxy_revocable":\n      return (\n        builtin_proxy_revocable(s, c, {}, {}, {}, get_arg(0, args),\n          get_arg(1, args)));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}(\n          strappend("Call prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented"))));\n  }\n  \n};\n\nvar run_call = function (s, c, l, vthis, args) {\n  return (\n    if_some(run_object_method(object_call_, s, l), function(co) {\n        \n        return (\n          if_some(co, function(c0) {\n              \n              switch (c0.tag) {\n                case "Coq_call_default":\n                  return (entering_func_code(s, c, l, vthis, args));\n                case "Coq_call_after_bind":\n                  return (\n                    if_some(run_object_method(object_bound_args_, s, l),\n                      function(oarg) {\n                        \n                        return (\n                          if_some(oarg, function(boundArgs) {\n                              \n                              return (\n                                if_some(\n                                  run_object_method(object_bound_this_, s, l),\n                                  function(obnd) {\n                                    \n                                    return (\n                                      if_some(obnd, function(boundThis) {\n                                          \n                                          return (\n                                            if_some(\n                                              run_object_method(\n                                                object_target_function_, s,\n                                                l), function(otrg) {\n                                                \n                                                return (\n                                                  if_some(otrg,\n                                                    function(target) {\n                                                      \n                                                      var arguments_ = \n                                                      LibList.append(\n                                                        boundArgs, args);\n                                                      return (\n                                                        run_call(s, c,\n                                                          target, boundThis,\n                                                          arguments_));}));}));\n                                        }));}));}));}));\n                case "Coq_call_prealloc":\n                  var b = c0.prealloc;\n                  return (run_call_prealloc(s, c, b, vthis, args));\n                case "Coq_call_proxy":\n                  return (Coq_result_not_yet_implemented());\n              }\n              }));}));\n};\n\nvar run_javascript_from_state = function (s, p) {\n  var c = execution_ctx_initial(prog_intro_strictness(p));\n  return (\n    if_void(\n      execution_ctx_binding_inst(s, c, Coq_codetype_global(), None(), p,\n        mk_nil()), function(s_2) { \n                                   return (run_prog(s_2, c, p));}));\n};\n\nvar run_javascript_from_result = function (w, p) {\n  return (\n    if_success(w, function(s, _pat_any_121) {\n        \n        return (run_javascript_from_state(s, p));}));\n};\n\nvar run_javascript = function (p) {\n  return (run_javascript_from_state(state_initial, p));\n};\n}// end of with Datatypes\n}// end of with JsCommon\n}// end of with JsCommonAux\n}// end of with JsInit\n}// end of with JsInterpreterMonads\n}// end of with JsSyntax\n}// end of with JsSyntaxAux\n}// end of with LibList\n}// end of with LibOption\n}// end of with LibProd\n}// end of with Shared\n\nreturn {\n  equality_test_for_same_type: equality_test_for_same_type, \n  strict_equality_test: strict_equality_test, \n  inequality_test_number: inequality_test_number, \n  inequality_test_string: inequality_test_string, \n  typeof_prim: typeof_prim, \n  string_of_propname: string_of_propname, \n  run_object_method: run_object_method, \n  run_object_set_internal: run_object_set_internal, \n  run_object_heap_set_extensible: run_object_heap_set_extensible, \n  build_error: build_error, \n  run_error: run_error, \n  run_error_no_c: run_error_no_c, \n  some_context: some_context, \n  object_has_internal_slot: object_has_internal_slot, \n  object_has_internal_method: object_has_internal_method, \n  object_internal_get_prototype_of: object_internal_get_prototype_of, \n  object_internal_set_prototype_of: object_internal_set_prototype_of, \n  object_internal_is_extensible: object_internal_is_extensible, \n  object_internal_prevent_extensions: object_internal_prevent_extensions, \n  object_internal_get_own_property: object_internal_get_own_property, \n  object_internal_define_own_property: object_internal_define_own_property, \n  object_internal_has_property: object_internal_has_property, \n  object_internal_get: object_internal_get, \n  object_internal_set: object_internal_set, \n  object_put: object_put, \n  object_internal_delete: object_internal_delete, \n  object_delete_default: object_delete_default, \n  object_internal_own_property_keys: object_internal_own_property_keys, \n  object_internal_call: object_internal_call, \n  object_internal_construct: object_internal_construct, \n  get_base: get_base, \n  get_referenced_name: get_referenced_name, \n  is_strict_reference: is_strict_reference, \n  has_primitive_base: has_primitive_base, \n  is_property_reference: is_property_reference, \n  is_unresolvable_reference: is_unresolvable_reference, \n  is_super_reference: is_super_reference, \n  get_value: get_value, \n  put_value: put_value, \n  get_this_value: get_this_value, \n  is_accessor_descriptor: is_accessor_descriptor, \n  is_data_descriptor: is_data_descriptor, \n  is_generic_descriptor: is_generic_descriptor, \n  from_property_descriptor: from_property_descriptor, \n  to_property_descriptor: to_property_descriptor, \n  complete_property_descriptor: complete_property_descriptor, \n  to_primitive: to_primitive, \n  to_boolean: to_boolean, \n  to_number: to_number, \n  to_number_string: to_number_string, \n  to_integer: to_integer, \n  to_string: to_string, \n  to_string_number: to_string_number, \n  to_length: to_length, \n  require_object_coercible: require_object_coercible, \n  is_callable: is_callable, \n  is_constructor: is_constructor, \n  is_extensible: is_extensible, \n  is_property_key: is_property_key, \n  same_value: same_value, \n  same_value_non_number: same_value_non_number, \n  get: get, \n  get_v: get_v, \n  set: set, \n  create_data_property: create_data_property, \n  define_property_or_throw: define_property_or_throw, \n  get_method: get_method, \n  has_property: has_property, \n  call: call, \n  construct: construct, \n  set_integrity_level: set_integrity_level, \n  test_integrity_level: test_integrity_level, \n  create_array_from_list: create_array_from_list, \n  create_list_from_array_like: create_list_from_array_like, \n  set_mutable_binding: set_mutable_binding, \n  get_binding_value: get_binding_value, \n  binding_is_uninitialized: binding_is_uninitialized, \n  binding_is_mutable: binding_is_mutable, \n  decl_env_record_create_mutable_binding: decl_env_record_create_mutable_binding, \n  decl_env_record_initialize_binding: decl_env_record_initialize_binding, \n  decl_env_record_set_mutable_binding: decl_env_record_set_mutable_binding, \n  decl_env_record_get_binding_value: decl_env_record_get_binding_value, \n  object_env_record_set_mutable_binding: object_env_record_set_mutable_binding, \n  object_env_record_get_binding_value: object_env_record_get_binding_value, \n  get_global_object: get_global_object, \n  ordinary_object_internal_get_prototype_of: ordinary_object_internal_get_prototype_of, \n  ordinary_get_prototype_of: ordinary_get_prototype_of, \n  ordinary_object_internal_set_prototype_of: ordinary_object_internal_set_prototype_of, \n  ordinary_set_prototype_of: ordinary_set_prototype_of, \n  ordinary_object_internal_is_extensible: ordinary_object_internal_is_extensible, \n  ordinary_is_extensible: ordinary_is_extensible, \n  ordinary_object_internal_prevent_extensions: ordinary_object_internal_prevent_extensions, \n  ordinary_prevent_extensions: ordinary_prevent_extensions, \n  ordinary_object_internal_get_own_property: ordinary_object_internal_get_own_property, \n  ordinary_get_own_property: ordinary_get_own_property, \n  ordinary_object_internal_define_own_property: ordinary_object_internal_define_own_property, \n  ordinary_define_own_property: ordinary_define_own_property, \n  is_compatible_property_descriptor: is_compatible_property_descriptor, \n  validate_and_apply_property_descriptor: validate_and_apply_property_descriptor, \n  ordinary_object_internal_has_property: ordinary_object_internal_has_property, \n  ordinary_has_property: ordinary_has_property, \n  ordinary_object_internal_get: ordinary_object_internal_get, \n  ordinary_get: ordinary_get, \n  ordinary_object_internal_set: ordinary_object_internal_set, \n  ordinary_set: ordinary_set, \n  ordinary_object_internal_delete: ordinary_object_internal_delete, \n  ordinary_delete: ordinary_delete, \n  ordinary_object_internal_own_property_keys: ordinary_object_internal_own_property_keys, \n  ordinary_own_property_keys: ordinary_own_property_keys, \n  object_create: object_create, \n  add_restricted_function_properties: add_restricted_function_properties, \n  builtin_throw_type_error: builtin_throw_type_error, \n  array_create: array_create, \n  is_proxy_exotic_object: is_proxy_exotic_object, \n  proxy_object_internal_get_prototype_of: proxy_object_internal_get_prototype_of, \n  proxy_object_internal_set_prototype_of: proxy_object_internal_set_prototype_of, \n  proxy_object_internal_is_extensible: proxy_object_internal_is_extensible, \n  proxy_object_internal_prevent_extensions: proxy_object_internal_prevent_extensions, \n  proxy_object_internal_get_own_property: proxy_object_internal_get_own_property, \n  proxy_object_internal_define_own_property: proxy_object_internal_define_own_property, \n  proxy_object_internal_has_property: proxy_object_internal_has_property, \n  proxy_object_internal_get: proxy_object_internal_get, \n  proxy_object_internal_set: proxy_object_internal_set, \n  proxy_object_internal_delete: proxy_object_internal_delete, \n  proxy_object_internal_own_property_keys: proxy_object_internal_own_property_keys, \n  proxy_object_internal_call: proxy_object_internal_call, \n  proxy_object_internal_construct: proxy_object_internal_construct, \n  proxy_create: proxy_create, \n  builtin_object_freeze: builtin_object_freeze, \n  builtin_object_get_prototype_of: builtin_object_get_prototype_of, \n  builtin_object_is_extensible: builtin_object_is_extensible, \n  builtin_object_is_frozen: builtin_object_is_frozen, \n  builtin_object_is_sealed: builtin_object_is_sealed, \n  builtin_object_prevent_extensions: builtin_object_prevent_extensions, \n  builtin_object_seal: builtin_object_seal, \n  builtin_object_set_prototype_of: builtin_object_set_prototype_of, \n  builtin_proxy_constructor: builtin_proxy_constructor, \n  builtin_proxy_revocable: builtin_proxy_revocable, \n  proxy_revocation_function_create: proxy_revocation_function_create, \n  builtin_proxy_revocation_function: builtin_proxy_revocation_function, \n  object_has_prop: object_has_prop, \n  out_error_or_void: out_error_or_void, \n  out_error_or_cst: out_error_or_cst, \n  object_get_builtin: object_get_builtin, \n  run_object_get: run_object_get, \n  run_object_get_prop: run_object_get_prop, \n  object_proto_is_prototype_of: object_proto_is_prototype_of, \n  object_default_value: object_default_value, \n  to_int32: to_int32, \n  to_uint32: to_uint32, \n  run_object_define_own_prop_array_loop: run_object_define_own_prop_array_loop, \n  object_define_own_prop: object_define_own_prop, \n  prim_new_object: prim_new_object, \n  to_object: to_object, \n  run_object_prim_value: run_object_prim_value, \n  prim_value_get: prim_value_get, \n  env_record_has_binding: env_record_has_binding, \n  lexical_env_get_identifier_ref: lexical_env_get_identifier_ref, \n  object_delete: object_delete, \n  env_record_delete_binding: env_record_delete_binding, \n  env_record_implicit_this_value: env_record_implicit_this_value, \n  identifier_resolution: identifier_resolution, \n  env_record_get_binding_value: env_record_get_binding_value, \n  ref_get_value: ref_get_value, \n  run_expr_get_value: run_expr_get_value, \n  env_record_set_mutable_binding: env_record_set_mutable_binding, \n  ref_put_value: ref_put_value, \n  env_record_create_mutable_binding: env_record_create_mutable_binding, \n  env_record_create_set_mutable_binding: env_record_create_set_mutable_binding, \n  env_record_create_immutable_binding: env_record_create_immutable_binding, \n  env_record_initialize_immutable_binding: env_record_initialize_immutable_binding, \n  call_object_new: call_object_new, \n  array_args_map_loop: array_args_map_loop, \n  run_construct_prealloc: run_construct_prealloc, \n  run_construct_default: run_construct_default, \n  run_construct: run_construct, \n  run_call_default: run_call_default, \n  creating_function_object_proto: creating_function_object_proto, \n  creating_function_object: creating_function_object, \n  binding_inst_formal_params: binding_inst_formal_params, \n  binding_inst_function_decls: binding_inst_function_decls, \n  make_arg_getter: make_arg_getter, \n  make_arg_setter: make_arg_setter, \n  arguments_object_map_loop: arguments_object_map_loop, \n  arguments_object_map: arguments_object_map, \n  create_arguments_object: create_arguments_object, \n  binding_inst_arg_obj: binding_inst_arg_obj, \n  binding_inst_var_decls: binding_inst_var_decls, \n  execution_ctx_binding_inst: execution_ctx_binding_inst, \n  entering_func_code: entering_func_code, \n  run_object_get_own_prop: run_object_get_own_prop, \n  run_function_has_instance: run_function_has_instance, \n  run_object_has_instance: run_object_has_instance, \n  from_prop_descriptor: from_prop_descriptor, \n  run_equal: run_equal, \n  convert_twice: convert_twice, \n  convert_twice_primitive: convert_twice_primitive, \n  convert_twice_number: convert_twice_number, \n  convert_twice_string: convert_twice_string, \n  issome: issome, \n  run_binary_op_add: run_binary_op_add, \n  run_binary_op_arith: run_binary_op_arith, \n  run_binary_op_shift: run_binary_op_shift, \n  run_binary_op_bitwise: run_binary_op_bitwise, \n  run_binary_op_compare: run_binary_op_compare, \n  run_binary_op_instanceof: run_binary_op_instanceof, \n  run_binary_op_in: run_binary_op_in, \n  run_binary_op: run_binary_op, \n  run_prepost_op: run_prepost_op, \n  run_typeof_value: run_typeof_value, \n  run_unary_op: run_unary_op, \n  create_new_function_in: create_new_function_in, \n  init_object: init_object, \n  run_array_element_list: run_array_element_list, \n  init_array: init_array, \n  run_var_decl_item: run_var_decl_item, \n  run_var_decl: run_var_decl, \n  run_list_expr: run_list_expr, \n  run_block: run_block, \n  run_binary_op_and: run_binary_op_and, \n  run_binary_op_or: run_binary_op_or, \n  run_expr_binary_op: run_expr_binary_op, \n  run_expr_access: run_expr_access, \n  run_expr_assign: run_expr_assign, \n  run_expr_function: run_expr_function, \n  entering_eval_code: entering_eval_code, \n  run_eval: run_eval, \n  run_expr_call: run_expr_call, \n  run_expr_conditionnal: run_expr_conditionnal, \n  run_expr_new: run_expr_new, \n  run_stat_label: run_stat_label, \n  run_stat_with: run_stat_with, \n  run_stat_if: run_stat_if, \n  run_stat_while: run_stat_while, \n  run_stat_switch_end: run_stat_switch_end, \n  run_stat_switch_no_default: run_stat_switch_no_default, \n  run_stat_switch_with_default_default: run_stat_switch_with_default_default, \n  run_stat_switch_with_default_B: run_stat_switch_with_default_B, \n  run_stat_switch_with_default_A: run_stat_switch_with_default_A, \n  run_stat_switch: run_stat_switch, \n  run_stat_do_while: run_stat_do_while, \n  run_stat_try: run_stat_try, \n  run_stat_throw: run_stat_throw, \n  run_stat_return: run_stat_return, \n  run_stat_for_loop: run_stat_for_loop, \n  run_stat_for: run_stat_for, \n  run_stat_for_var: run_stat_for_var, \n  run_expr: run_expr, \n  run_stat: run_stat, \n  run_elements: run_elements, \n  run_prog: run_prog, \n  push: push, \n  run_object_is_sealed: run_object_is_sealed, \n  run_object_seal: run_object_seal, \n  run_object_freeze: run_object_freeze, \n  run_object_is_frozen: run_object_is_frozen, \n  run_get_args_for_apply: run_get_args_for_apply, \n  valueToStringForJoin: valueToStringForJoin, \n  run_array_join_elements: run_array_join_elements, \n  run_call_prealloc: run_call_prealloc, \n  run_call: run_call, \n  run_javascript_from_state: run_javascript_from_state, \n  run_javascript_from_result: run_javascript_from_result, \n  run_javascript: run_javascript};\n})();\n'},

/* --------------------- JsInterpreter.pseudo --------------------- */
  { file: 'JsInterpreter.pseudo', contents: 'var JsInterpreter = (function() {\nwith (Datatypes) {\nwith (JsCommon) {\nwith (JsCommonAux) {\nwith (JsInit) {\nwith (JsInterpreterMonads) {\nwith (JsSyntax) {\nwith (JsSyntaxAux) {\nwith (LibList) {\nwith (LibOption) {\nwith (LibProd) {\nwith (Shared) {\n\nvar equality_test_for_same_type = function (ty, v1, v2) {\n  switch (ty) {\n    case Coq_type_undef:\n      return (true);\n    case Coq_type_null:\n      return (true);\n    case Coq_type_bool:\n      return (value_compare(v1, v2));\n    case Coq_type_number:\n      switch (v1) {\n        case Coq_value_undef:\n          return (false);\n        case Coq_value_null:\n          return (false);\n        case Coq_value_bool(b):\n          return (false);\n        case Coq_value_string(s):\n          return (false);\n        case Coq_value_number(n1):\n          switch (v2) {\n            case Coq_value_undef:\n              return (false);\n            case Coq_value_null:\n              return (false);\n            case Coq_value_bool(b):\n              return (false);\n            case Coq_value_string(s):\n              return (false);\n            case Coq_value_number(n2):\n              if (JsNumber.isnan(n1)) {\n                return (false);\n              } else {\n                if (JsNumber.isnan(n2)) {\n                  return (false);\n                } else {\n                  if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n                    return (true);\n                  } else {\n                    if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n                      return (true);\n                    } else {\n                      return ((n1 === n2));\n                    }\n                  }\n                }\n              }\n            case Coq_value_object(o):\n              return (false);\n          }\n          \n        case Coq_value_object(o):\n          return (false);\n      }\n      \n    case Coq_type_string:\n      return (value_compare(v1, v2));\n    case Coq_type_object:\n      return (value_compare(v1, v2));\n  }\n  \n};\n\n\n\nvar strict_equality_test = function (v1, v2) {\n  var ty1 = type_of(v1);\n  var ty2 = type_of(v2);\n  if (type_compare(ty1, ty2)) {\n    return (equality_test_for_same_type(ty1, v1, v2));\n  } else {\n    return (false);\n  }\n};\n\n\n\nvar inequality_test_number = function (n1, n2) {\n  if ((JsNumber.isnan(n1) || JsNumber.isnan(n2))) {\n    return (Value_undef);\n  } else {\n    if ((n1 === n2)) {\n      return (Value_bool(false));\n    } else {\n      if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n        return (Value_bool(false));\n      } else {\n        if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n          return (Value_bool(false));\n        } else {\n          if ((n1 === JsNumber.infinity)) {\n            return (Value_bool(false));\n          } else {\n            if ((n2 === JsNumber.infinity)) {\n              return (Value_bool(true));\n            } else {\n              if ((n2 === JsNumber.neg_infinity)) {\n                return (Value_bool(false));\n              } else {\n                if ((n1 === JsNumber.neg_infinity)) {\n                  return (Value_bool(true));\n                } else {\n                  return (Value_bool((n1 < n2)));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n\n\nvar inequality_test_string = function (s1, s2) {\n  return (string_lt(s1, s2));\n};\n\n\n\nvar typeof_prim = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_undef:\n      return ("undefined");\n    case Coq_value_null:\n      return ("object");\n    case Coq_value_bool(b):\n      return ("boolean");\n    case Coq_value_number(n):\n      return ("number");\n    case Coq_value_string(s):\n      return ("string");\n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar string_of_propname = function (_foo_) {\n  switch (_foo_) {\n    case Coq_propname_identifier(s):\n      return (s);\n    case Coq_propname_string(s):\n      return (s);\n    case Coq_propname_number(n):\n      return (JsNumber.to_string(n));\n  }\n  \n};\n\nvar run_object_method = function (proj, l) {\n  return (LibOption.map(proj, object_binds_option(l)));\n};\n\n\n\n\n\nvar run_object_set_internal = function (prj, l, v) {\n  return (\n    LibOption.map(function (o) { return (object_write(l, prj(o, v)));},\n      object_binds_option(l)));\n};\n\n\n\nvar run_object_heap_set_extensible = function (b, l) {\n  return (run_object_set_internal(object_set_extensible, l, b));\n};\n\nvar build_error = function (vproto, vmsg) {\n  var o = object_new(vproto, "Error");\n  var (l, s_2) = object_alloc(o);\n  if (value_compare(vmsg, Value_undef)) {\n    return (l);\n  } else {\n    var%value vstr = to_string(vmsg);\n    var a = {\n      attributes_data_value: vstr,\n      attributes_data_writable: true,\n      attributes_data_enumerable: false,\n      attributes_data_configurable: true\n    };\n    var%success rv = object_define_own_prop(l, "message",\n                       descriptor_of_attributes(a), throw_true);\n    return (l);\n  }\n};\n\nvar run_error = function (ne) {\n  var%object l = build_error(Prealloc_native_error_proto(ne), Value_undef);\n  return (res_throw(l));\n};\n\nvar run_error_no_c = function (ne) {\n  var vproto = Prealloc_native_error_proto(ne);\n  var o = object_new(vproto, "error");\n  var (l, s_2) = object_alloc(o);\n  return (res_throw(l));\n};\n\nvar some_context = execution_ctx_initial(true);\n\nvar object_has_internal_slot = function (l, prj) {\n  switch (run_object_method(prj, l)) {\n    case None:\n      throw false;\n    case Some(a):\n      return (is_some(a));\n  }\n  \n};\n\nvar object_has_internal_method = function (l, prj) {\n  return (object_has_internal_slot(l, prj));\n};\n\nvar object_internal_get_prototype_of = function (o) {\n  var%some internal_method = run_object_method(object_get_prototype_of_, o);\n  switch (internal_method) {\n    case Coq_builtin_get_prototype_of_default:\n      return (ordinary_object_internal_get_prototype_of(o));\n    case Coq_builtin_get_prototype_of_proxy:\n      return (proxy_object_internal_get_prototype_of(o));\n  }\n  \n};\n\nvar object_internal_set_prototype_of = function (o, v) {\n  var%some internal_method = run_object_method(object_set_prototype_of_, o);\n  switch (internal_method) {\n    case Coq_builtin_set_prototype_of_default:\n      return (ordinary_object_internal_set_prototype_of(o, v));\n    case Coq_builtin_set_prototype_of_proxy:\n      return (proxy_object_internal_set_prototype_of(o, v));\n  }\n  \n};\n\nvar object_internal_is_extensible = function (o) {\n  var%some internal_method = run_object_method(object_is_extensible_, o);\n  switch (internal_method) {\n    case Coq_builtin_is_extensible_default:\n      return (ordinary_object_internal_is_extensible(o));\n    case Coq_builtin_is_extensible_proxy:\n      return (proxy_object_internal_is_extensible(o));\n  }\n  \n};\n\nvar object_internal_prevent_extensions = function (o) {\n  var%some internal_method = run_object_method(object_prevent_extensions_, o);\n  switch (internal_method) {\n    case Coq_builtin_prevent_extensions_default:\n      return (ordinary_object_internal_prevent_extensions(o));\n    case Coq_builtin_prevent_extensions_proxy:\n      return (proxy_object_internal_prevent_extensions(o));\n  }\n  \n};\n\nvar object_internal_get_own_property = function (o, p) {\n  var%some internal_method = run_object_method(object_get_own_prop_, o);\n  switch (internal_method) {\n    case Coq_builtin_get_own_prop_default:\n      return (ordinary_object_internal_get_own_property(o, p));\n    case Coq_builtin_get_own_prop_args_obj:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_get_own_prop_string:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_get_own_prop_proxy:\n      return (proxy_object_internal_get_own_property(o, p));\n  }\n  \n};\n\nvar object_internal_define_own_property = function (o, p, desc) {\n  var%some internal_method = run_object_method(object_define_own_prop_, o);\n  switch (internal_method) {\n    case Coq_builtin_define_own_prop_default:\n      return (ordinary_object_internal_define_own_property(o, p, desc));\n    case Coq_builtin_define_own_prop_array:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_define_own_prop_args_obj:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_define_own_prop_proxy:\n      return (ordinary_object_internal_define_own_property(o, p, desc));\n  }\n  \n};\n\nvar object_internal_has_property = function (o, p) {\n  var%some b = run_object_method(object_has_prop_, o);\n  switch (b) {\n    case Coq_builtin_has_prop_default:\n      return (ordinary_object_internal_has_property(o, p));\n    case Coq_builtin_has_prop_proxy:\n      return (proxy_object_internal_has_property(o, p));\n  }\n  \n};\n\nvar object_internal_get = function (o, p, receiver) {\n  var%some internal_method = run_object_method(object_get_, o);\n  switch (internal_method) {\n    case Coq_builtin_get_default:\n      return (ordinary_object_internal_get(o, p, receiver));\n    case Coq_builtin_get_args_obj:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_get_proxy:\n      return (proxy_object_internal_get(o, p, receiver));\n  }\n  \n};\n\nvar object_internal_set = function (o, p, v, receiver) {\n  var%some internal_method = run_object_method(object_set_, o);\n  switch (internal_method) {\n    case Coq_builtin_set_default:\n      return (ordinary_object_internal_set(o, p, v, receiver));\n    case Coq_builtin_set_proxy:\n      return (proxy_object_internal_set(o, p, v, receiver));\n  }\n  \n};\n\nvar object_put = function (l, p, v, str) {\n  return (object_internal_set(l, Value_string(p), v, l));\n};\n\nvar object_internal_delete = function (o, p) {\n  var%some internal_method = run_object_method(object_delete_, o);\n  switch (internal_method) {\n    case Coq_builtin_delete_default:\n      return (ordinary_object_internal_delete(o, p));\n    case Coq_builtin_delete_args_obj:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_delete_proxy:\n      return (proxy_object_internal_delete(o, p));\n  }\n  \n};\n\nvar object_delete_default = function (l, x, str) {\n  var%bool b = ordinary_object_internal_delete(l, Value_string(x));\n  if ((str && !(b))) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    return (Value_bool(b));\n  }\n};\n\nvar object_internal_own_property_keys = function (o) {\n  var%some internal_method = run_object_method(object_own_property_keys_, o);\n  switch (internal_method) {\n    case Coq_builtin_own_property_keys_default:\n      return (ordinary_object_internal_own_property_keys(o));\n    case Coq_builtin_own_property_keys_proxy:\n      return (proxy_object_internal_own_property_keys(o));\n  }\n  \n};\n\nvar object_internal_call = function (o, thisArgument, argumentsList) {\n  var%some internal_method = run_object_method(object_call_, o);\n  var%some internal_method = internal_method;\n  switch (internal_method) {\n    case Coq_call_default:\n      return (run_call(o, thisArgument, argumentsList));\n    case Coq_call_after_bind:\n      return (run_call(o, thisArgument, argumentsList));\n    case Coq_call_prealloc:\n      return (run_call(o, thisArgument, argumentsList));\n    case Coq_call_proxy:\n      return (proxy_object_internal_call(o, thisArgument, argumentsList));\n  }\n  \n};\n\nvar object_internal_construct = function (o, argumentsList, newTarget) {\n  var%some internal_method = run_object_method(object_construct_, o);\n  var%some internal_method = internal_method;\n  switch (internal_method) {\n    case Coq_construct_default:\n      return (run_construct(internal_method, o, argumentsList));\n    case Coq_construct_after_bind:\n      return (run_construct(internal_method, o, argumentsList));\n    case Coq_construct_prealloc:\n      return (run_construct(internal_method, o, argumentsList));\n    case Coq_construct_proxy:\n      return (proxy_object_internal_construct(o, argumentsList, newTarget));\n  }\n  \n};\n\nvar get_base = ref_base;\n\nvar get_referenced_name = function (r) {\n  return (Value_string(ref_name(r)));\n};\n\nvar is_strict_reference = ref_strict;\n\nvar has_primitive_base = function (r) {\n  return (ref_kind_comparable(ref_kind_of(r), Ref_kind_primitive_base));\n};\n\nvar is_property_reference = function (r) {\n  return (\n    (_compare_JsCommon_ref_kind(ref_kind_of(r), Ref_kind_object)\n    || has_primitive_base(r)));\n};\n\nvar is_unresolvable_reference = function (r) {\n  return (_compare_JsCommon_ref_kind(ref_kind_of(r), Ref_kind_undef));\n};\n\nvar is_super_reference = function (r) {\n  return (is_some(r.ref_this_value));\n};\n\nvar get_value = function (v) {\n  var%success v$ = v;\n  if (!(\n        _compare_JsSyntax_resvalue_type(type_of_resvalue(v$),\n          Type_resvalue_ref))) {\n    return (v);\n  } else {\n    var v = ref_of_resvalue(v$);\n    var base = get_base(v);\n    if (is_unresolvable_reference(v)) {\n      return (run_error_no_c(Native_error_ref));\n    } else {\n      if (is_property_reference(v)) {\n        var base = value_of_ref_base_type(base);\n        var%_ret (s, base) = (function () {\n            if (has_primitive_base(v)) {\n              var%ck_assert_ret _pat_any_1 = !(\n                                               (_compare_JsSyntax_value(base,\n                                                  Value_undef)\n                                               || _compare_JsSyntax_value(\n                                                    base, Value_null)));\n              var%ert_object_ret base = to_object(base);\n              return (Continue([s, base]));\n            } else {\n              return (Continue([s, loc_of_value(base)]));\n            }}());\n        return (\n          object_internal_get(base, get_referenced_name(v),\n            get_this_value(v)));\n      } else {\n        var base = env_loc_of_ref_base_type(base);\n        return (\n          get_binding_value(base, get_referenced_name(v),\n            is_strict_reference(v)));\n      }\n    }\n  }\n};\n\nvar put_value = function (v, w) {\n  var%success v = v;\n  var%value w = w;\n  if (!(\n        _compare_JsSyntax_resvalue_type(type_of_resvalue(v),\n          Type_resvalue_ref))) {\n    return (run_error_no_c(Native_error_ref));\n  } else {\n    var v = ref_of_resvalue(v);\n    var base = get_base(v);\n    if (is_unresolvable_reference(v)) {\n      if (is_strict_reference(v)) {\n        return (run_error_no_c(Native_error_ref));\n      } else {\n        var globalObj = get_global_object();\n        return (\n          set(globalObj, get_referenced_name(v), w, Value_bool(false)));\n      }\n    } else {\n      if (is_property_reference(v)) {\n        var base = value_of_ref_base_type(base);\n        var%_ret (s, base) = (function () {\n            if (has_primitive_base(v)) {\n              var%ck_assert_ret _pat_any_3 = !(\n                                               (_compare_JsSyntax_value(base,\n                                                  Value_null)\n                                               || _compare_JsSyntax_value(\n                                                    base, Value_undef)));\n              var%ert_object_ret base = to_object(base);\n              return (Continue([s, base]));\n            } else {\n              return (Continue([s, loc_of_value(base)]));\n            }}());\n        var%bool succeeded = object_internal_set(base,\n                               get_referenced_name(v), w, get_this_value(v));\n        if ((!(succeeded) && is_strict_reference(v))) {\n          return (run_error_no_c(Native_error_type));\n        } else {\n          return (res_void());\n        }\n      } else {\n        var base = env_loc_of_ref_base_type(base);\n        return (\n          set_mutable_binding(base, get_referenced_name(v), w,\n            Value_bool(is_strict_reference(v))));\n      }\n    }\n  }\n};\n\nvar get_this_value = function (v) {\n  throw is_property_reference(v);\n  if (is_super_reference(v)) {\n    return (ref_this_value(v));\n  } else {\n    return (value_of_ref_base_type(get_base(v)));\n  }\n};\n\nvar is_accessor_descriptor = function (desc) {\n  switch (desc) {\n    case Descriptor_undef:\n      return (false);\n    case Descriptor(desc):\n      return (\n        !(\n          (option_compare(value_compare, desc.descriptor_get, None)\n          && option_compare(value_compare, desc.descriptor_set, None))));\n  }\n  \n};\n\nvar is_data_descriptor = function (desc) {\n  switch (desc) {\n    case Descriptor_undef:\n      return (false);\n    case Descriptor(desc):\n      return (\n        !(\n          (option_compare(value_compare, desc.descriptor_value, None)\n          && option_compare(bool_eq, desc.descriptor_writable, None))));\n  }\n  \n};\n\nvar is_generic_descriptor = function (desc) {\n  switch (desc) {\n    case Descriptor_undef:\n      return (false);\n    case Descriptor:\n      return (\n        (!(is_accessor_descriptor(desc)) && !(is_data_descriptor(desc))));\n  }\n  \n};\n\nvar from_property_descriptor = function (desc) {\n  if (_compare_JsSyntax_undef_descriptor(desc, Descriptor_undef)) {\n    return (Value_undef);\n  } else {\n    var desc = descriptor_get_defined(desc);\n    var%value obj = object_create(Prealloc_object_proto, None);\n    var%ck_assert _pat_any_11 = _compare_JsSyntax_coq_type(type_of(obj),\n                                  Type_object);\n    var%_ret _ = (function () {\n        if (is_some(desc.descriptor_value)) {\n          var%bool_ret result = create_data_property(obj,\n                                  Value_string("value"),\n                                  unsome_error(desc.descriptor_value));\n          var%ck_assert_ret _pat_any_5 = result;\n          return (Continue);\n        } else {\n          return (Continue);\n        }}());\n    var%_ret _ = (function () {\n        if (is_some(desc.descriptor_writable)) {\n          var%bool_ret result = create_data_property(obj,\n                                  Value_string("writable"),\n                                  Value_bool(\n                                    unsome_error(desc.descriptor_writable)));\n          var%ck_assert_ret _pat_any_6 = result;\n          return (Continue);\n        } else {\n          return (Continue);\n        }}());\n    var%_ret _ = (function () {\n        if (is_some(desc.descriptor_get)) {\n          var%bool_ret result = create_data_property(obj,\n                                  Value_string("get"),\n                                  unsome_error(desc.descriptor_get));\n          var%ck_assert_ret _pat_any_7 = result;\n          return (Continue);\n        } else {\n          return (Continue);\n        }}());\n    var%_ret _ = (function () {\n        if (is_some(desc.descriptor_set)) {\n          var%bool_ret result = create_data_property(obj,\n                                  Value_string("set"),\n                                  unsome_error(desc.descriptor_set));\n          var%ck_assert_ret _pat_any_8 = result;\n          return (Continue);\n        } else {\n          return (Continue);\n        }}());\n    var%_ret _ = (function () {\n        if (is_some(desc.descriptor_enumerable)) {\n          var%bool_ret result = create_data_property(obj,\n                                  Value_string("enumerable"),\n                                  Value_bool(\n                                    unsome_error(desc.descriptor_enumerable)));\n          var%ck_assert_ret _pat_any_9 = result;\n          return (Continue);\n        } else {\n          return (Continue);\n        }}());\n    var%_ret _ = (function () {\n        if (is_some(desc.descriptor_configurable)) {\n          var%bool_ret result = create_data_property(obj,\n                                  Value_string("configurable"),\n                                  Value_bool(\n                                    unsome_error(\n                                      desc.descriptor_configurable)));\n          var%ck_assert_ret _pat_any_10 = result;\n          return (Continue);\n        } else {\n          return (Continue);\n        }}());\n    return (obj);\n  }\n};\n\nvar to_property_descriptor = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_object(l):\n      var desc = descriptor_intro_empty;\n      var%bool hasEnumerable = has_property(_foo_,\n                                 Value_string("enumerable"));\n      var%spec desc = (function () {\n          if (hasEnumerable) {\n            var%value v = get(_foo_, Value_string("enumerable"));\n            var enum = to_boolean(v);\n            return (descriptor_with_enumerable(desc, Some(enum)));\n          } else {\n            return (desc);\n          }}());\n      var%bool hasConfigurable = has_property(_foo_,\n                                   Value_string("configurable"));\n      var%spec desc = (function () {\n          if (hasConfigurable) {\n            var%value v = get(_foo_, Value_string("configurable"));\n            var conf = to_boolean(v);\n            return (descriptor_with_configurable(desc, Some(conf)));\n          } else {\n            return (desc);\n          }}());\n      var%bool hasValue = has_property(_foo_, Value_string("value"));\n      var%spec desc = (function () {\n          if (hasValue) {\n            var%value value = get(_foo_, Value_string("value"));\n            return (descriptor_with_value(desc, Some(value)));\n          } else {\n            return (desc);\n          }}());\n      var%bool hasWritable = has_property(_foo_, Value_string("writable"));\n      var%spec desc = (function () {\n          if (hasValue) {\n            var%value v = get(_foo_, Value_string("writable"));\n            var writable = to_boolean(v);\n            return (descriptor_with_writable(desc, Some(writable)));\n          } else {\n            return (desc);\n          }}());\n      var%bool hasGet = has_property(_foo_, Value_string("get"));\n      var%spec desc = (function () {\n          if (hasGet) {\n            var%value getter = get(_foo_, Value_string("get"));\n            if ((!(is_callable(getter))\n                && !(_compare_JsSyntax_coq_type(type_of(getter), Type_undef)))) {\n              return (run_error_no_c(Native_error_type));\n            } else {\n              return (descriptor_with_get(desc, Some(getter)));\n            }\n          } else {\n            return (desc);\n          }}());\n      var%bool hasSet = has_property(_foo_, Value_string("set"));\n      var%spec desc = (function () {\n          if (hasSet) {\n            var%value setter = get(_foo_, Value_string("set"));\n            if ((!(is_callable(setter))\n                && !(_compare_JsSyntax_coq_type(type_of(setter), Type_undef)))) {\n              return (run_error_no_c(Native_error_type));\n            } else {\n              return (descriptor_with_set(desc, Some(setter)));\n            }\n          } else {\n            return (desc);\n          }}());\n      if (((!(_compare_option(desc.descriptor_get, None))\n           || !(_compare_option(desc.descriptor_set, None)))\n          && (!(_compare_option(desc.descriptor_value, None))\n             || !(_compare_option(desc.descriptor_writable, None))))) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        return (desc);\n      }\n    default:\n      return (throw_result(run_error_no_c(Native_error_type)));\n  }\n  \n};\n\nvar complete_property_descriptor = function (desc) {\n  var desc = descriptor_get_defined(desc);\n  var like = {\n    descriptor_value: Some(Value_undef),\n    descriptor_writable: Some(false),\n    descriptor_get: Some(Value_undef),\n    descriptor_set: Some(Value_undef),\n    descriptor_enumerable: Some(false),\n    descriptor_configurable: Some(false)\n  };\n  if ((is_generic_descriptor(Descriptor(desc))\n      || is_data_descriptor(Descriptor(desc)))) {\n    var desc = descriptor_with_value(desc, like.descriptor_value);\n    var desc = descriptor_with_writable(desc, like.descriptor_writable);\n  } else {\n    var desc = descriptor_with_get(desc, like.descriptor_get);\n    var desc = descriptor_with_set(desc, like.descriptor_set);\n  }\n  if (option_compare(bool_eq, desc.descriptor_enumerable, None)) {\n    var desc = descriptor_with_enumerable(desc, like.descriptor_enumerable);\n  } else {\n    var desc = desc;\n  }\n  if (option_compare(bool_eq, desc.descriptor_configurable, None)) {\n    var desc = descriptor_with_configurable(desc,\n                 like.descriptor_configurable);\n  } else {\n    var desc = desc;\n  }\n  return (desc);\n};\n\nvar to_primitive = function (input, preferredType) {\n  switch (input) {\n    case Coq_value_undef:\n      return (input);\n    case Coq_value_null:\n      return (input);\n    case Coq_value_bool:\n      return (input);\n    case Coq_value_number:\n      return (input);\n    case Coq_value_string:\n      return (input);\n    case Coq_value_object(l):\n      var%prim r = object_default_value(l, preferredType);\n      return (r);\n  }\n  \n};\n\nvar to_boolean = function (argument) {\n  switch (argument) {\n    case Coq_value_undef:\n      return (false);\n    case Coq_value_null:\n      return (false);\n    case Coq_value_bool(b):\n      return (b);\n    case Coq_value_number(n):\n      if ((JsNumber.isposzero(n)\n          || (JsNumber.isnegzero(n) || JsNumber.isnan(n)))) {\n        return (false);\n      } else {\n        return (true);\n      }\n    case Coq_value_string(s):\n      if (string_eq(s, "")) {\n        return (false);\n      } else {\n        return (true);\n      }\n    case Coq_value_object(o):\n      return (true);\n  }\n  \n};\n\nvar to_number = function (argument) {\n  switch (argument) {\n    case Coq_value_undef:\n      return (Value_number(JsNumber.nan));\n    case Coq_value_null:\n      return (Value_number(JsNumber.zero));\n    case Coq_value_bool(b):\n      if (b) {\n        return (Value_number(JsNumber.one));\n      } else {\n        return (Value_number(JsNumber.zero));\n      }\n    case Coq_value_number(n):\n      return (Value_number(n));\n    case Coq_value_string(x):\n      return (Value_number(to_number_string(x)));\n    case Coq_value_object(l):\n      var%value primValue = to_primitive(argument, Some(Preftype_number));\n      return (to_number(primValue));\n  }\n  \n};\n\nvar to_number_string = function (s) {\n  return (JsNumber.from_string(s));\n};\n\nvar to_integer = function (argument) {\n  var%number number = to_number(argument);\n  if (JsNumber.isnan(number)) {\n    return (Value_number(JsNumber.zero));\n  } else {\n    if ((JsNumber.isposzero(number)\n        || (JsNumber.isnegzero(number)\n           || ((number === JsNumber.infinity)\n              || (number === JsNumber.neg_infinity))))) {\n      return (Value_number(number));\n    } else {\n      return (\n        Value_number(\n          (JsNumber.sign(number) * JsNumber.floor(JsNumber.absolute(number)))));\n    }\n  }\n};\n\nvar to_string = function (argument) {\n  switch (argument) {\n    case Coq_value_undef:\n      return (Value_string("undefined"));\n    case Coq_value_null:\n      return (Value_string("null"));\n    case Coq_value_bool(b):\n      switch (b) {\n        case true:\n          return (Value_string("true"));\n        case false:\n          return (Value_string("false"));\n      }\n      \n    case Coq_value_number(n):\n      return (Value_string(to_string_number(n)));\n    case Coq_value_string:\n      return (argument);\n    case Coq_value_object(o):\n      var%value primValue = to_primitive(argument, Some(Preftype_string));\n      return (to_string(primValue));\n  }\n  \n};\n\nvar to_string_number = JsNumber.to_string;\n\nvar to_length = function (argument) {\n  var%number len = to_integer(argument);\n  if ((len <= 0.)) {\n    return (Value_number(0.));\n  } else {\n    return (Value_number(JsNumber.min(len, (JsNumber.pow(2., 53.) - 1.))));\n  }\n};\n\nvar require_object_coercible = function (argument) {\n  switch (argument) {\n    case Coq_value_undef:\n      return (run_error_no_c(Native_error_type));\n    case Coq_value_null:\n      return (run_error_no_c(Native_error_type));\n    case Coq_value_bool:\n      return (argument);\n    case Coq_value_number:\n      return (argument);\n    case Coq_value_string:\n      return (argument);\n    case Coq_value_object:\n      return (argument);\n  }\n  \n};\n\nvar is_callable = function (argument) {\n  if (!(_compare_JsSyntax_coq_type(type_of(argument), Type_object))) {\n    return (false);\n  } else {\n    return (\n      object_has_internal_method(loc_of_value(argument), object_call_));\n  }\n};\n\nvar is_constructor = function (argument) {\n  if (!(_compare_JsSyntax_coq_type(type_of(argument), Type_object))) {\n    return (false);\n  } else {\n    return (\n      object_has_internal_method(loc_of_value(argument), object_construct_));\n  }\n};\n\nvar is_extensible = function (o) {\n  var%ck_assert _pat_any_12 = (function () {\n      switch (type_of(o)) {\n        case Coq_type_object:\n          return (true);\n        default:\n          return (false);\n      }\n      }());\n  switch (o) {\n    case Coq_value_object(l):\n      return (object_internal_is_extensible(l));\n    default:\n      throw false;\n  }\n  \n};\n\nvar is_property_key = function (argument) {\n  return (_compare_JsSyntax_coq_type(type_of(argument), Type_string));\n};\n\nvar same_value = function (x, y) {\n  if (!(type_compare(type_of(x), type_of(y)))) {\n    return (false);\n  } else {\n    switch (type_of(x)) {\n      case Coq_type_number:\n        switch (x) {\n          case Coq_value_number(n_x):\n            switch (y) {\n              case Coq_value_number(n_y):\n                if ((JsNumber.isnan(n_x) && JsNumber.isnan(n_y))) {\n                  return (true);\n                } else {\n                  if ((JsNumber.isposzero(n_x) && JsNumber.isnegzero(n_y))) {\n                    return (true);\n                  } else {\n                    if ((JsNumber.isnegzero(n_x) && JsNumber.isposzero(n_y))) {\n                      return (true);\n                    } else {\n                      return ((n_x === n_y));\n                    }\n                  }\n                }\n              default:\n                throw false;\n            }\n            \n          default:\n            throw false;\n        }\n        \n      default:\n        return (same_value_non_number(x, y));\n    }\n    \n  }\n};\n\nvar same_value_non_number = function (x, y) {\n  throw !(type_compare(type_of(x), Type_number));\n  throw type_compare(type_of(x), type_of(y));\n  switch (x) {\n    case Coq_value_undef:\n      return (true);\n    case Coq_value_null:\n      return (true);\n    case Coq_value_string(s_x):\n      switch (y) {\n        case Coq_value_string(s_y):\n          return (string_eq(s_x, s_y));\n        default:\n          throw false;\n      }\n      \n    case Coq_value_bool(b_x):\n      switch (y) {\n        case Coq_value_bool(b_y):\n          return (bool_eq(b_x, b_y));\n        default:\n          throw false;\n      }\n      \n    case Coq_value_object(l_x):\n      switch (y) {\n        case Coq_value_object(l_y):\n          return (object_loc_compare(l_x, l_y));\n        default:\n          throw false;\n      }\n      \n    default:\n      throw false;\n  }\n  \n};\n\nvar get = function (o, p) {\n  var%ck_assert _pat_any_14 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var%ck_assert _pat_any_13 = is_property_key(p);\n  switch (o) {\n    case Coq_value_object(l):\n      return (object_internal_get(l, p, o));\n    default:\n      throw false;\n  }\n  \n};\n\nvar get_v = function (v, p) {\n  var%ck_assert _pat_any_15 = is_property_key(p);\n  var%object l = to_object(v);\n  return (object_internal_get(l, p, v));\n};\n\nvar set = function (o, p, v, throw) {\n  var%ck_assert _pat_any_18 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var l = loc_of_value(o);\n  var%ck_assert _pat_any_17 = is_property_key(p);\n  var%ck_assert _pat_any_16 = _compare_JsSyntax_coq_type(type_of(throw),\n                                Type_bool);\n  var throw = bool_of_value(throw);\n  var%bool success = object_internal_set(l, p, v, o);\n  if ((!(success) && throw)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    return (Value_bool(success));\n  }\n};\n\nvar create_data_property = function (o, p, v) {\n  var%ck_assert _pat_any_20 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var o = loc_of_value(o);\n  var%ck_assert _pat_any_19 = is_property_key(p);\n  var newDesc = descriptor_intro_data(v, true, true, true);\n  return (object_internal_define_own_property(o, p, newDesc));\n};\n\nvar define_property_or_throw = function (o, p, desc) {\n  var%ck_assert _pat_any_22 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var o = loc_of_value(o);\n  var%ck_assert _pat_any_21 = is_property_key(p);\n  var%bool success = object_internal_define_own_property(o, p, desc);\n  if (!(success)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    return (Value_bool(success));\n  }\n};\n\nvar get_method = function (v, p) {\n  var%ck_assert _pat_any_23 = is_property_key(p);\n  var%value func = get_v(v, p);\n  switch (type_of(func)) {\n    case Coq_type_undef:\n      return (Value_undef);\n    case Coq_type_null:\n      return (Value_undef);\n    default:\n      var callable = is_callable(func);\n      if (!(callable)) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        return (func);\n      }\n  }\n  \n};\n\nvar has_property = function (o, p) {\n  var%ck_assert _pat_any_25 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var%ck_assert _pat_any_24 = is_property_key(p);\n  switch (o) {\n    case Coq_value_object(l):\n      return (object_internal_has_property(l, p));\n    default:\n      throw false;\n  }\n  \n};\n\nvar call = function (f, v, argumentList) {\n  return (\n    if_some_or_apply_default(argumentList, mk_nil, function (argumentList) {\n        var callable = is_callable(f);\n        if (!(callable)) {\n          return (run_error_no_c(Native_error_type));\n        } else {\n          switch (f) {\n            case Coq_value_object(l):\n              return (object_internal_call(l, v, argumentList));\n            default:\n              throw false;\n          }\n          \n        }}));\n};\n\nvar construct = function (f, argumentsList, newTarget) {\n  var newTarget = unsome_default(f, newTarget);\n  var argumentsList = unsome_default(mk_nil, argumentsList);\n  var%ck_assert _pat_any_27 = is_constructor(f);\n  var%ck_assert _pat_any_26 = is_constructor(newTarget);\n  return (\n    object_internal_construct(loc_of_value(f), argumentsList, newTarget));\n};\n\nvar set_integrity_level = function (o, level) {\n  var%ck_assert _pat_any_29 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var o = loc_of_value(o);\n  var%ck_assert _pat_any_28 = ((level === "sealed") || (level === "frozen"));\n  var%bool status = object_internal_prevent_extensions(o);\n  if (!(status)) {\n    return (Value_bool(false));\n  } else {\n    var%spec keys = object_internal_own_property_keys(o);\n    var%_ret _ = (function () {\n        if ((level === "sealed")) {\n          return (Return(Result_not_yet_implemented));\n        } else {\n          return (Return(Result_not_yet_implemented));\n        }}());\n    return (Value_bool(true));\n  }\n};\n\nvar test_integrity_level = function (o, level) {\n  var%ck_assert _pat_any_31 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var%ck_assert _pat_any_30 = ((level === "sealed") || (level === "frozen"));\n  var%bool status = is_extensible(o);\n  if (status) {\n    return (Value_bool(false));\n  } else {\n    var%spec keys = object_internal_own_property_keys(loc_of_value(o));\n    return (Result_not_yet_implemented);\n  }\n};\n\nvar create_array_from_list = function (elements) {\n  var%value array = array_create(Value_number(0.), None);\n  var n = 0.;\n  var%_ret (s,\n    n) = iterate(elements, [s, n], function (e, acc) {\n             var (s, n) = acc;\n             var%ert_value_ret tempVar = to_string(Value_number(n));\n             var%ert_bool_ret status = create_data_property(array, tempVar,\n                                         e);\n             var%ck_assert_ret _pat_any_32 = status;\n             return (Continue([s, (n + 1.)]));});\n  return (array);\n};\n\nvar create_list_from_array_like = function (obj, elementTypes) {\n  var elementTypes = unsome_default(\n                       mk_cons(Type_undef,\n                         mk_cons(Type_null,\n                           mk_cons(Type_bool,\n                             mk_cons(Type_string,\n                               mk_cons(Type_number,\n                                 mk_cons(Type_object, mk_nil)))))),\n                       elementTypes);\n  var%ck_assert _pat_any_35 = _compare_JsSyntax_coq_type(type_of(obj),\n                                Type_object);\n  var%value tempVar = get(obj, Value_string("length"));\n  var%number len = to_length(tempVar);\n  var list = mk_nil;\n  var index = 0.;\n  var%_ret (s, index,\n    list) = repeat(function (acc) { var (index) = acc;\n                                    return ((index < len));},\n              [s, index, list], function (acc) {\n                var (s, index, list) = acc;\n                var%ert_value_ret indexName = to_string(Value_number(index));\n                var%value_ret next = get(obj, indexName);\n                if (!(mem_decide(===, type_of(next), elementTypes))) {\n                  return (Return(run_error_no_c(Native_error_type)));\n                } else {\n                  var list = append(list, mk_cons(next, mk_nil));\n                  var index = (index + 1.);\n                  return (Continue([s, index, list]));\n                }});\n  return (list);\n};\n\nvar set_mutable_binding = function (l, n, v, str) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(e):\n      return (decl_env_record_set_mutable_binding(l, e, n, v, str));\n    case Coq_env_record_object(l, this):\n      return (object_env_record_set_mutable_binding(l, this, n, v, str));\n  }\n  \n};\n\nvar get_binding_value = function (l, n, str) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(e):\n      return (decl_env_record_get_binding_value(e, n, str));\n    case Coq_env_record_object(l, this):\n      return (object_env_record_get_binding_value(l, this, n, str));\n  }\n  \n};\n\nvar binding_is_uninitialized = function (binding) {\n  var (mutability, unused) = binding;\n  return (\n    mutability_compare(mutability, Mutability_uninitialized_immutable));\n};\n\nvar binding_is_mutable = function (binding) {\n  var (mutability, unused) = binding;\n  return (\n    (_compare_JsSyntax_mutability(mutability, Mutability_nondeletable)\n    || _compare_JsSyntax_mutability(mutability, Mutability_deletable)));\n};\n\nvar decl_env_record_create_mutable_binding = function (l, envRec, n$, d) {\n  var n = string_of_value(n$);\n  var d = bool_of_value(d);\n  var%ck_assert _pat_any_36 = !(HeapStr.indom_dec(envRec, n));\n  var s = env_record_write_decl_env(l, n, mutability_of_bool(d), Value_undef);\n  return (res_void());\n};\n\nvar decl_env_record_initialize_binding = function (l, envRec, n$, v) {\n  var n = string_of_value(n$);\n  var%some binding = HeapStr.read_option(envRec, n);\n  var (mutability, unused) = binding;\n  var%ck_assert _pat_any_37 = binding_is_uninitialized(binding);\n  var s = env_record_write_decl_env(l, n, mutability, v);\n  return (res_void());\n};\n\nvar decl_env_record_set_mutable_binding = function (l, envRec, n$, v, str) {\n  var n = string_of_value(n$);\n  var str = bool_of_value(str);\n  if (!(HeapStr.indom_dec(envRec, n))) {\n    if (str) {\n      return (run_error_no_c(Native_error_ref));\n    } else {\n      var%success _pat_any_39 = decl_env_record_create_mutable_binding(l,\n                                  envRec, n$, Value_bool(true));\n      var%success _pat_any_38 = decl_env_record_initialize_binding(l, envRec,\n                                  n$, v);\n      return (res_void());\n    }\n  } else {\n    var%some binding = HeapStr.read_option(envRec, n);\n    var (mutability, unused) = binding;\n    if (binding_is_uninitialized(binding)) {\n      return (run_error_no_c(Native_error_ref));\n    } else {\n      var%_ret _ = (function () {\n          if (binding_is_mutable(binding)) {\n            return (\n              Continue(env_record_write_decl_env(l, n, mutability, v)));\n          } else {\n            if (str) {\n              return (Return(run_error_no_c(Native_error_type)));\n            } else {\n              return (Continue);\n            }\n          }}());\n      return (res_void());\n    }\n  }\n};\n\nvar decl_env_record_get_binding_value = function (envRec, n, str) {\n  var n = string_of_value(n);\n  var%ck_assert _pat_any_40 = HeapStr.indom_dec(envRec, n);\n  var%some binding = HeapStr.read_option(envRec, n);\n  var (mutability, v) = binding;\n  if (mutability_compare(mutability, Mutability_uninitialized_immutable)) {\n    return (run_error_no_c(Native_error_ref));\n  } else {\n    return (v);\n  }\n};\n\nvar object_env_record_set_mutable_binding = function (bindings, this, n, v, str) {\n  return (set(bindings, n, v, str));\n};\n\nvar object_env_record_get_binding_value = function (bindings, this, n, str) {\n  var%bool value = has_property(bindings, n);\n  if (!(value)) {\n    if (!(str)) {\n      return (Value_undef);\n    } else {\n      return (run_error_no_c(Native_error_ref));\n    }\n  } else {\n    return (get(bindings, n));\n  }\n};\n\nvar get_global_object = function () {\n  var e = unsome_error(env_record_binds_option(env_loc_global_env_record));\n  switch (e) {\n    case Coq_env_record_object(l, this):\n      return (l);\n    default:\n      throw false;\n  }\n  \n};\n\nvar ordinary_object_internal_get_prototype_of = function (o) {\n  var%value v = ordinary_get_prototype_of(o);\n  return (v);\n};\n\nvar ordinary_get_prototype_of = function (o) {\n  var%some v = run_object_method(object_proto_, o);\n  return (v);\n};\n\nvar ordinary_object_internal_set_prototype_of = function (o, v) {\n  var%value v = ordinary_set_prototype_of(o, v);\n  return (v);\n};\n\nvar ordinary_set_prototype_of = function (o, v) {\n  var%ck_assert _pat_any_41 = (function () {\n      switch (type_of(v)) {\n        case Coq_type_object:\n          return (true);\n        case Coq_type_null:\n          return (true);\n        default:\n          return (false);\n      }\n      }());\n  var%some extensible = run_object_method(object_extensible_, o);\n  var%some current = run_object_method(object_prototype_, o);\n  var sv = same_value(v, current);\n  if (sv) {\n    return (Value_bool(true));\n  } else {\n    if (!(extensible)) {\n      return (Value_bool(false));\n    } else {\n      var repeat = function (p, done_) {\n        if (!(done_)) {\n          switch (p) {\n            case Coq_value_null:\n              return (repeat(p, true));\n            case Coq_value_object(p_l):\n              if (same_value(p, o)) {\n                return (Value_bool(false));\n              } else {\n                var%some gpo = run_object_method(object_get_prototype_of_,\n                                 p_l);\n                switch (gpo) {\n                  case Coq_builtin_get_prototype_of_default:\n                    var%some prototype = run_object_method(object_prototype_,\n                                           p_l);\n                    return (repeat(prototype, false));\n                  default:\n                    return (repeat(p, true));\n                }\n                \n              }\n            default:\n              throw false;\n          }\n          \n        } else {\n          var%some _ = run_object_set_internal(object_set_proto, o, v);\n          return (Value_bool(true));\n        }\n      };\n      return (repeat(v, false));\n    }\n  }\n};\n\nvar ordinary_object_internal_is_extensible = function (o) {\n  var%value v = ordinary_is_extensible(o);\n  return (v);\n};\n\nvar ordinary_is_extensible = function (o) {\n  var%some b = run_object_method(object_extensible_, o);\n  return (Value_bool(b));\n};\n\nvar ordinary_object_internal_prevent_extensions = function (o) {\n  var%value v = ordinary_prevent_extensions(o);\n  return (v);\n};\n\nvar ordinary_prevent_extensions = function (o) {\n  var%some _ = run_object_set_internal(object_set_extensible, o, false);\n  return (Value_bool(true));\n};\n\nvar ordinary_object_internal_get_own_property = function (o, p) {\n  var%spec d = ordinary_get_own_property(o, p);\n  return (d);\n};\n\nvar ordinary_get_own_property = function (o, p) {\n  var%ck_assert _pat_any_42 = is_property_key(p);\n  var p = string_of_value(p);\n  if (!(object_property_exists(o, p))) {\n    return (Descriptor_undef);\n  } else {\n    var d = descriptor_intro_empty;\n    var%some x = object_retrieve_property(o, p);\n    switch (x) {\n      case Coq_attributes_data_of(x):\n        var d = Object.assign({}, d, {\n                    descriptor_value: Some(x.attributes_data_value),\n                    descriptor_writable: Some(x.attributes_data_writable)});\n        break;\n      case Coq_attributes_accessor_of(x):\n        var d = Object.assign({}, d, {\n                    descriptor_get: Some(x.attributes_accessor_get),\n                    descriptor_set: Some(x.attributes_accessor_set)});\n        break;\n    }\n    \n    var d = Object.assign({}, d, {\n                descriptor_enumerable: Some(attributes_enumerable(x))});\n    var d = Object.assign({}, d, {\n                descriptor_configurable: Some(attributes_configurable(x))});\n    return (Descriptor(d));\n  }\n};\n\nvar ordinary_object_internal_define_own_property = function (o, p, desc) {\n  return (ordinary_define_own_property(o, p, desc));\n};\n\nvar ordinary_define_own_property = function (o, p, desc) {\n  var%spec current = object_internal_get_own_property(o, p);\n  var%some extensible = run_object_method(object_extensible_, o);\n  return (\n    validate_and_apply_property_descriptor(o, p, extensible, desc, current));\n};\n\nvar is_compatible_property_descriptor = function (extensible, desc, current) {\n  return (\n    validate_and_apply_property_descriptor(Value_undef, Value_undef,\n      extensible, desc, current));\n};\n\nvar validate_and_apply_property_descriptor = function (o, p, extensible, desc, current) {\n  var%ck_assert _pat_any_44 = (value_compare(o, Value_undef)\n                              || is_property_key(p));\n  var p = string_of_value(p);\n  switch (current) {\n    case Descriptor_undef:\n      if (!(extensible)) {\n        return (Value_bool(false));\n      } else {\n        var%ck_assert _pat_any_43 = extensible;\n        var%some _ = (function () {\n            switch (o) {\n              case Coq_value_object(l):\n                if ((is_generic_descriptor(Descriptor(desc))\n                    || is_data_descriptor(Descriptor(desc)))) {\n                  return (\n                    object_set_property(l, p,\n                      attributes_data_of_descriptor(desc)));\n                } else {\n                  return (\n                    object_set_property(l, p,\n                      attributes_accessor_of_descriptor(desc)));\n                }\n              case Coq_value_undef:\n                return (Some);\n              default:\n                return (None);\n            }\n            }());\n        return (Value_bool(true));\n      }\n    case Descriptor(current):\n      var%_ret _ = (function () {\n          if (descriptor_is_empty(desc)) {\n            return (Return(Value_bool(true)));\n          } else {\n            return (Continue);\n          }}());\n      var%_ret _ = (function () {\n          if (descriptor_contained_by(desc, current, same_value)) {\n            return (Return(Value_bool(true)));\n          } else {\n            return (Continue);\n          }}());\n      var%_ret _ = (function () {\n          if (option_compare(bool_eq, current.descriptor_configurable,\n                Some(false))) {\n            if (option_compare(bool_eq, desc.descriptor_configurable,\n                  Some(true))) {\n              return (Return(Value_bool(false)));\n            } else {\n              if ((is_some(desc.descriptor_enumerable)\n                  && !(\n                       some_compare(bool_eq, current.descriptor_enumerable,\n                         desc.descriptor_enumerable)))) {\n                return (Return(Value_bool(false)));\n              } else {\n                return (Continue);\n              }\n            }\n          } else {\n            return (Continue);\n          }}());\n      var%_ret _ = (function () {\n          if (is_generic_descriptor(Descriptor(desc))) {\n            return (Continue);\n          } else {\n            if (!(\n                  bool_eq(is_data_descriptor(Descriptor(current)),\n                    is_data_descriptor(Descriptor(desc))))) {\n              if (option_compare(bool_eq, current.descriptor_configurable,\n                    Some(false))) {\n                return (Return(Value_bool(false)));\n              } else {\n                if (is_data_descriptor(Descriptor(current))) {\n                  var s = unsome_default((function () {\n                              switch (o) {\n                                case Coq_value_object(l):\n                                  return (\n                                    object_map_property(l, p,\n                                      attributes_accessor_of_attributes_data));\n                                default:\n                                  return (Some);\n                              }\n                              }()));\n                  return (Continue);\n                } else {\n                  var s = unsome_default((function () {\n                              switch (o) {\n                                case Coq_value_object(l):\n                                  return (\n                                    object_map_property(l, p,\n                                      attributes_data_of_attributes_accessor));\n                                default:\n                                  return (Some);\n                              }\n                              }()));\n                  return (Continue);\n                }\n              }\n            } else {\n              if ((is_data_descriptor(Descriptor(current))\n                  && is_data_descriptor(Descriptor(desc)))) {\n                if (option_compare(bool_eq, current.descriptor_configurable,\n                      Some(false))) {\n                  if ((option_compare(bool_eq, current.descriptor_writable,\n                         Some(false))\n                      && option_compare(bool_eq, desc.descriptor_writable,\n                           Some(true)))) {\n                    return (Return(Value_bool(false)));\n                  } else {\n                    if (option_compare(bool_eq, current.descriptor_writable,\n                          Some(false))) {\n                      if ((is_some(desc.descriptor_value)\n                          && !(\n                               option_compare(same_value,\n                                 desc.descriptor_value,\n                                 current.descriptor_value)))) {\n                        return (Return(Value_bool(false)));\n                      } else {\n                        return (Continue);\n                      }\n                    } else {\n                      return (Continue);\n                    }\n                  }\n                } else {\n                  if (!(\n                        option_compare(bool_eq,\n                          current.descriptor_configurable, Some(true)))) {\n                    return (Return(spec_assertion_failure({})));\n                  } else {\n                    return (Continue);\n                  }\n                }\n              } else {\n                if (!(\n                      (is_accessor_descriptor(Descriptor(current))\n                      && is_accessor_descriptor(Descriptor(desc))))) {\n                  return (Return(spec_assertion_failure({})));\n                } else {\n                  if (option_compare(bool_eq,\n                        current.descriptor_configurable, Some(false))) {\n                    if ((is_some(desc.descriptor_set)\n                        && !(\n                             option_compare(same_value, desc.descriptor_set,\n                               current.descriptor_set)))) {\n                      return (Return(Value_bool(false)));\n                    } else {\n                      if ((is_some(desc.descriptor_get)\n                          && !(\n                               option_compare(same_value,\n                                 desc.descriptor_get, current.descriptor_get)))) {\n                        return (Return(Value_bool(false)));\n                      } else {\n                        return (Continue);\n                      }\n                    }\n                  } else {\n                    return (Continue);\n                  }\n                }\n              }\n            }\n          }}());\n      var%some _ = (function () {\n          switch (o) {\n            case Coq_value_object(l):\n              return (\n                object_map_property(l, p, function (a) {\n                    return (attributes_update(a, desc));}));\n            default:\n              return (Some);\n          }\n          }());\n      return (Value_bool(true));\n  }\n  \n};\n\nvar ordinary_object_internal_has_property = function (o, p) {\n  return (ordinary_has_property(o, p));\n};\n\nvar ordinary_has_property = function (o, p) {\n  var%ck_assert _pat_any_45 = is_property_key(p);\n  var%spec hasOwn = object_internal_get_own_property(o, p);\n  if (!(_compare_JsSyntax_undef_descriptor(hasOwn, Descriptor_undef))) {\n    return (Value_bool(true));\n  } else {\n    var%value parent = object_internal_get_prototype_of(o);\n    if (!(_compare_JsSyntax_value(parent, Value_null))) {\n      return (object_internal_has_property(loc_of_value(parent), p));\n    } else {\n      return (Value_bool(false));\n    }\n  }\n};\n\nvar ordinary_object_internal_get = function (o, p, receiver) {\n  return (ordinary_get(o, p, receiver));\n};\n\nvar ordinary_get = function (o, p, receiver) {\n  var%ck_assert _pat_any_47 = is_property_key(p);\n  var%spec desc = object_internal_get_own_property(o, p);\n  if (_compare_JsSyntax_undef_descriptor(desc, Descriptor_undef)) {\n    var%value parent = object_internal_get_prototype_of(o);\n    if (_compare_JsSyntax_value(parent, Value_null)) {\n      return (Value_undef);\n    } else {\n      var parent = loc_of_value(parent);\n      return (object_internal_get(parent, p, receiver));\n    }\n  } else {\n    if (is_data_descriptor(desc)) {\n      var desc = descriptor_get_defined(desc);\n      var%some value = descriptor_value(desc);\n      return (value);\n    } else {\n      var%ck_assert _pat_any_46 = is_accessor_descriptor(desc);\n      var desc = descriptor_get_defined(desc);\n      var%some getter = descriptor_get(desc);\n      if (_compare_JsSyntax_value(getter, Value_undef)) {\n        return (Value_undef);\n      } else {\n        return (call(getter, receiver, None));\n      }\n    }\n  }\n};\n\nvar ordinary_object_internal_set = function (o, p, v, receiver) {\n  return (ordinary_set(o, p, v, receiver));\n};\n\nvar ordinary_set = function (o, p, v, receiver) {\n  var%ck_assert _pat_any_50 = is_property_key(p);\n  var%spec ownDesc = object_internal_get_own_property(o, p);\n  var%_ret ownDesc = (function () {\n      if (_compare_JsSyntax_undef_descriptor(ownDesc, Descriptor_undef)) {\n        var%value_ret parent = object_internal_get_prototype_of(o);\n        if (!(_compare_JsSyntax_value(parent, Value_null))) {\n          var parent = loc_of_value(parent);\n          return (Return(object_internal_set(parent, p, v, receiver)));\n        } else {\n          return (\n            Continue(\n              Descriptor({\n                  descriptor_value: Some(Value_undef),\n                  descriptor_writable: Some(false),\n                  descriptor_get: None,\n                  descriptor_set: None,\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)})));\n        }\n      } else {\n        return (Continue(ownDesc));\n      }}());\n  if (is_data_descriptor(ownDesc)) {\n    var ownDesc = descriptor_get_defined(ownDesc);\n    var%some writable = ownDesc.descriptor_writable;\n    if (!(writable)) {\n      return (Value_bool(false));\n    } else {\n      if (!(_compare_JsSyntax_coq_type(type_of(receiver), Type_object))) {\n        return (Value_bool(false));\n      } else {\n        var receiver = loc_of_value(receiver);\n        var%spec existingDescriptor = object_internal_get_own_property(\n                                        receiver, p);\n        if (!(\n              _compare_JsSyntax_undef_descriptor(existingDescriptor,\n                Descriptor_undef))) {\n          if (is_accessor_descriptor(existingDescriptor)) {\n            return (Value_bool(false));\n          } else {\n            var existingDescriptor = descriptor_get_defined(\n                                       existingDescriptor);\n            var%some w = existingDescriptor.descriptor_writable;\n            if (!(w)) {\n              return (Value_bool(false));\n            } else {\n              var valueDesc = descriptor_with_value(descriptor_intro_empty,\n                                Some(v));\n              return (\n                object_internal_define_own_property(receiver, p, valueDesc));\n            }\n          }\n        } else {\n          return (create_data_property(receiver, p, v));\n        }\n      }\n    }\n  } else {\n    var%ck_assert _pat_any_49 = is_accessor_descriptor(ownDesc);\n    var ownDesc = descriptor_get_defined(ownDesc);\n    var%some setter = ownDesc.descriptor_set;\n    if (_compare_JsSyntax_value(setter, Value_undef)) {\n      return (Value_bool(false));\n    } else {\n      var%spec _pat_any_48 = call(setter, receiver, Some(mk_cons(v, mk_nil)));\n      return (Value_bool(true));\n    }\n  }\n};\n\nvar ordinary_object_internal_delete = function (o, p) {\n  return (ordinary_delete(o, p));\n};\n\nvar ordinary_delete = function (o, p) {\n  var%ck_assert _pat_any_51 = is_property_key(p);\n  var%spec desc = object_internal_get_own_property(o, p);\n  if (_compare_JsSyntax_undef_descriptor(desc, Descriptor_undef)) {\n    return (Value_bool(true));\n  } else {\n    var desc = descriptor_get_defined(desc);\n    if (some_compare(===, descriptor_configurable(desc), Some(true))) {\n      var p = string_of_value(p);\n      var%some _ = run_object_heap_map_properties(o, function (props) {\n                       return (HeapStr.rem(props, p));});\n      return (Value_bool(true));\n    } else {\n      return (Value_bool(false));\n    }\n  }\n};\n\nvar ordinary_object_internal_own_property_keys = function (o) {\n  var%spec k = ordinary_own_property_keys(o);\n  return (k);\n};\n\nvar ordinary_own_property_keys = function (o) {\n  var%some keys = object_properties_keys_as_list_option(o);\n  var keys = LibList.map(function (key) { return (Value_string(key));}, keys);\n  return (keys);\n};\n\nvar object_create = function (proto, internalSlotsList) {\n  var internalSlotsList = unsome_default(mk_nil, internalSlotsList);\n  var obj = object_new(proto, "");\n  var (l, s) = object_alloc(obj);\n  return (l);\n};\n\nvar add_restricted_function_properties = function (f, realm) {\n  var thrower = Prealloc_throw_type_error;\n  var%ert_success _pat_any_52 = define_property_or_throw(f,\n                                  Value_string("caller"),\n                                  Object.assign({}, descriptor_intro_empty, {\n                                      descriptor_get: Some(thrower),\n                                      descriptor_set: Some(thrower),\n                                      descriptor_enumerable: Some(false),\n                                      descriptor_configurable: Some(true)}));\n  var%ert_success rv = define_property_or_throw(f, Value_string("arguments"),\n                         Object.assign({}, descriptor_intro_empty, {\n                             descriptor_get: Some(thrower),\n                             descriptor_set: Some(thrower),\n                             descriptor_enumerable: Some(false),\n                             descriptor_configurable: Some(true)}));\n  return (rv);\n};\n\nvar builtin_throw_type_error = function (thisArgument, argumentsList, newTarget) {\n  return (run_error(Native_error_type));\n};\n\nvar array_create = function (length, proto) {\n  return (run_construct_prealloc(Prealloc_array, mk_cons(length, mk_nil)));\n};\n\nvar is_proxy_exotic_object = function (l) {\n  return (object_has_internal_slot(l, object_proxy_handler_));\n};\n\nvar proxy_object_internal_get_prototype_of = function (o) {\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_53 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("getPrototypeOf"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_get_prototype_of(loc_of_value(target)));\n    } else {\n      var%value handlerProto = call(trap, handler,\n                                 Some(mk_cons(target, mk_nil)));\n      if (!(\n            (_compare_JsSyntax_coq_type(type_of(handlerProto), Type_object)\n            || _compare_JsSyntax_value(handlerProto, Value_null)))) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        var%bool extensibleTarget = is_extensible(target);\n        if (extensibleTarget) {\n          return (handlerProto);\n        } else {\n          var%value targetProto = object_internal_get_prototype_of(\n                                    loc_of_value(target));\n          if (!(same_value(handlerProto, targetProto))) {\n            return (run_error_no_c(Native_error_type));\n          } else {\n            return (handlerProto);\n          }\n        }\n      }\n    }\n  }\n};\n\nvar proxy_object_internal_set_prototype_of = function (o, v) {\n  var%ck_assert _pat_any_55 = (_compare_JsSyntax_coq_type(type_of(v),\n                                 Type_object)\n                              || _compare_JsSyntax_coq_type(type_of(v),\n                                   Type_null));\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_54 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string(""));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_set_prototype_of(loc_of_value(target), v));\n    } else {\n      var%value tempVal = call(trap, handler,\n                            Some(mk_cons(target, mk_cons(v, mk_nil))));\n      var booleanTrapResult = to_boolean(tempVal);\n      if (!(booleanTrapResult)) {\n        return (Value_bool(false));\n      } else {\n        var%bool extensibleTarget = is_extensible(target);\n        if (extensibleTarget) {\n          return (Value_bool(true));\n        } else {\n          var%value targetProto = object_internal_get_prototype_of(\n                                    loc_of_value(target));\n          if (!(same_value(v, targetProto))) {\n            return (run_error_no_c(Native_error_type));\n          } else {\n            return (Value_bool(true));\n          }\n        }\n      }\n    }\n  }\n};\n\nvar proxy_object_internal_is_extensible = function (o) {\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_56 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("isExtensible"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_is_extensible(loc_of_value(target)));\n    } else {\n      var%value tempVal = call(trap, handler, Some(mk_cons(target, mk_nil)));\n      var booleanTrapResult = to_boolean(tempVal);\n      var%value targetResult = object_internal_is_extensible(\n                                 loc_of_value(target));\n      if (!(same_value(Value_bool(booleanTrapResult), targetResult))) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        return (Value_bool(booleanTrapResult));\n      }\n    }\n  }\n};\n\nvar proxy_object_internal_prevent_extensions = function (o) {\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_57 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("preventExtensions"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_prevent_extensions(loc_of_value(target)));\n    } else {\n      var%value tempVal = call(trap, handler, Some(mk_cons(target, mk_nil)));\n      var booleanTrapResult = to_boolean(tempVal);\n      var%_ret _ = (function () {\n          if (booleanTrapResult) {\n            var%bool_ret targetIsExtensible = object_internal_is_extensible(\n                                                loc_of_value(target));\n            if (targetIsExtensible) {\n              return (Return(run_error_no_c(Native_error_type)));\n            } else {\n              return (Continue);\n            }\n          } else {\n            return (Continue);\n          }}());\n      return (Value_bool(booleanTrapResult));\n    }\n  }\n};\n\nvar proxy_object_internal_get_own_property = function (o, p) {\n  var%ck_assert _pat_any_59 = is_property_key(p);\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_58 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler,\n                       Value_string("getOwnPropertyDescriptor"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_get_own_property(o, p));\n    } else {\n      var%value trapResultObj = call(trap, handler,\n                                  Some(mk_cons(target, mk_cons(p, mk_nil))));\n      if (!(\n            (_compare_JsSyntax_coq_type(type_of(trapResultObj), Type_object)\n            || _compare_JsSyntax_value(trapResultObj, Value_undef)))) {\n        return (throw_result(run_error_no_c(Native_error_type)));\n      } else {\n        var%spec targetDesc = object_internal_get_own_property(\n                                loc_of_value(target), p);\n        if (_compare_JsSyntax_value(trapResultObj, Value_undef)) {\n          if (_compare_JsSyntax_undef_descriptor(targetDesc,\n                Descriptor_undef)) {\n            return (Descriptor_undef);\n          } else {\n            var targetDesc = descriptor_get_defined(targetDesc);\n            if (_compare_option(descriptor_configurable(targetDesc),\n                  Some(false))) {\n              return (throw_result(run_error_no_c(Native_error_type)));\n            } else {\n              var%bool extensibleTarget = is_extensible(target);\n              if (!(extensibleTarget)) {\n                return (throw_result(run_error_no_c(Native_error_type)));\n              } else {\n                return (Descriptor_undef);\n              }\n            }\n          }\n        } else {\n          var%bool extensibleTarget = is_extensible(target);\n          var%spec resultDesc = to_property_descriptor(trapResultObj);\n          var resultDesc = complete_property_descriptor(\n                             Descriptor(resultDesc));\n          var%bool valid = is_compatible_property_descriptor(\n                             extensibleTarget, resultDesc, targetDesc);\n          if (!(valid)) {\n            return (run_error_no_c(Native_error_type));\n          } else {\n            if ((_compare_option(descriptor_configurable(resultDesc),\n                   Some(true))\n                && (_compare_JsSyntax_undef_descriptor(targetDesc,\n                      Descriptor_undef)\n                   || _compare_option(\n                        descriptor_configurable(\n                          descriptor_get_defined(targetDesc)), Some(true))))) {\n              return (run_error_no_c(Native_error_type));\n            } else {\n              return (Descriptor(resultDesc));\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nvar proxy_object_internal_define_own_property = function (o, p, desc) {\n  var%ck_assert _pat_any_61 = is_property_key(p);\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_60 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("defineProperty"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (\n        object_internal_define_own_property(loc_of_value(target), p, desc));\n    } else {\n      var%value descObj = from_property_descriptor(Descriptor(desc));\n      var%value tempVar = call(trap, handler,\n                            Some(\n                              mk_cons(target,\n                                mk_cons(p, mk_cons(descObj, mk_nil)))));\n      var booleanTrapResult = to_boolean(tempVar);\n      if (!(booleanTrapResult)) {\n        return (Value_bool(false));\n      } else {\n        var%spec targetDesc = object_internal_get_own_property(\n                                loc_of_value(target), p);\n        var%bool extensibleTarget = is_extensible(target);\n        var settingConfigFalse = (is_some(desc.descriptor_configurable)\n                                 && _compare_option(\n                                      desc.descriptor_configurable,\n                                      Some(false)));\n        var%_ret _ = (function () {\n            if (_compare_JsSyntax_undef_descriptor(targetDesc,\n                  Descriptor_undef)) {\n              if (!(extensibleTarget)) {\n                return (Return(run_error_no_c(Native_error_type)));\n              } else {\n                if (settingConfigFalse) {\n                  return (Return(run_error_no_c(Native_error_type)));\n                } else {\n                  return (Continue);\n                }\n              }\n            } else {\n              var%bool_ret tempVal = is_compatible_property_descriptor(\n                                       extensibleTarget, desc, targetDesc);\n              var targetDesc = descriptor_get_defined(targetDesc);\n              if (!(tempVal)) {\n                return (Return(run_error_no_c(Native_error_type)));\n              } else {\n                if ((settingConfigFalse\n                    && _compare_option(targetDesc.descriptor_configurable,\n                         Some(true)))) {\n                  return (Return(run_error_no_c(Native_error_type)));\n                } else {\n                  return (Continue);\n                }\n              }\n            }}());\n        return (Value_bool(true));\n      }\n    }\n  }\n};\n\nvar proxy_object_internal_has_property = function (o, p) {\n  var%ck_assert _pat_any_63 = is_property_key(p);\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_62 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("has"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_has_property(loc_of_value(target), p));\n    } else {\n      var%value tempVar = call(trap, handler,\n                            Some(mk_cons(target, mk_cons(p, mk_nil))));\n      var booleanTrapResult = to_boolean(tempVar);\n      var%_ret _ = (function () {\n          if (!(booleanTrapResult)) {\n            var%spec_ret targetDesc = object_internal_get_own_property(\n                                        loc_of_value(target), p);\n            if (!(\n                  _compare_JsSyntax_undef_descriptor(targetDesc,\n                    Descriptor_undef))) {\n              var targetDesc = descriptor_get_defined(targetDesc);\n              if (_compare_option(targetDesc.descriptor_configurable,\n                    Some(false))) {\n                return (Return(run_error_no_c(Native_error_type)));\n              } else {\n                var%bool_ret extensibleTarget = is_extensible(target);\n                if (!(extensibleTarget)) {\n                  return (Return(run_error_no_c(Native_error_type)));\n                } else {\n                  return (Continue);\n                }\n              }\n            } else {\n              return (Continue);\n            }\n          } else {\n            return (Continue);\n          }}());\n      return (Value_bool(booleanTrapResult));\n    }\n  }\n};\n\nvar proxy_object_internal_get = function (o, p, receiver) {\n  var%ck_assert _pat_any_65 = is_property_key(p);\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_64 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("get"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_get(loc_of_value(target), p, receiver));\n    } else {\n      var%value trapResult = call(trap, handler,\n                               Some(\n                                 mk_cons(target,\n                                   mk_cons(p, mk_cons(receiver, mk_nil)))));\n      var%spec targetDesc = object_internal_get_own_property(\n                              loc_of_value(target), p);\n      var%_ret _ = (function () {\n          if (!(\n                _compare_JsSyntax_undef_descriptor(targetDesc,\n                  Descriptor_undef))) {\n            var targetDesc$ = descriptor_get_defined(targetDesc);\n            var%_ret_ret _ = (function () {\n                if ((is_data_descriptor(targetDesc)\n                    && (_compare_option(targetDesc$.descriptor_configurable,\n                          Some(false))\n                       && _compare_option(targetDesc$.descriptor_writable,\n                            Some(false))))) {\n                  if (!(\n                        same_value(trapResult,\n                          unsome_error(targetDesc$.descriptor_value)))) {\n                    return (Return(run_error_no_c(Native_error_type)));\n                  } else {\n                    return (Continue);\n                  }\n                } else {\n                  return (Continue);\n                }}());\n            var%_ret_ret _ = (function () {\n                if ((is_accessor_descriptor(targetDesc)\n                    && (_compare_option(targetDesc$.descriptor_configurable,\n                          Some(false))\n                       && _compare_option(targetDesc$.descriptor_get,\n                            Some(Value_undef))))) {\n                  if (!(_compare_JsSyntax_value(trapResult, Value_undef))) {\n                    return (Return(run_error_no_c(Native_error_type)));\n                  } else {\n                    return (Continue);\n                  }\n                } else {\n                  return (Continue);\n                }}());\n            return (Continue);\n          } else {\n            return (Continue);\n          }}());\n      return (trapResult);\n    }\n  }\n};\n\nvar proxy_object_internal_set = function (o, p, v, receiver) {\n  var%ck_assert _pat_any_67 = is_property_key(p);\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_66 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("set"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_set(loc_of_value(target), p, v, receiver));\n    } else {\n      var%value tempVar = call(trap, handler,\n                            Some(\n                              mk_cons(target,\n                                mk_cons(p,\n                                  mk_cons(v, mk_cons(receiver, mk_nil))))));\n      var booleanTrapResult = to_boolean(tempVar);\n      if (!(booleanTrapResult)) {\n        return (Value_bool(false));\n      } else {\n        var%spec targetDesc = object_internal_get_own_property(\n                                loc_of_value(target), p);\n        var%_ret _ = (function () {\n            if (!(\n                  _compare_JsSyntax_undef_descriptor(targetDesc,\n                    Descriptor_undef))) {\n              var targetDesc$ = descriptor_get_defined(targetDesc);\n              var%_ret_ret _ = (function () {\n                  if ((is_data_descriptor(targetDesc)\n                      && (_compare_option(\n                            targetDesc$.descriptor_configurable, Some(false))\n                         && _compare_option(targetDesc$.descriptor_writable,\n                              Some(false))))) {\n                    if (!(\n                          same_value(v,\n                            unsome_error(targetDesc$.descriptor_value)))) {\n                      return (Return(run_error_no_c(Native_error_type)));\n                    } else {\n                      return (Continue);\n                    }\n                  } else {\n                    return (Continue);\n                  }}());\n              var%_ret_ret _ = (function () {\n                  if ((is_accessor_descriptor(targetDesc)\n                      && _compare_option(targetDesc$.descriptor_configurable,\n                           Some(false)))) {\n                    if (_compare_option(targetDesc$.descriptor_set,\n                          Some(Value_undef))) {\n                      return (Return(run_error_no_c(Native_error_type)));\n                    } else {\n                      return (Continue);\n                    }\n                  } else {\n                    return (Continue);\n                  }}());\n              return (Continue);\n            } else {\n              return (Continue);\n            }}());\n        return (Value_bool(true));\n      }\n    }\n  }\n};\n\nvar proxy_object_internal_delete = function (o, p) {\n  var%ck_assert _pat_any_69 = is_property_key(p);\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_68 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("deleteProperty"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_delete(loc_of_value(target), p));\n    } else {\n      var%value tempVar = call(trap, handler,\n                            Some(mk_cons(target, mk_cons(p, mk_nil))));\n      var booleanTrapResult = to_boolean(tempVar);\n      if (!(booleanTrapResult)) {\n        return (Value_bool(false));\n      } else {\n        var%spec targetDesc = object_internal_get_own_property(\n                                loc_of_value(target), p);\n        if (_compare_JsSyntax_undef_descriptor(targetDesc, Descriptor_undef)) {\n          return (Value_bool(true));\n        } else {\n          var targetDesc = descriptor_get_defined(targetDesc);\n          if (_compare_option(targetDesc.descriptor_configurable,\n                Some(false))) {\n            return (run_error_no_c(Native_error_type));\n          } else {\n            return (Value_bool(true));\n          }\n        }\n      }\n    }\n  }\n};\n\nvar proxy_object_internal_own_property_keys = function (o) {\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_73 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("ownKeys"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (object_internal_own_property_keys(loc_of_value(target)));\n    } else {\n      var%value trapResultArray = call(trap, handler,\n                                    Some(mk_cons(target, mk_nil)));\n      var%spec trapResult = create_list_from_array_like(trapResultArray,\n                              Some(mk_cons(Type_string, mk_nil)));\n      var%bool extensibleTarget = is_extensible(target);\n      var%spec targetKeys = object_internal_own_property_keys(\n                              loc_of_value(target));\n      var targetConfigurableKeys = mk_nil;\n      var targetNonconfigurableKeys = mk_nil;\n      var%_ret (s, targetConfigurableKeys,\n        targetNonconfigurableKeys) = iterate(targetKeys,\n                                       [s, targetConfigurableKeys, targetNonconfigurableKeys],\n                                       function (key, acc) {\n                                         var (s, targetConfigurableKeys,\n                                           targetNonconfigurableKeys) = acc;\n                                         var%spec_ret desc = object_internal_get_own_property(\n                                                               loc_of_value(\n                                                                 target),\n                                                               key);\n                                         if ((!(\n                                                _compare_JsSyntax_undef_descriptor(\n                                                  desc, Descriptor_undef))\n                                             && _compare_option(\n                                                  descriptor_get_defined(\n                                                    desc).descriptor_configurable,\n                                                  Some(false)))) {\n                                           return (\n                                             Continue(\n                                               [s, targetConfigurableKeys, \n                                               append(\n                                                 targetNonconfigurableKeys,\n                                                 mk_cons(key, mk_nil))]));\n                                         } else {\n                                           return (\n                                             Continue(\n                                               [s, append(\n                                                     targetConfigurableKeys,\n                                                     mk_cons(key, mk_nil)), targetNonconfigurableKeys]));\n                                         }});\n      if ((extensibleTarget && is_empty(targetNonconfigurableKeys))) {\n        return (trapResult);\n      } else {\n        var uncheckedResultKeys = trapResult;\n        var%_ret (s,\n          uncheckedResultKeys) = iterate(targetNonconfigurableKeys,\n                                   [s, uncheckedResultKeys],\n                                   function (key, acc) {\n                                     var (s, uncheckedResultKeys) = acc;\n                                     if (!(\n                                           mem_decide(===, key,\n                                             uncheckedResultKeys))) {\n                                       return (\n                                         Return(\n                                           run_error_no_c(Native_error_type)));\n                                     } else {\n                                       return (\n                                         Continue(\n                                           [s, filter(function (x) {\n                                                   return (\n                                                     !(\n                                                       _compare_JsSyntax_value(\n                                                         x, key)));},\n                                                 uncheckedResultKeys)]));\n                                     }});\n        if (extensibleTarget) {\n          return (trapResult);\n        } else {\n          var%_ret (s,\n            uncheckedResultKeys) = iterate(targetConfigurableKeys,\n                                     [s, uncheckedResultKeys],\n                                     function (key, acc) {\n                                       var (s, uncheckedResultKeys) = acc;\n                                       if (!(\n                                             mem_decide(===, key,\n                                               uncheckedResultKeys))) {\n                                         return (\n                                           Return(\n                                             run_error_no_c(\n                                               Native_error_type)));\n                                       } else {\n                                         return (\n                                           Continue(\n                                             [s, filter(function (x) {\n                                                     return (\n                                                       !(\n                                                         _compare_JsSyntax_value(\n                                                           x, key)));},\n                                                   uncheckedResultKeys)]));\n                                       }});\n          if (!(is_empty(uncheckedResultKeys))) {\n            return (run_error_no_c(Native_error_type));\n          } else {\n            return (trapResult);\n          }\n        }\n      }\n    }\n  }\n};\n\nvar proxy_object_internal_call = function (o, thisArgument, argumentsList) {\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_74 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("apply"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      return (call(target, thisArgument, Some(argumentsList)));\n    } else {\n      var%value argArray = create_array_from_list(argumentsList);\n      return (\n        call(trap, handler,\n          Some(\n            mk_cons(target, mk_cons(thisArgument, mk_cons(argArray, mk_nil))))));\n    }\n  }\n};\n\nvar proxy_object_internal_construct = function (o, argumentsList, newTarget) {\n  var%some handler = run_object_method(object_proxy_handler_, o);\n  var%some handler = handler;\n  if (_compare_JsSyntax_value(handler, Value_null)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    var%ck_assert _pat_any_76 = _compare_JsSyntax_coq_type(type_of(handler),\n                                  Type_object);\n    var%some target = run_object_method(object_proxy_target_, o);\n    var%some target = target;\n    var%value trap = get_method(handler, Value_string("construct"));\n    if (_compare_JsSyntax_value(trap, Value_undef)) {\n      var%ck_assert _pat_any_75 = object_has_internal_method(\n                                    loc_of_value(target), object_construct_);\n      return (construct(target, Some(argumentsList), Some(newTarget)));\n    } else {\n      var%value argArray = create_array_from_list(argumentsList);\n      var%value newObj = call(trap, handler,\n                           Some(\n                             mk_cons(target,\n                               mk_cons(argArray, mk_cons(newTarget, mk_nil)))));\n      if (!(_compare_JsSyntax_coq_type(type_of(newObj), Type_object))) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        return (newObj);\n      }\n    }\n  }\n};\n\nvar proxy_create = function (target, handler) {\n  if (!(_compare_JsSyntax_coq_type(type_of(target), Type_object))) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    if ((is_proxy_exotic_object(loc_of_value(target))\n        && _compare_option(\n             run_object_method(object_proxy_handler_, loc_of_value(target)),\n             Some(Some(Value_null))))) {\n      return (run_error_no_c(Native_error_type));\n    } else {\n      if (!(_compare_JsSyntax_coq_type(type_of(handler), Type_object))) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        if ((is_proxy_exotic_object(loc_of_value(handler))\n            && _compare_option(\n                 run_object_method(object_proxy_handler_,\n                   loc_of_value(handler)), Some(Some(Value_null))))) {\n          return (run_error_no_c(Native_error_type));\n        } else {\n          var (p, s) = proxy_object_new();\n          var%_ret _ = (function () {\n              if (is_callable(target)) {\n                var%some_ret _ = run_object_set_internal(object_set_call, p,\n                                   Call_proxy);\n                if (object_has_internal_method(loc_of_value(target),\n                      object_construct_)) {\n                  var%some_ret _ = run_object_set_internal(\n                                     object_set_construct, p,\n                                     Construct_proxy);\n                  return (Continue);\n                } else {\n                  return (Continue);\n                }\n              } else {\n                return (Continue);\n              }}());\n          var%some _ = run_object_set_internal(object_set_proxy_target, p,\n                         target);\n          var%some _ = run_object_set_internal(object_set_proxy_handler, p,\n                         handler);\n          return (p);\n        }\n      }\n    }\n  }\n};\n\nvar builtin_object_freeze = function (c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Type_object))) {\n    return (o);\n  } else {\n    var%bool status = set_integrity_level(o, "frozen");\n    if (!(status)) {\n      return (run_error_no_c(Native_error_type));\n    } else {\n      return (o);\n    }\n  }\n};\n\nvar builtin_object_get_prototype_of = function (f, this, newTarget, o) {\n  var%object obj = to_object(o);\n  return (object_internal_get_prototype_of(obj));\n};\n\nvar builtin_object_is_extensible = function (f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Type_object))) {\n    return (Value_bool(false));\n  } else {\n    return (is_extensible(o));\n  }\n};\n\nvar builtin_object_is_frozen = function (c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Type_object))) {\n    return (Value_bool(true));\n  } else {\n    return (test_integrity_level(o, "frozen"));\n  }\n};\n\nvar builtin_object_is_sealed = function (c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Type_object))) {\n    return (Value_bool(true));\n  } else {\n    return (test_integrity_level(o, "sealed"));\n  }\n};\n\nvar builtin_object_prevent_extensions = function (f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Type_object))) {\n    return (o);\n  } else {\n    var%bool status = object_internal_prevent_extensions(loc_of_value(o));\n    if (!(status)) {\n      return (run_error_no_c(Native_error_type));\n    } else {\n      return (o);\n    }\n  }\n};\n\nvar builtin_object_seal = function (c, f, this, newTarget, o) {\n  if (!(_compare_JsSyntax_coq_type(type_of(o), Type_object))) {\n    return (o);\n  } else {\n    var%bool status = set_integrity_level(o, "sealed");\n    if (!(status)) {\n      return (run_error_no_c(Native_error_type));\n    } else {\n      return (o);\n    }\n  }\n};\n\nvar builtin_object_set_prototype_of = function (c, f, this, newTarget, o, proto) {\n  var%value o = require_object_coercible(o);\n  if (!(\n        (_compare_JsSyntax_coq_type(type_of(proto), Type_object)\n        || _compare_JsSyntax_value(proto, Value_null)))) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    if (!(_compare_JsSyntax_coq_type(type_of(o), Type_object))) {\n      return (o);\n    } else {\n      var%bool status = object_internal_set_prototype_of(loc_of_value(o),\n                          proto);\n      if (!(status)) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        return (o);\n      }\n    }\n  }\n};\n\nvar builtin_proxy_constructor = function (f, this, newTarget, target, handler) {\n  if (_compare_JsSyntax_value(newTarget, Value_undef)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    return (proxy_create(target, handler));\n  }\n};\n\nvar builtin_proxy_revocable = function (f, this, newTarget, target, handler) {\n  var%value p = proxy_create(target, handler);\n  var%object revoker = proxy_revocation_function_create();\n  var%some _ = run_object_set_internal(object_set_revocable_proxy, revoker,\n                 p);\n  var%value result = object_create(Prealloc_object_proto, None);\n  var%bool _pat_any_78 = create_data_property(result, Value_string("proxy"),\n                           p);\n  var%bool _pat_any_77 = create_data_property(result, Value_string("revoke"),\n                           revoker);\n  return (result);\n};\n\nvar proxy_revocation_function_create = function () {\n  return (Result_not_yet_implemented);\n};\n\nvar builtin_proxy_revocation_function = function (c, f, this, newTarget) {\n  var%some p = run_object_method(object_revocable_proxy_, f);\n  var%some p = p;\n  if (_compare_JsSyntax_value(p, Value_null)) {\n    return (Value_undef);\n  } else {\n    var p = loc_of_value(p);\n    var%some _ = run_object_set_internal(object_set_revocable_proxy, f,\n                   Value_null);\n    var%ck_assert _pat_any_79 = is_proxy_exotic_object(p);\n    var%some _ = run_object_set_internal(object_set_proxy_target, p,\n                   Value_null);\n    var%some _ = run_object_set_internal(object_set_proxy_handler, p,\n                   Value_null);\n    return (Value_undef);\n  }\n};\n\nvar object_has_prop = function (l, x) {\n  return (object_internal_has_property(l, Value_string(x)));\n};\n\nvar out_error_or_void = function (str, ne) {\n  if (str) {\n    return (run_error(ne));\n  } else {\n    return (res_void());\n  }\n};\n\nvar out_error_or_cst = function (str, ne, v) {\n  if (str) {\n    return (run_error(ne));\n  } else {\n    return (v);\n  }\n};\n\nvar object_get_builtin = function (b, vthis, l, x) {\n  var def = function (l0) {\n    var%spec d = run_object_get_prop(l0, x);\n    switch (d) {\n      case Coq_full_descriptor_undef:\n        return (Value_undef);\n      case Coq_full_descriptor_some(a):\n        switch (a) {\n          case Coq_attributes_data_of(ad):\n            return (ad.attributes_data_value);\n          case Coq_attributes_accessor_of(aa):\n            switch (aa.attributes_accessor_get) {\n              case Coq_value_undef:\n                return (Value_undef);\n              case Coq_value_null:\n                return (Result_impossible);\n              case Coq_value_bool(b0):\n                return (Result_impossible);\n              case Coq_value_number(n):\n                return (Result_impossible);\n              case Coq_value_string(s2):\n                return (Result_impossible);\n              case Coq_value_object(lf):\n                return (run_call(lf, vthis, mk_nil));\n            }\n            \n        }\n        \n    }\n    \n  };\n  var function0 = function () {\n    var%value v = def(l);\n    if (spec_function_get_error_case_dec(x, v)) {\n      return (run_error(Native_error_type));\n    } else {\n      return (v);\n    }\n  };\n  switch (b) {\n    case Coq_builtin_get_default:\n      return (def(l));\n    case Coq_builtin_get_args_obj:\n      var%some lmapo = run_object_method(object_parameter_map_, l);\n      var%some lmap = lmapo;\n      var%spec d = run_object_get_own_prop(lmap, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (function0());\n        case Coq_full_descriptor_some(a):\n          return (run_object_get(lmap, x));\n      }\n      \n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar run_object_get = function (l, x) {\n  var%some b = run_object_method(object_get_, l);\n  return (object_get_builtin(b, l, l, x));\n};\n\nvar run_object_get_prop = function (l, x) {\n  var%some b = run_object_method(object_get_prop_, l);\n  switch (b) {\n    case Coq_builtin_get_prop_default:\n      var%spec d = run_object_get_own_prop(l, x);\n      if (full_descriptor_compare(d, Full_descriptor_undef)) {\n        var%some proto = run_object_method(object_proto_, l);\n        switch (proto) {\n          case Coq_value_null:\n            return (Full_descriptor_undef);\n          case Coq_value_object(lproto):\n            return (run_object_get_prop(lproto, x));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Found a non-object or null value as a prototype in [run_object_get_prop]."));\n        }\n        \n      } else {\n        return (d);\n      }\n  }\n  \n};\n\nvar object_proto_is_prototype_of = function (l0, l) {\n  var%some b = run_object_method(object_proto_, l);\n  switch (b) {\n    case Coq_value_null:\n      return (Value_bool(false));\n    case Coq_value_object(l_2):\n      if (object_loc_compare(l_2, l0)) {\n        return (Value_bool(true));\n      } else {\n        return (object_proto_is_prototype_of(l0, l_2));\n      }\n    default:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[run_object_method] returned a non-object in [object_proto_is_prototype_of_body]."));\n  }\n  \n};\n\nvar object_default_value = function (l, prefo) {\n  var%some b = run_object_method(object_default_value_, l);\n  switch (b) {\n    case Coq_builtin_default_value_default:\n      var gpref = unsome_default(Preftype_number, prefo);\n      var lpref = other_preftypes(gpref);\n      var sub0 = function (x, k) {\n        var%value vfo = run_object_get(l, x);\n        var%some co = run_callable(vfo);\n        switch (co) {\n          case Some(b0):\n            var%object lfunc = vfo;\n            var%value v = run_call(lfunc, l, mk_nil);\n            switch (v) {\n              case Coq_value_object(l0):\n                return (k());\n              default:\n                return (v);\n            }\n            \n          case None:\n            return (k());\n        }\n        \n      };\n      var gmeth = method_of_preftype(gpref);\n      return (\n        sub0(gmeth, function () {\n            var lmeth = method_of_preftype(lpref);\n            return (\n              sub0(lmeth, function () {\n                  return (run_error(Native_error_type));}));}));\n  }\n  \n};\n\nvar to_int32 = function (v) {\n  var%number n = to_number(v);\n  return (JsNumber.to_int32(n));\n};\n\nvar to_uint32 = function (v) {\n  var%number n = to_number(v);\n  return (JsNumber.to_uint32(n));\n};\n\nvar run_object_define_own_prop_array_loop = function (l, newLen, oldLen, newLenDesc, newWritable, throwcont, def) {\n  if ((newLen < oldLen)) {\n    var oldLen_2 = (oldLen - 1.);\n    var%string slen = to_string(Value_number(oldLen_2));\n    var%bool deleteSucceeded = object_delete(l, slen, false);\n    if (!(deleteSucceeded)) {\n      var newLenDesc0 = descriptor_with_value(newLenDesc,\n                          Some(Value_number((oldLen_2 + 1.))));\n      if (!(newWritable)) {\n        var newLenDesc1 = descriptor_with_writable(newLenDesc0, Some(false));\n      } else {\n        var newLenDesc1 = newLenDesc0;\n      }\n      var%bool x = def("length", newLenDesc1, false);\n      return (\n        out_error_or_cst(throwcont, Native_error_type, Value_bool(false)));\n    } else {\n      return (\n        run_object_define_own_prop_array_loop(l, newLen, oldLen_2,\n          newLenDesc, newWritable, throwcont, def));\n    }\n  } else {\n    if (!(newWritable)) {\n      return (\n        def("length", {\n            descriptor_value: None,\n            descriptor_writable: Some(false),\n            descriptor_get: None,\n            descriptor_set: None,\n            descriptor_enumerable: None,\n            descriptor_configurable: None}, false));\n    } else {\n      return (Value_bool(true));\n    }\n  }\n};\n\nvar object_define_own_prop = function (l, x, desc, throwcont) {\n  var reject = function (throwcont0) {\n    return (\n      out_error_or_cst(throwcont0, Native_error_type, Value_bool(false)));\n  };\n  var def = function (p, d, _pat_any_80) {\n    return (ordinary_define_own_property(l, Value_string(p), d));\n  };\n  var%some b = run_object_method(object_define_own_prop_, l);\n  switch (b) {\n    case Coq_builtin_define_own_prop_default:\n      return (object_internal_define_own_property(l, Value_string(x), desc));\n    case Coq_builtin_define_own_prop_array:\n      var%spec d = run_object_get_own_prop(l, "length");\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "Array length property descriptor cannot be undefined."));\n        case Coq_full_descriptor_some(attr):\n          switch (attr) {\n            case Coq_attributes_data_of(a):\n              var oldLen = a.attributes_data_value;\n              switch (oldLen) {\n                case Coq_value_object(l0):\n                  Debug.impossible_with_heap_because(__LOC__,\n                    "Spec asserts length of array is number.");\n                  return (Result_impossible);\n                default:\n                  var%number oldLen = to_number(oldLen);\n                  var oldLen0 = JsNumber.to_uint32(oldLen);\n                  var descValueOpt = desc.descriptor_value;\n                  if (string_eq(x, "length")) {\n                    switch (descValueOpt) {\n                      case Some(descValue):\n                        var%spec newLen = to_uint32(descValue);\n                        var%number newLenN = to_number(descValue);\n                        if (!((newLen === newLenN))) {\n                          return (run_error(Native_error_range));\n                        } else {\n                          var newLenDesc = descriptor_with_value(desc,\n                                             Some(Value_number(newLen)));\n                          if (le_int_decidable(oldLen0, newLen)) {\n                            return (def("length", newLenDesc, throwcont));\n                          } else {\n                            if (!(a.attributes_data_writable)) {\n                              return (reject(throwcont));\n                            } else {\n                              switch (newLenDesc.descriptor_writable) {\n                                case Some(b0):\n                                  if (b0) {\n                                    var newWritable = true;\n                                  } else {\n                                    var newWritable = false;\n                                  }\n                                  break;\n                                case None:\n                                  var newWritable = true;\n                                  break;\n                              }\n                              \n                              if (!(newWritable)) {\n                                var newLenDesc0 = descriptor_with_writable(\n                                                    newLenDesc, Some(true));\n                              } else {\n                                var newLenDesc0 = newLenDesc;\n                              }\n                              var%bool succ = def("length", newLenDesc0,\n                                                throwcont);\n                              if (!(succ)) {\n                                return (Value_bool(false));\n                              } else {\n                                return (\n                                  run_object_define_own_prop_array_loop(l,\n                                    newLen, oldLen0, newLenDesc0,\n                                    newWritable, throwcont, def));\n                              }\n                            }\n                          }\n                        }\n                      case None:\n                        return (def("length", desc, throwcont));\n                    }\n                    \n                  } else {\n                    var%spec ilen = to_uint32(Value_string(x));\n                    var%string slen = to_string(Value_number(ilen));\n                    if ((string_eq(x, slen) && !((ilen == 4294967295.)))) {\n                      var%spec index = to_uint32(Value_string(x));\n                      if ((le_int_decidable(oldLen0, index)\n                          && !(a.attributes_data_writable))) {\n                        return (reject(throwcont));\n                      } else {\n                        var%bool b0 = def(x, desc, false);\n                        if (!(b0)) {\n                          return (reject(throwcont));\n                        } else {\n                          if (le_int_decidable(oldLen0, index)) {\n                            var a0 = descriptor_with_value(\n                                       descriptor_of_attributes(a),\n                                       Some(Value_number((index + 1.))));\n                            return (def("length", a0, false));\n                          } else {\n                            return (Value_bool(true));\n                          }\n                        }\n                      }\n                    } else {\n                      return (def(x, desc, throwcont));\n                    }\n                  }\n              }\n              \n            case Coq_attributes_accessor_of(a):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Array length property descriptor cannot be accessor."));\n          }\n          \n      }\n      \n    case Coq_builtin_define_own_prop_args_obj:\n      var%some lmapo = run_object_method(object_parameter_map_, l);\n      var%some lmap = lmapo;\n      var%spec d = run_object_get_own_prop(lmap, x);\n      var%bool b0 = def(x, desc, false);\n      if (b0) {\n        var follow = function () {\n          return (Value_bool(true));\n        };\n        switch (d) {\n          case Coq_full_descriptor_undef:\n            return (follow());\n          case Coq_full_descriptor_some(a):\n            if (is_accessor_descriptor(Descriptor(desc))) {\n              var%bool x0 = object_delete(lmap, x, false);\n              return (follow());\n            } else {\n              var follow0 = function () {\n                if (option_compare(bool_eq, desc.descriptor_writable,\n                      Some(false))) {\n                  var%bool x0 = object_delete(lmap, x, false);\n                  return (follow());\n                } else {\n                  return (follow());\n                }\n              };\n              switch (desc.descriptor_value) {\n                case Some(v):\n                  var%void _ = object_put(lmap, x, v, throwcont);\n                  return (follow0());\n                case None:\n                  return (follow0());\n              }\n              \n            }\n        }\n        \n      } else {\n        return (reject(throwcont));\n      }\n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar prim_new_object = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_bool(b):\n      var o1 = object_new(Prealloc_bool_proto, "Boolean");\n      var o = object_with_primitive_value(o1, Value_bool(b));\n      var (l, s1) = object_alloc(o);\n      return (l);\n    case Coq_value_number(n):\n      var o1 = object_new(Prealloc_number_proto, "Number");\n      var o = object_with_primitive_value(o1, Value_number(n));\n      var (l, s1) = object_alloc(o);\n      return (l);\n    case Coq_value_string(s0):\n      var o2 = object_new(Prealloc_string_proto, "String");\n      var o1 = object_with_get_own_property(o2, Builtin_get_own_prop_string);\n      var o = object_with_primitive_value(o1, Value_string(s0));\n      var (l, s1) = object_alloc(o);\n      var%some _ = run_object_heap_map_properties(l, function (p) {\n                       return (\n                         HeapStr.write(p, "length",\n                           attributes_data_intro_constant(\n                             Value_number(strlength(s0)))));});\n      return (l);\n    default:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[prim_new_object] received an null or undef."));\n  }\n  \n};\n\nvar to_object = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_undef:\n      return (run_error_no_c(Native_error_type));\n    case Coq_value_null:\n      return (run_error_no_c(Native_error_type));\n    case Coq_value_bool(b):\n      return (prim_new_object(_foo_));\n    case Coq_value_number(n):\n      return (prim_new_object(_foo_));\n    case Coq_value_string(s0):\n      return (prim_new_object(_foo_));\n    case Coq_value_object(l):\n      return (l);\n  }\n  \n};\n\nvar run_object_prim_value = function (l) {\n  var%some ov = run_object_method(object_prim_value_, l);\n  var%some v = ov;\n  return (v);\n};\n\nvar prim_value_get = function (v, x) {\n  var%object l = to_object(v);\n  return (object_get_builtin(Builtin_get_default, v, l, x));\n};\n\nvar env_record_has_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      return (Value_bool(HeapStr.indom_dec(ed, x)));\n    case Coq_env_record_object(l0, pt):\n      return (object_has_prop(l0, x));\n  }\n  \n};\n\nvar lexical_env_get_identifier_ref = function (x, x0, str) {\n  switch (x) {\n    case []:\n      return (ref_create_value(Value_undef, x0, str));\n    case (l::x_2):\n      var%bool has = env_record_has_binding(l, x0);\n      if (has) {\n        return (ref_create_env_loc(l, x0, str));\n      } else {\n        return (lexical_env_get_identifier_ref(x_2, x0, str));\n      }\n  }\n  \n};\n\nvar object_delete = function (l, x, str) {\n  var%some b = run_object_method(object_delete_, l);\n  switch (b) {\n    case Coq_builtin_delete_default:\n      return (object_delete_default(l, x, str));\n    case Coq_builtin_delete_args_obj:\n      var%some mo = run_object_method(object_parameter_map_, l);\n      var%some m = mo;\n      var%spec d = run_object_get_own_prop(m, x);\n      var%bool b0 = object_delete_default(l, x, str);\n      if (b0) {\n        switch (d) {\n          case Coq_full_descriptor_undef:\n            return (Value_bool(b0));\n          case Coq_full_descriptor_some(a):\n            var%bool b_2 = object_delete(m, x, false);\n            return (Value_bool(b0));\n        }\n        \n      } else {\n        return (Value_bool(b0));\n      }\n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar env_record_delete_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      switch (HeapStr.read_option(ed, x)) {\n        case Some(p):\n          var (mu, v) = p;\n          switch (mu) {\n            case Coq_mutability_uninitialized_immutable:\n              return (Value_bool(false));\n            case Coq_mutability_immutable:\n              return (Value_bool(false));\n            case Coq_mutability_nondeletable:\n              return (Value_bool(false));\n            case Coq_mutability_deletable:\n              var s_2 = env_record_write(l, decl_env_record_rem(ed, x));\n              return (Value_bool(true));\n          }\n          \n        case None:\n          return (Value_bool(true));\n      }\n      \n    case Coq_env_record_object(l0, pt):\n      return (object_delete(l0, x, throw_false));\n  }\n  \n};\n\nvar env_record_implicit_this_value = function (l) {\n  return (\n    ifx_some_or_default(env_record_binds_option(l), None, function (e) {\n        return (\n          Some((function () {\n              switch (e) {\n                case Coq_env_record_decl(ed):\n                  return (Value_undef);\n                case Coq_env_record_object(l0, provide_this):\n                  if (provide_this) {\n                    return (l0);\n                  } else {\n                    return (Value_undef);\n                  }\n              }\n              }())));}));\n};\n\nvar identifier_resolution = function (x) {\n  var x0 = c.execution_ctx_lexical_env;\n  var str = c.execution_ctx_strict;\n  return (lexical_env_get_identifier_ref(x0, x, str));\n};\n\nvar env_record_get_binding_value = function (c, l, x, str) {\n  return (get_binding_value(l, Value_string(x), str));\n};\n\nvar ref_get_value = function (_foo_) {\n  var%value v = get_value(_foo_);\n  return (v);\n};\n\nvar run_expr_get_value = function (e) {\n  var result = run_expr(e);\n  var%ter _pat_any_81 = result;\n  var%value v = get_value(result);\n  return (v);\n};\n\nvar env_record_set_mutable_binding = function (l, x, v, str) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      var%some rm = HeapStr.read_option(ed, x);\n      var (mu, v_old) = rm;\n      if (!(mutability_compare(mu, Mutability_immutable))) {\n        return (res_void(env_record_write_decl_env(l, x, mu, v)));\n      } else {\n        return (out_error_or_void(str, Native_error_type));\n      }\n    case Coq_env_record_object(l0, pt):\n      var%success _pat_any_82 = object_put(l0, x, v, str);\n      return (res_void());\n  }\n  \n};\n\nvar ref_put_value = function (rv, v) {\n  var%success _pat_any_83 = put_value(rv, v);\n  return (res_void());\n};\n\nvar env_record_create_mutable_binding = function (l, x, deletable_opt) {\n  var deletable = unsome_default(false, deletable_opt);\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      if (HeapStr.indom_dec(ed, x)) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared environnment record in [env_record_create_mutable_binding]."));\n      } else {\n        var s_2 = env_record_write_decl_env(l, x,\n                    mutability_of_bool(deletable), Value_undef);\n        return (res_void());\n      }\n    case Coq_env_record_object(l0, pt):\n      var%bool has = object_has_prop(l0, x);\n      if (has) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared binding in [env_record_create_mutable_binding]."));\n      } else {\n        var a = {\n          attributes_data_value: Value_undef,\n          attributes_data_writable: true,\n          attributes_data_enumerable: true,\n          attributes_data_configurable: deletable\n        };\n        var%success rv = object_define_own_prop(l0, x,\n                           descriptor_of_attributes(a), throw_true);\n        return (res_void());\n      }\n  }\n  \n};\n\nvar env_record_create_set_mutable_binding = function (l, x, deletable_opt, v, str) {\n  var%void _ = env_record_create_mutable_binding(l, x, deletable_opt);\n  return (env_record_set_mutable_binding(l, x, v, str));\n};\n\nvar env_record_create_immutable_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      if (HeapStr.indom_dec(ed, x)) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared environnment record in [env_record_create_immutable_binding]."));\n      } else {\n        return (\n          res_void(\n            env_record_write_decl_env(l, x,\n              Mutability_uninitialized_immutable, Value_undef)));\n      }\n    case Coq_env_record_object(o, p):\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[env_record_create_immutable_binding] received an environnment record object."));\n  }\n  \n};\n\nvar env_record_initialize_immutable_binding = function (l, x, v) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      var%some evs = decl_env_record_option(ed, x);\n      if (prod_compare(mutability_compare, value_compare, evs,\n            [Mutability_uninitialized_immutable, Value_undef])) {\n        var s_2 = env_record_write_decl_env(l, x, Mutability_immutable, v);\n        return (res_void());\n      } else {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Non suitable binding in [env_record_initialize_immutable_binding]."));\n      }\n    case Coq_env_record_object(o, p):\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[env_record_initialize_immutable_binding] received an environnment record object."));\n  }\n  \n};\n\nvar call_object_new = function (v) {\n  switch (type_of(v)) {\n    case Coq_type_undef:\n      var o = object_new(Prealloc_object_proto, "Object");\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      return (l);\n    case Coq_type_null:\n      var o = object_new(Prealloc_object_proto, "Object");\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      return (l);\n    case Coq_type_bool:\n      return (to_object(v));\n    case Coq_type_number:\n      return (to_object(v));\n    case Coq_type_string:\n      return (to_object(v));\n    case Coq_type_object:\n      return (v);\n  }\n  \n};\n\nvar array_args_map_loop = function (l, args, ind) {\n  switch (args) {\n    case []:\n      return (res_void());\n    case (h::rest):\n      var%some _ = run_object_heap_map_properties(l, function (p) {\n                       return (\n                         HeapStr.write(p, JsNumber.to_string(ind),\n                           attributes_data_intro_all_true(h)));});\n      return (array_args_map_loop(l, rest, (ind + 1.)));\n  }\n  \n};\n\nvar run_construct_prealloc = function (b, args) {\n  switch (b) {\n    case Coq_prealloc_object:\n      var v = get_arg(0, args);\n      return (call_object_new(v));\n    case Coq_prealloc_bool:\n      var v = get_arg(0, args);\n      var b0 = to_boolean(v);\n      var o1 = object_new(Prealloc_bool_proto, "Boolean");\n      var o = object_with_primitive_value(o1, Value_bool(b0));\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      return (l);\n    case Coq_prealloc_number:\n      var follow = function (v) {\n        var o1 = object_new(Prealloc_number_proto, "Number");\n        var o = object_with_primitive_value(o1, v);\n        var (l, s1) = object_alloc(o);\n        return (l);\n      };\n      if (list_eq_nil_decidable(args)) {\n        return (follow(Value_number(JsNumber.zero)));\n      } else {\n        var v = get_arg(0, args);\n        var%number x0 = to_number(v);\n        return (follow(Value_number(x0)));\n      }\n    case Coq_prealloc_array:\n      var o_2 = object_new(Prealloc_array_proto, "Array");\n      var o = object_for_array(o_2, Builtin_define_own_prop_array);\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      var follow = function (length0) {\n        var%some _ = run_object_heap_map_properties(l, function (p0) {\n                         return (\n                           HeapStr.write(p0, "length", {\n                               attributes_data_value: Value_number(length0),\n                               attributes_data_writable: true,\n                               attributes_data_enumerable: false,\n                               attributes_data_configurable: false}));});\n        return (l);\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 1)) {\n        var v = get_arg(0, args);\n        switch (v) {\n          case Coq_value_undef:\n            var%some _ = run_object_heap_map_properties(l, function (p1) {\n                             return (\n                               HeapStr.write(p1, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n          case Coq_value_null:\n            var%some _ = run_object_heap_map_properties(l, function (p1) {\n                             return (\n                               HeapStr.write(p1, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n          case Coq_value_bool(b0):\n            var%some _ = run_object_heap_map_properties(l, function (p1) {\n                             return (\n                               HeapStr.write(p1, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n          case Coq_value_number(vlen):\n            var%spec ilen = to_uint32(Value_number(vlen));\n            if ((ilen === vlen)) {\n              return (follow(ilen));\n            } else {\n              return (run_error(Native_error_range));\n            }\n          case Coq_value_string(s0):\n            var%some _ = run_object_heap_map_properties(l, function (p1) {\n                             return (\n                               HeapStr.write(p1, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n          case Coq_value_object(o0):\n            var%some _ = run_object_heap_map_properties(l, function (p0) {\n                             return (\n                               HeapStr.write(p0, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n        }\n        \n      } else {\n        var%some _ = run_object_heap_map_properties(l, function (p0) {\n                         return (\n                           HeapStr.write(p0, "length", {\n                               attributes_data_value: Value_number(arg_len),\n                               attributes_data_writable: true,\n                               attributes_data_enumerable: false,\n                               attributes_data_configurable: false}));});\n        var%void _ = array_args_map_loop(l, args, 0.);\n        return (l);\n      }\n    case Coq_prealloc_string:\n      var o2 = object_new(Prealloc_string_proto, "String");\n      var o1 = object_with_get_own_property(o2, Builtin_get_own_prop_string);\n      var follow = function (s1) {\n        var o = object_with_primitive_value(o1, Value_string(s1));\n        var (l, s2) = object_alloc(o);\n        var lenDesc = attributes_data_intro_constant(\n                        Value_number(strlength(s1)));\n        var%some _ = run_object_heap_map_properties(l, function (p) {\n                         return (HeapStr.write(p, "length", lenDesc));});\n        return (l);\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 0)) {\n        return (follow(""));\n      } else {\n        var arg = get_arg(0, args);\n        var%string s1 = to_string(arg);\n        return (follow(s1));\n      }\n    case Coq_prealloc_error:\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_error_proto, v));\n    case Coq_prealloc_native_error(ne):\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_native_error_proto(ne), v));\n    case Coq_prealloc_proxy:\n      return (\n        builtin_proxy_constructor({}, {}, Prealloc_proxy, get_arg(0, args),\n          get_arg(1, args)));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}(\n          strappend("Construct prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented."))));\n  }\n  \n};\n\nvar run_construct_default = function (l, args) {\n  var%value v1 = run_object_get(l, "prototype");\n  if (type_compare(type_of(v1), Type_object)) {\n    var vproto = v1;\n  } else {\n    var vproto = Prealloc_object_proto;\n  }\n  var o = object_new(vproto, "Object");\n  var p = object_alloc(o);\n  var (l_2, s2) = p;\n  var%value v2 = run_call(l, l_2, args);\n  if (type_compare(type_of(v2), Type_object)) {\n    var vr = v2;\n  } else {\n    var vr = l_2;\n  }\n  return (vr);\n};\n\nvar run_construct = function (co, l, args) {\n  switch (co) {\n    case Coq_construct_default:\n      return (run_construct_default(l, args));\n    case Coq_construct_after_bind:\n      var%some otrg = run_object_method(object_target_function_, l);\n      var%some target = otrg;\n      var%some oco = run_object_method(object_construct_, target);\n      switch (oco) {\n        case Some(co0):\n          var%some oarg = run_object_method(object_bound_args_, l);\n          var%some boundArgs = oarg;\n          var arguments_ = LibList.append(boundArgs, args);\n          return (run_construct(co0, target, arguments_));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_construct_prealloc(b):\n      return (run_construct_prealloc(b, args));\n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar run_call_default = function (lf) {\n  var def = Value_undef;\n  var%some oC = run_object_method(object_code_, lf);\n  switch (oC) {\n    case Some(bd):\n      if (list_eq_nil_decidable(prog_elements(funcbody_prog(bd)))) {\n        return (def);\n      } else {\n        return (\n          ifx_success_or_return(run_prog(funcbody_prog(bd)), function () {\n              return (Value_undef);}, function (rv) { return (rv);}));\n      }\n    case None:\n      return (def);\n  }\n  \n};\n\nvar creating_function_object_proto = function (l) {\n  var%object lproto = run_construct_prealloc(Prealloc_object, mk_nil);\n  var a1 = {\n    attributes_data_value: l,\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  var%bool b = object_define_own_prop(lproto, "constructor",\n                 descriptor_of_attributes(a1), false);\n  var a2 = {\n    attributes_data_value: lproto,\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  return (\n    object_define_own_prop(l, "prototype", descriptor_of_attributes(a2),\n      false));\n};\n\nvar creating_function_object = function (names, bd, x, str) {\n  var o = object_new(Prealloc_function_proto, "Function");\n  var o2 = object_with_invokation(o, Some(Construct_default),\n             Some(Call_default), Some(Builtin_has_instance_function));\n  var o3 = object_with_details(o2, Some(x), Some(names), Some(bd), None,\n             None, None, None);\n  var p = object_alloc(o3);\n  var (l, s1) = p;\n  var a1 = {\n    attributes_data_value: Value_number(LibList.length(names)),\n    attributes_data_writable: false,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  var%bool b2 = object_define_own_prop(l, "length",\n                  descriptor_of_attributes(a1), false);\n  var%bool b3 = creating_function_object_proto(l);\n  if (!(str)) {\n    return (l);\n  } else {\n    var vthrower = Prealloc_throw_type_error;\n    var a2 = {\n      attributes_accessor_get: vthrower,\n      attributes_accessor_set: vthrower,\n      attributes_accessor_enumerable: false,\n      attributes_accessor_configurable: false\n    };\n    var%bool b4 = object_define_own_prop(l, "caller",\n                    descriptor_of_attributes(a2), false);\n    var%bool b5 = object_define_own_prop(l, "arguments",\n                    descriptor_of_attributes(a2), false);\n    return (l);\n  }\n};\n\nvar binding_inst_formal_params = function (l, args, names, str) {\n  switch (names) {\n    case []:\n      return (res_void());\n    case (argname::names_2):\n      var v = hd(Value_undef, args);\n      var args_2 = tl(args);\n      var%bool hb = env_record_has_binding(l, argname);\n      var follow = function () {\n        var%void _ = env_record_set_mutable_binding(l, argname, v, str);\n        return (binding_inst_formal_params(l, args_2, names_2, str));\n      };\n      if (hb) {\n        return (follow());\n      } else {\n        var%void _ = env_record_create_mutable_binding(l, argname, None);\n        return (follow());\n      }\n  }\n  \n};\n\nvar binding_inst_function_decls = function (l, fds, str, bconfig) {\n  switch (fds) {\n    case []:\n      return (res_void());\n    case (fd::fds_2):\n      var fbd = fd.funcdecl_body;\n      var str_fd = funcbody_is_strict(fbd);\n      var fparams = fd.funcdecl_parameters;\n      var fname = fd.funcdecl_name;\n      var%object fo = creating_function_object(fparams, fbd,\n                        c.execution_ctx_variable_env, str_fd);\n      var follow = function () {\n        var%void _ = env_record_set_mutable_binding(l, fname, fo, str);\n        return (binding_inst_function_decls(l, fds_2, str, bconfig));\n      };\n      var%bool has = env_record_has_binding(l, fname);\n      if (has) {\n        if (nat_eq(l, env_loc_global_env_record)) {\n          var%spec d = run_object_get_prop(Prealloc_global, fname);\n          switch (d) {\n            case Coq_full_descriptor_undef:\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Undefined full descriptor in [binding_inst_function_decls]."));\n            case Coq_full_descriptor_some(a):\n              if (attributes_configurable(a)) {\n                var a_2 = {\n                  attributes_data_value: Value_undef,\n                  attributes_data_writable: true,\n                  attributes_data_enumerable: true,\n                  attributes_data_configurable: bconfig\n                };\n                var%bool x = object_define_own_prop(Prealloc_global, fname,\n                               descriptor_of_attributes(a_2), true);\n                return (follow());\n              } else {\n                if ((is_accessor_descriptor(\n                       Descriptor(descriptor_of_attributes(a)))\n                    || (!(attributes_writable(a))\n                       || !(attributes_enumerable(a))))) {\n                  return (run_error(Native_error_type));\n                } else {\n                  return (follow());\n                }\n              }\n          }\n          \n        } else {\n          return (follow());\n        }\n      } else {\n        var%void _ = env_record_create_mutable_binding(l, fname,\n                       Some(bconfig));\n        return (follow());\n      }\n  }\n  \n};\n\nvar make_arg_getter = function (x, x0) {\n  var xbd = strappend("return ", strappend(x, ";"));\n  var bd = Funcbody_intro(\n             Prog_intro(true,\n               mk_cons(Element_stat(Stat_return(Some(Expr_identifier(x)))),\n                 mk_nil)), xbd);\n  return (creating_function_object(mk_nil, bd, x0, true));\n};\n\nvar make_arg_setter = function (x, x0) {\n  var xparam = strappend(x, "_arg");\n  var xbd = strappend(x, strappend(" = ", strappend(xparam, ";")));\n  var bd = Funcbody_intro(\n             Prog_intro(true,\n               mk_cons(\n                 Element_stat(\n                   Stat_expr(\n                     Expr_assign(Expr_identifier(x), None,\n                       Expr_identifier(xparam)))), mk_nil)), xbd);\n  return (creating_function_object(mk_cons(xparam, mk_nil), bd, x0, true));\n};\n\nvar arguments_object_map_loop = function (l, xs, len, args, x, str, lmap, xsmap) {\n  return (\n    function (fO, fS, n) {\n        if (int_eq(n, 0)) {\n          return (fO({}));\n        } else {\n          return (fS((n - 1)));\n        }}(function (_pat_any_84) {\n        if (list_eq_nil_decidable(xsmap)) {\n          return (res_void());\n        } else {\n          var%some o = object_binds_option(l);\n          var o_2 = object_for_args_object(o, lmap, Builtin_get_args_obj,\n                      Builtin_get_own_prop_args_obj,\n                      Builtin_define_own_prop_args_obj,\n                      Builtin_delete_args_obj);\n          return (res_void(object_write(l, o_2)));\n        }}, function (len_2) {\n        var tdl = take_drop_last(args);\n        var (rmlargs, largs) = tdl;\n        var arguments_object_map_loop_2 = function (xsmap0) {\n          return (\n            arguments_object_map_loop(l, xs, len_2, rmlargs, x, str, lmap,\n              xsmap0));\n        };\n        var a = attributes_data_intro_all_true(largs);\n        var%string tempVar = to_string(Value_number(len_2));\n        var%bool b = object_define_own_prop(l, tempVar,\n                       descriptor_of_attributes(a), false);\n        if (ge_nat_decidable(len_2, LibList.length(xs))) {\n          return (arguments_object_map_loop_2(xsmap));\n        } else {\n          var dummy = "";\n          var x0 = nth_def(dummy, len_2, xs);\n          if ((str || mem_decide(string_eq, x0, xsmap))) {\n            return (arguments_object_map_loop_2(xsmap));\n          } else {\n            var%object lgetter = make_arg_getter(x0, x);\n            var%object lsetter = make_arg_setter(x0, x);\n            var a_2 = {\n              attributes_accessor_get: lgetter,\n              attributes_accessor_set: lsetter,\n              attributes_accessor_enumerable: false,\n              attributes_accessor_configurable: true\n            };\n            var%string tempVar = to_string(Value_number(len_2));\n            var%bool b_2 = object_define_own_prop(lmap, tempVar,\n                             descriptor_of_attributes(a_2), false);\n            return (arguments_object_map_loop_2(mk_cons(x0, xsmap)));\n          }\n        }}, len));\n};\n\nvar arguments_object_map = function (l, xs, args, x, str) {\n  var%object lmap = run_construct_prealloc(Prealloc_object, mk_nil);\n  return (\n    arguments_object_map_loop(l, xs, LibList.length(args), args, x, str,\n      lmap, mk_nil));\n};\n\nvar create_arguments_object = function (lf, xs, args, x, str) {\n  var o = object_create_builtin(Prealloc_object_proto, "Arguments",\n            Heap.empty);\n  var p = object_alloc(o);\n  var (l, s_2) = p;\n  var a = {\n    attributes_data_value: Value_number(LibList.length(args)),\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  var%bool b = object_define_own_prop(l, "length",\n                 descriptor_of_attributes(a), false);\n  var%void _ = arguments_object_map(l, xs, args, x, str);\n  if (str) {\n    var vthrower = Prealloc_throw_type_error;\n    var a0 = {\n      attributes_accessor_get: vthrower,\n      attributes_accessor_set: vthrower,\n      attributes_accessor_enumerable: false,\n      attributes_accessor_configurable: false\n    };\n    var%bool b_2 = object_define_own_prop(l, "caller",\n                     descriptor_of_attributes(a0), false);\n    var%bool b_3 = object_define_own_prop(l, "callee",\n                     descriptor_of_attributes(a0), false);\n    return (l);\n  } else {\n    var a0 = {\n      attributes_data_value: lf,\n      attributes_data_writable: true,\n      attributes_data_enumerable: false,\n      attributes_data_configurable: true\n    };\n    var%bool b_2 = object_define_own_prop(l, "callee",\n                     descriptor_of_attributes(a0), false);\n    return (l);\n  }\n};\n\nvar binding_inst_arg_obj = function (lf, p, xs, args, l) {\n  var arguments_ = "arguments";\n  var str = prog_intro_strictness(p);\n  var%object largs = create_arguments_object(lf, xs, args,\n                       c.execution_ctx_variable_env, str);\n  if (str) {\n    var%void _ = env_record_create_immutable_binding(l, arguments_);\n    return (env_record_initialize_immutable_binding(l, arguments_, largs));\n  } else {\n    return (\n      env_record_create_set_mutable_binding(l, arguments_, None, largs,\n        false));\n  }\n};\n\nvar binding_inst_var_decls = function (l, vds, bconfig, str) {\n  switch (vds) {\n    case []:\n      return (res_void());\n    case (vd::vds_2):\n      var bivd = function () {\n        return (binding_inst_var_decls(l, vds_2, bconfig, str));\n      };\n      var%bool has = env_record_has_binding(l, vd);\n      if (has) {\n        return (bivd());\n      } else {\n        var%void _ = env_record_create_set_mutable_binding(l, vd,\n                       Some(bconfig), Value_undef, str);\n        return (bivd());\n      }\n  }\n  \n};\n\nvar execution_ctx_binding_inst = function (ct, funco, p, args) {\n  switch (c.execution_ctx_variable_env) {\n    case []:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst]."));\n    case (l::l0):\n      var str = prog_intro_strictness(p);\n      var follow = function (names) {\n        var bconfig = codetype_compare(ct, Codetype_eval);\n        var fds = prog_funcdecl(p);\n        var%void _ = binding_inst_function_decls(l, fds, str, bconfig);\n        var%bool bdefined = env_record_has_binding(l, "arguments");\n        var follow2 = function () {\n          var vds = prog_vardecl(p);\n          return (binding_inst_var_decls(l, vds, bconfig, str));\n        };\n        switch (ct) {\n          case Coq_codetype_func:\n            switch (funco) {\n              case Some(func):\n                if (bdefined) {\n                  return (follow2());\n                } else {\n                  var%void _ = binding_inst_arg_obj(func, p, names, args, l);\n                  return (follow2());\n                }\n              case None:\n                if (bdefined) {\n                  return (follow2());\n                } else {\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "Weird `arguments\' object in [execution_ctx_binding_inst]."));\n                }\n            }\n            \n          case Coq_codetype_global:\n            return (follow2());\n          case Coq_codetype_eval:\n            return (follow2());\n        }\n        \n      };\n      switch (ct) {\n        case Coq_codetype_func:\n          switch (funco) {\n            case Some(func):\n              var%some nameso = run_object_method(object_formal_parameters_,\n                                  func);\n              var%some names = nameso;\n              var%void _ = binding_inst_formal_params(l, args, names, str);\n              return (follow(names));\n            case None:\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent functionnal code type in [execution_ctx_binding_inst]."));\n          }\n          \n        case Coq_codetype_global:\n          switch (funco) {\n            case Some(o):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case None:\n              return (follow(mk_nil));\n          }\n          \n        case Coq_codetype_eval:\n          switch (funco) {\n            case Some(o):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case None:\n              return (follow(mk_nil));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar entering_func_code = function (lf, vthis, args) {\n  var%some bdo = run_object_method(object_code_, lf);\n  var%some bd = bdo;\n  var str = funcbody_is_strict(bd);\n  var follow = function (vthis_2) {\n    var%some lexo = run_object_method(object_scope_, lf);\n    var%some lex = lexo;\n    var p = lexical_env_alloc_decl(lex);\n    var (lex_2, s1) = p;\n    var c_2 = execution_ctx_intro_same(lex_2, vthis_2, str);\n    var%void _ = execution_ctx_binding_inst(Codetype_func, Some(lf),\n                   funcbody_prog(bd), args);\n    return (run_call_default(lf));\n  };\n  if (str) {\n    return (follow(vthis));\n  } else {\n    switch (vthis) {\n      case Coq_value_undef:\n        return (follow(Prealloc_global));\n      case Coq_value_null:\n        return (follow(Prealloc_global));\n      case Coq_value_bool(b):\n        var%value v = to_object(vthis);\n        return (follow(v));\n      case Coq_value_number(n):\n        var%value v = to_object(vthis);\n        return (follow(v));\n      case Coq_value_string(s0):\n        var%value v = to_object(vthis);\n        return (follow(v));\n      case Coq_value_object(lthis):\n        return (follow(vthis));\n    }\n    \n  }\n};\n\nvar run_object_get_own_prop = function (l, x) {\n  var%some b = run_object_method(object_get_own_prop_, l);\n  var def = function () {\n    var%some p = run_object_method(object_properties_, l);\n    return (\n      ifx_some_or_default(\n        convert_option_attributes(HeapStr.read_option(p, x)),\n        Full_descriptor_undef, function (x) { return (x);}));\n  };\n  switch (b) {\n    case Coq_builtin_get_own_prop_default:\n      return (def());\n    case Coq_builtin_get_own_prop_args_obj:\n      var%spec d = def();\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (Full_descriptor_undef);\n        case Coq_full_descriptor_some(a):\n          var%some lmapo = run_object_method(object_parameter_map_, l);\n          var%some lmap = lmapo;\n          var%spec d0 = run_object_get_own_prop(lmap, x);\n          var follow = function (a0) {\n            return (a0);\n          };\n          switch (d0) {\n            case Coq_full_descriptor_undef:\n              return (follow(a));\n            case Coq_full_descriptor_some(amap):\n              var%value v = run_object_get(lmap, x);\n              switch (a) {\n                case Coq_attributes_data_of(ad):\n                  return (follow(attributes_data_with_value(ad, v)));\n                case Coq_attributes_accessor_of(aa):\n                  Debug.impossible_with_heap_because(__LOC__,\n                    "[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens.");\n                  return (Result_impossible);\n              }\n              \n          }\n          \n      }\n      \n    case Coq_builtin_get_own_prop_string:\n      var%spec d = def();\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          var%spec k = to_int32(Value_string(x));\n          var%string s3 = to_string(Value_number(JsNumber.absolute(k)));\n          if (!(string_eq(x, s3))) {\n            return (Full_descriptor_undef);\n          } else {\n            var%string str = run_object_prim_value(l);\n            var%spec k0 = to_int32(Value_string(x));\n            var len = strlength(str);\n            if (le_int_decidable(len, k0)) {\n              return (Full_descriptor_undef);\n            } else {\n              var resultStr = string_sub(str, int_of_number(k0), 1);\n              var a = {\n                attributes_data_value: Value_string(resultStr),\n                attributes_data_writable: false,\n                attributes_data_enumerable: true,\n                attributes_data_configurable: false\n              };\n              return (a);\n            }\n          }\n        case Coq_full_descriptor_some(a):\n          return (d);\n      }\n      \n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar run_function_has_instance = function (lv, _foo_) {\n  switch (_foo_) {\n    case Coq_value_object(lo):\n      var%some vproto = run_object_method(object_proto_, lv);\n      switch (vproto) {\n        case Coq_value_null:\n          return (Value_bool(false));\n        case Coq_value_object(proto):\n          if (object_loc_compare(proto, lo)) {\n            return (Value_bool(true));\n          } else {\n            return (run_function_has_instance(proto, lo));\n          }\n        default:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "Primitive found in the prototype chain in [run_object_has_instance_loop]."));\n      }\n      \n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_object_has_instance = function (b, l, v) {\n  switch (b) {\n    case Coq_builtin_has_instance_function:\n      switch (v) {\n        case Coq_value_object(lv):\n          var%value vproto = run_object_get(l, "prototype");\n          switch (vproto) {\n            case Coq_value_object(lproto):\n              return (run_function_has_instance(lv, lproto));\n            default:\n              return (run_error(Native_error_type));\n          }\n          \n        default:\n          return (Value_bool(false));\n      }\n      \n    case Coq_builtin_has_instance_after_bind:\n      var%some ol = run_object_method(object_target_function_, l);\n      var%some l0 = ol;\n      var%some ob = run_object_method(object_has_instance_, l0);\n      switch (ob) {\n        case Some(b0):\n          return (run_object_has_instance(b0, l0, v));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n  }\n  \n};\n\nvar from_prop_descriptor = function (_foo_) {\n  switch (_foo_) {\n    case Coq_full_descriptor_undef:\n      return (Value_undef);\n    case Coq_full_descriptor_some(a):\n      var%object l = run_construct_prealloc(Prealloc_object, mk_nil);\n      var follow = function (x) {\n        var a1 = attributes_data_intro_all_true(\n                   Value_bool(attributes_enumerable(a)));\n        var%bool x0 = object_define_own_prop(l, "enumerable",\n                        descriptor_of_attributes(a1), throw_false);\n        var a2 = attributes_data_intro_all_true(\n                   Value_bool(attributes_configurable(a)));\n        var%bool x1 = object_define_own_prop(l, "configurable",\n                        descriptor_of_attributes(a2), throw_false);\n        return (l);\n      };\n      switch (a) {\n        case Coq_attributes_data_of(ad):\n          var a1 = attributes_data_intro_all_true(ad.attributes_data_value);\n          var%bool x = object_define_own_prop(l, "value",\n                         descriptor_of_attributes(a1), throw_false);\n          var a2 = attributes_data_intro_all_true(\n                     Value_bool(ad.attributes_data_writable));\n          var%bool v = object_define_own_prop(l, "writable",\n                         descriptor_of_attributes(a2), throw_false);\n          return (follow(v));\n        case Coq_attributes_accessor_of(aa):\n          var a1 = attributes_data_intro_all_true(aa.attributes_accessor_get);\n          var%bool x = object_define_own_prop(l, "get",\n                         descriptor_of_attributes(a1), throw_false);\n          var a2 = attributes_data_intro_all_true(aa.attributes_accessor_set);\n          var%bool v = object_define_own_prop(l, "set",\n                         descriptor_of_attributes(a2), throw_false);\n          return (follow(v));\n      }\n      \n  }\n  \n};\n\nvar run_equal = function (v1, v2) {\n  var conv_number = function (v) {\n    return (to_number(v));\n  };\n  var conv_primitive = function (v) {\n    return (to_primitive(v, None));\n  };\n  var checkTypesThen = function (v3, v4, k) {\n    var ty1 = type_of(v3);\n    var ty2 = type_of(v4);\n    if (type_compare(ty1, ty2)) {\n      return (Value_bool(equality_test_for_same_type(ty1, v3, v4)));\n    } else {\n      return (k(ty1, ty2));\n    }\n  };\n  return (\n    checkTypesThen(v1, v2, function (ty1, ty2) {\n        var dc_conv = function (v3, f, v4) {\n          var%value v2_2 = f(v4);\n          return (run_equal(v3, v2_2));\n        };\n        var so = function (b) {\n          return (Value_bool(b));\n        };\n        if ((type_compare(ty1, Type_null) && type_compare(ty2, Type_undef))) {\n          return (so(true));\n        } else {\n          if ((type_compare(ty1, Type_undef) && type_compare(ty2, Type_null))) {\n            return (so(true));\n          } else {\n            if ((type_compare(ty1, Type_number)\n                && type_compare(ty2, Type_string))) {\n              return (dc_conv(v1, conv_number, v2));\n            } else {\n              if ((type_compare(ty1, Type_string)\n                  && type_compare(ty2, Type_number))) {\n                return (dc_conv(v2, conv_number, v1));\n              } else {\n                if (type_compare(ty1, Type_bool)) {\n                  return (dc_conv(v2, conv_number, v1));\n                } else {\n                  if (type_compare(ty2, Type_bool)) {\n                    return (dc_conv(v1, conv_number, v2));\n                  } else {\n                    if (((type_compare(ty1, Type_string)\n                         || type_compare(ty1, Type_number))\n                        && type_compare(ty2, Type_object))) {\n                      return (dc_conv(v1, conv_primitive, v2));\n                    } else {\n                      if ((type_compare(ty1, Type_object)\n                          && (type_compare(ty2, Type_string)\n                             || type_compare(ty2, Type_number)))) {\n                        return (dc_conv(v2, conv_primitive, v1));\n                      } else {\n                        return (so(false));\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }}));\n};\n\nvar convert_twice = function (ifv, kC, v1, v2) {\n  return (\n    ifv(kC(v1), function (vc1) {\n        return (ifv(kC(v2), function (vc2) { return ([vc1, vc2]);}));}));\n};\n\nvar convert_twice_primitive = function (v1, v2) {\n  return (\n    convert_twice(ifx_prim, function (v) { return (to_primitive(v, None));},\n      v1, v2));\n};\n\nvar convert_twice_number = function (v1, v2) {\n  return (\n    convert_twice(ifx_number, function (v) { return (to_number(v));}, v1, v2));\n};\n\nvar convert_twice_string = function (v1, v2) {\n  return (\n    convert_twice(ifx_string, function (v) { return (to_string(v));}, v1, v2));\n};\n\nvar issome = function (_foo_) {\n  switch (_foo_) {\n    case Some(t):\n      return (true);\n    case None:\n      return (false);\n  }\n  \n};\n\nvar run_binary_op_add = function (v1, v2) {\n  var%spec (w1, w2) = convert_twice_primitive(v1, v2);\n  if ((type_compare(type_of(w1), Type_string)\n      || type_compare(type_of(w2), Type_string))) {\n    var%spec (str1, str2) = convert_twice_string(w1, w2);\n    return (Value_string(strappend(str1, str2)));\n  } else {\n    var%spec (n1, n2) = convert_twice_number(w1, w2);\n    return (Value_number((n1 + n2)));\n  }\n};\n\nvar run_binary_op_arith = function (mathop, v1, v2) {\n  var%spec nn = convert_twice_number(v1, v2);\n  var (n1, n2) = nn;\n  return (Value_number(mathop(n1, n2)));\n};\n\nvar run_binary_op_shift = function (b_unsigned, mathop, v1, v2) {\n  if (b_unsigned) {\n    var conv = to_uint32;\n  } else {\n    var conv = to_int32;\n  }\n  var%spec k1 = conv(v1);\n  var%spec k2 = to_uint32(v2);\n  var k2_2 = JsNumber.modulo_32(k2);\n  return (Value_number(mathop(k1, k2_2)));\n};\n\nvar run_binary_op_bitwise = function (mathop, v1, v2) {\n  var%spec k1 = to_int32(v1);\n  var%spec k2 = to_int32(v2);\n  return (Value_number(mathop(k1, k2)));\n};\n\nvar run_binary_op_compare = function (b_swap, b_neg, v1, v2) {\n  var%spec ww = convert_twice_primitive(v1, v2);\n  var (w1, w2) = ww;\n  if (b_swap) {\n    var p = [w2, w1];\n  } else {\n    var p = [w1, w2];\n  }\n  var (wa, wb) = p;\n  var%_ret (s, wr) = (function () {\n      if ((_compare_JsSyntax_coq_type(type_of(wa), Type_string)\n          && _compare_JsSyntax_coq_type(type_of(wb), Type_string))) {\n        return (\n          Continue(\n            [s, Value_bool(\n                  inequality_test_string(string_of_value(wb),\n                    string_of_value(wb)))]));\n      } else {\n        var%number_ret nx = to_number(wa);\n        var%number_ret ny = to_number(wb);\n        return (Continue([s, inequality_test_number(nx, ny)]));\n      }}());\n  if (value_compare(wr, Value_undef)) {\n    return (Value_bool(false));\n  } else {\n    if ((b_neg && value_compare(wr, Value_bool(true)))) {\n      return (Value_bool(false));\n    } else {\n      if ((b_neg && value_compare(wr, Value_bool(false)))) {\n        return (Value_bool(true));\n      } else {\n        return (wr);\n      }\n    }\n  }\n};\n\nvar run_binary_op_instanceof = function (v1, v2) {\n  switch (v2) {\n    case Coq_value_object(l):\n      var%some b = run_object_method(object_has_instance_, l);\n      switch (b) {\n        case None:\n          return (run_error(Native_error_type));\n        case Some(has_instance_id):\n          return (run_object_has_instance(has_instance_id, l, v1));\n      }\n      \n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_binary_op_in = function (v1, v2) {\n  switch (v2) {\n    case Coq_value_object(l):\n      var%string x = to_string(v1);\n      return (object_has_prop(l, x));\n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_binary_op = function (op, v1, v2) {\n  switch (op) {\n    case Coq_binary_op_mult:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x * y));}, v1, v2));\n    case Coq_binary_op_div:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x / y));}, v1, v2));\n    case Coq_binary_op_mod:\n      return (\n        run_binary_op_arith(function (x, y) { return (JsNumber.fmod(x, y));},\n          v1, v2));\n    case Coq_binary_op_sub:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x - y));}, v1, v2));\n    case Coq_binary_op_lt:\n      return (run_binary_op_compare(false, false, v1, v2));\n    case Coq_binary_op_gt:\n      return (run_binary_op_compare(true, false, v1, v2));\n    case Coq_binary_op_le:\n      return (run_binary_op_compare(true, true, v1, v2));\n    case Coq_binary_op_ge:\n      return (run_binary_op_compare(false, true, v1, v2));\n    case Coq_binary_op_left_shift:\n      return (run_binary_op_shift(false, JsNumber.int32_left_shift, v1, v2));\n    case Coq_binary_op_right_shift:\n      return (\n        run_binary_op_shift(false, JsNumber.int32_right_shift, v1, v2));\n    case Coq_binary_op_unsigned_right_shift:\n      return (\n        run_binary_op_shift(true, JsNumber.uint32_right_shift, v1, v2));\n    case Coq_binary_op_bitwise_and:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_and, v1, v2));\n    case Coq_binary_op_bitwise_or:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_or, v1, v2));\n    case Coq_binary_op_bitwise_xor:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_xor, v1, v2));\n    case Coq_binary_op_add:\n      return (run_binary_op_add(v1, v2));\n    case Coq_binary_op_instanceof:\n      return (run_binary_op_instanceof(v1, v2));\n    case Coq_binary_op_in:\n      return (run_binary_op_in(v1, v2));\n    case Coq_binary_op_equal:\n      return (run_equal(v1, v2));\n    case Coq_binary_op_disequal:\n      var%bool b0 = run_equal(v1, v2);\n      return (Value_bool(!(b0)));\n    case Coq_binary_op_strict_equal:\n      return (Value_bool(strict_equality_test(v1, v2)));\n    case Coq_binary_op_strict_disequal:\n      return (Value_bool(!(strict_equality_test(v1, v2))));\n    case Coq_binary_op_coma:\n      return (v2);\n    case Coq_binary_op_and:\n      return (Result_impossible);\n    case Coq_binary_op_or:\n      return (Result_impossible);\n  }\n  \n};\n\nvar run_prepost_op = function (_foo_) {\n  switch (_foo_) {\n    case Coq_unary_op_delete:\n      return (None);\n    case Coq_unary_op_void:\n      return (None);\n    case Coq_unary_op_typeof:\n      return (None);\n    case Coq_unary_op_post_incr:\n      return (Some([add_one, false]));\n    case Coq_unary_op_post_decr:\n      return (Some([sub_one, false]));\n    case Coq_unary_op_pre_incr:\n      return (Some([add_one, true]));\n    case Coq_unary_op_pre_decr:\n      return (Some([sub_one, true]));\n    case Coq_unary_op_add:\n      return (None);\n    case Coq_unary_op_neg:\n      return (None);\n    case Coq_unary_op_bitwise_not:\n      return (None);\n    case Coq_unary_op_not:\n      return (None);\n  }\n  \n};\n\nvar run_typeof_value = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_object(l):\n      if (is_callable_dec(l)) {\n        return ("function");\n      } else {\n        return ("object");\n      }\n    default:\n      return (typeof_prim(_foo_));\n  }\n  \n};\n\nvar run_unary_op = function (op, e) {\n  if (prepost_unary_op_dec(op)) {\n    var%success rv1 = run_expr(e);\n    var%spec v2 = ref_get_value(rv1);\n    var%number n1 = to_number(v2);\n    var%some po = run_prepost_op(op);\n    var (number_op, is_pre) = po;\n    var n2 = number_op(n1);\n    var v = Value_number((function () {\n                if (is_pre) {\n                  return (n2);\n                } else {\n                  return (n1);\n                }}()));\n    var%void _ = ref_put_value(rv1, Value_number(n2));\n    return (v);\n  } else {\n    switch (op) {\n      case Coq_unary_op_delete:\n        var%success rv = run_expr(e);\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (Value_bool(true));\n          case Coq_resvalue_value(v):\n            return (Value_bool(true));\n          case Coq_resvalue_ref(r):\n            if (ref_kind_comparable(ref_kind_of(r), Ref_kind_undef)) {\n              if (r.ref_strict) {\n                return (run_error(Native_error_syntax));\n              } else {\n                return (Value_bool(true));\n              }\n            } else {\n              switch (r.ref_base) {\n                case Coq_ref_base_type_value(v):\n                  var%object l = to_object(v);\n                  return (object_delete(l, r.ref_name, r.ref_strict));\n                case Coq_ref_base_type_env_loc(l):\n                  if (r.ref_strict) {\n                    return (run_error(Native_error_syntax));\n                  } else {\n                    return (env_record_delete_binding(l, r.ref_name));\n                  }\n              }\n              \n            }\n        }\n        \n      case Coq_unary_op_typeof:\n        var%success rv = run_expr(e);\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Empty result for a `typeof\' in [run_unary_op]."));\n          case Coq_resvalue_value(v):\n            return (Value_string(run_typeof_value(v)));\n          case Coq_resvalue_ref(r):\n            if (ref_kind_comparable(ref_kind_of(r), Ref_kind_undef)) {\n              return (Value_string("undefined"));\n            } else {\n              var%spec v = ref_get_value(r);\n              return (Value_string(run_typeof_value(v)));\n            }\n        }\n        \n      default:\n        var%spec v = run_expr_get_value(e);\n        switch (op) {\n          case Coq_unary_op_void:\n            return (Value_undef);\n          case Coq_unary_op_add:\n            return (to_number(v));\n          case Coq_unary_op_neg:\n            var%number n = to_number(v);\n            return (Value_number(JsNumber.neg(n)));\n          case Coq_unary_op_bitwise_not:\n            var%spec k = to_int32(v);\n            return (Value_number(JsNumber.int32_bitwise_not(k)));\n          case Coq_unary_op_not:\n            return (Value_bool(!(to_boolean(v))));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Undealt regular operator in [run_unary_op]."));\n        }\n        \n    }\n    \n  }\n};\n\nvar create_new_function_in = function (args, bd) {\n  return (\n    creating_function_object(args, bd, c.execution_ctx_lexical_env,\n      c.execution_ctx_strict));\n};\n\nvar init_object = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (l);\n    case (p::pds_2):\n      var (pn, pb) = p;\n      var x = string_of_propname(pn);\n      var follows = function (desc) {\n        var%success rv = object_define_own_prop(l, x, desc, false);\n        return (init_object(l, pds_2));\n      };\n      switch (pb) {\n        case Coq_propbody_val(e0):\n          var%spec v0 = run_expr_get_value(e0);\n          var desc = {\n            descriptor_value: Some(v0),\n            descriptor_writable: Some(true),\n            descriptor_get: None,\n            descriptor_set: None,\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n        case Coq_propbody_get(bd):\n          var%value v0 = create_new_function_in(mk_nil, bd);\n          var desc = {\n            descriptor_value: None,\n            descriptor_writable: None,\n            descriptor_get: Some(v0),\n            descriptor_set: None,\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n        case Coq_propbody_set(args, bd):\n          var%value v0 = create_new_function_in(args, bd);\n          var desc = {\n            descriptor_value: None,\n            descriptor_writable: None,\n            descriptor_get: None,\n            descriptor_set: Some(v0),\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n      }\n      \n  }\n  \n};\n\nvar run_array_element_list = function (l, oes, n) {\n  switch (oes) {\n    case []:\n      return (l);\n    case (o::oes_2):\n      switch (o) {\n        case Some(e):\n          var loop_result = function () {\n            return (run_array_element_list(l, oes_2, 0.));\n          };\n          var%spec v = run_expr_get_value(e);\n          var%value vlen = run_object_get(l, "length");\n          var%spec ilen = to_uint32(vlen);\n          var%string slen = to_string(Value_number((ilen + n)));\n          var desc = {\n            attributes_data_value: v,\n            attributes_data_writable: true,\n            attributes_data_enumerable: true,\n            attributes_data_configurable: true\n          };\n          var%bool x = object_define_own_prop(l, slen,\n                         descriptor_of_attributes(desc), false);\n          var%object l0 = loop_result();\n          return (l0);\n        case None:\n          var firstIndex = elision_head_count(mk_cons(None, oes_2));\n          return (\n            run_array_element_list(l,\n              elision_head_remove(mk_cons(None, oes_2)), firstIndex));\n      }\n      \n  }\n  \n};\n\nvar init_array = function (l, oes) {\n  var elementList = elision_tail_remove(oes);\n  var elisionLength = elision_tail_count(oes);\n  var%object l0 = run_array_element_list(l, elementList, 0.);\n  var%value vlen = run_object_get(l0, "length");\n  var%spec ilen = to_uint32(vlen);\n  var%spec len = to_uint32(Value_number((ilen + elisionLength)));\n  var%not_throw x = object_put(l0, "length", Value_number(len), throw_false);\n  return (l0);\n};\n\nvar run_var_decl_item = function (x, _foo_) {\n  switch (_foo_) {\n    case Some(e):\n      var%spec ir = identifier_resolution(x);\n      var%spec v = run_expr_get_value(e);\n      var%void _ = ref_put_value(ir, v);\n      return (Value_string(x));\n    case None:\n      return (Value_string(x));\n  }\n  \n};\n\nvar run_var_decl = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (res_empty);\n    case (y::xeos_2):\n      var (x, eo) = y;\n      var%value vname = run_var_decl_item(x, eo);\n      return (run_var_decl(xeos_2));\n  }\n  \n};\n\nvar run_list_expr = function (vs, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rev(vs));\n    case (e::es_2):\n      var%spec v = run_expr_get_value(e);\n      return (run_list_expr(mk_cons(v, vs), es_2));\n  }\n  \n};\n\nvar run_block = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (Resvalue_empty);\n    case (t::ts_rev_2):\n      var%success rv0 = run_block(ts_rev_2);\n      return (\n        ifx_success_state(rv0, run_stat(t), function (x0) { return (x0);}));\n  }\n  \n};\n\nvar run_binary_op_and = function (e1, e2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b1 = to_boolean(v1);\n  if (!(b1)) {\n    return (v1);\n  } else {\n    var%spec v = run_expr_get_value(e2);return (v);\n  }\n};\n\nvar run_binary_op_or = function (e1, e2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b1 = to_boolean(v1);\n  if (b1) {\n    return (v1);\n  } else {\n    var%spec v = run_expr_get_value(e2);return (v);\n  }\n};\n\nvar run_expr_binary_op = function (op, e1, e2) {\n  switch (op) {\n    case Coq_binary_op_and:\n      return (run_binary_op_and(e1, e2));\n    case Coq_binary_op_or:\n      return (run_binary_op_or(e1, e2));\n    default:\n      var%spec v1 = run_expr_get_value(e1);\n      var%spec v2 = run_expr_get_value(e2);\n      return (run_binary_op(op, v1, v2));\n  }\n  \n};\n\nvar run_expr_access = function (e1, e2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var%spec v2 = run_expr_get_value(e2);\n  if ((value_compare(v1, Value_undef) || value_compare(v1, Value_null))) {\n    return (run_error(Native_error_type));\n  } else {\n    var%string x = to_string(v2);\n    return (ref_create_value(v1, x, c.execution_ctx_strict));\n  }\n};\n\nvar run_expr_assign = function (opo, e1, e2) {\n  var%success rv1 = run_expr(e1);\n  var follow = function (rv_2) {\n    switch (rv_2) {\n      case Coq_resvalue_value(v):\n        var%void _ = ref_put_value(rv1, v);\n        return (v);\n      case Coq_resvalue_empty:\n        Debug.impossible_with_heap_because(__LOC__,\n          "Non-value result in [run_expr_assign].");\n        return (Result_impossible);\n      case Coq_resvalue_ref(r):\n        Debug.impossible_with_heap_because(__LOC__,\n          "Non-value result in [run_expr_assign].");\n        return (Result_impossible);\n    }\n    \n  };\n  switch (opo) {\n    case Some(op):\n      var%spec v1 = ref_get_value(rv1);\n      var%spec v2 = run_expr_get_value(e2);\n      var%success v = run_binary_op(op, v1, v2);\n      return (follow(v));\n    case None:\n      var%spec x0 = run_expr_get_value(e2);\n      return (follow(x0));\n  }\n  \n};\n\nvar run_expr_function = function (fo, args, bd) {\n  switch (fo) {\n    case Some(fn):\n      var p = lexical_env_alloc_decl(c.execution_ctx_lexical_env);\n      var (lex_2, s_2) = p;\n      var follow = function (l) {\n        var%some e = env_record_binds_option(l);\n        var%void _ = env_record_create_immutable_binding(l, fn);\n        var%object l0 = creating_function_object(args, bd, lex_2,\n                          funcbody_is_strict(bd));\n        var%void _ = env_record_initialize_immutable_binding(l, fn, l0);\n        return (l0);\n      };\n      return (\n        destr_list(lex_2, function (x) {\n            Debug.impossible_with_heap_because(__LOC__,\n              "Empty lexical environnment allocated in [run_expr_function].");\n            return (Result_impossible);}, function (l, x) {\n            return (follow(l));}, {}));\n    case None:\n      var lex = c.execution_ctx_lexical_env;\n      return (\n        creating_function_object(args, bd, lex, funcbody_is_strict(bd)));\n  }\n  \n};\n\nvar entering_eval_code = function (direct, bd, k) {\n  var str = (funcbody_is_strict(bd) || (direct && c.execution_ctx_strict));\n  if (direct) {\n    var c_2 = c;\n  } else {\n    var c_2 = execution_ctx_initial(str);\n  }\n  if (str) {\n    var p = lexical_env_alloc_decl(c_2.execution_ctx_lexical_env);\n  } else {\n    var p = [c_2.execution_ctx_lexical_env, s];\n  }\n  var (lex, s_2) = p;\n  if (str) {\n    var c1 = execution_ctx_with_lex_same(lex);\n  } else {\n    var c1 = c_2;\n  }\n  var p0 = funcbody_prog(bd);\n  var%void _ = execution_ctx_binding_inst(Codetype_eval, None, p0, mk_nil);\n  return (k());\n};\n\nvar run_eval = function (is_direct_call, vs) {\n  switch (get_arg(0, vs)) {\n    case Coq_value_undef:\n      return (Value_undef);\n    case Coq_value_null:\n      return (Value_null);\n    case Coq_value_bool(b):\n      return (Value_bool(b));\n    case Coq_value_number(n):\n      return (Value_number(n));\n    case Coq_value_string(s0):\n      var str = (is_direct_call && c.execution_ctx_strict);\n      switch (parse_pickable(s0, str)) {\n        case Some(p0):\n          return (\n            entering_eval_code(is_direct_call, Funcbody_intro(p0, s0),\n              function () {\n                var%ter r = run_prog(p0);\n                switch (r.res_type) {\n                  case Coq_restype_normal:\n                    return (\n                      ifx_empty_label(r, function (x) {\n                          switch (r.res_value) {\n                            case Coq_resvalue_empty:\n                              return (Value_undef);\n                            case Coq_resvalue_value(v):\n                              return (v);\n                            case Coq_resvalue_ref(r0):\n                              Debug.impossible_with_heap_because(__LOC__,\n                                "Reference found in the result of an `eval\' in [run_eval].");\n                              return (Result_impossible);\n                          }\n                          }));\n                  case Coq_restype_throw:\n                    return (res_throw(r.res_value));\n                  default:\n                    Debug.impossible_with_heap_because(__LOC__,\n                      "Forbidden result type returned by an `eval\' in [run_eval].");\n                    return (Result_impossible);\n                }\n                }));\n        case None:\n          return (run_error(Native_error_syntax));\n      }\n      \n    case Coq_value_object(o):\n      return (o);\n  }\n  \n};\n\nvar run_expr_call = function (e1, e2s) {\n  var is_eval_direct = is_syntactic_eval(e1);\n  var%success rv = run_expr(e1);\n  var%spec f = ref_get_value(rv);\n  var%spec vs = run_list_expr(mk_nil, e2s);\n  switch (f) {\n    case Coq_value_object(l):\n      if (is_callable_dec(l)) {\n        var follow = function (vthis) {\n          if (object_loc_compare(l, Prealloc_global_eval)) {\n            return (run_eval(is_eval_direct, vs));\n          } else {\n            return (run_call(l, vthis, vs));\n          }\n        };\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "[run_expr_call] unable to call an  empty result."));\n          case Coq_resvalue_value(v):\n            return (follow(Value_undef));\n          case Coq_resvalue_ref(r):\n            switch (r.ref_base) {\n              case Coq_ref_base_type_value(v):\n                if ((ref_kind_comparable(ref_kind_of(r),\n                       Ref_kind_primitive_base)\n                    || (ref_kind_comparable(ref_kind_of(r), Ref_kind_null)\n                       || ref_kind_comparable(ref_kind_of(r),\n                            Ref_kind_object)))) {\n                  return (follow(v));\n                } else {\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "[run_expr_call] unable to call a non-property function."));\n                }\n              case Coq_ref_base_type_env_loc(l0):\n                var%some v = env_record_implicit_this_value(l0);\n                return (follow(v));\n            }\n            \n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_expr_conditionnal = function (e1, e2, e3) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b = to_boolean(v1);\n  if (b) {\n    var e = e2;\n  } else {\n    var e = e3;\n  }\n  var%spec r = run_expr_get_value(e);\n  return (r);\n};\n\nvar run_expr_new = function (e1, e2s) {\n  var%spec v = run_expr_get_value(e1);\n  var%spec args = run_list_expr(mk_nil, e2s);\n  switch (v) {\n    case Coq_value_object(l):\n      var%some coo = run_object_method(object_construct_, l);\n      switch (coo) {\n        case Some(co):\n          return (run_construct(co, l, args));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_stat_label = function (lab, t) {\n  var%break r1 = run_stat(t);\n  return (\n    (function () {\n      if (label_compare(r1.res_label, lab)) {\n        return (r1.res_value);\n      } else {\n        return (r1);\n      }\n    }())\n    );\n};\n\nvar run_stat_with = function (e1, t2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var%object l = to_object(v1);\n  var lex = c.execution_ctx_lexical_env;\n  var p = lexical_env_alloc_object(lex, l, provide_this_true);\n  var (lex_2, s3) = p;\n  var c_2 = execution_ctx_with_lex(lex_2);\n  return (run_stat(t2));\n};\n\nvar run_stat_if = function (e1, t2, to0) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b = to_boolean(v1);\n  if (b) {\n    return (run_stat(t2));\n  } else {\n    switch (to0) {\n      case Some(t3):\n        return (run_stat(t3));\n      case None:\n        return (Resvalue_empty);\n    }\n    \n  }\n};\n\nvar run_stat_while = function (rv, labs, e1, t2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b = to_boolean(v1);\n  if (b) {\n    var%ter r = run_stat(t2);\n    if (!(resvalue_compare(r.res_value, Resvalue_empty))) {\n      var rv_2 = r.res_value;\n    } else {\n      var rv_2 = rv;\n    }\n    var loop = function (x) {\n      return (run_stat_while(rv_2, labs, e1, t2));\n    };\n    if ((!(restype_compare(r.res_type, Restype_continue))\n        || !(res_label_in(r, labs)))) {\n      if ((restype_compare(r.res_type, Restype_break)\n          && res_label_in(r, labs))) {\n        return (rv_2);\n      } else {\n        if (!(restype_compare(r.res_type, Restype_normal))) {\n          return (r);\n        } else {\n          return (loop({}));\n        }\n      }\n    } else {\n      return (loop({}));\n    }\n  } else {\n    return (rv);\n  }\n};\n\nvar run_stat_switch_end = function (rv, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rv);\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          return (\n            ifx_success_state(rv, run_block(rev(ts)), function (rv1) {\n                return (run_stat_switch_end(rv1, scs_2));}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_no_default = function (vi, rv, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rv);\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var%spec v1 = run_expr_get_value(e);\n          var b = strict_equality_test(v1, vi);\n          if (b) {\n            var%success rv2 = run_block(rev(ts));\n            return (run_stat_switch_end(rv2, scs_2));\n          } else {\n            return (run_stat_switch_no_default(vi, rv, scs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_default = function (ts, scs) {\n  var%success rv = run_block(rev(ts));\n  return (run_stat_switch_end(rv, scs));\n};\n\nvar run_stat_switch_with_default_B = function (vi, rv, ts0, scs) {\n  switch (scs) {\n    case []:\n      return (run_stat_switch_with_default_default(ts0, scs));\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var%spec v1 = run_expr_get_value(e);\n          var b = strict_equality_test(v1, vi);\n          if (b) {\n            var%success rv2 = run_block(rev(ts));\n            return (run_stat_switch_end(rv2, scs_2));\n          } else {\n            return (run_stat_switch_with_default_B(vi, rv, ts0, scs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_A = function (found, vi, rv, scs1, ts0, scs2) {\n  switch (scs1) {\n    case []:\n      if (found) {\n        return (run_stat_switch_with_default_default(ts0, scs2));\n      } else {\n        return (run_stat_switch_with_default_B(vi, rv, ts0, scs2));\n      }\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var follow = function () {\n            return (\n              ifx_success_state(rv, run_block(rev(ts)), function (rv0) {\n                  return (\n                    run_stat_switch_with_default_A(true, vi, rv0, scs_2, ts0,\n                      scs2));}));\n          };\n          if (found) {\n            return (follow());\n          } else {\n            var%spec v1 = run_expr_get_value(e);\n            var b = strict_equality_test(v1, vi);\n            if (b) {\n              return (follow());\n            } else {\n              return (\n                run_stat_switch_with_default_A(false, vi, rv, scs_2, ts0,\n                  scs2));\n            }\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch = function (labs, e, sb) {\n  var%spec vi = run_expr_get_value(e);\n  var follow = function (w) {\n    var%success r = var%break r = w;\n      if (res_label_in(r, labs)) {\n        return (r.res_value);\n      } else {\n        return (r);\n      };\n    return (r);\n  };\n  switch (sb) {\n    case Coq_switchbody_nodefault(scs):\n      return (follow(run_stat_switch_no_default(vi, Resvalue_empty, scs)));\n    case Coq_switchbody_withdefault(scs1, ts, scs2):\n      return (\n        follow(\n          run_stat_switch_with_default_A(false, vi, Resvalue_empty, scs1, ts,\n            scs2)));\n  }\n  \n};\n\nvar run_stat_do_while = function (rv, labs, e1, t2) {\n  var%ter r = run_stat(t2);\n  if (resvalue_compare(r.res_value, Resvalue_empty)) {\n    var rv_2 = rv;\n  } else {\n    var rv_2 = r.res_value;\n  }\n  var loop = function (x) {\n    var%spec v1 = run_expr_get_value(e1);\n    var b = to_boolean(v1);\n    if (b) {\n      return (run_stat_do_while(rv_2, labs, e1, t2));\n    } else {\n      return (rv_2);\n    }\n  };\n  if ((restype_compare(r.res_type, Restype_continue)\n      && res_label_in(r, labs))) {\n    return (loop({}));\n  } else {\n    if ((restype_compare(r.res_type, Restype_break) && res_label_in(r, labs))) {\n      return (rv_2);\n    } else {\n      if (!(restype_compare(r.res_type, Restype_normal))) {\n        return (r);\n      } else {\n        return (loop({}));\n      }\n    }\n  }\n};\n\nvar run_stat_try = function (t1, t2o, t3o) {\n  var finallycont = function (r) {\n    switch (t3o) {\n      case Some(t3):\n        var%success rv_2 = run_stat(t3);\n        return (r);\n      case None:\n        return (r);\n    }\n    \n  };\n  return (\n    ifx_any_or_throw(run_stat(t1), finallycont, function (v) {\n        switch (t2o) {\n          case Some(y):\n            var (x, t2) = y;\n            var lex = c.execution_ctx_lexical_env;\n            var p = lexical_env_alloc_decl(lex);\n            var (lex_2, s_2) = p;\n            switch (lex_2) {\n              case []:\n                return (\n                  function (m) {\n                      Debug.impossible_with_heap_because(__LOC__, m);\n                      return (Result_impossible);}(\n                    "Empty lexical environnment in [run_stat_try]."));\n              case (l::oldlex):\n                var%void _ = env_record_create_set_mutable_binding(l, x,\n                               None, v, throw_irrelevant);\n                var c_2 = execution_ctx_with_lex(lex_2);\n                var%ter r = run_stat(t2);\n                return (finallycont(r));\n            }\n            \n          case None:\n            return (finallycont(res_throw(v)));\n        }\n        }));\n};\n\nvar run_stat_throw = function (e) {\n  var%spec v1 = run_expr_get_value(e);\n  return (res_throw(v1));\n};\n\nvar run_stat_return = function (_foo_) {\n  switch (_foo_) {\n    case Some(e):\n      var%spec v1 = run_expr_get_value(e);\n      return (res_return(v1));\n    case None:\n      return (res_return(Value_undef));\n  }\n  \n};\n\nvar run_stat_for_loop = function (labs, rv, eo2, eo3, t) {\n  var follows = function () {\n    var%ter r = run_stat(t);\n    if (!(resvalue_compare(r.res_value, Resvalue_empty))) {\n      var rv_2 = r.res_value;\n    } else {\n      var rv_2 = rv;\n    }\n    var loop = function () {\n      return (run_stat_for_loop(labs, rv_2, eo2, eo3, t));\n    };\n    if ((restype_compare(r.res_type, Restype_break) && res_label_in(r, labs))) {\n      return (rv_2);\n    } else {\n      if ((restype_compare(r.res_type, Restype_normal)\n          || (restype_compare(r.res_type, Restype_continue)\n             && res_label_in(r, labs)))) {\n        switch (eo3) {\n          case Some(e3):\n            var%spec v3 = run_expr_get_value(e3);\n            return (loop());\n          case None:\n            return (loop());\n        }\n        \n      } else {\n        return (r);\n      }\n    }\n  };\n  switch (eo2) {\n    case Some(e2):\n      var%spec v2 = run_expr_get_value(e2);\n      var b = to_boolean(v2);\n      if (b) {\n        return (follows());\n      } else {\n        return (rv);\n      }\n    case None:\n      return (follows());\n  }\n  \n};\n\nvar run_stat_for = function (labs, eo1, eo2, eo3, t) {\n  var follows = function () {\n    return (run_stat_for_loop(labs, Resvalue_empty, eo2, eo3, t));\n  };\n  switch (eo1) {\n    case Some(e1):\n      var%spec v1 = run_expr_get_value(e1);\n      return (follows());\n    case None:\n      return (follows());\n  }\n  \n};\n\nvar run_stat_for_var = function (labs, ds, eo2, eo3, t) {\n  var%ter r = run_stat(Stat_var_decl(ds));\n  return (run_stat_for_loop(labs, Resvalue_empty, eo2, eo3, t));\n};\n\nvar run_expr = function (_term_) {\n  switch (_term_) {\n    case Coq_expr_this:\n      return (c.execution_ctx_this_binding);\n    case Coq_expr_identifier(x):\n      var%spec r = identifier_resolution(x);\n      return (r);\n    case Coq_expr_literal(i):\n      return (convert_literal_to_prim(i));\n    case Coq_expr_object(pds):\n      var%object l = run_construct_prealloc(Prealloc_object, mk_nil);\n      return (init_object(l, pds));\n    case Coq_expr_array(oes):\n      var%object l = run_construct_prealloc(Prealloc_array, mk_nil);\n      return (init_array(l, oes));\n    case Coq_expr_function(fo, args, bd):\n      return (run_expr_function(fo, args, bd));\n    case Coq_expr_access(e1, e2):\n      return (run_expr_access(e1, e2));\n    case Coq_expr_member(e1, f):\n      return (run_expr(Expr_access(e1, Expr_literal(Literal_string(f)))));\n    case Coq_expr_new(e1, e2s):\n      return (run_expr_new(e1, e2s));\n    case Coq_expr_call(e1, e2s):\n      return (run_expr_call(e1, e2s));\n    case Coq_expr_unary_op(op, e0):\n      return (run_unary_op(op, e0));\n    case Coq_expr_binary_op(e1, op, e2):\n      return (run_expr_binary_op(op, e1, e2));\n    case Coq_expr_conditional(e1, e2, e3):\n      return (run_expr_conditionnal(e1, e2, e3));\n    case Coq_expr_assign(e1, opo, e2):\n      return (run_expr_assign(opo, e1, e2));\n  }\n  \n};\n\nvar run_stat = function (_term_) {\n  switch (_term_) {\n    case Coq_stat_expr(e):\n      var%spec r = run_expr_get_value(e);\n      return (r);\n    case Coq_stat_label(lab, t0):\n      return (run_stat_label(Label_string(lab), t0));\n    case Coq_stat_block(ts):\n      return (run_block(rev(ts)));\n    case Coq_stat_var_decl(xeos):\n      return (run_var_decl(xeos));\n    case Coq_stat_if(e1, t2, to0):\n      return (run_stat_if(e1, t2, to0));\n    case Coq_stat_do_while(ls, t1, e2):\n      return (run_stat_do_while(Resvalue_empty, ls, e2, t1));\n    case Coq_stat_while(ls, e1, t2):\n      return (run_stat_while(Resvalue_empty, ls, e1, t2));\n    case Coq_stat_with(e1, t2):\n      return (run_stat_with(e1, t2));\n    case Coq_stat_throw(e):\n      return (run_stat_throw(e));\n    case Coq_stat_return(eo):\n      return (run_stat_return(eo));\n    case Coq_stat_break(so):\n      return (res_break(so));\n    case Coq_stat_continue(so):\n      return (res_continue(so));\n    case Coq_stat_try(t1, t2o, t3o):\n      return (run_stat_try(t1, t2o, t3o));\n    case Coq_stat_for(ls, eo1, eo2, eo3, s0):\n      return (run_stat_for(ls, eo1, eo2, eo3, s0));\n    case Coq_stat_for_var(ls, ds, eo2, eo3, s0):\n      return (run_stat_for_var(ls, ds, eo2, eo3, s0));\n    case Coq_stat_for_in(ls, e1, e2, s0):\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}("stat_for_in"));\n    case Coq_stat_for_in_var(ls, x, e1o, e2, s0):\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}("stat_for_in_var"));\n    case Coq_stat_debugger:\n      return (res_empty);\n    case Coq_stat_switch(labs, e, sb):\n      return (run_stat_switch(labs, e, sb));\n  }\n  \n};\n\nvar run_elements = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (Resvalue_empty);\n    case (el::els_rev_2):\n      var%success rv0 = run_elements(els_rev_2);\n      switch (el) {\n        case Coq_element_stat(t):\n          var%ter r1 = run_stat(t);\n          var r2 = res_overwrite_value_if_empty(rv0, r1);\n          return (r2);\n        case Coq_element_func_decl(name, args, bd):\n          return (rv0);\n      }\n      \n  }\n  \n};\n\nvar run_prog = function (_term_) {\n  switch (_term_) {\n    case Coq_prog_intro(str, els):\n      return (run_elements(rev(els)));\n  }\n  \n};\n\nvar push = function (l, args, ilen) {\n  var vlen = ilen;\n  switch (args) {\n    case []:\n      var%not_throw x = object_put(l, "length", Value_number(vlen),\n                          throw_true);\n      return (Value_number(vlen));\n    case (v::vs):\n      var%string slen = to_string(Value_number(vlen));\n      var%not_throw x = object_put(l, slen, v, throw_true);\n      return (push(l, vs, (ilen + 1.)));\n  }\n  \n};\n\nvar run_object_is_sealed = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some ext = run_object_method(object_extensible_, l);\n      return (Value_bool(!(ext)));\n    case (x::xs_2):\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if (attributes_configurable(a)) {\n            return (Value_bool(false));\n          } else {\n            return (run_object_is_sealed(l, xs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_object_seal = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some _ = run_object_heap_set_extensible(false, l);\n      return (l);\n    case (x::xs_2):\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_seal]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if (attributes_configurable(a)) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: None,\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: Some(false)\n            };\n            var a_2 = attributes_update(a, desc);\n          } else {\n            var a_2 = a;\n          }\n          var%bool x0 = object_define_own_prop(l, x,\n                          descriptor_of_attributes(a_2), true);\n          return (run_object_seal(l, xs_2));\n      }\n      \n  }\n  \n};\n\nvar run_object_freeze = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some _ = run_object_heap_set_extensible(false, l);\n      return (l);\n    case (x::xs_2):\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if ((attributes_is_data_dec(a) && attributes_writable(a))) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: Some(false),\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: None\n            };\n            var a_2 = attributes_update(a, desc);\n          } else {\n            var a_2 = a;\n          }\n          if (attributes_configurable(a_2)) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: None,\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: Some(false)\n            };\n            var a_3 = attributes_update(a_2, desc);\n          } else {\n            var a_3 = a_2;\n          }\n          var%bool x0 = object_define_own_prop(l, x,\n                          descriptor_of_attributes(a_3), true);\n          return (run_object_freeze(l, xs_2));\n      }\n      \n  }\n  \n};\n\nvar run_object_is_frozen = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some ext = run_object_method(object_extensible_, l);\n      return (Value_bool(!(ext)));\n    case (x::xs_2):\n      var%spec d = run_object_get_own_prop(l, x);\n      var check_configurable = function (a) {\n        if (attributes_configurable(a)) {\n          return (Value_bool(false));\n        } else {\n          return (run_object_is_frozen(l, xs_2));\n        }\n      };\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          switch (a) {\n            case Coq_attributes_data_of(ad):\n              if (attributes_writable(ad)) {\n                return (Value_bool(false));\n              } else {\n                return (check_configurable(ad));\n              }\n            case Coq_attributes_accessor_of(aa):\n              return (check_configurable(aa));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar run_get_args_for_apply = function (l, index, n) {\n  if ((index < n)) {\n    var%string sindex = to_string(Value_number(index));\n    var%value v = run_object_get(l, sindex);\n    var tail_args = run_get_args_for_apply(l, (index + 1.), n);\n    var%spec tail = tail_args;\n    return (mk_cons(v, tail));\n  } else {\n    return (mk_nil);\n  }\n};\n\nvar valueToStringForJoin = function (l, k) {\n  var%string prop = to_string(Value_number(k));\n  var%value v = run_object_get(l, prop);\n  switch (v) {\n    case Coq_value_undef:\n      return ("");\n    case Coq_value_null:\n      return ("");\n    case Coq_value_bool(b):\n      var%string s3 = to_string(v);\n      return (s3);\n    case Coq_value_number(n):\n      var%string s3 = to_string(v);\n      return (s3);\n    case Coq_value_string(s2):\n      var%string s4 = to_string(v);\n      return (s4);\n    case Coq_value_object(o):\n      var%string s3 = to_string(v);\n      return (s3);\n  }\n  \n};\n\nvar run_array_join_elements = function (l, k, length0, sep, sR) {\n  if ((k < length0)) {\n    var ss = strappend(sR, sep);\n    var sE = valueToStringForJoin(l, k);\n    var%spec element = sE;\n    var sR0 = strappend(ss, element);\n    return (run_array_join_elements(l, (k + 1.), length0, sep, sR0));\n  } else {\n    return (Value_string(sR));\n  }\n};\n\nvar run_call_prealloc = function (b, vthis, args) {\n  switch (b) {\n    case Coq_prealloc_global_is_finite:\n      var v = get_arg(0, args);\n      var%number n = to_number(v);\n      return (\n        Value_bool(\n          !(\n            (JsNumber.isnan(n)\n            || ((n === JsNumber.infinity) || (n === JsNumber.neg_infinity))))));\n    case Coq_prealloc_global_is_nan:\n      var v = get_arg(0, args);\n      var%number n = to_number(v);\n      return (Value_bool(JsNumber.isnan(n)));\n    case Coq_prealloc_object:\n      var value0 = get_arg(0, args);\n      switch (value0) {\n        case Coq_value_undef:\n          return (run_construct_prealloc(b, args));\n        case Coq_value_null:\n          return (run_construct_prealloc(b, args));\n        case Coq_value_bool(b0):\n          return (to_object(value0));\n        case Coq_value_number(n):\n          return (to_object(value0));\n        case Coq_value_string(s0):\n          return (to_object(value0));\n        case Coq_value_object(o):\n          return (to_object(value0));\n      }\n      \n    case Coq_prealloc_object_get_proto_of:\n      var v = get_arg(0, args);\n      return (builtin_object_get_prototype_of({}, vthis, {}, v));\n    case Coq_prealloc_object_get_own_prop_descriptor:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%string x = to_string(get_arg(1, args));\n          var%spec d = run_object_get_own_prop(l, x);\n          return (from_prop_descriptor(d));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_define_prop:\n      var o = get_arg(0, args);\n      var p = get_arg(1, args);\n      var attr = get_arg(2, args);\n      switch (o) {\n        case Coq_value_object(l):\n          var%string name = to_string(p);\n          var%spec desc = to_property_descriptor(attr);\n          var%bool x = object_define_own_prop(l, name, desc, true);\n          return (l);\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_seal:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_seal(l, _x_));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_freeze:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_freeze(l, _x_));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_prevent_extensions:\n      var v = get_arg(0, args);\n      return (builtin_object_prevent_extensions({}, vthis, {}, v));\n    case Coq_prealloc_object_is_sealed:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_is_sealed(l, _x_));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_is_frozen:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_is_frozen(l, _x_));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_is_extensible:\n      var v = get_arg(0, args);\n      return (builtin_object_is_extensible({}, vthis, {}, v));\n    case Coq_prealloc_object_proto_to_string:\n      switch (vthis) {\n        case Coq_value_undef:\n          return (Value_string("[object Undefined]"));\n        case Coq_value_null:\n          return (Value_string("[object Null]"));\n        case Coq_value_bool(b0):\n          var%object l = to_object(vthis);\n          var%some s0 = run_object_method(object_class_, l);\n          return (Value_string(strappend("[object ", strappend(s0, "]"))));\n        case Coq_value_number(n):\n          var%object l = to_object(vthis);\n          var%some s0 = run_object_method(object_class_, l);\n          return (Value_string(strappend("[object ", strappend(s0, "]"))));\n        case Coq_value_string(s0):\n          var%object l = to_object(vthis);\n          var%some s2 = run_object_method(object_class_, l);\n          return (Value_string(strappend("[object ", strappend(s2, "]"))));\n        case Coq_value_object(o):\n          var%object l = to_object(vthis);\n          var%some s0 = run_object_method(object_class_, l);\n          return (Value_string(strappend("[object ", strappend(s0, "]"))));\n      }\n      \n    case Coq_prealloc_object_proto_value_of:\n      return (to_object(vthis));\n    case Coq_prealloc_object_proto_has_own_prop:\n      var v = get_arg(0, args);\n      var%string x = to_string(v);\n      var%object l = to_object(vthis);\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (Value_bool(false));\n        case Coq_full_descriptor_some(a):\n          return (Value_bool(true));\n      }\n      \n    case Coq_prealloc_object_proto_is_prototype_of:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%object lo = to_object(vthis);\n          return (object_proto_is_prototype_of(lo, l));\n        default:\n          return (Value_bool(false));\n      }\n      \n    case Coq_prealloc_object_proto_prop_is_enumerable:\n      var v = get_arg(0, args);\n      var%string x = to_string(v);\n      var%object l = to_object(vthis);\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (Value_bool(false));\n        case Coq_full_descriptor_some(a):\n          return (Value_bool(attributes_enumerable(a)));\n      }\n      \n    case Coq_prealloc_function_proto:\n      return (Value_undef);\n    case Coq_prealloc_function_proto_to_string:\n      if (is_callable_dec(vthis)) {\n        return (\n          function (s) {\n              Debug.not_yet_implemented_because(__LOC__, s);\n              return (Result_not_yet_implemented);}(\n            "Function.prototype.toString() is implementation dependent."));\n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_apply:\n      var thisArg = get_arg(0, args);\n      var argArray = get_arg(1, args);\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_object(thisobj):\n            switch (argArray) {\n              case Coq_value_undef:\n                return (run_call(thisobj, thisArg, mk_nil));\n              case Coq_value_null:\n                return (run_call(thisobj, thisArg, mk_nil));\n              case Coq_value_bool(b0):\n                return (run_error(Native_error_type));\n              case Coq_value_number(n):\n                return (run_error(Native_error_type));\n              case Coq_value_string(s0):\n                return (run_error(Native_error_type));\n              case Coq_value_object(array):\n                var%value v = run_object_get(array, "length");\n                var%spec ilen = to_uint32(v);\n                var%spec arguments_ = run_get_args_for_apply(array, 0., ilen);\n                return (run_call(thisobj, thisArg, arguments_));\n            }\n            \n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_call:\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_object(thisobj):\n            var (thisArg, a) = get_arg_first_and_rest(args);\n            return (run_call(thisobj, thisArg, a));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_bind:\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_object(thisobj):\n            var (vthisArg, a) = get_arg_first_and_rest(args);\n            var o1 = object_new(Prealloc_object_proto, "Object");\n            var o2 = o1;\n            var o3 = object_with_details(o2, None, None, None, Some(thisobj),\n                       Some(vthisArg), Some(a), None);\n            var o4 = object_set_class(o3, "Function");\n            var o5 = object_set_proto(o4, Prealloc_function_proto);\n            var o6 = object_with_invokation(o5, Some(Construct_after_bind),\n                       Some(Call_after_bind),\n                       Some(Builtin_has_instance_after_bind));\n            var o7 = object_set_extensible(o6, true);\n            var (l, s_2) = object_alloc(o7);\n            var vlength = (function () {\n              var%some class0 = run_object_method(object_class_, thisobj);\n              if (string_eq(class0, "Function")) {\n                var%number n = run_object_get(thisobj, "length");\n                var%spec ilen = to_int32(Value_number(n));\n                if ((ilen < LibList.length(a))) {\n                  return (0.);\n                } else {\n                  return ((ilen - LibList.length(a)));\n                }\n              } else {\n                return (0.);\n              }\n            }())\n            ;\n            var%spec length0 = vlength;\n            var a0 = {\n              attributes_data_value: Value_number(length0),\n              attributes_data_writable: false,\n              attributes_data_enumerable: false,\n              attributes_data_configurable: false\n            };\n            var%some _ = run_object_heap_map_properties(l, function (p) {\n                             return (HeapStr.write(p, "length", a0));});\n            var vthrower = Prealloc_throw_type_error;\n            var a1 = {\n              attributes_accessor_get: vthrower,\n              attributes_accessor_set: vthrower,\n              attributes_accessor_enumerable: false,\n              attributes_accessor_configurable: false\n            };\n            var%bool x = object_define_own_prop(l, "caller",\n                           descriptor_of_attributes(a1), false);\n            var%bool x0 = object_define_own_prop(l, "arguments",\n                            descriptor_of_attributes(a1), false);\n            return (l);\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_bool:\n      var v = get_arg(0, args);\n      return (Value_bool(to_boolean(v)));\n    case Coq_prealloc_bool_proto_to_string:\n      switch (vthis) {\n        case Coq_value_undef:\n          return (run_error(Native_error_type));\n        case Coq_value_null:\n          return (run_error(Native_error_type));\n        case Coq_value_bool(b0):\n          return (\n            Value_string((function () {\n                if (b0) {\n                  return ("true");\n                } else {\n                  return ("false");\n                }}())));\n        case Coq_value_number(n):\n          return (run_error(Native_error_type));\n        case Coq_value_string(s0):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_undef:\n                                return (run_error(Native_error_type));\n                              case Coq_value_null:\n                                return (run_error(Native_error_type));\n                              case Coq_value_bool(b0):\n                                return (\n                                  Value_string((function () {\n                                      if (b0) {\n                                        return ("true");\n                                      } else {\n                                        return ("false");\n                                      }}())));\n                              case Coq_value_number(n):\n                                return (run_error(Native_error_type));\n                              case Coq_value_string(s1):\n                                return (run_error(Native_error_type));\n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_bool_proto_value_of:\n      switch (vthis) {\n        case Coq_value_undef:\n          return (run_error(Native_error_type));\n        case Coq_value_null:\n          return (run_error(Native_error_type));\n        case Coq_value_bool(b0):\n          return (Value_bool(b0));\n        case Coq_value_number(n):\n          return (run_error(Native_error_type));\n        case Coq_value_string(s0):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_undef:\n                                return (run_error(Native_error_type));\n                              case Coq_value_null:\n                                return (run_error(Native_error_type));\n                              case Coq_value_bool(b0):\n                                return (Value_bool(b0));\n                              case Coq_value_number(n):\n                                return (run_error(Native_error_type));\n                              case Coq_value_string(s1):\n                                return (run_error(Native_error_type));\n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_number:\n      if (list_eq_nil_decidable(args)) {\n        return (Value_number(JsNumber.zero));\n      } else {\n        var v = get_arg(0, args);return (to_number(v));\n      }\n    case Coq_prealloc_number_proto_value_of:\n      switch (vthis) {\n        case Coq_value_undef:\n          return (run_error(Native_error_type));\n        case Coq_value_null:\n          return (run_error(Native_error_type));\n        case Coq_value_bool(b0):\n          return (run_error(Native_error_type));\n        case Coq_value_number(n):\n          return (Value_number(n));\n        case Coq_value_string(s0):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Number")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_undef:\n                                return (run_error(Native_error_type));\n                              case Coq_value_null:\n                                return (run_error(Native_error_type));\n                              case Coq_value_bool(b0):\n                                return (run_error(Native_error_type));\n                              case Coq_value_number(n):\n                                return (Value_number(n));\n                              case Coq_value_string(s1):\n                                return (run_error(Native_error_type));\n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_array:\n      return (run_construct_prealloc(Prealloc_array, args));\n    case Coq_prealloc_array_is_array:\n      var arg = get_arg(0, args);\n      switch (arg) {\n        case Coq_value_object(arg0):\n          var%some class0 = run_object_method(object_class_, arg0);\n          if (string_eq(class0, "Array")) {\n            return (Value_bool(true));\n          } else {\n            return (Value_bool(false));\n          }\n        default:\n          return (Value_bool(false));\n      }\n      \n    case Coq_prealloc_array_proto_to_string:\n      var%object array = to_object(vthis);\n      var%value vfunc = run_object_get(array, "join");\n      if (is_callable_dec(vfunc)) {\n        switch (vfunc) {\n          case Coq_value_object(func):\n            return (run_call(func, array, mk_nil));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (\n          run_call_prealloc(Prealloc_object_proto_to_string, array, mk_nil));\n      }\n    case Coq_prealloc_array_proto_join:\n      var vsep = get_arg(0, args);\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%spec ilen = to_uint32(vlen);\n      if (!(value_compare(vsep, Value_undef))) {\n        var rsep = vsep;\n      } else {\n        var rsep = Value_string(",");\n      }\n      var%string sep = to_string(rsep);\n      if ((ilen == 0.0)) {\n        return (Value_string(""));\n      } else {\n        var sR = valueToStringForJoin(l, 0.);\n        var%spec sR0 = sR;\n        return (run_array_join_elements(l, 1., ilen, sep, sR0));\n      }\n    case Coq_prealloc_array_proto_pop:\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%spec ilen = to_uint32(vlen);\n      if ((ilen == 0.0)) {\n        var%not_throw x = object_put(l, "length",\n                            Value_number(JsNumber.zero), throw_true);\n        return (Value_undef);\n      } else {\n        var%string sindx = to_string(Value_number((ilen - 1.)));\n        var%value velem = run_object_get(l, sindx);\n        var%not_throw x = object_delete(l, sindx, throw_true);\n        var%not_throw x0 = object_put(l, "length", Value_string(sindx),\n                             throw_true);\n        return (velem);\n      }\n    case Coq_prealloc_array_proto_push:\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%spec ilen = to_uint32(vlen);\n      return (push(l, args, ilen));\n    case Coq_prealloc_string:\n      if (list_eq_nil_decidable(args)) {\n        return (Value_string(""));\n      } else {\n        var value0 = get_arg(0, args);\n        var%string s1 = to_string(value0);\n        return (Value_string(s1));\n      }\n    case Coq_prealloc_string_proto_to_string:\n      switch (vthis) {\n        case Coq_value_object(l):\n          var%some s0 = run_object_method(object_class_, l);\n          if (string_eq(s0, "String")) {\n            return (run_object_prim_value(l));\n          } else {\n            return (run_error(Native_error_type));\n          }\n        default:\n          if (type_compare(type_of(vthis), Type_string)) {\n            return (vthis);\n          } else {\n            return (run_error(Native_error_type));\n          }\n      }\n      \n    case Coq_prealloc_string_proto_value_of:\n      switch (vthis) {\n        case Coq_value_object(l):\n          var%some s0 = run_object_method(object_class_, l);\n          if (string_eq(s0, "String")) {\n            return (run_object_prim_value(l));\n          } else {\n            return (run_error(Native_error_type));\n          }\n        default:\n          if (type_compare(type_of(vthis), Type_string)) {\n            return (vthis);\n          } else {\n            return (run_error(Native_error_type));\n          }\n      }\n      \n    case Coq_prealloc_error:\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_error_proto, v));\n    case Coq_prealloc_native_error(ne):\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_native_error_proto(ne), v));\n    case Coq_prealloc_throw_type_error:\n      return (builtin_throw_type_error({}, {}, {}));\n    case Coq_prealloc_proxy:\n      return (\n        builtin_proxy_constructor({}, {}, Value_undef, get_arg(0, args),\n          get_arg(1, args)));\n    case Coq_prealloc_proxy_revocable:\n      return (\n        builtin_proxy_revocable({}, {}, {}, get_arg(0, args),\n          get_arg(1, args)));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}(\n          strappend("Call prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented"))));\n  }\n  \n};\n\nvar run_call = function (l, vthis, args) {\n  var%some co = run_object_method(object_call_, l);\n  var%some c0 = co;\n  switch (c0) {\n    case Coq_call_default:\n      return (entering_func_code(l, vthis, args));\n    case Coq_call_after_bind:\n      var%some oarg = run_object_method(object_bound_args_, l);\n      var%some boundArgs = oarg;\n      var%some obnd = run_object_method(object_bound_this_, l);\n      var%some boundThis = obnd;\n      var%some otrg = run_object_method(object_target_function_, l);\n      var%some target = otrg;\n      var arguments_ = LibList.append(boundArgs, args);\n      return (run_call(target, boundThis, arguments_));\n    case Coq_call_prealloc(b):\n      return (run_call_prealloc(b, vthis, args));\n    case Coq_call_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar run_javascript_from_state = function (p) {\n  var c = execution_ctx_initial(prog_intro_strictness(p));\n  var%void _ = execution_ctx_binding_inst(Codetype_global, None, p, mk_nil);\n  return (run_prog(p));\n};\n\nvar run_javascript_from_result = function (w, p) {\n  var%success _pat_any_89 = w;\n  return (run_javascript_from_state(p));\n};\n\nvar run_javascript = function (p) {\n  return (run_javascript_from_state(p));\n};\n}// end of with Datatypes\n}// end of with JsCommon\n}// end of with JsCommonAux\n}// end of with JsInit\n}// end of with JsInterpreterMonads\n}// end of with JsSyntax\n}// end of with JsSyntaxAux\n}// end of with LibList\n}// end of with LibOption\n}// end of with LibProd\n}// end of with Shared\n\nreturn {\n  equality_test_for_same_type: equality_test_for_same_type, \n  strict_equality_test: strict_equality_test, \n  inequality_test_number: inequality_test_number, \n  inequality_test_string: inequality_test_string, \n  typeof_prim: typeof_prim, \n  string_of_propname: string_of_propname, \n  run_object_method: run_object_method, \n  run_object_set_internal: run_object_set_internal, \n  run_object_heap_set_extensible: run_object_heap_set_extensible, \n  build_error: build_error, \n  run_error: run_error, \n  run_error_no_c: run_error_no_c, \n  some_context: some_context, \n  object_has_internal_slot: object_has_internal_slot, \n  object_has_internal_method: object_has_internal_method, \n  object_internal_get_prototype_of: object_internal_get_prototype_of, \n  object_internal_set_prototype_of: object_internal_set_prototype_of, \n  object_internal_is_extensible: object_internal_is_extensible, \n  object_internal_prevent_extensions: object_internal_prevent_extensions, \n  object_internal_get_own_property: object_internal_get_own_property, \n  object_internal_define_own_property: object_internal_define_own_property, \n  object_internal_has_property: object_internal_has_property, \n  object_internal_get: object_internal_get, \n  object_internal_set: object_internal_set, \n  object_put: object_put, \n  object_internal_delete: object_internal_delete, \n  object_delete_default: object_delete_default, \n  object_internal_own_property_keys: object_internal_own_property_keys, \n  object_internal_call: object_internal_call, \n  object_internal_construct: object_internal_construct, \n  get_base: get_base, \n  get_referenced_name: get_referenced_name, \n  is_strict_reference: is_strict_reference, \n  has_primitive_base: has_primitive_base, \n  is_property_reference: is_property_reference, \n  is_unresolvable_reference: is_unresolvable_reference, \n  is_super_reference: is_super_reference, \n  get_value: get_value, \n  put_value: put_value, \n  get_this_value: get_this_value, \n  is_accessor_descriptor: is_accessor_descriptor, \n  is_data_descriptor: is_data_descriptor, \n  is_generic_descriptor: is_generic_descriptor, \n  from_property_descriptor: from_property_descriptor, \n  to_property_descriptor: to_property_descriptor, \n  complete_property_descriptor: complete_property_descriptor, \n  to_primitive: to_primitive, \n  to_boolean: to_boolean, \n  to_number: to_number, \n  to_number_string: to_number_string, \n  to_integer: to_integer, \n  to_string: to_string, \n  to_string_number: to_string_number, \n  to_length: to_length, \n  require_object_coercible: require_object_coercible, \n  is_callable: is_callable, \n  is_constructor: is_constructor, \n  is_extensible: is_extensible, \n  is_property_key: is_property_key, \n  same_value: same_value, \n  same_value_non_number: same_value_non_number, \n  get: get, \n  get_v: get_v, \n  set: set, \n  create_data_property: create_data_property, \n  define_property_or_throw: define_property_or_throw, \n  get_method: get_method, \n  has_property: has_property, \n  call: call, \n  construct: construct, \n  set_integrity_level: set_integrity_level, \n  test_integrity_level: test_integrity_level, \n  create_array_from_list: create_array_from_list, \n  create_list_from_array_like: create_list_from_array_like, \n  set_mutable_binding: set_mutable_binding, \n  get_binding_value: get_binding_value, \n  binding_is_uninitialized: binding_is_uninitialized, \n  binding_is_mutable: binding_is_mutable, \n  decl_env_record_create_mutable_binding: decl_env_record_create_mutable_binding, \n  decl_env_record_initialize_binding: decl_env_record_initialize_binding, \n  decl_env_record_set_mutable_binding: decl_env_record_set_mutable_binding, \n  decl_env_record_get_binding_value: decl_env_record_get_binding_value, \n  object_env_record_set_mutable_binding: object_env_record_set_mutable_binding, \n  object_env_record_get_binding_value: object_env_record_get_binding_value, \n  get_global_object: get_global_object, \n  ordinary_object_internal_get_prototype_of: ordinary_object_internal_get_prototype_of, \n  ordinary_get_prototype_of: ordinary_get_prototype_of, \n  ordinary_object_internal_set_prototype_of: ordinary_object_internal_set_prototype_of, \n  ordinary_set_prototype_of: ordinary_set_prototype_of, \n  ordinary_object_internal_is_extensible: ordinary_object_internal_is_extensible, \n  ordinary_is_extensible: ordinary_is_extensible, \n  ordinary_object_internal_prevent_extensions: ordinary_object_internal_prevent_extensions, \n  ordinary_prevent_extensions: ordinary_prevent_extensions, \n  ordinary_object_internal_get_own_property: ordinary_object_internal_get_own_property, \n  ordinary_get_own_property: ordinary_get_own_property, \n  ordinary_object_internal_define_own_property: ordinary_object_internal_define_own_property, \n  ordinary_define_own_property: ordinary_define_own_property, \n  is_compatible_property_descriptor: is_compatible_property_descriptor, \n  validate_and_apply_property_descriptor: validate_and_apply_property_descriptor, \n  ordinary_object_internal_has_property: ordinary_object_internal_has_property, \n  ordinary_has_property: ordinary_has_property, \n  ordinary_object_internal_get: ordinary_object_internal_get, \n  ordinary_get: ordinary_get, \n  ordinary_object_internal_set: ordinary_object_internal_set, \n  ordinary_set: ordinary_set, \n  ordinary_object_internal_delete: ordinary_object_internal_delete, \n  ordinary_delete: ordinary_delete, \n  ordinary_object_internal_own_property_keys: ordinary_object_internal_own_property_keys, \n  ordinary_own_property_keys: ordinary_own_property_keys, \n  object_create: object_create, \n  add_restricted_function_properties: add_restricted_function_properties, \n  builtin_throw_type_error: builtin_throw_type_error, \n  array_create: array_create, \n  is_proxy_exotic_object: is_proxy_exotic_object, \n  proxy_object_internal_get_prototype_of: proxy_object_internal_get_prototype_of, \n  proxy_object_internal_set_prototype_of: proxy_object_internal_set_prototype_of, \n  proxy_object_internal_is_extensible: proxy_object_internal_is_extensible, \n  proxy_object_internal_prevent_extensions: proxy_object_internal_prevent_extensions, \n  proxy_object_internal_get_own_property: proxy_object_internal_get_own_property, \n  proxy_object_internal_define_own_property: proxy_object_internal_define_own_property, \n  proxy_object_internal_has_property: proxy_object_internal_has_property, \n  proxy_object_internal_get: proxy_object_internal_get, \n  proxy_object_internal_set: proxy_object_internal_set, \n  proxy_object_internal_delete: proxy_object_internal_delete, \n  proxy_object_internal_own_property_keys: proxy_object_internal_own_property_keys, \n  proxy_object_internal_call: proxy_object_internal_call, \n  proxy_object_internal_construct: proxy_object_internal_construct, \n  proxy_create: proxy_create, \n  builtin_object_freeze: builtin_object_freeze, \n  builtin_object_get_prototype_of: builtin_object_get_prototype_of, \n  builtin_object_is_extensible: builtin_object_is_extensible, \n  builtin_object_is_frozen: builtin_object_is_frozen, \n  builtin_object_is_sealed: builtin_object_is_sealed, \n  builtin_object_prevent_extensions: builtin_object_prevent_extensions, \n  builtin_object_seal: builtin_object_seal, \n  builtin_object_set_prototype_of: builtin_object_set_prototype_of, \n  builtin_proxy_constructor: builtin_proxy_constructor, \n  builtin_proxy_revocable: builtin_proxy_revocable, \n  proxy_revocation_function_create: proxy_revocation_function_create, \n  builtin_proxy_revocation_function: builtin_proxy_revocation_function, \n  object_has_prop: object_has_prop, \n  out_error_or_void: out_error_or_void, \n  out_error_or_cst: out_error_or_cst, \n  object_get_builtin: object_get_builtin, \n  run_object_get: run_object_get, \n  run_object_get_prop: run_object_get_prop, \n  object_proto_is_prototype_of: object_proto_is_prototype_of, \n  object_default_value: object_default_value, \n  to_int32: to_int32, \n  to_uint32: to_uint32, \n  run_object_define_own_prop_array_loop: run_object_define_own_prop_array_loop, \n  object_define_own_prop: object_define_own_prop, \n  prim_new_object: prim_new_object, \n  to_object: to_object, \n  run_object_prim_value: run_object_prim_value, \n  prim_value_get: prim_value_get, \n  env_record_has_binding: env_record_has_binding, \n  lexical_env_get_identifier_ref: lexical_env_get_identifier_ref, \n  object_delete: object_delete, \n  env_record_delete_binding: env_record_delete_binding, \n  env_record_implicit_this_value: env_record_implicit_this_value, \n  identifier_resolution: identifier_resolution, \n  env_record_get_binding_value: env_record_get_binding_value, \n  ref_get_value: ref_get_value, \n  run_expr_get_value: run_expr_get_value, \n  env_record_set_mutable_binding: env_record_set_mutable_binding, \n  ref_put_value: ref_put_value, \n  env_record_create_mutable_binding: env_record_create_mutable_binding, \n  env_record_create_set_mutable_binding: env_record_create_set_mutable_binding, \n  env_record_create_immutable_binding: env_record_create_immutable_binding, \n  env_record_initialize_immutable_binding: env_record_initialize_immutable_binding, \n  call_object_new: call_object_new, \n  array_args_map_loop: array_args_map_loop, \n  run_construct_prealloc: run_construct_prealloc, \n  run_construct_default: run_construct_default, \n  run_construct: run_construct, \n  run_call_default: run_call_default, \n  creating_function_object_proto: creating_function_object_proto, \n  creating_function_object: creating_function_object, \n  binding_inst_formal_params: binding_inst_formal_params, \n  binding_inst_function_decls: binding_inst_function_decls, \n  make_arg_getter: make_arg_getter, \n  make_arg_setter: make_arg_setter, \n  arguments_object_map_loop: arguments_object_map_loop, \n  arguments_object_map: arguments_object_map, \n  create_arguments_object: create_arguments_object, \n  binding_inst_arg_obj: binding_inst_arg_obj, \n  binding_inst_var_decls: binding_inst_var_decls, \n  execution_ctx_binding_inst: execution_ctx_binding_inst, \n  entering_func_code: entering_func_code, \n  run_object_get_own_prop: run_object_get_own_prop, \n  run_function_has_instance: run_function_has_instance, \n  run_object_has_instance: run_object_has_instance, \n  from_prop_descriptor: from_prop_descriptor, \n  run_equal: run_equal, \n  convert_twice: convert_twice, \n  convert_twice_primitive: convert_twice_primitive, \n  convert_twice_number: convert_twice_number, \n  convert_twice_string: convert_twice_string, \n  issome: issome, \n  run_binary_op_add: run_binary_op_add, \n  run_binary_op_arith: run_binary_op_arith, \n  run_binary_op_shift: run_binary_op_shift, \n  run_binary_op_bitwise: run_binary_op_bitwise, \n  run_binary_op_compare: run_binary_op_compare, \n  run_binary_op_instanceof: run_binary_op_instanceof, \n  run_binary_op_in: run_binary_op_in, \n  run_binary_op: run_binary_op, \n  run_prepost_op: run_prepost_op, \n  run_typeof_value: run_typeof_value, \n  run_unary_op: run_unary_op, \n  create_new_function_in: create_new_function_in, \n  init_object: init_object, \n  run_array_element_list: run_array_element_list, \n  init_array: init_array, \n  run_var_decl_item: run_var_decl_item, \n  run_var_decl: run_var_decl, \n  run_list_expr: run_list_expr, \n  run_block: run_block, \n  run_binary_op_and: run_binary_op_and, \n  run_binary_op_or: run_binary_op_or, \n  run_expr_binary_op: run_expr_binary_op, \n  run_expr_access: run_expr_access, \n  run_expr_assign: run_expr_assign, \n  run_expr_function: run_expr_function, \n  entering_eval_code: entering_eval_code, \n  run_eval: run_eval, \n  run_expr_call: run_expr_call, \n  run_expr_conditionnal: run_expr_conditionnal, \n  run_expr_new: run_expr_new, \n  run_stat_label: run_stat_label, \n  run_stat_with: run_stat_with, \n  run_stat_if: run_stat_if, \n  run_stat_while: run_stat_while, \n  run_stat_switch_end: run_stat_switch_end, \n  run_stat_switch_no_default: run_stat_switch_no_default, \n  run_stat_switch_with_default_default: run_stat_switch_with_default_default, \n  run_stat_switch_with_default_B: run_stat_switch_with_default_B, \n  run_stat_switch_with_default_A: run_stat_switch_with_default_A, \n  run_stat_switch: run_stat_switch, \n  run_stat_do_while: run_stat_do_while, \n  run_stat_try: run_stat_try, \n  run_stat_throw: run_stat_throw, \n  run_stat_return: run_stat_return, \n  run_stat_for_loop: run_stat_for_loop, \n  run_stat_for: run_stat_for, \n  run_stat_for_var: run_stat_for_var, \n  run_expr: run_expr, \n  run_stat: run_stat, \n  run_elements: run_elements, \n  run_prog: run_prog, \n  push: push, \n  run_object_is_sealed: run_object_is_sealed, \n  run_object_seal: run_object_seal, \n  run_object_freeze: run_object_freeze, \n  run_object_is_frozen: run_object_is_frozen, \n  run_get_args_for_apply: run_get_args_for_apply, \n  valueToStringForJoin: valueToStringForJoin, \n  run_array_join_elements: run_array_join_elements, \n  run_call_prealloc: run_call_prealloc, \n  run_call: run_call, \n  run_javascript_from_state: run_javascript_from_state, \n  run_javascript_from_result: run_javascript_from_result, \n  run_javascript: run_javascript};\n})();\n'},

/* --------------------- JsInterpreter.ml --------------------- */
  { file: 'JsInterpreter.ml', contents: 'open Datatypes\nopen JsCommon\nopen JsCommonAux\nopen JsInit\nopen JsInterpreterMonads\nopen JsSyntax\nopen JsSyntaxAux\nopen LibList\nopen LibOption\nopen LibProd\nopen Shared\n\n(** ECMAScript Reference Interpreter Implementation\n\n    @esurl     https://tc39.github.io/ecma262/\n    @esversion 2017\n*)\n\n(* Basically, the ordering of the functions in this file are random. They need to be sorted. *)\n\n(*------------JS preliminary -----------*)\n\n\n(** val equality_test_for_same_type : coq_type -> value -> value -> bool **)\n\nlet equality_test_for_same_type ty v1 v2 =\n  match ty with\n  | Coq_type_undef -> true\n  | Coq_type_null -> true\n  | Coq_type_bool -> value_compare v1 v2\n  | Coq_type_number ->\n    (match v1 with\n     | Coq_value_undef -> false\n     | Coq_value_null -> false\n     | Coq_value_bool b -> false\n     | Coq_value_string s -> false\n     | Coq_value_number n1 ->\n       (match v2 with\n        | Coq_value_undef -> false\n        | Coq_value_null -> false\n        | Coq_value_bool b -> false\n        | Coq_value_string s -> false\n        | Coq_value_number n2 ->\n          if JsNumber.isnan n1\n          then false\n          else if JsNumber.isnan n2\n               then false\n               else if   (JsNumber.isposzero n1)\n                      && (JsNumber.isnegzero n2)\n                    then true\n                    else if   (JsNumber.isnegzero n1)\n                          &&  (JsNumber.isposzero n2)\n                         then true\n                         else n1 === n2\n        | Coq_value_object o -> false)\n     | Coq_value_object o -> false)\n  | Coq_type_string -> value_compare v1 v2\n  | Coq_type_object -> value_compare v1 v2\n\n(** val strict_equality_test : value -> value -> bool **)\n\nlet strict_equality_test v1 v2 =\n  let ty1 = type_of v1 in\n  let ty2 = type_of v2 in\n  if type_compare ty1 ty2\n  then equality_test_for_same_type ty1 v1 v2\n  else false\n\n(** val inequality_test_number : number -> number -> prim **)\n\nlet inequality_test_number n1 n2 =\n  if (JsNumber.isnan n1) || (JsNumber.isnan n2)\n  then Coq_value_undef else if n1 === n2\n       then Coq_value_bool false\n       else if   (JsNumber.isposzero n1)\n              && (JsNumber.isnegzero n2)\n            then Coq_value_bool false\n            else if (JsNumber.isnegzero n1)\n                 && (JsNumber.isposzero n2)\n                 then Coq_value_bool false\n                 else if n1 === JsNumber.infinity\n                      then Coq_value_bool false\n                      else if n2 === JsNumber.infinity\n                           then Coq_value_bool true\n                           else if n2 === JsNumber.neg_infinity\n                                then Coq_value_bool false\n                                else if n1 === JsNumber.neg_infinity\n                                     then Coq_value_bool true\n                                     else Coq_value_bool (n1 < n2)\n\n(** val inequality_test_string : string -> string -> bool **)\n\n(* ARTHUR hack \nlet rec inequality_test_string s1 s2 =\n  match s1 with\n  | [] ->\n    (match s2 with\n     | [] -> false\n     | a::s -> true)\n  | c1::s1_2 ->\n    (match s2 with\n     | [] -> false\n     | c2::s2_2 ->\n       if ascii_comparable c1 c2\n       then inequality_test_string s1_2 s2_2\n       else lt_int_decidable (int_of_char c1) (int_of_char c2))\n*)\nlet inequality_test_string s1 s2 = string_lt s1 s2\n\n\n(** val typeof_prim : prim -> string **)\n\nlet typeof_prim _foo_ = match _foo_ with\n| Coq_value_undef -> "undefined"\n| Coq_value_null -> "object"\n| Coq_value_bool b -> "boolean"\n| Coq_value_number n -> "number"\n| Coq_value_string s -> "string"\n| _ -> assert false\n\n(** val string_of_propname : propname -> prop_name **)\n\nlet string_of_propname _foo_ = match _foo_ with\n| Coq_propname_identifier s -> s\n| Coq_propname_string s -> s\n| Coq_propname_number n -> JsNumber.to_string n\n\n(*---------------------------------*)\n\n\n(** Fetches a given object slot value (using proj) from the object l in state s\n    FIXME: The name is very confusing. *)\nlet run_object_method proj s l =\n  LibOption.map proj (object_binds_option s l)\n\n(*---DEBUG\n  let run_object_method proj s l =\n   let opt = object_binds_option s l in\n     begin match opt with\n       | None -> Debug.run_object_method l\n       | _ -> ()\n     end;\n     LibOption.map proj opt\n*)\n\n(** val run_object_heap_set :\n    (coq_object -> a\' -> coq_object) -> state -> object_loc -> a\' -> state option **)\n(** Updates an object\'s internal field with the given update function [prj].\n    (Update functions are defined in JsSyntaxAux) *)\n\nlet run_object_set_internal prj s l v =\n  LibOption.map (fun o -> object_write s l (prj o v)) (object_binds_option s l)\n\n(** val run_object_heap_set_extensible :\n    bool -> state -> object_loc -> state option **)\n\nlet run_object_heap_set_extensible b s l =\n  run_object_set_internal object_set_extensible s l b\n\n(* DEBUG\n   let run_object_heap_set_extensible b s l =\n   let opt = object_binds_option s l in\n     begin match opt with\n       | None -> Debug.run_object_heap_set_extensible l\n       | _ -> ()\n     end;\n     LibOption.map (fun o -> object_write s l (object_set_extensible o b)) opt\n*)\n\nlet rec build_error s c vproto vmsg =\n  let o = object_new vproto ("Error") in\n  let (l, s_2) = object_alloc s o in\n  if value_compare vmsg Coq_value_undef\n  then res_out s_2 (res_val (Coq_value_object l))\n  else (\n    let%value (s_3, vstr) = to_string s_2 vmsg in\n    let a = { attributes_data_value = vstr; attributes_data_writable = true;\n      attributes_data_enumerable = false; attributes_data_configurable = true } in\n    let%success (s_4, rv) = object_define_own_prop s_3 c l "message" (descriptor_of_attributes (Coq_attributes_data_of a)) throw_true in\n    res_out s_4 (res_val (Coq_value_object l))\n  )\n\nand run_error s c ne =\n  let%object (s_2, l) = (build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                                            (Coq_prealloc_native_error_proto ne))) Coq_value_undef) in\n  res_out s_2 (res_throw (Coq_resvalue_value (Coq_value_object l)))\n\nand run_error_no_c : \'a. state -> native_error -> \'a specret resultof =\n  fun s ne ->\n  let vproto = Coq_value_object (Coq_object_loc_prealloc (Coq_prealloc_native_error_proto ne)) in\n  let o = object_new vproto ("error") in\n  let (l, s_2) = object_alloc s o in\n  res_out s_2 (res_throw (Coq_resvalue_value (Coq_value_object l)))\n\n(* FIXME: ES5 HACK for where a context is required *)\nand some_context = execution_ctx_initial true\n\n(*****************************************************************************)\n(*****************************************************************************)\n(************* START OF THE BIG RECURSIVE INTERPRETER FUNCTION ***************)\n(*****************************************************************************)\n(*****************************************************************************)\n\n(** New ES6 Spec functions here, writting in the specification in CamelCase()\n    will all be prefixed with spec_ *)\n\n(** {4 Object Internal Methods and Internal Slots }\n    @esid sec-object-internal-methods-and-internal-slots\n    @essec 6.1.7.2 *)\n(** Function to implement the specification text "O has a [[X]] internal slot"\n    @param l    The location of O\n    @param prj  The object projection function corresponding to [[X]] *)\nand object_has_internal_slot : \'a. state -> object_loc -> (coq_object -> \'a option) -> bool =\n  fun s l prj ->\n  match run_object_method prj s l with\n  | None -> assert false\n  | Some a -> is_some a\n\n(** Function to implement the specification text of "O has a [[X]] internal method" *)\nand object_has_internal_method : \'a. state -> object_loc -> (coq_object -> \'a option) -> bool =\n  fun s l prj ->\n  object_has_internal_slot s l prj\n\n(** {5 Object Internal Method Dispatch Functions }\n    Functions in this section are used to dispatch Internal Methods to the\n    correct implementation based upon the value of the internal slot\n\n    All these functions accept a parameter o, which is the {i location} of the object.\n *)\n\n(** Function to dispatch calls to O.[[GetPrototypeOf]]() *)\nand object_internal_get_prototype_of s o =\n  let%some internal_method = run_object_method object_get_prototype_of_ s o in\n  match internal_method with\n  | Coq_builtin_get_prototype_of_default -> ordinary_object_internal_get_prototype_of s o\n  | Coq_builtin_get_prototype_of_proxy   -> proxy_object_internal_get_prototype_of s o\n\n(** Function to dispatch calls to O.[[GetPrototypeOf]](V) *)\nand object_internal_set_prototype_of s o v =\n  let%some internal_method = run_object_method object_set_prototype_of_ s o in\n  match internal_method with\n  | Coq_builtin_set_prototype_of_default -> ordinary_object_internal_set_prototype_of s o v\n  | Coq_builtin_set_prototype_of_proxy   -> proxy_object_internal_set_prototype_of s o v\n\n(** Function to dispatch calls to O.[[IsExtensible]]() *)\nand object_internal_is_extensible s o =\n  let%some internal_method = run_object_method object_is_extensible_ s o in\n  match internal_method with\n  | Coq_builtin_is_extensible_default -> ordinary_object_internal_is_extensible s o\n  | Coq_builtin_is_extensible_proxy   -> proxy_object_internal_is_extensible s o\n\n(** Function to dispatch calls to O.[[PreventExtensions]]() *)\nand object_internal_prevent_extensions s o =\n  let%some internal_method = run_object_method object_prevent_extensions_ s o in\n  match internal_method with\n  | Coq_builtin_prevent_extensions_default -> ordinary_object_internal_prevent_extensions s o\n  | Coq_builtin_prevent_extensions_proxy   -> proxy_object_internal_prevent_extensions s o\n\n(** Function to dispatch calls to O.[[GetOwnProperty]](P) *)\nand object_internal_get_own_property s o p =\n  let%some internal_method = run_object_method object_get_own_prop_ s o in\n  match internal_method with\n  | Coq_builtin_get_own_prop_default  -> ordinary_object_internal_get_own_property s o p\n  | Coq_builtin_get_own_prop_args_obj -> Coq_result_not_yet_implemented (* TODO *)\n  | Coq_builtin_get_own_prop_string   -> Coq_result_not_yet_implemented (* TODO *)\n  | Coq_builtin_get_own_prop_proxy    -> proxy_object_internal_get_own_property s o p\n\n(** Function to dispatch calls to O.[[DefineOwnProperty]](P, desc) *)\nand object_internal_define_own_property s o p desc =\n  let%some internal_method = run_object_method object_define_own_prop_ s o in\n  match internal_method with\n  | Coq_builtin_define_own_prop_default  -> ordinary_object_internal_define_own_property s o p desc\n  | Coq_builtin_define_own_prop_array    -> Coq_result_not_yet_implemented (* TODO *)\n  | Coq_builtin_define_own_prop_args_obj -> Coq_result_not_yet_implemented (* TODO *)\n  | Coq_builtin_define_own_prop_proxy    -> ordinary_object_internal_define_own_property s o p desc\n\n(** Function to dispatch calls to O.[[HasProperty]](P) *)\nand object_internal_has_property s o p =\n  let%some b = run_object_method object_has_prop_ s o in\n  match b with\n  | Coq_builtin_has_prop_default -> ordinary_object_internal_has_property s o p\n  | Coq_builtin_has_prop_proxy   -> proxy_object_internal_has_property s o p\n\n(** Function to dispatch calls to O.[[Get]](P, receiver) *)\nand object_internal_get s o p receiver =\n  let%some internal_method = (run_object_method object_get_ s o) in\n  match internal_method with\n  | Coq_builtin_get_default  -> ordinary_object_internal_get s o p receiver\n  | Coq_builtin_get_args_obj -> Coq_result_not_yet_implemented\n  | Coq_builtin_get_proxy    -> proxy_object_internal_get s o p receiver\n\n(** Function to dispatch calls to O.[[Set]](P, V, Receiver) *)\nand object_internal_set s o p v receiver =\n  let%some internal_method = (run_object_method object_set_ s o) in\n  match internal_method with\n  | Coq_builtin_set_default -> ordinary_object_internal_set s o p v receiver\n  | Coq_builtin_set_proxy   -> proxy_object_internal_set s o p v receiver\n\n(** @deprecated FIXME: In favour of potentially the same [object_internal_set] ES6 method *)\nand object_put s c l p v str = object_internal_set s l (Coq_value_string p) v (Coq_value_object l)\n\n(** Function to dispatch calls to O.[[Delete]](P) *)\nand object_internal_delete s o p =\n  let%some internal_method = run_object_method object_delete_ s o in\n  match internal_method with\n  | Coq_builtin_delete_default  -> ordinary_object_internal_delete s o p\n  | Coq_builtin_delete_args_obj -> Coq_result_not_yet_implemented\n  | Coq_builtin_delete_proxy    -> proxy_object_internal_delete s o p\n\n(** @deprecated FIXME: ES5 *)\nand object_delete_default s c l x str =\n  let%bool s, b = ordinary_object_internal_delete s l (Coq_value_string x) in\n  if str && (not b) then\n    run_error_no_c s Coq_native_error_type\n  else\n    res_ter s (res_val (Coq_value_bool b))\n\n(** Function to dispatch calls to O.[[OwnPropertyKeys]]() *)\nand object_internal_own_property_keys s o =\n  let%some internal_method = run_object_method object_own_property_keys_ s o in\n  match internal_method with\n  | Coq_builtin_own_property_keys_default -> ordinary_object_internal_own_property_keys s o\n  | Coq_builtin_own_property_keys_proxy   -> proxy_object_internal_own_property_keys s o\n\n(** Function to dispatch calls to O.[[Call]](thisArgument, argumentsList) *)\nand object_internal_call s o thisArgument argumentsList =\n  let%some internal_method = run_object_method object_call_ s o in\n  let%some internal_method = internal_method in\n  match internal_method with\n  (* FIXME: ES5 hacks *)\n  | Coq_call_default    -> run_call s some_context o thisArgument argumentsList\n  | Coq_call_after_bind -> run_call s some_context o thisArgument argumentsList\n  | Coq_call_prealloc _ -> run_call s some_context o thisArgument argumentsList\n  | Coq_call_proxy      -> proxy_object_internal_call s o thisArgument argumentsList\n\n(** Function to dispatch calls to O.[[Construct]](argumentsList, newTarget) *)\nand object_internal_construct s o argumentsList newTarget =\n  let%some internal_method = run_object_method object_construct_ s o in\n  let%some internal_method = internal_method in\n  match internal_method with\n  (* FIXME: ES5 hacks *)\n  | Coq_construct_default    -> run_construct s some_context internal_method o argumentsList\n  | Coq_construct_after_bind -> run_construct s some_context internal_method o argumentsList\n  | Coq_construct_prealloc _ -> run_construct s some_context internal_method o argumentsList\n  | Coq_construct_proxy      -> proxy_object_internal_construct s o argumentsList newTarget\n\n\n(** {3 The Reference Specification Type}\n    @essec 6.2.4\n    @esid sec-reference-specification-type *)\n\nand get_base = ref_base\n\n(* Note: may prefer this to return a raw string? *)\nand get_referenced_name r =\n  Coq_value_string (ref_name r)\n\nand is_strict_reference = ref_strict\n\n(* TODO: Copied ES5 code, tidy up *)\nand has_primitive_base r =\n  ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base\n\nand is_property_reference r =\n  (ref_kind_of r === Coq_ref_kind_object) || has_primitive_base r\n\nand is_unresolvable_reference r =\n  ref_kind_of r === Coq_ref_kind_undef\n\nand is_super_reference r =\n  is_some r.ref_this_value\n\n(** GetValue(V)\n\n    Note: Although the type of [v] is a resultof, its state is disregarded\n    and must be explicitly passed to prevent issues with the value being\n    computed prior to other state mutations.\n\n    @esid sec-getvalue\n    @essec 6.2.4.1\n*)\nand get_value s v =\n  let%success (_, v\') = v in\n  if not (type_of_resvalue v\' === Type_resvalue_ref) then v\n  else\n    let v = ref_of_resvalue v\' in\n    let base = get_base v in\n    if is_unresolvable_reference v then\n      run_error_no_c s Coq_native_error_ref\n    else if is_property_reference v then\n      let base = value_of_ref_base_type base in\n      let%ret (s, base) =\n        if has_primitive_base v then\n          let%assert_ret _ = not (base === Coq_value_undef || base === Coq_value_null) in\n          let%OBJECT_ret (s, base) = to_object s base in\n          Continue (s, base)\n        else\n          Continue (s, loc_of_value base)\n      in object_internal_get s base (get_referenced_name v) (get_this_value v)\n    else\n      let base = env_loc_of_ref_base_type base in\n      get_binding_value s base (get_referenced_name v) (is_strict_reference v)\n\n(** PutValue(V,W)\n\n    Note: Although the types of [v] and [w] are resultof, their states are\n    disregarded and must be explicitly passed, as it is not clear in which\n    order they were calculated.\n\n    @esid sec-putvalue\n    @essec 6.2.4.2\n*)\nand put_value s c v w =\n  let%success (_, v) = v in\n  let%value (_, w) = w in\n  if not (type_of_resvalue v === Type_resvalue_ref) then\n    run_error_no_c s Coq_native_error_ref\n  else\n  let v = ref_of_resvalue v in\n  let base = get_base v in\n  if is_unresolvable_reference v then\n    if is_strict_reference v then\n      run_error_no_c s Coq_native_error_ref\n    else\n      let globalObj = get_global_object s c in\n      set s globalObj (get_referenced_name v) w (Coq_value_bool false)\n  else if is_property_reference v then\n    let base = value_of_ref_base_type base in\n    let%ret s, base =\n      if has_primitive_base v then\n        let%assert_ret _ = not (base === Coq_value_null || base === Coq_value_undef) in\n        let%OBJECT_ret s, base = to_object s base in\n        Continue (s, base)\n      else\n        Continue (s, loc_of_value base)\n    in\n    let%bool s, succeeded = object_internal_set s base (get_referenced_name v) w (get_this_value v) in\n    if (not succeeded) && (is_strict_reference v) then\n      run_error_no_c s Coq_native_error_type\n    else\n      res_void s\n  else\n    let base = env_loc_of_ref_base_type base in\n    set_mutable_binding s base (get_referenced_name v) w (Coq_value_bool (is_strict_reference v))\n\n(** @esid sec-getthisvalue\n    @essec 6.2.4.3 *)\nand get_this_value v =\n  let asrt = assert (is_property_reference v) in\n  if is_super_reference v then\n    ref_this_value v\n  else\n    value_of_ref_base_type (get_base v)\n\n\n(** {3 The Property Descriptor Specification Type}\n    @esid sec-property-descriptor-specification-type\n    @essec 6.2.5 *)\n\n(** @essec 6.2.5.1\n    @esid sec-isaccessordescriptor *)\nand is_accessor_descriptor desc =\n  match desc with\n  | Descriptor_undef -> false\n  | Descriptor desc -> not\n    (  (option_compare value_compare desc.descriptor_get None)\n    && (option_compare value_compare desc.descriptor_set None))\n\n(** @essec 6.2.5.2\n    @esid sec-isdatadescriptor *)\nand is_data_descriptor desc =\n  match desc with\n  | Descriptor_undef -> false\n  | Descriptor desc -> not\n    (  (option_compare value_compare desc.descriptor_value None)\n    && (option_compare bool_eq desc.descriptor_writable None))\n\n(** @essec 6.2.5.3\n    @esid sec-isgenericdescriptor *)\nand is_generic_descriptor desc =\n  match desc with\n  | Descriptor_undef -> false\n  | Descriptor _ -> (not (is_accessor_descriptor desc)) && (not (is_data_descriptor desc))\n\n(** @essec 6.2.5.4\n    @esid sec-frompropertydescriptor *)\nand from_property_descriptor s desc =\n  if desc === Descriptor_undef then res_ter s (res_val Coq_value_undef)\n  else\n  let desc = descriptor_get_defined desc in\n  let%value s, obj = object_create s (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_object_proto)) None in\n  let%assert _ = type_of obj === Coq_type_object in (* TODO: is extensible with no own properties *)\n  let%ret s = if is_some desc.descriptor_value then\n    let%bool_ret s, result = create_data_property s obj (Coq_value_string "value") (unsome_error desc.descriptor_value) in\n    let%assert_ret _ = result in\n    Continue s\n    else Continue s\n\n  in let%ret s = if is_some desc.descriptor_writable then\n    let%bool_ret s, result = create_data_property s obj (Coq_value_string "writable") (Coq_value_bool (unsome_error desc.descriptor_writable)) in\n    let%assert_ret _ = result in\n    Continue s\n    else Continue s\n\n  in let%ret s = if is_some desc.descriptor_get then\n    let%bool_ret s, result = create_data_property s obj (Coq_value_string "get") (unsome_error desc.descriptor_get) in\n    let%assert_ret _ = result in\n    Continue s\n    else Continue s\n\n  in let%ret s = if is_some desc.descriptor_set then\n    let%bool_ret s, result = create_data_property s obj (Coq_value_string "set") (unsome_error desc.descriptor_set) in\n    let%assert_ret _ = result in\n    Continue s\n    else Continue s\n\n  in let%ret s = if is_some desc.descriptor_enumerable then\n    let%bool_ret s, result = create_data_property s obj (Coq_value_string "enumerable") (Coq_value_bool (unsome_error desc.descriptor_enumerable)) in\n    let%assert_ret _ = result in\n    Continue s\n    else Continue s\n\n  in let%ret s = if is_some desc.descriptor_configurable then\n    let%bool_ret s, result = create_data_property s obj (Coq_value_string "configurable") (Coq_value_bool (unsome_error desc.descriptor_configurable)) in\n    let%assert_ret _ = result in\n    Continue s\n    else Continue s\n  (* The bulk CreateDataProperty returns true assertion of step 10 has been placed into each individual operation *)\n  in res_ter s (res_val obj)\n\n(** @esid sec-topropertydescriptor\n    @essec 6.2.5.5 *)\nand to_property_descriptor s _foo_ =\n  match _foo_ with\n  | Coq_value_object l ->\n    let desc = descriptor_intro_empty in\n    let%bool (s, hasEnumerable) = has_property s _foo_ (Coq_value_string "enumerable") in\n    let%spec (s, desc) =\n      if hasEnumerable\n      then\n        let%value (s, v) = get s _foo_ (Coq_value_string "enumerable") in\n        let enum = to_boolean v in\n        res_spec s (descriptor_with_enumerable desc (Some enum))\n      else res_spec s desc\n    in\n    let%bool (s, hasConfigurable) = has_property s _foo_ (Coq_value_string "configurable") in\n    let%spec (s, desc) =\n      if hasConfigurable\n      then\n        let%value (s, v) = get s _foo_ (Coq_value_string "configurable") in\n        let conf = to_boolean v in\n        res_spec s (descriptor_with_configurable desc (Some conf))\n      else res_spec s desc\n    in\n    let%bool (s, hasValue) = has_property s _foo_ (Coq_value_string "value") in\n    let%spec (s, desc) =\n      if hasValue\n      then\n        let%value (s, value) = get s _foo_ (Coq_value_string "value") in\n        res_spec s (descriptor_with_value desc (Some value))\n      else res_spec s desc\n    in\n    let%bool (s, hasWritable) = has_property s _foo_ (Coq_value_string "writable") in\n    let%spec (s, desc) =\n      if hasValue\n      then\n        let%value (s, v) = get s _foo_ (Coq_value_string "writable") in\n        let writable = to_boolean v in\n        res_spec s (descriptor_with_writable desc (Some writable))\n      else res_spec s desc\n    in\n    let%bool (s, hasGet) = has_property s _foo_ (Coq_value_string "get") in\n    let%spec (s, desc) =\n      if hasGet\n      then\n        let%value (s, getter) = get s _foo_ (Coq_value_string "get") in\n        if (not (is_callable s getter)) && (not (type_of getter === Coq_type_undef))\n        then run_error_no_c s Coq_native_error_type\n        else res_spec s (descriptor_with_get desc (Some getter))\n      else res_spec s desc\n    in\n    let%bool (s, hasSet) = has_property s _foo_ (Coq_value_string "set") in\n    let%spec (s, desc) =\n      if hasSet\n      then\n        let%value (s, setter) = get s _foo_ (Coq_value_string "set") in\n        if (not (is_callable s setter)) && (not (type_of setter === Coq_type_undef))\n        then run_error_no_c s Coq_native_error_type\n        else res_spec s (descriptor_with_set desc (Some setter))\n      else res_spec s desc\n    in\n    if ((not (desc.descriptor_get === None)) || (not (desc.descriptor_set === None)))\n      && ((not (desc.descriptor_value === None)) || (not (desc.descriptor_writable === None)))\n    then run_error_no_c s Coq_native_error_type\n    else res_spec s desc\n  | _ -> throw_result (run_error_no_c s Coq_native_error_type)\n\n(** Completes a property descriptor by setting default fields.\n\n  FIXME: This implementation treats Property Descriptors as value types\n  instead of as reference types as the specification intends. This method\n  is used in the spec as "Call CompletePropertyDescriptor(Desc)" expecting\n  that Desc will be mutated.\n\n  @essec 6.2.5.6\n  @esid sec-completepropertydescriptor *)\nand complete_property_descriptor desc =\n  let desc = descriptor_get_defined desc in\n  let like = { descriptor_value        = Some Coq_value_undef;\n               descriptor_writable     = Some false;\n               descriptor_get          = Some Coq_value_undef;\n               descriptor_set          = Some Coq_value_undef;\n               descriptor_enumerable   = Some false;\n               descriptor_configurable = Some false }\n  in let desc =\n    if is_generic_descriptor (Descriptor desc) || is_data_descriptor (Descriptor desc)\n    then\n      let desc = descriptor_with_value desc like.descriptor_value in\n      descriptor_with_writable desc like.descriptor_writable\n    else\n      let desc = descriptor_with_get desc like.descriptor_get in\n      descriptor_with_set desc like.descriptor_set\n  in let desc =\n    if option_compare bool_eq desc.descriptor_enumerable None\n    then descriptor_with_enumerable desc like.descriptor_enumerable\n    else desc\n  in let desc =\n    if option_compare bool_eq desc.descriptor_configurable None\n    then descriptor_with_configurable desc like.descriptor_configurable\n    else desc\n  in desc\n\n(** {1 Abstract Operations }\n    @essec 7\n    @esid sec-abstract-operations *)\n\n(** {2 Type Conversion }\n    @essec 7.1\n    @esid sec-type-conversion *)\n\n(** @essec 7.1.1\n    @esid sec-toprimitive *)\nand to_primitive s input preferredType =\n  match input with\n  (** @esid table-9 *)\n  | Coq_value_undef    -> res_out s (res_val input)\n  | Coq_value_null     -> res_out s (res_val input)\n  | Coq_value_bool _   -> res_out s (res_val input)\n  | Coq_value_number _ -> res_out s (res_val input)\n  | Coq_value_string _ -> res_out s (res_val input)\n  (* | Coq_value_symbol _ -> res_out s (res_val input) *)\n  | Coq_value_object l ->\n    (* TODO: ES5 HACK! *)\n    let%prim s0, r = object_default_value s some_context l preferredType in\n    res_ter s0 (res_val r)\n\n\n(** @essec 7.1.2\n    @esid sec-toboolean *)\nand to_boolean argument = match argument with\n| Coq_value_undef -> false\n| Coq_value_null -> false\n| Coq_value_bool b -> b\n| Coq_value_number n ->\n  if (JsNumber.isposzero n) || (JsNumber.isnegzero n) || (JsNumber.isnan n) then false\n  else true\n| Coq_value_string s -> if string_eq s "" then false else true\n(* | Coq_value_symbol s -> true *)\n| Coq_value_object o -> true\n\n(** @essed 7.1.3\n    @esid sec-tonumber *)\nand to_number s argument = match argument with\n(** @esid table-11 *)\n| Coq_value_undef    -> res_ter s (res_val (Coq_value_number JsNumber.nan))\n| Coq_value_null     -> res_ter s (res_val (Coq_value_number JsNumber.zero))\n| Coq_value_bool b   ->\n    if b then res_ter s (res_val (Coq_value_number JsNumber.one))\n    else res_ter s (res_val (Coq_value_number JsNumber.zero))\n| Coq_value_number n -> res_ter s (res_val (Coq_value_number n))\n| Coq_value_string x -> res_ter s (res_val (Coq_value_number (to_number_string x)))\n(* TODO: | Coq_value_symbol _ -> run_error_no_c s Coq_native_error_type *)\n| Coq_value_object l ->\n  let%value s, primValue = to_primitive s argument (Some Coq_preftype_number) in\n  to_number s primValue\n\n(** TODO: ES6-ify\n    @essec 7.1.3.1\n    @esid sec-tonumber-applied-to-the-string-type *)\nand to_number_string s = JsNumber.from_string s\n\n(** @essec 7.1.4\n    @esid sec-tointeger *)\nand to_integer s argument =\n  let%number s, number = to_number s argument in\n  if JsNumber.isnan number then\n    res_ter s (res_val (Coq_value_number JsNumber.zero))\n  else if (JsNumber.isposzero number) || (JsNumber.isnegzero number) ||\n          (number === JsNumber.infinity) || (number === JsNumber.neg_infinity) then\n    res_ter s (res_val (Coq_value_number number))\n  else\n    res_ter s (res_val (Coq_value_number ((JsNumber.sign number) *. (JsNumber.floor (JsNumber.absolute number)))))\n\n\n(** @essec 7.1.12\n    @esid sec-tostring *)\nand to_string s argument =\n  match argument with\n  (** @esid table-12 *)\n  | Coq_value_undef    -> res_out s (res_val (Coq_value_string "undefined"))\n  | Coq_value_null     -> res_out s (res_val (Coq_value_string "null"))\n  | Coq_value_bool b   -> (match b with\n    | true  -> res_out s (res_val (Coq_value_string "true"))\n    | false -> res_out s (res_val (Coq_value_string "false")))\n  | Coq_value_number n -> res_out s (res_val (Coq_value_string (to_string_number n)))\n  | Coq_value_string _ -> res_out s (res_val argument)\n  (* | Coq_value_symbol _ -> run_error_no_c s Coq_native_error_type *)\n  | Coq_value_object o ->\n      let%value s, primValue = to_primitive s argument (Some Coq_preftype_string) in\n      to_string s primValue\n\n(** @essec 7.1.12.1\n    @esid sec-tostring-applied-to-the-number-type *)\nand to_string_number = JsNumber.to_string\n\n(** @essec 7.1.15\n    @esid sec-tolength *)\nand to_length s argument =\n  let%number s, len = to_integer s argument in\n  if len <= 0. then res_ter s (res_val (Coq_value_number 0.))\n  else res_ter s (res_val (Coq_value_number (JsNumber.min len ((JsNumber.pow 2. 53.)-.1.))))\n\n(** {2 Testing and Comparison Operations }\n    @essec 7.2\n    @esid sec-testing-and-comparison-operations *)\n\n(** @essec 7.2.1\n    @esid sec-requireobjectcoercible *)\nand require_object_coercible s argument =\n  match argument with\n  (** @esid table-14 *)\n  | Coq_value_undef -> run_error_no_c s Coq_native_error_type\n  | Coq_value_null  -> run_error_no_c s Coq_native_error_type\n  | Coq_value_bool   _ -> res_ter s (res_val argument)\n  | Coq_value_number _ -> res_ter s (res_val argument)\n  | Coq_value_string _ -> res_ter s (res_val argument)\n  (* | Coq_value_symbol  _ -> res_ter s (res_val argument) *)\n  | Coq_value_object _ -> res_ter s (res_val argument)\n\n(** @essec 7.2.3\n    @esid sec-iscallable *)\nand is_callable s argument =\n  if not (type_of argument === Coq_type_object) then false\n  else object_has_internal_method s (loc_of_value argument) object_call_\n\n(** @essec 7.2.4\n    @esid sec-isconstructor *)\nand is_constructor s argument =\n  if not (type_of argument === Coq_type_object) then false\n  else object_has_internal_method s (loc_of_value argument) object_construct_\n\n(** @essec 7.2.5\n    @esid sec-isextensible-o *)\nand is_extensible s o =\n  let%assert _ = match type_of o with Coq_type_object -> true | _ -> false in\n  match o with\n  | Coq_value_object l -> object_internal_is_extensible s l\n  | _ -> assert false\n\n(** @essec 7.2.7\n    @esid sec-ispropertykey *)\nand is_property_key argument =\n  (type_of argument) === Coq_type_string (* FIXME: || (type_of argument) === Coq_type_symbol *)\n\n(** @essec 7.2.9\n    @esid sec-samevalue *)\nand same_value x y =\n  if not (type_compare (type_of x) (type_of y))\n  then false\n  else match type_of x with\n  | Coq_type_number ->\n    (match x with\n    | Coq_value_number n_x ->\n      (match y with\n      | Coq_value_number n_y ->\n        if (JsNumber.isnan n_x) && (JsNumber.isnan n_y) then true\n        else if (JsNumber.isposzero n_x) && (JsNumber.isnegzero n_y) then true\n        else if (JsNumber.isnegzero n_x) && (JsNumber.isposzero n_y) then true\n        else n_x === n_y\n      | _ -> assert false)\n    | _ -> assert false)\n  | _ -> same_value_non_number x y\n\n(** @essec 7.2.11\n    @esid sec-samevaluenonnumber *)\nand same_value_non_number x y =\n  let (*%assert*) asrt = assert (not (type_compare (type_of x) Coq_type_number)) in\n  let (*%assert*) asrt = assert (type_compare (type_of x) (type_of y)) in\n  match x with\n  | Coq_value_undef      -> true\n  | Coq_value_null       -> true\n  | Coq_value_string s_x ->\n    (match y with\n    | Coq_value_string s_y -> string_eq s_x s_y\n    | _ -> assert false)\n  | Coq_value_bool b_x   ->\n    (match y with\n     | Coq_value_bool b_y -> bool_eq b_x b_y\n     | _ -> assert false)\n  (* FIXME: Symbol\n  | Coq_value_symbol s_x ->\n     (match y with\n     | Coq_value_symbol s_y -> symbol_compare s_x s_y\n     | _ -> assert false)\n  *)\n  | Coq_value_object l_x ->\n    (match y with\n    | Coq_value_object l_y -> object_loc_compare l_x l_y\n    | _ -> assert false)\n  | _ -> assert false\n\n(** {2 Operations on Objects }\n    @essec 7.3\n    @esid sec-operations-on-objects *)\n\n(** @essec 7.3.1\n    @esid sec-get-o-p *)\nand get s o p =\n  let%assert _ = (type_of o) === Coq_type_object in\n  let%assert _ = is_property_key p in\n  match o with\n  | Coq_value_object l -> object_internal_get s l p o\n  | _ -> assert false\n\n(** @essec 7.3.2\n    @esid sec-getv *)\nand get_v s v p =\n  let%assert _ = is_property_key p in\n  let%object (s1, l) = to_object s v in\n  object_internal_get s1 l p v\n\n(** @essec 7.3.3\n    @esid sec-set-o-p-v-throw *)\nand set s o p v throw =\n  let%assert _ = (type_of o) === Coq_type_object in\n  let l = loc_of_value o in\n  let%assert _ = is_property_key p in\n  let%assert _ = (type_of throw) === Coq_type_bool in\n  let throw = bool_of_value throw in\n  let%bool s, success = object_internal_set s l p v o in\n  if (not success) && throw then\n    run_error_no_c s Coq_native_error_type\n  else\n    res_ter s (res_val (Coq_value_bool success))\n\n(** @essec 7.3.4\n    @esid sec-createdataproperty *)\nand create_data_property s o p v =\n  let%assert _ = type_of o === Coq_type_object in\n  let o = loc_of_value o in\n  let%assert _ = is_property_key p in\n  let newDesc = descriptor_intro_data v true true true in\n  object_internal_define_own_property s o p newDesc\n\n(** @essec 7.3.7\n    @esid sec-definepropertyorthrow *)\nand define_property_or_throw s o p desc =\n  let%assert _ = type_of o === Coq_type_object in\n  let o = loc_of_value o in\n  let%assert _ = is_property_key p in\n  let%bool s, success = object_internal_define_own_property s o p desc in\n  if not success then\n    run_error_no_c s Coq_native_error_type\n  else\n    res_ter s (res_val (Coq_value_bool success))\n\n(** @essec 7.3.9\n    @esid sec-getmethod *)\nand get_method s v p =\n  let%assert _ = is_property_key p in\n  let%value (s1, func) = get_v s v p in\n  match type_of func with\n  | Coq_type_undef -> res_out s1 (res_val Coq_value_undef)\n  | Coq_type_null  -> res_out s1 (res_val Coq_value_undef)\n  | _ ->\n    let callable = is_callable s1 func in\n    if not callable\n    then run_error_no_c s1 Coq_native_error_type\n    else res_out s1 (res_val func)\n\n(** @essec 7.3.10\n    @esid sec-hasproperty *)\nand has_property s o p =\n  let%assert _ = (type_of o) === Coq_type_object in\n  let%assert _ = is_property_key p in\n  match o with\n  | Coq_value_object l -> object_internal_has_property s l p\n  | _ -> assert false\n\n(** @essec 7.3.12\n    @esid sec-call *)\nand call s f v argumentList =\n  if_some_or_apply_default argumentList [] (fun argumentList ->\n    let callable = is_callable s f in\n    if not callable then run_error_no_c s Coq_native_error_type\n    else match f with\n    | Coq_value_object l -> object_internal_call s l v argumentList\n    | _ -> assert false\n  )\n\n(** @essec 7.3.13\n    @esid sec-construct *)\nand construct s f argumentsList newTarget =\n  let newTarget = unsome_default f newTarget in\n  let argumentsList = unsome_default [] argumentsList in\n  let%assert _ = is_constructor s f in\n  let%assert _ = is_constructor s newTarget in\n  object_internal_construct s (loc_of_value f) argumentsList newTarget\n\n(** @essec 7.3.14\n    @esid sec-setintegritylevel *)\nand set_integrity_level s o level =\n  let%assert _ = type_of o === Coq_type_object in\n  let o = loc_of_value o in\n  let%assert _ = level === "sealed" || level === "frozen" in\n  let%bool s, status = object_internal_prevent_extensions s o in\n  if not status then res_ter s (res_val (Coq_value_bool false))\n  else\n  let%spec s, keys = object_internal_own_property_keys s o in\n  let%ret s =\n  if level === "sealed" then\n    (* FIXME: repeat for k in keys *)\n    Return Coq_result_not_yet_implemented\n  else\n    (* FIXME: repeat for k in keys *)\n    Return Coq_result_not_yet_implemented\n  in\n  res_ter s (res_val (Coq_value_bool true))\n\n(** @essec 7.3.15\n    @esid sec-testintegritylevel *)\nand test_integrity_level s o level =\n  let%assert _ = type_of o === Coq_type_object in\n  let%assert _ = level === "sealed" || level === "frozen" in\n  let%bool s, status = is_extensible s o in\n  if status then res_ter s (res_val (Coq_value_bool false))\n  else\n  let%spec s, keys = object_internal_own_property_keys s (loc_of_value o) in\n  (* FIXME: repeat for k in keys *)\n  Coq_result_not_yet_implemented\n\n(** @essec 7.3.16\n    @esid sec-createarrayfromlist *)\nand create_array_from_list s elements =\n  (* first assertion is implicit through type signature *)\n  let%value s, array = array_create s (Coq_value_number 0.) None in\n  let n = 0. in\n  let%ret (s, n) = iterate elements (s, n) (fun e acc ->\n      let s, n = acc in\n      let%VALUE_ret s, tempVar = to_string s (Coq_value_number n) in\n      let%BOOL_ret s, status = create_data_property s array tempVar e in\n      let%assert_ret _ = status in\n      Continue (s, n +. 1.)) in\n  res_out s (res_val array)\n\n(** @essec 7.3.17\n    @esid sec-createlistfromarraylike *)\nand create_list_from_array_like s obj elementTypes =\n  let elementTypes = unsome_default\n      [Coq_type_undef; Coq_type_null; Coq_type_bool; Coq_type_string;\n       (* TODO: Symbols Coq_type_symbol; *) Coq_type_number; Coq_type_object]\n      elementTypes in\n  let%assert _ = (type_of obj) === Coq_type_object in\n  let%value s, tempVar = get s obj (Coq_value_string "length") in\n  let%number s, len = to_length s tempVar in\n  let list = [] in\n  let index = 0. in\n  let%ret (s, index, list) = repeat (fun acc -> let _, index, _ = acc in index < len) (s, index, list) (fun acc ->\n      let s, index, list = acc in\n      let%VALUE_ret s, indexName = to_string s (Coq_value_number index) in\n      let%value_ret s, next = get s obj indexName in\n      if not (mem_decide (===) (type_of next) elementTypes) then\n        Return (run_error_no_c s Coq_native_error_type)\n      else\n      let list = append list [next] in\n      let index = index +. 1. in\n      Continue (s, index, list)) in\n  res_spec s list\n\n\n(** {1 Executable Code and Execution Contexts}\n    @essec 8\n    @esid sec-executable-code-and-execution-contexts *)\n(** {2 Lexical Environments}\n    @essec 8.1\n    @esid sec-lexical-environments *)\n(** {3 Environment Records}\n    @essec 8.1.1\n    @esid sec-environment-records *)\n(** {4 Abstract Methods}\n    Dynamic dispatch functions for environment record abstract methods.\n\n    @esid table-15\n*)\n(*\nand has_binding s e n =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_has_binding s e n\n  | Coq_env_record_object (l, this) -> object_env_record_has_binding s l this n\n\nand create_mutable_binding s e n d =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_create_mutable_binding s e n d\n  | Coq_env_record_object (l, this) -> object_env_record_create_mutable_binding s l this n d\n\nand create_immutable_binding s e n str =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_create_immutable_binding s e n str\n  | Coq_env_record_object (l, this) -> object_env_record_create_immutable_binding s l this n str\n\nand initialize_binding s e n v =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_initialize_binding s e n v\n  | Coq_env_record_object (l, this) -> object_env_record_initialize_binding s l this n v\n*)\n\nand set_mutable_binding s l n v str =\n  let%some e = env_record_binds_option s l in\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_set_mutable_binding s l e n v str\n  | Coq_env_record_object (l, this) -> object_env_record_set_mutable_binding s (Coq_value_object l) this n v str\n\nand get_binding_value s l n str =\n  let%some e = env_record_binds_option s l in\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_get_binding_value s e n str\n  | Coq_env_record_object (l, this) -> object_env_record_get_binding_value s (Coq_value_object l) this n str\n\n(*\nand delete_binding s e n =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_delete_binding s e n\n  | Coq_env_record_object (l, this) -> object_env_record_delete_binding s l this n\n\nand has_this_binding s e =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_has_this_binding s e\n  | Coq_env_record_object (l, this) -> object_env_record_has_this_binding s l this\n\nand has_super_binding s e =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_has_super_binding s e\n  | Coq_env_record_object (l, this) -> object_env_record_has_super_binding s l this\n\nand with_base_object s e =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_with_base_object s e\n  | Coq_env_record_object (l, this) -> object_env_record_with_base_object s l this\n*)\n\n(**\n    {4 Declarative Environment Records}\n    @essec 8.1.1.1\n    @esid sec-declarative-environment-records\n*)\n\n(* FIXME: Move to a bindings data structure section. Apply to mutable bindings also. *)\nand binding_is_uninitialized binding =\n  let (mutability, unused) = binding in\n  mutability_compare mutability Coq_mutability_uninitialized_immutable\n\nand binding_is_mutable binding =\n  let (mutability, unused) = binding in\n  (mutability === Coq_mutability_nondeletable) || (mutability === Coq_mutability_deletable)\n\n(** @essec 8.1.1.1.2\n    @esid sec-declarative-environment-records-createmutablebinding-n-d *)\nand decl_env_record_create_mutable_binding s l envRec n\' d =\n  let n = string_of_value n\' in\n  let d = bool_of_value d in\n  let%assert _ = not (HeapStr.indom_dec envRec n) in\n  let s = env_record_write_decl_env s l n (mutability_of_bool d) Coq_value_undef in (* FIXME: Uninitialized field *)\n  res_void s\n\n(** @essec 8.1.1.1.4\n    @esid sec-declarative-environment-records-initializebinding-n-v *)\nand decl_env_record_initialize_binding s l envRec n\' v =\n  let n = string_of_value n\' in\n  let%some binding = HeapStr.read_option envRec n in\n  let (mutability, unused) = binding in (* TODO: Tidy up *)\n  let%assert _ = binding_is_uninitialized binding in\n  (* Update mutability / initialization flag *)\n  let s = env_record_write_decl_env s l n mutability v in\n  res_void s\n\n(** @essec 8.1.1.1.5\n    @esid sec-declarative-environment-records-setmutablebinding-n-v-s *)\nand decl_env_record_set_mutable_binding s l envRec n\' v str =\n  let n = string_of_value n\' in\n  let str = bool_of_value str in\n  if not (HeapStr.indom_dec envRec n) then\n    if str then\n      run_error_no_c s Coq_native_error_ref\n    else\n      let%success s, _ = decl_env_record_create_mutable_binding s l envRec n\' (Coq_value_bool true) in\n      let%success s, _ = decl_env_record_initialize_binding s l envRec n\' v in\n      res_void s\n  else\n  let%some binding = HeapStr.read_option envRec n in\n  let (mutability, unused) = binding in\n  (* FIXME: Implement strictness for bindings: let str = if binding.ref_strict then true else str in *)\n  if binding_is_uninitialized binding then\n    run_error_no_c s Coq_native_error_ref\n  else let%ret s =\n    if binding_is_mutable binding then\n      Continue (env_record_write_decl_env s l n mutability v)\n    else\n      if str then\n        Return (run_error_no_c s Coq_native_error_type)\n      else\n        Continue s\n    in\n    res_void s\n\n(** @essec 8.1.1.1.6\n    @esid sec sec-declarative-environment-records-getbindingvalue-n-s *)\nand decl_env_record_get_binding_value s envRec n str =\n  let n = string_of_value n in\n  let%assert _ = HeapStr.indom_dec envRec n in\n  let%some binding = HeapStr.read_option envRec n in\n  let (mutability, v) = binding in\n  if mutability_compare mutability Coq_mutability_uninitialized_immutable (* FIXME: Need to handle mutable uninitialized also *)\n  then run_error_no_c s Coq_native_error_ref\n  else res_ter s (res_val v)\n\n(**\n    {4 Object Environment Records}\n    @essec 8.1.1.2\n    @esid sec-object-environment-records\n*)\n\n(** @essec 8.1.1.1.2.5\n    @edid sec-object-environment-records-setmutablebinding-n-v-s *)\nand object_env_record_set_mutable_binding s bindings this n v str =\n  set s bindings n v str\n\n(** @essec 8.1.1.1.2.6\n    @esid sec-object-environment-records-getbindingvalue-n-s *)\nand object_env_record_get_binding_value s bindings this n str =\n  let%bool s, value = has_property s bindings n in\n  if not value then\n    if not str\n    then res_ter s (res_val Coq_value_undef)\n    else run_error_no_c s Coq_native_error_ref\n  else\n    get s bindings n\n\n(** {2 Execution Contexts}\n    @essec 8.3\n    @esid sec-execution-contexts *)\n\n(** @esid sec-getglobalobject\n    @essec 8.3.6 *)\nand get_global_object s ctx =\n  (* FIXME: ES5 hack (realms required) *)\n  let e = unsome_error (env_record_binds_option s env_loc_global_env_record) in\n  match e with\n  | Coq_env_record_object (l, this) -> Coq_value_object l\n  |  _ -> assert false\n\n(** {1 Ordinary and Exotic Objects Behaviours }\n    @essec 9\n    @esid sec-ordinary-and-exotic-objects-behaviours *)\n\n(**\n    {2 Ordinary Object Internal Methods and Internal Slots }\n    @essec 9.1\n    @esid sec-ordinary-object-internal-methods-and-internal-slots *)\n\n(** [[GetPrototypeOf]]()\n    @essec 9.1.1\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof *)\nand ordinary_object_internal_get_prototype_of s o =\n  let%value (s1, v) = ordinary_get_prototype_of s o in\n  res_out s (res_val v)\n\n(** @essec 9.1.1.1\n    @esid sec-ordinarygetprototypeof *)\nand ordinary_get_prototype_of s o =\n  let%some v = run_object_method object_proto_ s o in\n  res_out s (res_val v)\n\n(** [[SetPrototypeOf]](V)\n    @essec 9.1.2\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v *)\nand ordinary_object_internal_set_prototype_of s o v =\n  let%value (s1, v) = ordinary_set_prototype_of s o v in\n  res_out s (res_val v)\n\n(** @essec 9.1.2.1\n    @esid sec-ordinarysetprototypeof *)\nand ordinary_set_prototype_of s o v =\n  let%assert _ = (match type_of v with Coq_type_object -> true | Coq_type_null -> true | _ -> false) in\n  let%some extensible = run_object_method object_extensible_ s o in\n  let%some current = run_object_method object_prototype_ s o in\n  let sv = same_value v current in\n  if sv then res_out s (res_val (Coq_value_bool true))\n  else if not extensible then res_out s (res_val (Coq_value_bool false))\n  else\n    let rec repeat p done_ = begin\n      if not done_ then\n        (match p with\n        | Coq_value_null -> repeat p true\n        | Coq_value_object p_l ->\n          if same_value p (Coq_value_object o)\n          then res_out s (res_val (Coq_value_bool false))\n          else\n            let%some gpo = run_object_method object_get_prototype_of_ s p_l in\n            (match gpo with\n            | Coq_builtin_get_prototype_of_default -> (\n              let%some prototype = run_object_method object_prototype_ s p_l in\n              repeat prototype false)\n            | _ -> repeat p true)\n        | _ -> assert false)\n      else\n        (* Set the value of the [[Prototype]] internal slot of O to V *)\n        let%some s\' = run_object_set_internal object_set_proto s o v in\n        res_spec s\' (res_val (Coq_value_bool true))\n    end\n    in repeat v false\n\n(** @essec 9.1.3\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-isextensible *)\nand ordinary_object_internal_is_extensible s o =\n  let%value (s1, v) = ordinary_is_extensible s o in\n  res_out s (res_val v)\n\n(** @essec 9.1.3.1\n    @esid sec-ordinaryisextensible *)\nand ordinary_is_extensible s o =\n  let%some b = run_object_method object_extensible_ s o in\n  res_out s (res_val (Coq_value_bool b))\n\n(** @essec 9.1.4\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-preventextensions *)\nand ordinary_object_internal_prevent_extensions s o =\n  let%value (s1, v) = ordinary_prevent_extensions s o in\n  res_out s (res_val v)\n\n(** @essec 9.1.4.1\n    @esid sec-ordinarypreventextensions *)\nand ordinary_prevent_extensions s o =\n  let%some s\' = run_object_set_internal object_set_extensible s o false in\n  res_ter s (res_val (Coq_value_bool true))\n\n(** @essec 9.1.5\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p *)\nand ordinary_object_internal_get_own_property s o p =\n  let%spec s, d = ordinary_get_own_property s o p in\n  res_spec s d\n\n(** @essec 9.1.5.1\n    @esid sec-ordinarygetownproperty *)\nand ordinary_get_own_property s o p =\n  let%assert _ = is_property_key p in\n  let p = string_of_value p in\n  if not (object_property_exists s o p) then res_spec s Descriptor_undef\n  else let d = descriptor_intro_empty in\n  let%some x = object_retrieve_property s o p in\n  let d = match x with\n  | Coq_attributes_data_of x ->\n      { d with descriptor_value    = (Some x.attributes_data_value);\n               descriptor_writable = (Some x.attributes_data_writable) }\n  | Coq_attributes_accessor_of x ->\n      { d with descriptor_get = (Some x.attributes_accessor_get);\n               descriptor_set = (Some x.attributes_accessor_set) } in\n  let d = { d with descriptor_enumerable   = (Some (attributes_enumerable x)) } in\n  let d = { d with descriptor_configurable = (Some (attributes_configurable x)) } in\n  res_spec s (Descriptor d)\n\n(** @essec 9.1.6\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc *)\nand ordinary_object_internal_define_own_property s o p desc =\n  ordinary_define_own_property s o p desc\n\n(** @essec 9.1.6.1\n    @esid sec-ordinarydefineownproperty *)\nand ordinary_define_own_property s o p desc =\n  let%spec (s, current) = object_internal_get_own_property s o p in\n  let%some extensible = run_object_method object_extensible_ s o in\n  validate_and_apply_property_descriptor s (Coq_value_object o) p extensible desc current\n\n(** @essec 9.1.6.2\n    @esid sec-iscompatiblepropertydescriptor *)\nand is_compatible_property_descriptor s extensible desc current =\n  validate_and_apply_property_descriptor s Coq_value_undef Coq_value_undef extensible desc current\n\n(** @essec 9.1.6.3\n    @esid sec-validateandapplypropertydescriptor *)\nand validate_and_apply_property_descriptor s o p extensible desc current =\n  (* FIXME: o, p type mismatch, specified as object, property key but undefined passed *)\n  (* A -> B === !A || B *)\n  let%assert _ = (value_compare o Coq_value_undef) || (is_property_key p) in\n  let p = string_of_value p in (* FIXME: Will break with Symbols *)\n  match current with\n  (* Three types of descriptors: full, attributes: accessor and data...\n     Spec assumes one with variable field definitions, move to this? (equiv. our full)\n   *)\n  | Descriptor_undef ->\n    if not extensible then res_out s (res_val (Coq_value_bool false))\n    else\n      let%assert _ = extensible in (* SPEC: This assert assumes extensible is any value, but is strictly typed for us *)\n      let%some s =\n        match o with\n        | Coq_value_object l ->\n          if (is_generic_descriptor (Descriptor desc)) || (is_data_descriptor (Descriptor desc))\n          then object_set_property s l p (Coq_attributes_data_of (attributes_data_of_descriptor desc))\n          else object_set_property s l p (Coq_attributes_accessor_of (attributes_accessor_of_descriptor desc))\n        | Coq_value_undef -> Some s\n        | _ -> None\n      in res_ter s (res_val (Coq_value_bool true))\n\n  | Descriptor current ->\n    (* The following two steps 3 & 4 of the spec are implied by the rest of the function, except in the\n       case of NaN values for [[Value]] which may change internal representation.\n       Otherwise, they are only an optimisation as far as I can tell. *)\n    (* Step 3 (also implied by step 4) *)\n    let%ret s = if descriptor_is_empty desc\n      then Return (res_ter s (res_val (Coq_value_bool true)))\n      else Continue s\n\n    (* Step 4 *)\n    in let%ret s =\n    if descriptor_contained_by desc current same_value\n      then Return (res_ter s (res_val (Coq_value_bool true)))\n      else Continue s\n\n    (* Steps 5 *)\n    in let%ret s =\n    if (option_compare bool_eq current.descriptor_configurable (Some false))\n    then\n      if (option_compare bool_eq desc.descriptor_configurable (Some true))\n      then Return (res_ter s (res_val (Coq_value_bool false)))\n      else if ((is_some desc.descriptor_enumerable) &&\n        not (some_compare bool_eq current.descriptor_enumerable desc.descriptor_enumerable))\n      then Return (res_ter s (res_val (Coq_value_bool false)))\n      else Continue s\n    else Continue s\n\n    (* Step 6 if IsGenericDescriptor(Desc) is true, implied by following conditions *)\n    in let%ret s =\n    if is_generic_descriptor (Descriptor desc)\n    then Continue s\n\n    (* Step 7 *)\n    else if not (bool_eq (is_data_descriptor (Descriptor current)) (is_data_descriptor (Descriptor desc)))\n    then\n      (* 7a *)\n      if (option_compare bool_eq current.descriptor_configurable (Some false))\n        then Return (res_ter s (res_val (Coq_value_bool false)))\n      (* 7b *)\n      else if is_data_descriptor (Descriptor current)\n        then\n          let s = unsome_default s (match o with\n          | Coq_value_object l -> object_map_property s l p attributes_accessor_of_attributes_data\n          | _ -> Some s)\n          in Continue s\n        else\n          let s = unsome_default s (match o with\n          | Coq_value_object l -> object_map_property s l p attributes_data_of_attributes_accessor\n          | _ -> Some s)\n          in Continue s\n\n    (* Step 8 *)\n    else if (is_data_descriptor (Descriptor current)) && (is_data_descriptor (Descriptor desc))\n    then\n      (* Step 8a *)\n      if option_compare bool_eq current.descriptor_configurable (Some false)\n      then\n        (* Step 8ai *)\n        if (option_compare bool_eq current.descriptor_writable (Some false))\n           && (option_compare bool_eq desc.descriptor_writable (Some true))\n        then Return (res_ter s (res_val (Coq_value_bool false)))\n\n        (* Step 8aii *)\n        else if option_compare bool_eq current.descriptor_writable (Some false)\n        then\n          (* Step 8aii1 *)\n          if (is_some desc.descriptor_value)\n             && not (option_compare same_value desc.descriptor_value current.descriptor_value)\n          then Return (res_ter s (res_val (Coq_value_bool false)))\n          else Continue s\n        else Continue s\n\n      (* Step 8b *)\n      else if not (option_compare bool_eq current.descriptor_configurable (Some true))\n        then Return (spec_assertion_failure ())\n        else Continue s\n\n    (* Step 9 *)\n    else if not ((is_accessor_descriptor (Descriptor current)) && (is_accessor_descriptor (Descriptor desc)))\n      then Return (spec_assertion_failure ())\n      else if option_compare bool_eq current.descriptor_configurable (Some false)\n      then\n        if (is_some desc.descriptor_set) &&\n            not (option_compare same_value desc.descriptor_set current.descriptor_set)\n        then Return (res_ter s (res_val (Coq_value_bool false)))\n        else if (is_some desc.descriptor_get) &&\n                not (option_compare same_value desc.descriptor_get current.descriptor_get)\n        then Return (res_ter s (res_val (Coq_value_bool false)))\n        else Continue s\n      else Continue s\n\n    (* Step 10 *)\n    in let%some s = match o with\n    | Coq_value_object l ->\n       object_map_property s l p (fun a -> attributes_update a desc)\n    | _ -> Some s\n\n    (* Step 11 *)\n    in res_ter s (res_val (Coq_value_bool true))\n\n(** @essesc 9.1.7\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p *)\nand ordinary_object_internal_has_property s o p =\n  ordinary_has_property s o p\n\n(** @essec 9.1.7.1\n    @esid sec-ordinaryhasproperty *)\nand ordinary_has_property s o p =\n  let%assert _ = is_property_key p in\n  let%spec s, hasOwn = object_internal_get_own_property s o p in\n  if not (hasOwn === Descriptor_undef) then res_ter s (res_val (Coq_value_bool true))\n  else let%value s, parent = object_internal_get_prototype_of s o in\n  if not (parent === Coq_value_null) then object_internal_has_property s (loc_of_value parent) p\n  else res_ter s (res_val (Coq_value_bool false))\n\n(** @essec 9.1.8\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver *)\nand ordinary_object_internal_get s o p receiver =\n  ordinary_get s o p receiver\n\n(** @essec 9.1.8.1\n    @esid sec-ordinaryget *)\nand ordinary_get s o p receiver =\n  let%assert _ = is_property_key p in\n  let%spec s, desc = object_internal_get_own_property s o p in\n  if desc === Descriptor_undef then\n    let%value s, parent = object_internal_get_prototype_of s o in\n    if parent === Coq_value_null then\n      res_ter s (res_val Coq_value_undef)\n    else\n      let parent = loc_of_value parent in\n      object_internal_get s parent p receiver\n  else if is_data_descriptor desc then\n    let desc = descriptor_get_defined desc in\n    let%some value = descriptor_value desc in\n    res_ter s (res_val value)\n  else\n    let%assert _ = is_accessor_descriptor desc in\n    let desc = descriptor_get_defined desc in\n    let%some getter = descriptor_get desc in (* None value should be invalid as it represents "absent" in spec *)\n    if getter === Coq_value_undef then\n      res_ter s (res_val Coq_value_undef)\n    else\n      call s getter receiver None\n\n(** @essec 9.1.9\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver *)\nand ordinary_object_internal_set s o p v receiver =\n  ordinary_set s o p v receiver\n\n(** @essec 9.1.9.1\n    @esid sec-ordinaryset *)\nand ordinary_set s o p v receiver =\n  let%assert _ = is_property_key p in\n  let%spec s, ownDesc = object_internal_get_own_property s o p in\n  let%ret ownDesc =\n    if ownDesc === Descriptor_undef then begin\n      let%value_ret s, parent = object_internal_get_prototype_of s o in\n      if not (parent === Coq_value_null) then\n        let parent = loc_of_value parent in\n        Return (object_internal_set s parent p v receiver)\n      else Continue (Descriptor {\n        descriptor_value = Some Coq_value_undef;\n        descriptor_writable = Some false;\n        descriptor_get = None;\n        descriptor_set = None;\n        descriptor_enumerable = Some true;\n        descriptor_configurable = Some true\n      })\n    end else Continue ownDesc\n  in\n  if is_data_descriptor ownDesc then begin\n    let ownDesc = descriptor_get_defined ownDesc in\n    let%some writable = ownDesc.descriptor_writable in\n    if not writable then res_ter s (res_val (Coq_value_bool false))\n    else if not (type_of receiver === Coq_type_object) then res_ter s (res_val (Coq_value_bool false))\n    else\n      let receiver = loc_of_value receiver in\n      let%spec s, existingDescriptor = object_internal_get_own_property s receiver p in\n      if not (existingDescriptor === Descriptor_undef) then begin\n        if is_accessor_descriptor existingDescriptor then res_ter s (res_val (Coq_value_bool false))\n        else\n          let existingDescriptor = descriptor_get_defined existingDescriptor in\n          let%some w = existingDescriptor.descriptor_writable in\n          if not w then res_ter s (res_val (Coq_value_bool false))\n          else\n            let valueDesc = (descriptor_with_value descriptor_intro_empty (Some v)) in\n            object_internal_define_own_property s receiver p valueDesc\n      end else\n        create_data_property s (Coq_value_object receiver) p v\n  end else\n    let%assert _ = is_accessor_descriptor ownDesc in\n    let ownDesc = descriptor_get_defined ownDesc in\n    let%some setter = ownDesc.descriptor_set in\n    if setter === Coq_value_undef then res_ter s (res_val (Coq_value_bool false))\n    else\n      let%spec s, _ = call s setter receiver (Some [v]) in\n      res_ter s (res_val (Coq_value_bool true))\n\n(** @essec 9.1.10\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-delete-p *)\nand ordinary_object_internal_delete s o p =\n  ordinary_delete s o p\n\n(** @essec 9.1.10.1\n    @esid sec-ordinarydelete *)\nand ordinary_delete s o p =\n  let%assert _ = is_property_key p in\n  let%spec s, desc = object_internal_get_own_property s o p in\n  if desc === Descriptor_undef then\n    res_ter s (res_val (Coq_value_bool true))\n  else\n  let desc = descriptor_get_defined desc in\n  if some_compare (===) (descriptor_configurable desc) (Some true) then\n    let p = string_of_value p in\n    let%some s = run_object_heap_map_properties s o (fun props -> HeapStr.rem props p)  in\n    res_ter s (res_val (Coq_value_bool true))\n  else\n    res_ter s (res_val (Coq_value_bool false))\n\nand ordinary_object_internal_own_property_keys s o =\n  let%spec s, k = ordinary_own_property_keys s o in\n  res_spec s k\n\n(** @essec 9.1.11.1\n    @esid sec-ordinaryownpropertykeys *)\nand ordinary_own_property_keys s o =\n  let%some keys = object_properties_keys_as_list_option s o in\n  (* FIXME: Precise key ordering is to be implemented here! *)\n  let keys = LibList.map (fun key -> Coq_value_string key) keys in\n  res_spec s keys\n\n(** @essec 9.1.12\n    @esid sec-objectcreate *)\nand object_create s proto internalSlotsList =\n  let internalSlotsList = unsome_default [] internalSlotsList in\n  (* FIXME: Do something with internalSlotsList *)\n  (* TODO: Draw this definition closer to the spec language *)\n  let obj = object_new proto "" in\n  let l, s = object_alloc s obj in\n  res_ter s (res_val (Coq_value_object l))\n\n(** {2 ECMAScript Function Objects}\n    @essec 9.2\n    @esid sec-ecmascript-function-objects *)\n\n(** TODO: Realm support\n    @essec 9.2.7\n    @esid sec-addrestrictedfunctionproperties\n*)\nand add_restricted_function_properties s f realm =\n  (* Assert ... *)\n  let thrower = Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_throw_type_error) in\n  let%SUCCESS s, _ = define_property_or_throw s f (Coq_value_string "caller") {\n      descriptor_intro_empty with\n      descriptor_get = Some thrower;\n      descriptor_set = Some thrower;\n      descriptor_enumerable = Some false;\n      descriptor_configurable = Some true;\n    } in\n  let%SUCCESS s, rv = define_property_or_throw s f (Coq_value_string "arguments") {\n      descriptor_intro_empty with\n      descriptor_get = Some thrower;\n      descriptor_set = Some thrower;\n      descriptor_enumerable = Some false;\n      descriptor_configurable = Some true;\n    } in\n  res_ter s (res_normal rv)\n\n\n(** @essec 9.2.7.1\n    @esid sec-%throwtypeerror% *)\nand builtin_throw_type_error s c thisArgument argumentsList newTarget =\n  run_error s c Coq_native_error_type\n\n(** {2 Built-in Function Objects}\n    @essec 9.3\n    @esid sec-built-in-function-objects *)\n\n(** {2 Array Exotic Objects}\n    @essec 9.4.2\n    @esid sec-array-exotic-objects *)\n(** @essec 9.4.2.2\n    @esid sec-arraycreate *)\nand array_create s length proto =\n  (* FIXME: ES5 HACK *)\n  run_construct_prealloc s some_context Coq_prealloc_array [length]\n\n(** {2 Proxy Object Internal Methods and Internal Slots}\n    @essec 9.5\n    @esid sec-proxy-object-internal-methods-and-internal-slots *)\n\n(** {3 Specification text helper functions} *)\n(** Implements the specification text "If [l] is a Proxy exotic object" *)\nand is_proxy_exotic_object s l =\n  object_has_internal_slot s l object_proxy_handler_\n\n(** @essec 9.5.1\n    @esid sec-proxy-object-internal-methods-and-internal-slots-getprototypeof *)\nand proxy_object_internal_get_prototype_of s o =\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "getPrototypeOf") in\n  if trap === Coq_value_undef then\n    object_internal_get_prototype_of s (loc_of_value target)\n  else\n  let%value s, handlerProto = call s trap handler (Some [target]) in\n  if not ((type_of handlerProto === Coq_type_object) || (handlerProto === Coq_value_null)) then\n    run_error_no_c s Coq_native_error_type\n  else\n  let%bool s, extensibleTarget = is_extensible s target in\n  if extensibleTarget then res_ter s (res_val handlerProto)\n  else\n  let%value s, targetProto = object_internal_get_prototype_of s (loc_of_value target) in\n  if not (same_value handlerProto targetProto) then\n    run_error_no_c s Coq_native_error_type\n  else\n    res_ter s (res_val handlerProto)\n\n(** @essec 9.5.2\n    @esid sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v *)\nand proxy_object_internal_set_prototype_of s o v =\n  let%assert _ = (type_of v) === Coq_type_object || (type_of v) === Coq_type_null in\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "") in\n  if trap === Coq_value_undef then\n    object_internal_set_prototype_of s (loc_of_value target) v\n  else\n  let%value s, tempVal = call s trap handler (Some [target; v]) in\n  let booleanTrapResult = to_boolean tempVal in\n  if not booleanTrapResult then res_ter s (res_val (Coq_value_bool false))\n  else\n  let%bool s, extensibleTarget = is_extensible s target in\n  if extensibleTarget then res_ter s (res_val (Coq_value_bool true))\n  else\n  let%value s, targetProto = object_internal_get_prototype_of s (loc_of_value target) in\n  if not (same_value v targetProto) then run_error_no_c s Coq_native_error_type\n  else res_ter s (res_val (Coq_value_bool true))\n\n(** @essec 9.5.3\n    @esid sec-proxy-object-internal-methods-and-internal-slots-isextensible *)\nand proxy_object_internal_is_extensible s o =\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "isExtensible") in\n  if trap === Coq_value_undef then\n    object_internal_is_extensible s (loc_of_value target)\n  else\n  let%value s, tempVal = call s trap handler (Some [target]) in\n  let booleanTrapResult = to_boolean tempVal in\n  let%value s, targetResult = object_internal_is_extensible s (loc_of_value target) in\n  if not (same_value (Coq_value_bool booleanTrapResult) targetResult) then run_error_no_c s Coq_native_error_type\n  else res_ter s (res_val (Coq_value_bool booleanTrapResult))\n\n(** @essec 9.5.4\n    @esid sec-proxy-object-internal-methods-and-internal-slots-preventextensions *)\nand proxy_object_internal_prevent_extensions s o =\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "preventExtensions") in\n  if trap === Coq_value_undef then\n    object_internal_prevent_extensions s (loc_of_value target)\n  else\n  let%value s, tempVal = call s trap handler (Some [target]) in\n  let booleanTrapResult = to_boolean tempVal in\n  let%ret s =\n  if booleanTrapResult then\n    let%bool_ret s, targetIsExtensible = object_internal_is_extensible s (loc_of_value target) in\n    if targetIsExtensible then Return (run_error_no_c s Coq_native_error_type)\n    else Continue s\n  else Continue s\n  in\n  res_ter s (res_val (Coq_value_bool booleanTrapResult))\n\n(** @essec 9.5.5\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p *)\nand proxy_object_internal_get_own_property s o p =\n  let%assert _ = is_property_key p in\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "getOwnPropertyDescriptor") in\n  if trap === Coq_value_undef then\n    object_internal_get_own_property s o p\n  else\n  let%value s, trapResultObj = call s trap handler (Some [target; p]) in\n  if not ((type_of trapResultObj === Coq_type_object) || (trapResultObj === Coq_value_undef)) then\n    throw_result (run_error_no_c s Coq_native_error_type)\n  else\n  let%spec s, targetDesc = object_internal_get_own_property s (loc_of_value target) p in\n  if trapResultObj === Coq_value_undef then\n    if targetDesc === Descriptor_undef then\n      res_spec s Descriptor_undef\n    else\n      let targetDesc = descriptor_get_defined targetDesc in\n      if descriptor_configurable targetDesc === Some false then\n        throw_result (run_error_no_c s Coq_native_error_type)\n      else\n        let%bool s, extensibleTarget = is_extensible s target in\n        if not extensibleTarget then\n          throw_result (run_error_no_c s Coq_native_error_type)\n        else\n          res_spec s Descriptor_undef\n  else\n  let%bool s, extensibleTarget = is_extensible s target in\n  let%spec s, resultDesc = to_property_descriptor s trapResultObj in\n  let resultDesc = complete_property_descriptor (Descriptor resultDesc) in (* FIXME: See note in [complete_property_descriptor] *)\n  let%bool s, valid = is_compatible_property_descriptor s extensibleTarget resultDesc targetDesc in\n  if not valid then\n    run_error_no_c s Coq_native_error_type\n  else if descriptor_configurable resultDesc === Some true &&\n    (targetDesc === Descriptor_undef || (descriptor_configurable (descriptor_get_defined targetDesc) === Some true)) then\n      run_error_no_c s Coq_native_error_type\n  else\n    res_spec s (Descriptor resultDesc)\n\n(** @essec 9.5.6\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc *)\nand proxy_object_internal_define_own_property s o p desc =\n  let%assert _ = is_property_key p in\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "defineProperty") in\n  if trap === Coq_value_undef then\n    object_internal_define_own_property s (loc_of_value target) p desc\n  else\n  let%value s, descObj = from_property_descriptor s (Descriptor desc) in\n  let%value s, tempVar = call s trap handler (Some [target; p; descObj]) in\n  let booleanTrapResult = to_boolean tempVar in\n  if not booleanTrapResult then\n    res_ter s (res_val (Coq_value_bool false))\n  else\n  let%spec s, targetDesc = object_internal_get_own_property s (loc_of_value target) p in\n  let%bool s, extensibleTarget = is_extensible s target in\n  let settingConfigFalse = (is_some desc.descriptor_configurable) && (desc.descriptor_configurable === Some false) in\n  let%ret s =\n    if targetDesc === Descriptor_undef then\n      if not extensibleTarget then Return (run_error_no_c s Coq_native_error_type)\n      else if settingConfigFalse then Return (run_error_no_c s Coq_native_error_type)\n      else Continue s\n    else\n      let%bool_ret s, tempVal = is_compatible_property_descriptor s extensibleTarget desc targetDesc in\n      let targetDesc = descriptor_get_defined targetDesc in\n      if not tempVal then\n        Return (run_error_no_c s Coq_native_error_type)\n      else if settingConfigFalse && targetDesc.descriptor_configurable === (Some true) then\n        Return (run_error_no_c s Coq_native_error_type)\n      else Continue s\n  in\n  res_ter s (res_val (Coq_value_bool true))\n\n\n(** @essec 9.5.7\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p *)\nand proxy_object_internal_has_property s o p =\n  let%assert _ = is_property_key p in\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "has") in\n  if trap === Coq_value_undef then\n    object_internal_has_property s (loc_of_value target) p\n  else\n  let%value s, tempVar = call s trap handler (Some [target; p]) in\n  let booleanTrapResult = to_boolean tempVar in\n  let%ret s =\n  if not booleanTrapResult then\n    let%spec_ret s, targetDesc = object_internal_get_own_property s (loc_of_value target) p in\n    if not (targetDesc === Descriptor_undef) then\n      let targetDesc = descriptor_get_defined targetDesc in\n      if targetDesc.descriptor_configurable === Some false then\n        Return (run_error_no_c s Coq_native_error_type)\n      else\n      let%bool_ret s, extensibleTarget = is_extensible s target in\n      if not extensibleTarget then Return (run_error_no_c s Coq_native_error_type)\n      else Continue s\n    else Continue s\n  else Continue s\n  in res_ter s (res_val (Coq_value_bool booleanTrapResult))\n\n(** @essec 9.5.8\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver *)\nand proxy_object_internal_get s o p receiver =\n  let%assert _ = is_property_key p in\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "get") in\n  if trap === Coq_value_undef then\n    object_internal_get s (loc_of_value target) p receiver\n  else\n  let%value s, trapResult = call s trap handler (Some [target; p; receiver]) in\n  let%spec s, targetDesc = object_internal_get_own_property s (loc_of_value target) p in\n\n  let%ret s =\n  if not (targetDesc === Descriptor_undef) then\n    let targetDesc\' = descriptor_get_defined targetDesc in\n\n    let%ret_ret s =\n    if is_data_descriptor targetDesc && targetDesc\'.descriptor_configurable === Some false && targetDesc\'.descriptor_writable === Some false then\n      if not (same_value trapResult (unsome_error targetDesc\'.descriptor_value)) then\n        Return (run_error_no_c s Coq_native_error_type)\n      else Continue s\n    else Continue s\n\n    in let%ret_ret s =\n    if is_accessor_descriptor targetDesc && targetDesc\'.descriptor_configurable === Some false && targetDesc\'.descriptor_get === Some Coq_value_undef then\n      if not (trapResult === Coq_value_undef) then\n        Return (run_error_no_c s Coq_native_error_type)\n      else Continue s\n    else Continue s\n\n    in Continue s\n  else Continue s\n\n  in res_ter s (res_val trapResult)\n\n(** @essec 9.5.9\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver *)\nand proxy_object_internal_set s o p v receiver =\n  let%assert _ = is_property_key p in\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "set") in\n  if trap === Coq_value_undef then\n    object_internal_set s (loc_of_value target) p v receiver\n  else\n  let%value s, tempVar = call s trap handler (Some [target; p; v; receiver]) in\n  let booleanTrapResult = to_boolean tempVar in\n  if not booleanTrapResult then res_ter s (res_val (Coq_value_bool false))\n  else\n  let%spec s, targetDesc = object_internal_get_own_property s (loc_of_value target) p in\n  let%ret s =\n  if not (targetDesc === Descriptor_undef) then\n    let targetDesc\' = descriptor_get_defined targetDesc in\n    let%ret_ret s =\n    if is_data_descriptor targetDesc && targetDesc\'.descriptor_configurable === Some false && targetDesc\'.descriptor_writable === Some false then\n      if not (same_value v (unsome_error targetDesc\'.descriptor_value)) then\n        Return (run_error_no_c s Coq_native_error_type)\n      else Continue s\n    else Continue s\n\n    in let%ret_ret s =\n    if is_accessor_descriptor targetDesc && targetDesc\'.descriptor_configurable === Some false then\n      if targetDesc\'.descriptor_set === Some Coq_value_undef then\n        Return (run_error_no_c s Coq_native_error_type)\n      else Continue s\n    else Continue s\n\n    in Continue s\n  else Continue s\n  in res_ter s (res_val (Coq_value_bool true))\n\n(** @essec 9.5.10\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-delete-p *)\nand proxy_object_internal_delete s o p =\n  let%assert _ = is_property_key p in\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "deleteProperty") in\n  if trap === Coq_value_undef then\n    object_internal_delete s (loc_of_value target) p\n  else\n  let%value s, tempVar = call s trap handler (Some [target; p]) in\n  let booleanTrapResult = to_boolean tempVar in\n  if not booleanTrapResult then res_ter s (res_val (Coq_value_bool false))\n  else\n  let%spec s, targetDesc = object_internal_get_own_property s (loc_of_value target) p in\n  if targetDesc === Descriptor_undef then res_ter s (res_val (Coq_value_bool true))\n  else\n  let targetDesc = descriptor_get_defined targetDesc in\n  if targetDesc.descriptor_configurable === Some false then run_error_no_c s Coq_native_error_type\n  else res_ter s (res_val (Coq_value_bool true))\n\n(** @essec 9.5.11\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys *)\nand proxy_object_internal_own_property_keys s o =\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "ownKeys") in\n  if trap === Coq_value_undef then\n    object_internal_own_property_keys s (loc_of_value target)\n  else\n  let%value s, trapResultArray = call s trap handler (Some [target]) in\n  let%spec s, trapResult = create_list_from_array_like s trapResultArray (Some [Coq_type_string(*TODO: ; Coq_type_symbol*)]) in\n  let%bool s, extensibleTarget = is_extensible s target in\n  let%spec s, targetKeys = object_internal_own_property_keys s (loc_of_value target) in\n  (* Assert that [targetKeys : (Coq_type_string | Coq_type_symbol) list *)\n  let targetConfigurableKeys = [] in\n  let targetNonconfigurableKeys = [] in\n  let%ret (s, targetConfigurableKeys, targetNonconfigurableKeys)  =\n      iterate targetKeys (s, targetConfigurableKeys, targetNonconfigurableKeys)\n      (fun key acc -> let (s, targetConfigurableKeys, targetNonconfigurableKeys) = acc in\n        let%spec_ret s, desc = object_internal_get_own_property s (loc_of_value target) key in\n        if (not (desc === Descriptor_undef)) && ((descriptor_get_defined desc).descriptor_configurable === Some false) then\n          Continue (s, targetConfigurableKeys, append targetNonconfigurableKeys [key])\n        else\n          Continue (s, append targetConfigurableKeys [key], targetNonconfigurableKeys)\n      )\n  in\n  if extensibleTarget && is_empty targetNonconfigurableKeys then\n    res_spec s trapResult\n  else\n  let uncheckedResultKeys = trapResult in\n  let%ret s, uncheckedResultKeys = iterate targetNonconfigurableKeys (s, uncheckedResultKeys) (fun key acc ->\n      let s, uncheckedResultKeys = acc in\n      if not (mem_decide (===) key uncheckedResultKeys) then\n        Return (run_error_no_c s Coq_native_error_type)\n      else\n        Continue (s, filter (fun x -> not (x === key)) uncheckedResultKeys)\n    )\n  in\n  if extensibleTarget then res_spec s trapResult\n  else\n  let%ret s, uncheckedResultKeys = iterate targetConfigurableKeys (s, uncheckedResultKeys) (fun key acc ->\n      let s, uncheckedResultKeys = acc in\n      if not (mem_decide (===) key uncheckedResultKeys) then\n        Return (run_error_no_c s Coq_native_error_type)\n      else\n        Continue (s, filter (fun x -> not (x === key)) uncheckedResultKeys)\n    )\n  in\n  if not (is_empty uncheckedResultKeys) then run_error_no_c s Coq_native_error_type\n  else res_spec s trapResult\n\n(** @essec 9.5.12\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist *)\nand proxy_object_internal_call s o thisArgument argumentsList =\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "apply") in\n  if trap === Coq_value_undef then\n    call s target thisArgument (Some argumentsList)\n  else\n  let%value s, argArray = create_array_from_list s argumentsList in\n  call s trap handler (Some [target; thisArgument; argArray])\n\n(** @essec 9.5.13\n    @esid  sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget *)\nand proxy_object_internal_construct s o argumentsList newTarget =\n  let%some handler = run_object_method object_proxy_handler_ s o in\n  let%some handler = handler in\n  (** Note: this check also implies that [target] is not null *)\n  if handler === Coq_value_null then run_error_no_c s Coq_native_error_type\n  else\n  let%assert _ = (type_of handler) === Coq_type_object in\n  let%some target = run_object_method object_proxy_target_ s o in\n  let%some target = target in\n  let%value s, trap = get_method s handler (Coq_value_string "construct") in\n  if trap === Coq_value_undef then\n    let%assert _ = object_has_internal_method s (loc_of_value target) object_construct_ in\n    construct s target (Some argumentsList) (Some newTarget)\n  else\n  let%value s, argArray = create_array_from_list s argumentsList in\n  let%value s, newObj = call s trap handler (Some [target; argArray; newTarget]) in\n  if not (type_of newObj === Coq_type_object) then run_error_no_c s Coq_native_error_type\n  else res_ter s (res_val newObj)\n\n(** @essec 9.5.14\n    @esid  sec-proxycreate *)\nand proxy_create s target handler =\n  if not (type_of target === Coq_type_object) then\n    run_error_no_c s Coq_native_error_type\n  else if is_proxy_exotic_object s (loc_of_value target)\n       && ((run_object_method object_proxy_handler_ s (loc_of_value target)) === Some (Some Coq_value_null)) then\n    run_error_no_c s Coq_native_error_type\n  else if not (type_of handler === Coq_type_object) then\n    run_error_no_c s Coq_native_error_type\n  else if is_proxy_exotic_object s (loc_of_value handler)\n       && ((run_object_method object_proxy_handler_ s (loc_of_value handler)) === Some (Some Coq_value_null)) then\n    run_error_no_c s Coq_native_error_type\n  else\n  let p, s = proxy_object_new s in\n  let%ret s =\n  if is_callable s target then\n    let%some_ret s = run_object_set_internal object_set_call s p Coq_call_proxy in\n    if object_has_internal_method s (loc_of_value target) object_construct_ then\n      let%some_ret s = run_object_set_internal object_set_construct s p Coq_construct_proxy in\n      Continue s\n    else Continue s\n  else Continue s\n  in\n  let%some s = run_object_set_internal object_set_proxy_target s p target in\n  let%some s = run_object_set_internal object_set_proxy_handler s p handler in\n  res_ter s (res_val (Coq_value_object p))\n\n(** {1 Fundamental Objects}\n    @essec 19\n    @esid  sec-fundamental-objects *)\n(** {2 Object Objects}\n    @essec 19.1\n    @esid  sec-object-objects *)\n(** {3 Properties of the Object Contructor}\n    @essec 19.1.2\n    @esid  sec-properties-of-the-object-constructor *)\n\n(** TODO: Hook into ES5 run_prealloc once [set_integrity_level] fully implemented.\n    @esid sec-object.freeze\n    @essec 19.1.2.6 *)\nand builtin_object_freeze s c f this newTarget o =\n  if not (type_of o === Coq_type_object) then res_ter s (res_val o)\n  else\n  let%bool s, status = set_integrity_level s o "frozen" in\n  if not status then run_error_no_c s Coq_native_error_type\n  else res_ter s (res_val o)\n\n(** @esid sec-object.getprototypeof\n    @essec 19.1.2.11 *)\nand builtin_object_get_prototype_of s c f this newTarget o =\n  let%object s, obj = to_object s o in\n  object_internal_get_prototype_of s obj\n\n(** @esid sec-object.isextensible\n    @essec 19.1.2.13 *)\nand builtin_object_is_extensible s c f this newTarget o =\n  if not (type_of o === Coq_type_object) then res_ter s (res_val (Coq_value_bool false))\n  else is_extensible s o\n\n(** TODO: Hook into ES5 run_prealloc once [test_integrity_level] fully implemented.\n    @esid sec-object.isfrozen\n    @essec 19.1.2.14 *)\nand builtin_object_is_frozen s c f this newTarget o =\n  if not (type_of o === Coq_type_object) then res_ter s (res_val (Coq_value_bool true))\n  else test_integrity_level s o "frozen"\n\n(** TODO: Hook into ES5 run_prealloc once [test_integrity_level] fully implemented.\n    @esid sec-object.issealed\n    @essec 19.1.2.15 *)\nand builtin_object_is_sealed s c f this newTarget o =\n  if not (type_of o === Coq_type_object) then res_ter s (res_val (Coq_value_bool true))\n  else test_integrity_level s o "sealed"\n\n(** @esid sec-object.preventextensions\n    @essec 19.1.2.17 *)\nand builtin_object_prevent_extensions s c f this newTarget o =\n  if not (type_of o === Coq_type_object) then res_ter s (res_val o)\n  else\n  let%bool s, status = object_internal_prevent_extensions s (loc_of_value o) in\n  if not status then run_error_no_c s Coq_native_error_type\n  else res_ter s (res_val o)\n\n(** TODO: Hook into ES5 run_prealloc once [set_integrity_level] fully implemented.\n    @esid sec-object.seal\n    @essec 19.1.2.19 *)\nand builtin_object_seal s c f this newTarget o =\n  if not (type_of o === Coq_type_object) then res_ter s (res_val o)\n  else\n  let%bool s, status = set_integrity_level s o "sealed" in\n  if not status then run_error_no_c s Coq_native_error_type\n  else res_ter s (res_val o)\n\n(** TODO: Hook into prealloc object code.\n    @esid sec-object.setprototypeof\n    @essec 19.1.2.20 *)\nand builtin_object_set_prototype_of s c f this newTarget o proto =\n  let%value s, o = require_object_coercible s o in\n  if not (type_of proto === Coq_type_object || proto === Coq_value_null) then run_error_no_c s Coq_native_error_type\n  else if not (type_of o === Coq_type_object) then res_ter s (res_val o)\n  else\n  let%bool s, status = object_internal_set_prototype_of s (loc_of_value o) proto in\n  if not status then run_error_no_c s Coq_native_error_type\n  else res_ter s (res_val o)\n\n(** {1 Reflection}\n    @essec 26\n    @esid sec-reflection *)\n(** {2 Proxy Objects}\n    @essec 26.2\n    @esid sec-proxy-objects *)\n(** {3 The Proxy Constructor}\n\n    The [%Proxy%] intrinsic object, initial value of the [Proxy] property of the global object.\n\n    @essec 26.2.1\n    @esid sec-proxy-constructor *)\n(** @essec 26.2.1.1\n    @esid sec-proxy-target-handler *)\nand builtin_proxy_constructor s c f this newTarget target handler =\n  if newTarget === Coq_value_undef then\n    run_error_no_c s Coq_native_error_type\n  else\n    proxy_create s target handler\n\n(** {3 Properties of the Proxy Constructor}\n    @essec 26.2.2\n    @esid sec-properties-of-the-proxy-constructor *)\n(** [%Proxy%.[[Prototype]] = %FunctionPrototype%] *)\n\n(** @essec 26.2.2.1\n    @esid sec-proxy.revocable *)\nand builtin_proxy_revocable s c f this newTarget target handler =\n  let%value s, p = proxy_create s target handler in\n  let%object s, revoker = proxy_revocation_function_create s in\n  let%some s = run_object_set_internal object_set_revocable_proxy s revoker p in\n  let%value s, result = object_create s (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_object_proto)) None in\n  let%bool s, _ = create_data_property s result (Coq_value_string "proxy") p in\n  let%bool s, _ = create_data_property s result (Coq_value_string "revoke") (Coq_value_object revoker) in\n  res_ter s (res_val result)\n\n(** @essec 26.2.2.2.1.1\n    @esid sec-proxy-revocation-functions *)\nand proxy_revocation_function_create s =\n  Coq_result_not_yet_implemented (* FIXME *)\n\nand builtin_proxy_revocation_function s c f this newTarget =\n  let%some p = run_object_method object_revocable_proxy_ s f in\n  let%some p = p in\n  if p === Coq_value_null then res_ter s (res_val Coq_value_undef)\n  else\n  let p = loc_of_value p in\n  let%some s = run_object_set_internal object_set_revocable_proxy s f Coq_value_null in\n  let%assert _ = is_proxy_exotic_object s p in\n  let%some s = run_object_set_internal object_set_proxy_target s p Coq_value_null in\n  let%some s = run_object_set_internal object_set_proxy_handler s p Coq_value_null in\n  res_ter s (res_val Coq_value_undef)\n\n(******** UNCHECKED ES5 IMPLEMENTATION CONTINUES BELOW ***********)\n\n(** @deprecated Compatibility wrapper for ES5 code to ES6\n                implementation use [has_property] instead *)\nand object_has_prop s c l x =\n  object_internal_has_property s l (Coq_value_string x)\n\n\n(** val out_error_or_void :\n    state -> strictness_flag -> native_error -> result **)\n\nand out_error_or_void s c str ne =\n  if str then run_error s c ne else res_void s\n\n(** val out_error_or_cst :\n    state -> strictness_flag -> native_error -> value -> result **)\n\nand out_error_or_cst s c str ne v =\n  if str then run_error s c ne else res_out s (res_val v)\n\n(** val object_get_builtin :\n    state -> execution_ctx -> builtin_get -> value -> object_loc\n    -> prop_name -> result\n\n    @deprecated ES5 version of function. New versions need to be written and\n                dispatched to in {!object_internal_get}.\n**)\nand object_get_builtin s c b vthis l x =\n  let def s0 l0 =\n    let%spec (s1, d) = (run_object_get_prop s0 c l0 x) in\n    match d with\n    | Coq_full_descriptor_undef ->\n      res_ter s1 (res_val Coq_value_undef)\n    | Coq_full_descriptor_some a ->\n      (match a with\n       | Coq_attributes_data_of ad ->\n         res_ter s1 (res_val ad.attributes_data_value)\n       | Coq_attributes_accessor_of aa ->\n         (match aa.attributes_accessor_get with\n          | Coq_value_undef ->\n            res_ter s1 (res_val Coq_value_undef)\n          | Coq_value_null -> Coq_result_impossible\n          | Coq_value_bool b0 -> Coq_result_impossible\n          | Coq_value_number n -> Coq_result_impossible\n          | Coq_value_string s2 -> Coq_result_impossible\n          | Coq_value_object lf -> run_call s1 c lf vthis [])) in\n  let function0 s0 =\n    let%value (s_2, v) = (def s0 l) in\n    if spec_function_get_error_case_dec s_2 x v\n    then run_error s_2 c Coq_native_error_type\n    else res_ter s_2 (res_val v) in\n  match b with\n  | Coq_builtin_get_default -> def s l\n  | Coq_builtin_get_args_obj -> (\n    let%some lmapo = (run_object_method object_parameter_map_ s l) in\n    let%some lmap = (lmapo) in\n    let%spec (s0, d) = (run_object_get_own_prop s c lmap x) in\n    match d with\n    | Coq_full_descriptor_undef -> function0 s0\n    | Coq_full_descriptor_some a -> run_object_get s0 c lmap x)\n  | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val run_object_get :\n    state -> execution_ctx -> object_loc -> prop_name -> result\n\n    @deprecated This is the ES5 version, replaced by {!object_internal_get}\n    **)\nand run_object_get s c l x =\n  let%some b = (run_object_method object_get_ s l) in\n  object_get_builtin s c b (Coq_value_object l) l x\n\n(** val run_object_get_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    full_descriptor specres **)\n\nand run_object_get_prop s c l x =\n  let%some b = (run_object_method object_get_prop_ s l) in\n  match b with Coq_builtin_get_prop_default ->\n    let%spec (s1, d) = (run_object_get_own_prop s c l x) in\n    if full_descriptor_compare d Coq_full_descriptor_undef\n    then let%some proto = (run_object_method object_proto_ s1 l) in\n      match proto with\n      | Coq_value_null -> res_spec s1 Coq_full_descriptor_undef\n      | Coq_value_object lproto ->\n        run_object_get_prop s1 c lproto x\n      | _ ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s1\n          ("Found a non-object or null value as a prototype in [run_object_get_prop].")\n    else res_spec s1 d\n\n(** val object_proto_is_prototype_of :\n    state -> object_loc -> object_loc -> result **)\n\nand object_proto_is_prototype_of s l0 l =\n  let%some b = (run_object_method object_proto_ s l) in\n  match b with\n  | Coq_value_null ->\n    res_out s (res_val (Coq_value_bool false))\n  | Coq_value_object l_2 ->\n    if object_loc_compare l_2 l0\n    then res_out s (res_val (Coq_value_bool true))\n    else object_proto_is_prototype_of s l0 l_2\n  | _ ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("[run_object_method] returned a non-object in [object_proto_is_prototype_of_body].")\n\n(** val object_default_value :\n    state -> execution_ctx -> object_loc -> preftype option ->\n    result **)\n\nand object_default_value s c l prefo =\n  let%some b = (run_object_method object_default_value_ s l) in\n  match b with Coq_builtin_default_value_default ->\n    let gpref = unsome_default Coq_preftype_number prefo in\n    let lpref = other_preftypes gpref in\n    let sub0 s_2 x k =\n      let%value (s1, vfo) = (run_object_get s_2 c l x) in\n      let%some co = (run_callable s1 vfo) in\n      match co with\n      | Some b0 ->\n        let%object (s2, lfunc) = (res_out s1 (res_val vfo)) in\n        let%value (s3, v) = (run_call s2 c lfunc (Coq_value_object l) []) in begin\n          match v with\n          | Coq_value_object l0 -> k s3\n          | _ -> res_out s3 (res_val v)\n        end\n      | None -> k s1 in\n    let gmeth = (method_of_preftype gpref) in\n    sub0 s gmeth (fun s_2 ->\n        let lmeth = method_of_preftype lpref in\n        sub0 s_2 lmeth (fun s_3 -> run_error s_3 c Coq_native_error_type))\n\n(** val to_int32 :\n    state -> execution_ctx -> value -> float specres **)\n\nand to_int32 s c v =\n  let%number (s_2, n) = to_number s v in res_spec s_2 (JsNumber.to_int32 n)\n\n(** val to_uint32 :\n    state -> execution_ctx -> value -> float specres **)\n\nand to_uint32 s c v =\n  let%number (s_2, n) = to_number s v in res_spec s_2 (JsNumber.to_uint32 n)\n\n(** val run_object_define_own_prop_array_loop :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    descriptor -> bool -> bool -> (state -> prop_name -> descriptor ->\n    strictness_flag -> __ specres) -> result **)\n\nand run_object_define_own_prop_array_loop s c l newLen oldLen newLenDesc newWritable throwcont def =\n  if newLen < oldLen\n  then let oldLen_2 = (oldLen -. 1.) in\n    let%string (s0, slen) = (to_string s (Coq_value_number oldLen_2)) in\n    let%bool (s1, deleteSucceeded) = (object_delete s0 c l slen false) in\n    if not deleteSucceeded\n    then let newLenDesc0 =\n           (descriptor_with_value\n              newLenDesc\n              (Some (Coq_value_number (oldLen_2 +. 1.)))) in\n      let newLenDesc1 = (if not newWritable\n                         then descriptor_with_writable newLenDesc0 (Some false)\n                         else newLenDesc0) in\n      let%bool (s2, x) = (def s1 ("length")\n                            newLenDesc1 false) in\n      out_error_or_cst s2 c throwcont Coq_native_error_type\n        (Coq_value_bool false)\n    else run_object_define_own_prop_array_loop s1 c l\n        newLen oldLen_2 newLenDesc newWritable throwcont def\n  else if not newWritable\n  then def s ("length")\n      { descriptor_value = None; descriptor_writable = (Some false);\n        descriptor_get = None; descriptor_set = None;\n        descriptor_enumerable = None; descriptor_configurable = None }\n      false\n  else res_ter s (res_val (Coq_value_bool true))\n\n(** val object_define_own_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    descriptor -> strictness_flag -> result **)\n\nand object_define_own_prop s c l x desc throwcont =\n  let reject s0 throwcont0 =\n    out_error_or_cst\n      s0 c throwcont0 Coq_native_error_type (Coq_value_bool false) in\n  let def s p d _ = ordinary_define_own_property s l (Coq_value_string p) d in\n  let%some b = (run_object_method object_define_own_prop_ s l) in\n  match b with\n  | Coq_builtin_define_own_prop_default ->\n      object_internal_define_own_property s l (Coq_value_string x) desc (* ES6 hack *)\n  | Coq_builtin_define_own_prop_array ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l ("length")) in\n    begin\n      match d with\n      | Coq_full_descriptor_undef ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s0\n          ("Array length property descriptor cannot be undefined.")\n      | Coq_full_descriptor_some attr ->\n        (match attr with\n         | Coq_attributes_data_of a ->\n           let  oldLen = (a.attributes_data_value) in begin\n             match oldLen with\n             | Coq_value_object l0 ->\n               (Debug.impossible_with_heap_because __LOC__ s0\n                  "Spec asserts length of array is number.";\n                Coq_result_impossible)\n             | _ ->\n               let%number s0, oldLen = to_number s0 oldLen in\n               let oldLen0 = (JsNumber.to_uint32 oldLen) in\n               let descValueOpt = (desc.descriptor_value) in\n               if string_eq x ("length")\n               then (match descValueOpt with\n                   | Some descValue ->\n                     let%spec (s1, newLen) = (to_uint32 s0 c descValue) in\n                     let%number (s2, newLenN) = to_number s1 descValue in\n                     if not (newLen === newLenN)\n                     then run_error s2 c Coq_native_error_range\n                     else let newLenDesc =\n                            (descriptor_with_value desc (Some (Coq_value_number newLen))) in\n                       if le_int_decidable oldLen0 newLen\n                       then def s2 ("length") newLenDesc throwcont\n                       else if not a.attributes_data_writable\n                       then reject s2 throwcont\n                       else let newWritable = (match newLenDesc.descriptor_writable with\n                           | Some b0 -> if b0 then true else false\n                           | None -> true) in\n                         let newLenDesc0 = (if not newWritable\n                                            then descriptor_with_writable newLenDesc (Some true)\n                                            else newLenDesc) in\n                         let%bool (s3, succ) = (def s2 ("length") newLenDesc0 throwcont) in\n                         if not succ\n                         then res_ter s3 (res_val (Coq_value_bool false))\n                         else run_object_define_own_prop_array_loop s3 c l newLen oldLen0 newLenDesc0 newWritable throwcont def\n                   | None -> def s0 ("length") desc throwcont)\n               else let%spec (s1, ilen) = (to_uint32 s0 c (Coq_value_string x)) in\n                 let%string (s2, slen) = (to_string s1 (Coq_value_number ilen)) in\n                 if (string_eq x slen) && (not ( ilen = 4294967295.))\n                 then let%spec (s3, index) = (to_uint32 s2 c (Coq_value_string x)) in\n                   if  (le_int_decidable oldLen0 index) && (not a.attributes_data_writable)\n                   then reject s3 throwcont\n                   else let%bool (s4, b0) = (def s3 x desc false) in\n                     if not b0\n                     then reject s4 throwcont\n                     else if le_int_decidable oldLen0 index\n                     then let a0 =\n                            descriptor_with_value (descriptor_of_attributes (Coq_attributes_data_of a))\n                              (Some (Coq_value_number (index +. 1.))) in\n                       def s4 ("length") a0 false\n                     else res_ter s4 (res_val (Coq_value_bool true))\n                 else def s2 x desc throwcont\n           end\n         | Coq_attributes_accessor_of a ->\n           (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n             s0\n             ("Array length property descriptor cannot be accessor."))\n    end\n  | Coq_builtin_define_own_prop_args_obj ->\n    let%some lmapo = (run_object_method object_parameter_map_ s l) in\n    let%some lmap = (lmapo) in\n    let%spec (s0, d) = (run_object_get_own_prop s c lmap x) in\n    let%bool (s1, b0) = (def s0 x desc false) in\n    if b0\n    then let follow s2 = res_ter s2 (res_val (Coq_value_bool true)) in\n      match d with\n      | Coq_full_descriptor_undef -> follow s1\n      | Coq_full_descriptor_some a ->\n        if is_accessor_descriptor (Descriptor desc)\n        then let%bool (s2, x0) = (object_delete s1 c lmap x false) in follow s2\n        else let follow0 s2 =\n               if option_compare bool_eq desc.descriptor_writable (Some false)\n               then let%bool (s3, x0) = (object_delete s2 c lmap x false) in\n                 follow s3\n               else follow s2 in\n          match desc.descriptor_value with\n          | Some v ->\n            let%void s2 = (object_put s1 c lmap x v throwcont) in follow0 s2\n          | None -> follow0 s1\n    else reject s1 throwcont\n  | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val prim_new_object : state -> prim -> result **)\n\nand prim_new_object s _foo_ = match _foo_ with\n  | Coq_value_bool b ->\n    let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_bool_proto)) ("Boolean")) in\n    let o = (object_with_primitive_value o1 (Coq_value_bool b)) in\n    let (l, s1) = object_alloc s o in\n    res_out s1 (res_val (Coq_value_object l))\n  | Coq_value_number n ->\n    let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_number_proto)) ("Number")) in\n     let o = (object_with_primitive_value o1 (Coq_value_number n)) in\n     let (l, s1) = object_alloc s o in\n     res_out s1 (res_val (Coq_value_object l))\n  | Coq_value_string s0 ->\n    let o2 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_string_proto)) ("String")) in\n    let o1 = (object_with_get_own_property o2 Coq_builtin_get_own_prop_string) in\n    let o = (object_with_primitive_value o1 (Coq_value_string s0)) in\n    let (l, s1) = object_alloc s o in\n    let%some s_2 = (run_object_heap_map_properties s1 l\n      (fun p -> HeapStr.write p ("length")\n         (Coq_attributes_data_of (attributes_data_intro_constant\n         (Coq_value_number (number_of_int (strlength s0))))))) in\n    res_ter s_2 (res_val (Coq_value_object l))\n  | _ ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("[prim_new_object] received an null or undef.")\n\n(** val to_object : state -> value -> result **)\n\nand to_object s _foo_ = match _foo_ with\n  | Coq_value_undef -> run_error_no_c s Coq_native_error_type\n  | Coq_value_null -> run_error_no_c s Coq_native_error_type\n  | Coq_value_bool b -> prim_new_object s _foo_\n  | Coq_value_number n -> prim_new_object s _foo_\n  | Coq_value_string s0 -> prim_new_object s _foo_\n  | Coq_value_object l ->\n    res_out s (res_val (Coq_value_object l))\n\n(** val run_object_prim_value : state -> object_loc -> result **)\n\nand run_object_prim_value s l =\n  let%some ov = (run_object_method object_prim_value_ s l) in\n      let%some v = (ov) in  res_ter s (res_val v)\n\n(** val prim_value_get :\n    state -> execution_ctx -> value -> prop_name -> result **)\n\nand prim_value_get s c v x =\n  let%object (s_2, l) = (to_object s v) in\n      object_get_builtin s_2 c Coq_builtin_get_default v l x\n\n(** val env_record_has_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> result **)\n\nand env_record_has_binding s c l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        res_out s (res_val (Coq_value_bool (HeapStr.indom_dec ed x)))\n      | Coq_env_record_object (l0, pt) -> object_has_prop s c l0 x\n\n(** val lexical_env_get_identifier_ref :\n    state -> execution_ctx -> lexical_env -> prop_name ->\n    strictness_flag -> ref specres **)\n\nand lexical_env_get_identifier_ref s c x x0 str =\n  match x with\n  | [] ->\n    res_spec s (ref_create_value Coq_value_undef x0 str)\n  | l :: x_2 ->\n    let%bool (s1, has) = (env_record_has_binding s c l x0) in\n        if has\n        then res_spec s1 (ref_create_env_loc l x0 str)\n        else lexical_env_get_identifier_ref s1 c x_2 x0 str\n\n(** val object_delete :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    strictness_flag -> result **)\n\nand object_delete s c l x str =\n  let%some b = (run_object_method object_delete_ s l) in\n      match b with\n      | Coq_builtin_delete_default -> object_delete_default s c l x str\n      | Coq_builtin_delete_args_obj ->\n        begin\n          let%some mo = (run_object_method object_parameter_map_ s l) in\n          let%some m = (mo) in\n          let%spec (s1, d) = (run_object_get_own_prop s c m x) in\n          let%bool (s2, b0) = (object_delete_default s1 c l x str) in\n          if b0 then (match d with\n            | Coq_full_descriptor_undef ->\n              res_ter s2 (res_val (Coq_value_bool b0))\n            | Coq_full_descriptor_some a ->\n              let%bool (s3, b_2) = (object_delete s2 c m x false) in\n              res_ter s3 (res_val (Coq_value_bool b0)))\n          else res_ter s2 (res_val (Coq_value_bool b0))\n        end\n      | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val env_record_delete_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> result **)\n\nand env_record_delete_binding s c l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        (match HeapStr.read_option ed x with\n         | Some p ->\n           let (mu, v) = p in\n           (match mu with\n            | Coq_mutability_uninitialized_immutable ->\n              res_out s (res_val (Coq_value_bool false))\n            | Coq_mutability_immutable ->\n              res_out s (res_val (Coq_value_bool false))\n            | Coq_mutability_nondeletable ->\n              res_out s (res_val (Coq_value_bool false))\n            | Coq_mutability_deletable ->\n              let s_2 =\n                env_record_write s l (Coq_env_record_decl (decl_env_record_rem ed x))\n              in\n              res_out s_2 (res_val (Coq_value_bool true)))\n         | None ->\n           res_out s (res_val (Coq_value_bool true)))\n      | Coq_env_record_object (l0, pt) ->\n        object_delete s c l0 x throw_false\n\n(** val env_record_implicit_this_value : state -> env_loc -> value option **)\n\nand env_record_implicit_this_value s l =\n  ifx_some_or_default (env_record_binds_option s l) None (fun e ->\n      Some\n        (match e with\n         | Coq_env_record_decl ed -> Coq_value_undef\n         | Coq_env_record_object (l0, provide_this) ->\n           if provide_this\n           then Coq_value_object l0\n           else Coq_value_undef))\n\n(** val identifier_resolution :\n    state -> execution_ctx -> prop_name -> ref specres **)\n\nand identifier_resolution s c x =\n  let x0 = c.execution_ctx_lexical_env in\n  let str = c.execution_ctx_strict in\n  lexical_env_get_identifier_ref s c x0 x str\n\n(** @deprecated ES5 *)\nand env_record_get_binding_value s c l x str =\n  get_binding_value s l (Coq_value_string x) str\n\n(** @deprecated ES5 *)\nand ref_get_value s c _foo_ =\n  let%value s, v = get_value s (res_ter s (res_normal _foo_)) in\n  res_spec s v\n\n(** @deprecated ES5 *)\nand run_expr_get_value s c e =\n  let result = run_expr s c e in\n  let%ter s, _ = result in\n  let%value s, v = get_value s result in\n  res_spec s v\n\n(** val env_record_set_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> value ->\n    strictness_flag -> result_void **)\n\nand env_record_set_mutable_binding s c l x v str =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        let%some rm = (HeapStr.read_option ed x) in\n            let (mu, v_old) = rm in\n            if not (mutability_compare mu Coq_mutability_immutable)\n            then res_void (env_record_write_decl_env s l x mu v)\n            else out_error_or_void s c str Coq_native_error_type\n      | Coq_env_record_object (l0, pt) ->\n        let%success s, _ = object_put s c l0 x v str in\n        res_void s\n\n(** @deprecated ES5 *)\nand ref_put_value s c rv v =\n  let%success s, _ = put_value s c (res_ter s (res_normal rv)) (res_ter s (res_val v))\n  in res_void s\n\n(** val env_record_create_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> bool\n    option -> result_void **)\n\nand env_record_create_mutable_binding s c l x deletable_opt =\n  let  deletable = (unsome_default false deletable_opt) in\n      let%some e = (env_record_binds_option s l) in\n          match e with\n          | Coq_env_record_decl ed ->\n            if HeapStr.indom_dec ed x\n            then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s\n                ("Already declared environnment record in [env_record_create_mutable_binding].")\n            else let s_2 = (env_record_write_decl_env s l x\n                              (mutability_of_bool deletable) Coq_value_undef) in\n              res_void s_2\n          | Coq_env_record_object (l0, pt) ->\n            let%bool (s1, has) = (object_has_prop s c l0 x) in\n              if has\n              then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                    s1\n                    ("Already declared binding in [env_record_create_mutable_binding].")\n              else let  a = ({ attributes_data_value = Coq_value_undef; attributes_data_writable = true;\n                                   attributes_data_enumerable = true;\n                                   attributes_data_configurable = deletable }) in\n                    let%success\n                       (s2, rv) = (object_define_own_prop s1 c l0 x\n                         (descriptor_of_attributes (Coq_attributes_data_of a))\n                         throw_true) in  res_void s2\n\n(** val env_record_create_set_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> bool\n    option -> value -> strictness_flag -> result_void **)\n\nand env_record_create_set_mutable_binding s c l x deletable_opt v str =\n  let%void\n    s0 = (env_record_create_mutable_binding s c l x deletable_opt) in  env_record_set_mutable_binding s0 c l x v str\n\n(** val env_record_create_immutable_binding :\n    state -> env_loc -> prop_name -> result_void **)\n\nand env_record_create_immutable_binding s l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        if HeapStr.indom_dec ed x\n        then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("Already declared environnment record in [env_record_create_immutable_binding].")\n        else res_void\n            (env_record_write_decl_env s l x\n               Coq_mutability_uninitialized_immutable Coq_value_undef)\n      | Coq_env_record_object (o, p) ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("[env_record_create_immutable_binding] received an environnment record object.")\n\n(** val env_record_initialize_immutable_binding :\n    state -> env_loc -> prop_name -> value -> result_void **)\n\nand env_record_initialize_immutable_binding s l x v =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        let%some evs = (decl_env_record_option ed x) in\n            if prod_compare mutability_compare value_compare evs\n                (Coq_mutability_uninitialized_immutable, Coq_value_undef)\n            then let s_2 = (env_record_write_decl_env s l x Coq_mutability_immutable v) in res_void s_2\n            else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s\n                ("Non suitable binding in [env_record_initialize_immutable_binding].")\n      | Coq_env_record_object (o, p) ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("[env_record_initialize_immutable_binding] received an environnment record object.")\n\n(** val call_object_new : state -> value -> result **)\n\nand call_object_new s c v =\n  match type_of v with\n  | Coq_type_undef ->\n    let o = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_object_proto))\n      ("Object")) in\n    let  p = object_alloc s o in\n    let (l, s_2) = p in\n    res_out s_2 (res_val (Coq_value_object l))\n  | Coq_type_null ->\n    let o = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_object_proto))\n      ("Object")) in\n    let  p = object_alloc s o in\n    let (l, s_2) = p in\n    res_out s_2 (res_val (Coq_value_object l))\n  | Coq_type_bool -> to_object s v\n  | Coq_type_number -> to_object s v\n  | Coq_type_string -> to_object s v\n  | Coq_type_object -> res_out s (res_val v)\n\n(** val array_args_map_loop :\n    state -> execution_ctx -> object_loc -> value list -> float\n    -> result_void **)\n\nand array_args_map_loop s c l args ind =\n  match args with\n  | [] -> res_void s\n  | h :: rest ->\n    let%some s_2 = (run_object_heap_map_properties s l (fun p ->\n           HeapStr.write p (JsNumber.to_string ind)\n             (Coq_attributes_data_of (attributes_data_intro_all_true h)))) in\n             array_args_map_loop s_2 c l rest (ind +. 1.)\n\n(** val run_construct_prealloc :\n    state -> execution_ctx -> prealloc -> value list -> result **)\n\nand run_construct_prealloc s c b args =\n  match b with\n  | Coq_prealloc_object ->\n    let v = (get_arg 0 args) in call_object_new s c v\n  | Coq_prealloc_bool ->\n    let v = get_arg 0 args in\n    let b0 = to_boolean v in\n    let o1 = object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_bool_proto))\n      ("Boolean") in\n    let o = object_with_primitive_value o1 (Coq_value_bool b0) in\n    let  p = object_alloc s o in\n    let (l, s_2) = p in\n    res_out s_2 (res_val (Coq_value_object l))\n  | Coq_prealloc_number ->\n    let follow = (fun s_2 v ->\n      let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_number_proto))\n        ("Number")) in\n      let o = object_with_primitive_value o1 v in\n      let (l, s1) = object_alloc s_2 o in\n      res_out s1 (res_val (Coq_value_object l))) in\n    if list_eq_nil_decidable args\n    then follow s (Coq_value_number JsNumber.zero)\n    else\n      let v = get_arg 0 args in\n      let%number (x, x0) = (to_number s v) in\n      follow x (Coq_value_number x0)\n  | Coq_prealloc_array ->\n    let o_2 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_array_proto))\n      ("Array")) in\n    let o = (object_for_array o_2 Coq_builtin_define_own_prop_array) in\n    let p = (object_alloc s o) in\n    let (l, s_2) = p in\n    let follow = (fun s_3 length0 ->\n      let%some s0 = (run_object_heap_map_properties s_3 l (fun p0 ->\n        HeapStr.write p0 ("length") (Coq_attributes_data_of\n          { attributes_data_value = (Coq_value_number length0);\n            attributes_data_writable = true;\n            attributes_data_enumerable = false;\n            attributes_data_configurable = false }))) in\n      res_ter s0 (res_val (Coq_value_object l))) in\n    let arg_len = (LibList.length args) in\n    if nat_eq arg_len 1\n    then let v = get_arg 0 args in\n    match v with\n    | Coq_value_undef ->\n      let%some s0 = (run_object_heap_map_properties s_2 l\n        (fun p1 -> HeapStr.write p1 ("0") (Coq_attributes_data_of (attributes_data_intro_all_true v)))) in\n      follow s0 1.0\n    | Coq_value_null ->\n      let%some s0 = (run_object_heap_map_properties s_2 l\n        (fun p1 -> HeapStr.write p1 ("0") (Coq_attributes_data_of (attributes_data_intro_all_true v)))) in\n      follow s0 1.0\n    | Coq_value_bool b0 ->\n      let%some s0 = (run_object_heap_map_properties s_2 l\n        (fun p1 -> HeapStr.write p1 ("0") (Coq_attributes_data_of (attributes_data_intro_all_true v)))) in\n      follow s0 1.0\n    | Coq_value_number vlen ->\n      let%spec (s0, ilen) = (to_uint32 s_2 c (Coq_value_number vlen)) in\n      if ilen === vlen\n      then follow s0 ilen\n      else run_error s0 c Coq_native_error_range\n    | Coq_value_string s0 ->\n      let%some s1 = (run_object_heap_map_properties s_2 l\n        (fun p1 -> HeapStr.write p1 ("0") (Coq_attributes_data_of (attributes_data_intro_all_true v)))) in\n      follow s1 1.0\n    | Coq_value_object o0 ->\n      let%some\n         s0 = (run_object_heap_map_properties s_2 l\n           (fun p0 ->\n              HeapStr.write p0 ("0") (Coq_attributes_data_of\n                                     (attributes_data_intro_all_true v)))) in\n            follow s0 1.0\n                          else let%some\n                               s0 = (run_object_heap_map_properties s_2 l\n                                 (fun p0 ->\n                                    HeapStr.write p0\n                                      ("length")\n                                      (Coq_attributes_data_of { attributes_data_value =\n                                                                  (Coq_value_number (number_of_int arg_len));\n                                                                attributes_data_writable = true;\n                                                                attributes_data_enumerable = false;\n                                                                attributes_data_configurable = false }))) in\n                                  let%void\n                                    s1 = (array_args_map_loop s0 c l args 0.) in  res_ter s1 (res_val (Coq_value_object l))\n  | Coq_prealloc_string ->\n    let\n       o2 = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                       Coq_prealloc_string_proto))\n         ("String")) in\n          let\n\n            o1 = (object_with_get_own_property o2 Coq_builtin_get_own_prop_string) in\n               let  follow = (fun s0 s1 ->\n                   let\n                      o = (object_with_primitive_value o1 (Coq_value_string s1)) in\n                         let (l, s2) = object_alloc s0 o in\n                         let lenDesc = (attributes_data_intro_constant (Coq_value_number (number_of_int (strlength s1)))) in\n                              let%some\n                                 s_2 = (run_object_heap_map_properties s2 l (fun p ->\n                                     HeapStr.write p ("length")\n                                       (Coq_attributes_data_of lenDesc))) in\n                                    res_ter s_2 (res_val (Coq_value_object l))) in\n                   let  arg_len = (LibList.length args) in\n                       if nat_eq arg_len 0\n                       then follow s ""\n                       else let  arg = (get_arg 0 args) in\n                           let%string (s0, s1) = (to_string s arg) in\n                               follow s0 s1\n  | Coq_prealloc_error ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           Coq_prealloc_error_proto)) v\n  | Coq_prealloc_native_error ne ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           (Coq_prealloc_native_error_proto ne))) v\n  | Coq_prealloc_proxy -> builtin_proxy_constructor s c () () (Coq_value_object (Coq_object_loc_prealloc\n                                                                                   Coq_prealloc_proxy)) (get_arg 0 args) (get_arg 1 args)\n  | _ ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      (strappend\n         ("Construct prealloc_")\n         (strappend (string_of_prealloc b)\n            (" not yet implemented.")))\n\n(** val run_construct_default :\n    state -> execution_ctx -> object_loc -> value list -> __\n    specres **)\n\nand run_construct_default s c l args =\n  let%value\n\n    (s1, v1) = (run_object_get s c l\n       ("prototype")) in\n       let\n          vproto = (if type_compare (type_of v1) Coq_type_object\n          then v1\n          else Coq_value_object (Coq_object_loc_prealloc\n                                   Coq_prealloc_object_proto)) in\n             let\n\n               o = (object_new vproto ("Object")) in\n                  let  p = (object_alloc s1 o) in\n                      let (l_2, s2) = p in\n                      let%value\n                        (s3, v2) = (run_call s2 c l (Coq_value_object l_2) args) in\n                           let\n                              vr = (if type_compare (type_of v2) Coq_type_object\n                              then v2\n                              else Coq_value_object l_2) in res_ter s3 (res_val vr)\n\n(** val run_construct :\n    state -> execution_ctx -> construct -> object_loc -> value\n    list -> result **)\n\nand run_construct s c co l args =\n  match co with\n  | Coq_construct_default -> run_construct_default s c l args\n  | Coq_construct_after_bind ->\n    let%some otrg = run_object_method object_target_function_ s l in\n    let%some target = (otrg) in\n    let%some oco = run_object_method object_construct_ s target in begin\n      match oco with\n      | Some co0 ->\n        let%some oarg = run_object_method object_bound_args_ s l in\n        let%some boundArgs = oarg in\n        let  arguments_ = (LibList.append boundArgs args) in\n            run_construct s c co0 target arguments_\n      | None -> run_error s c Coq_native_error_type\n    end\n  | Coq_construct_prealloc b -> run_construct_prealloc s c b args\n  | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val run_call_default :\n    state -> execution_ctx -> object_loc -> result **)\n\nand run_call_default s c lf =\n  let def = res_out s (res_val Coq_value_undef) in\n  let%some oC = (run_object_method object_code_ s lf) in\n  match oC with\n  | Some bd ->\n    if list_eq_nil_decidable (prog_elements (funcbody_prog bd))\n    then def\n    else ifx_success_or_return (run_prog s c (funcbody_prog bd))\n      (fun s_2 -> res_out s_2 (res_val Coq_value_undef))\n      (fun s_2 rv -> res_out s_2 (res_normal rv))\n  | None -> def\n\n(** val creating_function_object_proto :\n    state -> execution_ctx -> object_loc -> result **)\n\nand creating_function_object_proto s c l =\n  let%object\n    (s1, lproto) = (run_construct_prealloc s c Coq_prealloc_object []) in\n       let  a1 = ({ attributes_data_value = (Coq_value_object l);\n                     attributes_data_writable = true; attributes_data_enumerable = false;\n                     attributes_data_configurable = true }) in\n           let%bool\n\n             (s2, b) = (object_define_own_prop s1 c lproto\n                ("constructor")\n                (descriptor_of_attributes (Coq_attributes_data_of a1)) false) in\n                let  a2 = ({ attributes_data_value = (Coq_value_object lproto);\n                              attributes_data_writable = true; attributes_data_enumerable =\n                                                                 false; attributes_data_configurable = false }) in\n                    object_define_own_prop s2 c l\n                      ("prototype")\n                      (descriptor_of_attributes (Coq_attributes_data_of a2)) false\n\n(** val creating_function_object :\n    state -> execution_ctx -> string list -> funcbody ->\n    lexical_env -> strictness_flag -> result **)\n\nand creating_function_object s c names bd x str =\n  let\n     o = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                     Coq_prealloc_function_proto))\n       ("Function")) in\n            let o2 = (object_with_invokation o (Some Coq_construct_default) (Some\n                                                                         Coq_call_default) (Some Coq_builtin_has_instance_function)) in\n             let o3 = (object_with_details o2 (Some x) (Some names) (Some bd) None None None None) in\n             let p = (object_alloc s o3) in\n             let (l, s1) = p in\n             let a1 = ({\n               attributes_data_value = (Coq_value_number (number_of_int (LibList.length names)));\n               attributes_data_writable = false; attributes_data_enumerable = false;\n               attributes_data_configurable = false\n             }) in\n             let%bool (s2, b2) = (object_define_own_prop s1 c l ("length")\n               (descriptor_of_attributes (Coq_attributes_data_of a1)) false) in\n             let%bool (s3, b3) = (creating_function_object_proto s2 c l) in\n             if not str\n             then res_ter s3 (res_val (Coq_value_object l))\n             else\n               let vthrower = (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_throw_type_error)) in\n               let a2 = ({ attributes_accessor_get = vthrower;\n                           attributes_accessor_set = vthrower;\n                           attributes_accessor_enumerable = false;\n                           attributes_accessor_configurable = false }) in\n               let%bool (s4, b4) = (object_define_own_prop s3 c l ("caller")\n                 (descriptor_of_attributes (Coq_attributes_accessor_of a2)) false) in\n               let%bool (s5, b5) = (object_define_own_prop s4 c l ("arguments")\n                 (descriptor_of_attributes (Coq_attributes_accessor_of a2)) false) in\n               res_ter s5 (res_val (Coq_value_object l))\n\n(** val binding_inst_formal_params :\n    state -> execution_ctx -> env_loc -> value list -> string\n    list -> strictness_flag -> result_void **)\n\nand binding_inst_formal_params s c l args names str =\n  match names with\n  | [] -> res_void s\n  | argname :: names_2 ->\n    let  v = (hd Coq_value_undef args) in\n        let  args_2 = (tl args) in\n            let%bool (s1, hb) = (env_record_has_binding s c l argname) in\n                let\n                  follow = (fun s_2 ->\n                    let%void\n\n                      s_3= (env_record_set_mutable_binding s_2 c l argname v str) in\n                         binding_inst_formal_params s_3 c l args_2 names_2 str) in\n                     if hb\n                     then follow s1\n                     else let%void\n                          s2 = (env_record_create_mutable_binding s1 c l argname\n                            None) in  follow s2\n\n(** val binding_inst_function_decls :\n    state -> execution_ctx -> env_loc -> funcdecl list ->\n    strictness_flag -> bool -> result_void **)\n\nand binding_inst_function_decls s c l fds str bconfig =\n\n  match fds with\n  | [] -> res_void s\n  | fd :: fds_2 ->\n    let  fbd = (fd.funcdecl_body) in\n        let  str_fd = (funcbody_is_strict fbd) in\n            let  fparams = (fd.funcdecl_parameters) in\n                let  fname = (fd.funcdecl_name) in\n                    let%object\n                       (s1, fo) = (creating_function_object s c fparams fbd\n                         c.execution_ctx_variable_env str_fd) in\n                          let\n                            follow = (fun s2 ->\n                              let%void\n                                 s3= (env_record_set_mutable_binding s2 c l fname\n                                   (Coq_value_object fo) str) in\n                                    binding_inst_function_decls s3 c l fds_2 str bconfig) in\n                               let%bool\n                                 (s2, has) = (env_record_has_binding s1 c l fname) in\n                                    if has\n                                    then if nat_eq l env_loc_global_env_record\n                                      then let%spec\n                                           (s3, d) = (run_object_get_prop s2 c\n                                             (Coq_object_loc_prealloc Coq_prealloc_global)\n                                             fname) in\n                                              match d with\n                                              | Coq_full_descriptor_undef ->\n                                                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                                  s3\n                                                  ("Undefined full descriptor in [binding_inst_function_decls].")\n                                              | Coq_full_descriptor_some a ->\n                                                if attributes_configurable a\n                                                then let  a_2 = ({ attributes_data_value =\n                                                                     Coq_value_undef;\n                                                                   attributes_data_writable = true;\n                                                                   attributes_data_enumerable = true;\n                                                                   attributes_data_configurable =\n                                                                     bconfig }) in\n                                                    let%bool\n                                                       (s0, x) = (object_define_own_prop s3 c\n                                                         (Coq_object_loc_prealloc\n                                                            Coq_prealloc_global) fname\n                                                         (descriptor_of_attributes\n                                                            (Coq_attributes_data_of a_2))\n                                                         true) in follow s0\n                                                else if\n                                                       (is_accessor_descriptor (Descriptor (descriptor_of_attributes a)))\n                                                    || (not (attributes_writable a))\n                                                    || (not (attributes_enumerable a))\n                                                then run_error s3 c Coq_native_error_type\n                                                else follow s3\n                                      else follow s2\n                                    else let%void\n                                         s3 = (env_record_create_mutable_binding s2 c l\n                                           fname (Some bconfig)) in  follow s3\n\n(** val make_arg_getter :\n    state -> execution_ctx -> prop_name -> lexical_env -> result **)\n\nand make_arg_getter s c x x0 =\n  let xbd =\n    strappend ("return ")\n      (strappend x (";"))\n  in\n  let bd = Coq_funcbody_intro ((Coq_prog_intro (true, ((Coq_element_stat\n                                                          (Coq_stat_return (Some (Coq_expr_identifier x)))) :: []))), xbd)\n  in\n  creating_function_object s c [] bd x0 true\n\n(** val make_arg_setter :\n    state -> execution_ctx -> prop_name -> lexical_env -> result **)\n\nand make_arg_setter s c x x0 =\n  let xparam = strappend x ("_arg") in\n  let xbd =\n    strappend x (strappend (" = ") (strappend xparam ";"))\n  in\n  let bd = Coq_funcbody_intro ((Coq_prog_intro (true, ((Coq_element_stat\n                                                          (Coq_stat_expr (Coq_expr_assign ((Coq_expr_identifier x), None,\n                                                                                           (Coq_expr_identifier xparam))))) :: []))), xbd)\n  in\n  creating_function_object s c (xparam :: []) bd x0 true\n\n(** val arguments_object_map_loop :\n    state -> execution_ctx -> object_loc -> string list ->\n    int -> value list -> lexical_env -> strictness_flag -> object_loc ->\n    string list -> result_void **)\n\nand arguments_object_map_loop s c l xs len args x str lmap xsmap =\n  (fun fO fS n -> if int_eq n 0 then fO () else fS (n-1))\n    (fun _ ->\n       if list_eq_nil_decidable xsmap\n       then res_void s\n       else let%some o = (object_binds_option s l) in\n           let\n              o_2 = (object_for_args_object o lmap Coq_builtin_get_args_obj\n                Coq_builtin_get_own_prop_args_obj\n                Coq_builtin_define_own_prop_args_obj\n                Coq_builtin_delete_args_obj) in\n                 res_void (object_write s l o_2))\n    (fun len_2 ->\n       let  tdl = (take_drop_last args) in\n           let (rmlargs, largs) = tdl in\n           let  arguments_object_map_loop_2 = (fun s0 xsmap0 ->\n               arguments_object_map_loop s0 c l xs len_2 rmlargs x str lmap\n                 xsmap0) in\n               let  a = (attributes_data_intro_all_true largs) in\n                  let%string s, tempVar = to_string s (Coq_value_number (number_of_int len_2)) in\n                   let%bool\n\n                     (s1, b) = (object_define_own_prop s c l tempVar\n                        (descriptor_of_attributes (Coq_attributes_data_of a)) false) in\n                        if ge_nat_decidable len_2 (LibList.length xs)\n                        then arguments_object_map_loop_2 s1 xsmap\n                        else let dummy = "" in\n                          let  x0 = (nth_def dummy len_2 xs) in\n                              if    (str)\n                                 || (mem_decide string_eq x0 xsmap)\n                              then arguments_object_map_loop_2 s1 xsmap\n                              else let%object\n                                  (s2, lgetter) = (make_arg_getter s1 c x0 x) in\n                                     let%object\n                                       (s3, lsetter) = (make_arg_setter s2 c x0 x) in\n                                          let  a_2 = ({ attributes_accessor_get =\n                                                          (Coq_value_object lgetter);\n                                                        attributes_accessor_set = (Coq_value_object\n                                                                                     lsetter); attributes_accessor_enumerable =\n                                                                                                 false; attributes_accessor_configurable =\n                                                                                                          true }) in\n                                let%string s3, tempVar = to_string s3 (Coq_value_number (number_of_int len_2)) in\n                                              let%bool\n\n                                                (s4, b_2) = (object_define_own_prop s3 c lmap\n                                                   tempVar\n                                                   (descriptor_of_attributes\n                                                      (Coq_attributes_accessor_of a_2)) false) in\n                                                   arguments_object_map_loop_2 s4 (x0 :: xsmap))\n    len\n\n(** val arguments_object_map :\n    state -> execution_ctx -> object_loc -> string list ->\n    value list -> lexical_env -> strictness_flag -> result_void **)\n\nand arguments_object_map s c l xs args x str =\n  let%object\n    (s_2, lmap) = (run_construct_prealloc s c Coq_prealloc_object []) in\n       arguments_object_map_loop s_2 c l xs (LibList.length args) args x\n         str lmap []\n\n(** val create_arguments_object :\n    state -> execution_ctx -> object_loc -> string list ->\n    value list -> lexical_env -> strictness_flag -> result **)\n\nand create_arguments_object s c lf xs args x str =\n  let\n     o = (object_create_builtin (Coq_value_object (Coq_object_loc_prealloc\n                                                Coq_prealloc_object_proto))\n       ("Arguments")\n       Heap.empty) in\n        let  p = (object_alloc s o) in\n            let (l, s_2) = p in\n            let  a = ({ attributes_data_value = (Coq_value_number (number_of_int (LibList.length args)));\n                          attributes_data_writable = true; attributes_data_enumerable = false;\n                          attributes_data_configurable = true }) in\n                let%bool\n\n                  (s1, b) = (object_define_own_prop s_2 c l\n                     ("length")\n                     (descriptor_of_attributes (Coq_attributes_data_of a)) false) in\n                     let%void\n                       s2= (arguments_object_map s1 c l xs args x str) in\n                          if str\n                          then let  vthrower = (Coq_value_object (Coq_object_loc_prealloc\n                                                                Coq_prealloc_throw_type_error)) in\n                              let  a0 = ({ attributes_accessor_get = vthrower;\n                                            attributes_accessor_set = vthrower;\n                                            attributes_accessor_enumerable = false;\n                                            attributes_accessor_configurable = false }) in\n                                  let%bool\n\n                                    (s3, b_2) = (object_define_own_prop s2 c l\n                                       ("caller")\n                                       (descriptor_of_attributes\n                                          (Coq_attributes_accessor_of a0)) false) in\n                                       let%bool\n\n                                         (s4, b_3) = (object_define_own_prop s3 c l\n                                            ("callee")\n                                            (descriptor_of_attributes\n                                               (Coq_attributes_accessor_of a0)) false) in\n                                            res_ter s4 (res_val (Coq_value_object l))\n                          else let  a0 = ({ attributes_data_value = (Coq_value_object lf);\n                                             attributes_data_writable = true;\n                                             attributes_data_enumerable = false;\n                                             attributes_data_configurable = true }) in\n                              let%bool\n                                 (s3, b_2) = (object_define_own_prop s2 c l\n                                   ("callee")\n                                   (descriptor_of_attributes (Coq_attributes_data_of a0))\n                                   false) in\n                                    res_ter s3 (res_val (Coq_value_object l))\n\n(** val binding_inst_arg_obj :\n    state -> execution_ctx -> object_loc -> prog -> string\n    list -> value list -> env_loc -> result_void **)\n\nand binding_inst_arg_obj s c lf p xs args l =\n  let arguments_ =\n    "arguments"\n  in\n  let  str = (prog_intro_strictness p) in\n      let%object\n         (s1, largs) = (create_arguments_object s c lf xs args\n           c.execution_ctx_variable_env str) in\n            if str\n            then let%void\n                s2= (env_record_create_immutable_binding s1 l arguments_) in\n                   env_record_initialize_immutable_binding s2 l arguments_\n                     (Coq_value_object largs)\n            else env_record_create_set_mutable_binding s1 c l arguments_ None\n                (Coq_value_object largs) false\n\n(** val binding_inst_var_decls :\n    state -> execution_ctx -> env_loc -> string list -> bool\n    -> strictness_flag -> result_void **)\n\nand binding_inst_var_decls s c l vds bconfig str =\n  match vds with\n  | [] -> res_void s\n  | vd :: vds_2 ->\n    let  bivd = (fun s0 -> binding_inst_var_decls s0 c l vds_2 bconfig str) in\n    let%bool (s1, has) = (env_record_has_binding s c l vd) in\n    if has then\n      bivd s1\n    else\n      let%void s2 = env_record_create_set_mutable_binding s1 c l vd (Some bconfig) Coq_value_undef str in\n      bivd s2\n\n(** val execution_ctx_binding_inst :\n    state -> execution_ctx -> codetype -> object_loc option ->\n    prog -> value list -> result_void **)\n\nand execution_ctx_binding_inst s c ct funco p args =\n  match c.execution_ctx_variable_env with\n  | [] ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst].")\n  | l :: l0 ->\n    let  str = (prog_intro_strictness p) in\n    let  follow = (fun s_2 names ->\n        let bconfig = (codetype_compare ct Coq_codetype_eval) in\n        let  fds = (prog_funcdecl p) in\n        let%void s1= (binding_inst_function_decls s_2 c l fds str bconfig) in\n        let%bool (s2, bdefined) = (env_record_has_binding s1 c l ("arguments")) in\n        let follow2 = (fun s10 ->\n            let vds = prog_vardecl p in\n            binding_inst_var_decls s10 c l vds bconfig str) in\n        match ct with\n        | Coq_codetype_func ->\n          (match funco with\n           | Some func ->\n             if bdefined\n             then follow2 s2\n             else let%void s3 = (binding_inst_arg_obj s2 c func p names args l) in  follow2 s3\n           | None ->\n             if bdefined\n             then follow2 s2\n             else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                 s2\n                 ("Weird `arguments\\\' object in [execution_ctx_binding_inst]."))\n        | Coq_codetype_global -> follow2 s2\n        | Coq_codetype_eval -> follow2 s2) in\n    match ct with\n    | Coq_codetype_func ->\n      (match funco with\n       | Some func ->\n         let%some nameso = (run_object_method object_formal_parameters_ s func) in\n         let%some names = (nameso) in\n         let%void s_2 = (binding_inst_formal_params s c l args names str) in\n         follow s_2 names\n       | None ->\n         (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n           s\n           ("Non coherent functionnal code type in [execution_ctx_binding_inst]."))\n    | Coq_codetype_global ->\n      (match funco with\n       | Some o ->\n         (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n           s\n           ("Non coherent non-functionnal code type in [execution_ctx_binding_inst].")\n       | None -> follow s [])\n    | Coq_codetype_eval ->\n      (match funco with\n       | Some o ->\n         (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n           s\n           ("Non coherent non-functionnal code type in [execution_ctx_binding_inst].")\n       | None -> follow s [])\n\n(** val entering_func_code :\n    state -> execution_ctx -> object_loc -> value -> value list\n    -> result **)\n\nand entering_func_code s c lf vthis args =\n  let%some bdo = (run_object_method object_code_ s lf) in\n  let%some bd = (bdo) in\n  let str = (funcbody_is_strict bd) in\n  let follow = (fun s_2 vthis_2 ->\n    let%some lexo = (run_object_method object_scope_ s_2 lf) in\n    let%some lex = (lexo) in\n    let p = (lexical_env_alloc_decl s_2 lex) in\n    let (lex_2, s1) = p in\n    let c_2 = (execution_ctx_intro_same lex_2 vthis_2 str) in\n    let%void s2 = (execution_ctx_binding_inst s1 c_2 Coq_codetype_func\n      (Some lf) (funcbody_prog bd) args) in\n    run_call_default s2 c_2 lf)\n  in\n  if str\n  then follow s vthis\n  else (match vthis with\n      | Coq_value_undef ->\n        follow s (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_global))\n      | Coq_value_null ->\n        follow s (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_global))\n      | Coq_value_bool b -> let%value (s2, v) = (to_object s vthis) in follow s2 v\n      | Coq_value_number n -> let%value (s2, v) = (to_object s vthis) in follow s2 v\n      | Coq_value_string s0 -> let%value (s2, v) = (to_object s vthis) in follow s2 v\n      | Coq_value_object lthis -> follow s vthis)\n\n(** val run_object_get_own_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    full_descriptor specres **)\n\nand run_object_get_own_prop s c l x =\n  let%some b = (run_object_method object_get_own_prop_ s l) in\n  let def = (fun s_2 ->\n    let%some p = (run_object_method object_properties_ s_2 l) in\n    res_spec s_2 (ifx_some_or_default (convert_option_attributes (HeapStr.read_option p x))\n      Coq_full_descriptor_undef (fun x -> x))\n  ) in\n  match b with\n  | Coq_builtin_get_own_prop_default -> def s\n  | Coq_builtin_get_own_prop_args_obj ->\n    let%spec (s1, d) = (def s) in\n    begin\n      match d with\n      | Coq_full_descriptor_undef -> res_spec s1 Coq_full_descriptor_undef\n      | Coq_full_descriptor_some a ->\n        let%some lmapo = (run_object_method object_parameter_map_ s1 l) in\n        let%some lmap = (lmapo) in\n        let%spec (s2, d0) = (run_object_get_own_prop s1 c lmap x) in\n        let follow = (fun s_2 a0 -> res_spec s_2 (Coq_full_descriptor_some a0)) in\n        match d0 with\n        | Coq_full_descriptor_undef -> follow s2 a\n        | Coq_full_descriptor_some amap ->\n          let%value (s3, v) = (run_object_get s2 c lmap x) in\n          match a with\n          | Coq_attributes_data_of ad ->\n            follow s3 (Coq_attributes_data_of (attributes_data_with_value ad v))\n          | Coq_attributes_accessor_of aa ->\n            (Debug.impossible_with_heap_because __LOC__ s3\n              "[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens.";\n              Coq_result_impossible)\n    end\n  | Coq_builtin_get_own_prop_string ->\n    let%spec (s0, d) = def s in\n    (match d with\n    | Coq_full_descriptor_undef ->\n      let%spec (s1, k) = (to_int32 s0 c (Coq_value_string x)) in\n      let%string (s2, s3) = (to_string s1 (Coq_value_number (JsNumber.absolute k))) in\n      if not (string_eq x s3)\n      then res_spec s2 Coq_full_descriptor_undef\n      else\n        let%string (s4, str) = (run_object_prim_value s2 l) in\n        let%spec (s5, k0) = (to_int32 s4 c (Coq_value_string x)) in\n        let len = (number_of_int (strlength str)) in\n        if le_int_decidable len k0\n        then res_spec s5 Coq_full_descriptor_undef\n        else\n          let resultStr = string_sub str (int_of_number k0) 1 (* TODO: check k0 is not negative *) in\n          let a = { attributes_data_value = (Coq_value_string resultStr);\n                    attributes_data_writable = false; attributes_data_enumerable = true;\n                    attributes_data_configurable = false } in\n          res_spec s5 (Coq_full_descriptor_some (Coq_attributes_data_of a))\n    | Coq_full_descriptor_some a -> res_spec s0 d)\n  | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val run_function_has_instance :\n    state -> object_loc -> value -> result **)\n\nand run_function_has_instance s c lv _foo_ =\n  (match _foo_ with\n  | Coq_value_object lo ->\n    let%some vproto = (run_object_method object_proto_ s lv) in\n      (match vproto with\n        | Coq_value_null -> res_ter s (res_val (Coq_value_bool false))\n        | Coq_value_object proto ->\n          if object_loc_compare proto lo\n          then res_ter s (res_val (Coq_value_bool true))\n          else run_function_has_instance s c proto (Coq_value_object lo)\n        | _ -> (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("Primitive found in the prototype chain in [run_object_has_instance_loop]."))\n  | _ -> run_error s c Coq_native_error_type)\n\n(** val run_object_has_instance :\n    state -> execution_ctx -> builtin_has_instance -> object_loc\n    -> value -> result **)\n\nand run_object_has_instance s c b l v =\n  match b with\n  | Coq_builtin_has_instance_function ->\n    (match v with\n     | Coq_value_object lv ->\n       let%value (s1, vproto) = (run_object_get s c l ("prototype")) in\n       (match vproto with\n       | Coq_value_object lproto -> run_function_has_instance s1 c lv (Coq_value_object lproto)\n       | _ -> run_error s1 c Coq_native_error_type)\n     | _ -> res_out s (res_val (Coq_value_bool false)))\n  | Coq_builtin_has_instance_after_bind ->\n    let%some ol = run_object_method object_target_function_ s l in\n    let%some l0 = ol in\n    let%some ob = run_object_method object_has_instance_ s l0 in\n    match ob with\n    | Some b0 -> run_object_has_instance s c b0 l0 v\n    | None -> run_error s c Coq_native_error_type\n\n(** val from_prop_descriptor :\n    state -> execution_ctx -> full_descriptor -> result **)\n\nand from_prop_descriptor s c _foo_ = match _foo_ with\n  | Coq_full_descriptor_undef ->\n    res_out s (res_val Coq_value_undef)\n  | Coq_full_descriptor_some a ->\n    let%object (s1, l) = run_construct_prealloc s c Coq_prealloc_object [] in\n    let follow = (fun s0 x ->\n      let a1 = (attributes_data_intro_all_true (Coq_value_bool (attributes_enumerable a))) in\n      let%bool (s0_2, x0) = (object_define_own_prop s0 c l ("enumerable")\n        (descriptor_of_attributes (Coq_attributes_data_of a1)) throw_false) in\n      let a2 = (attributes_data_intro_all_true (Coq_value_bool (attributes_configurable a))) in\n      let%bool (s_2, x1) = (object_define_own_prop s0_2 c l ("configurable") (descriptor_of_attributes (Coq_attributes_data_of a2)) throw_false) in\n      res_ter s_2 (res_val (Coq_value_object l))) in\n    match a with\n    | Coq_attributes_data_of ad ->\n      let a1 = (attributes_data_intro_all_true ad.attributes_data_value) in\n      let%bool (s2, x) = (object_define_own_prop s1 c l ("value")\n        (descriptor_of_attributes (Coq_attributes_data_of a1)) throw_false) in\n      let a2 = (attributes_data_intro_all_true (Coq_value_bool ad.attributes_data_writable)) in\n      let%bool (s3, v) = (object_define_own_prop s2 c l ("writable")\n        (descriptor_of_attributes (Coq_attributes_data_of a2)) throw_false) in\n      follow s3 v\n    | Coq_attributes_accessor_of aa ->\n      let a1 = (attributes_data_intro_all_true aa.attributes_accessor_get) in\n      let%bool (s2, x) = (object_define_own_prop s1 c l ("get")\n        (descriptor_of_attributes (Coq_attributes_data_of a1)) throw_false) in\n      let a2 = (attributes_data_intro_all_true aa.attributes_accessor_set) in\n      let%bool (s3, v) = (object_define_own_prop s2 c l ("set")\n        (descriptor_of_attributes (Coq_attributes_data_of a2)) throw_false) in\n      follow s3 v\n\n(** val run_equal :\n    state -> execution_ctx -> value -> value -> result **)\n\nand run_equal s c v1 v2 =\n  let conv_number = fun s0 v -> to_number s0 v in\n  let conv_primitive = fun s0 v -> to_primitive s0 v None in\n  let checkTypesThen = (fun s0 v3 v4 k ->\n    let ty1 = type_of v3 in\n    let ty2 = type_of v4 in\n    if type_compare ty1 ty2\n    then res_out s0 (res_val (Coq_value_bool (equality_test_for_same_type ty1 v3 v4)))\n    else k ty1 ty2) in\n  checkTypesThen s v1 v2 (fun ty1 ty2 ->\n    let dc_conv = (fun v3 f v4 -> let%value (s0, v2_2) = (f s v4) in run_equal s0 c v3 v2_2) in\n    let so = fun b -> res_out s (res_val (Coq_value_bool b)) in\n    if (type_compare ty1 Coq_type_null) && (type_compare ty2 Coq_type_undef)\n    then so true\n    else if (type_compare ty1 Coq_type_undef) && (type_compare ty2 Coq_type_null)\n    then so true\n    else if (type_compare ty1 Coq_type_number) && (type_compare ty2 Coq_type_string)\n    then dc_conv v1 conv_number v2\n    else if (type_compare ty1 Coq_type_string) && (type_compare ty2 Coq_type_number)\n    then dc_conv v2 conv_number v1\n    else if type_compare ty1 Coq_type_bool\n    then dc_conv v2 conv_number v1\n    else if type_compare ty2 Coq_type_bool\n    then dc_conv v1 conv_number v2\n    else if ((type_compare ty1 Coq_type_string) || (type_compare ty1 Coq_type_number)) && (type_compare ty2 Coq_type_object)\n    then dc_conv v1 conv_primitive v2\n    else if (type_compare ty1 Coq_type_object) && ((type_compare ty2 Coq_type_string) || (type_compare ty2 Coq_type_number))\n    then dc_conv v2 conv_primitive v1\n    else so false)\n\n(** val convert_twice :\n    (\'a2 resultof -> (state -> \'a1 -> (\'a1 * \'a1) specres) -> (\'a1 * \'a1)\n    specres) -> (state -> value -> \'a2 resultof) -> state -> value -> value\n    -> (\'a1 * \'a1) specres **)\n\nand convert_twice :\n  \'a1 \'a2 . (\'a2 resultof -> (state -> \'a1 -> (\'a1 * \'a1) specres) -> (\'a1 * \'a1) specres) ->\n  (state -> value -> \'a2 resultof) -> state -> value -> value -> (\'a1 * \'a1) specres\n = fun ifv kC s v1 v2 ->\n    ifv (kC s v1) (fun s1 vc1 ->\n        ifv (kC s1 v2) (fun s2 vc2 -> res_spec s2 (vc1, vc2)))\n\n(** val convert_twice_primitive :\n    state -> execution_ctx -> value -> value -> (prim * prim)\n    specres **)\n\nand convert_twice_primitive s c v1 v2 =\n  convert_twice ifx_prim (fun s0 v -> to_primitive s0 v None) s v1 v2\n\n(** val convert_twice_number :\n    state -> execution_ctx -> value -> value ->\n    (number * number) specres **)\n\nand convert_twice_number s c v1 v2 =\n  convert_twice ifx_number (fun s0 v -> to_number s0 v) s v1 v2\n\n(** val convert_twice_string :\n    state -> execution_ctx -> value -> value ->\n    (string * string) specres **)\n\nand convert_twice_string s c v1 v2 =\n  convert_twice ifx_string (fun s0 v -> to_string s0 v) s v1 v2\n\n(** val issome : \'a1 option -> bool **)\n\nand issome : \'a1 . \'a1 option -> bool = fun _foo_ ->\n  match _foo_ with\n  | Some t -> true\n  | None -> false\n\nand run_binary_op_add s c v1 v2 =\n  let%spec (s1, (w1, w2)) = (convert_twice_primitive s c v1 v2) in\n  if  (type_compare (type_of w1) Coq_type_string)\n   || (type_compare (type_of w2) Coq_type_string)\n  then let%spec (s2, (str1, str2)) = (convert_twice_string s1 c w1 w2) in\n    res_out s2 (res_val (Coq_value_string (strappend str1 str2)))\n  else let%spec (s2, (n1, n2)) = (convert_twice_number s1 c w1 w2) in\n    res_out s2 (res_val (Coq_value_number (n1 +. n2)))\n\nand run_binary_op_arith mathop s c v1 v2 =\n  let%spec (s1, nn) = (convert_twice_number s c v1 v2) in\n  let (n1, n2) = nn in\n  res_out s1 (res_val (Coq_value_number (mathop n1 n2)))\n\nand run_binary_op_shift b_unsigned mathop s c v1 v2 =\n  let conv = (if b_unsigned then to_uint32 else to_int32) in\n  let%spec (s1, k1) = (conv s c v1) in\n  let%spec (s2, k2) = (to_uint32 s1 c v2) in\n  let k2_2 = JsNumber.modulo_32 k2 in\n  res_ter s2 (res_val (Coq_value_number (mathop k1 k2_2)))\n\nand run_binary_op_bitwise mathop s c v1 v2 =\n  let%spec (s1, k1) = (to_int32 s c v1) in\n  let%spec (s2, k2) = (to_int32 s1 c v2) in\n  res_ter s2 (res_val (Coq_value_number (mathop k1 k2)))\n\n(** TODO: ES6ify\n    @essec 7.2.12 *)\nand run_binary_op_compare b_swap b_neg s c v1 v2 =\n  let%spec (s1, ww) = convert_twice_primitive s c v1 v2 in\n  let (w1, w2) = ww in\n  let p = if b_swap then (w2, w1) else (w1, w2) in\n  let (wa, wb) = p in\n  let%ret s, wr =\n    if (type_of wa === Coq_type_string) && (type_of wb === Coq_type_string) then\n      Continue (s, Coq_value_bool (inequality_test_string (string_of_value wb) (string_of_value wb)))\n    else\n      let%number_ret s, nx = to_number s1 wa in\n      let%number_ret s, ny = to_number s wb in\n      Continue (s, inequality_test_number nx ny)\n  in\n  if value_compare wr Coq_value_undef then res_out s1 (res_val (Coq_value_bool false))\n  else if (b_neg) && (value_compare wr (Coq_value_bool true))\n  then res_out s1 (res_val (Coq_value_bool false))\n  else if (b_neg) && (value_compare wr (Coq_value_bool false))\n  then res_out s1 (res_val (Coq_value_bool true))\n  else res_out s1 (res_val wr)\n\nand run_binary_op_instanceof s c v1 v2 =\n  match v2 with\n  | Coq_value_object l ->\n    let%some b = (run_object_method object_has_instance_ s l) in\n    (match b with\n    | None -> run_error s c Coq_native_error_type\n    | Some has_instance_id -> run_object_has_instance s c has_instance_id l v1)\n  | _ -> run_error s c Coq_native_error_type\n\nand run_binary_op_in s c v1 v2 =\n  match v2 with\n  | Coq_value_object l ->\n    let%string (s2, x) = (to_string s v1) in\n    object_has_prop s2 c l x\n  | _ -> run_error s c Coq_native_error_type\n\n(** val run_binary_op :\n    state -> execution_ctx -> binary_op -> value -> value ->\n    result **)\n\nand run_binary_op s c op v1 v2 =\n  match op with\n  | Coq_binary_op_mult -> run_binary_op_arith (fun x y -> x *. y) s c v1 v2\n  | Coq_binary_op_div -> run_binary_op_arith (fun x y -> x /. y) s c v1 v2\n  | Coq_binary_op_mod -> run_binary_op_arith (fun x y -> JsNumber.fmod x y) s c v1 v2\n  | Coq_binary_op_sub -> run_binary_op_arith (fun x y -> x -. y) s c v1 v2\n  | Coq_binary_op_lt -> run_binary_op_compare false false s c v1 v2\n  | Coq_binary_op_gt -> run_binary_op_compare true false s c v1 v2\n  | Coq_binary_op_le -> run_binary_op_compare true true s c v1 v2\n  | Coq_binary_op_ge -> run_binary_op_compare false true s c v1 v2\n  | Coq_binary_op_left_shift -> run_binary_op_shift false JsNumber.int32_left_shift s c v1 v2\n  | Coq_binary_op_right_shift -> run_binary_op_shift false JsNumber.int32_right_shift s c v1 v2\n  | Coq_binary_op_unsigned_right_shift -> run_binary_op_shift true JsNumber.uint32_right_shift s c v1 v2\n  | Coq_binary_op_bitwise_and -> run_binary_op_bitwise JsNumber.int32_bitwise_and s c v1 v2\n  | Coq_binary_op_bitwise_or  -> run_binary_op_bitwise JsNumber.int32_bitwise_or s c v1 v2\n  | Coq_binary_op_bitwise_xor -> run_binary_op_bitwise JsNumber.int32_bitwise_xor s c v1 v2\n  | Coq_binary_op_add -> run_binary_op_add s c v1 v2\n  | Coq_binary_op_instanceof -> run_binary_op_instanceof s c v1 v2\n  | Coq_binary_op_in -> run_binary_op_in s c v1 v2\n  | Coq_binary_op_equal -> run_equal s c v1 v2\n  | Coq_binary_op_disequal ->\n    let%bool (s0, b0) = (run_equal s c v1 v2) in\n    res_ter s0 (res_val (Coq_value_bool (not b0)))\n  | Coq_binary_op_strict_equal ->\n    res_out s (res_val (Coq_value_bool (strict_equality_test v1 v2)))\n  | Coq_binary_op_strict_disequal ->\n    res_out s (res_val (Coq_value_bool (not (strict_equality_test v1 v2))))\n  | Coq_binary_op_coma -> res_out s (res_val v2)\n  | Coq_binary_op_and -> Coq_result_impossible\n  | Coq_binary_op_or  -> Coq_result_impossible\n\n(** val run_prepost_op : unary_op -> ((number -> number) * bool) option **)\n\nand run_prepost_op _foo_ = match _foo_ with\n  | Coq_unary_op_delete -> None\n  | Coq_unary_op_void -> None\n  | Coq_unary_op_typeof -> None\n  | Coq_unary_op_post_incr -> Some (add_one, false)\n  | Coq_unary_op_post_decr -> Some (sub_one, false)\n  | Coq_unary_op_pre_incr -> Some (add_one, true)\n  | Coq_unary_op_pre_decr -> Some (sub_one, true)\n  | Coq_unary_op_add -> None\n  | Coq_unary_op_neg -> None\n  | Coq_unary_op_bitwise_not -> None\n  | Coq_unary_op_not -> None\n\n(** val run_typeof_value : state -> value -> string **)\n\nand run_typeof_value s _foo_ =\n  match _foo_ with\n  | Coq_value_object l ->\n    if is_callable_dec s (Coq_value_object l)\n    then "function"\n    else "object"\n  | _ -> typeof_prim _foo_\n\n(** val run_unary_op :\n    state -> execution_ctx -> unary_op -> expr -> result **)\n\nand run_unary_op s c op e =\n  if prepost_unary_op_dec op\n  then\n    let%success (s1, rv1)= run_expr s c e in\n    let%spec (s2, v2) = ref_get_value s1 c rv1 in\n    let%number (s3, n1) = to_number s2 v2 in\n    let%some po = run_prepost_op op in\n    let (number_op, is_pre) = po in\n    let n2 = number_op n1 in\n    let v = Coq_value_number (if is_pre then n2 else n1) in\n    let%void s4 = ref_put_value s3 c rv1 (Coq_value_number n2) in\n    res_out s4 (res_val v)\n  else (match op with\n      | Coq_unary_op_delete ->\n        let%success (s0, rv)= (run_expr s c e) in begin\n            match rv with\n            | Coq_resvalue_empty ->\n              res_ter s0 (res_val (Coq_value_bool true))\n            | Coq_resvalue_value v ->\n              res_ter s0 (res_val (Coq_value_bool true))\n            | Coq_resvalue_ref r ->\n              if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_undef\n              then if r.ref_strict\n                then run_error s0 c Coq_native_error_syntax\n                else res_ter s0\n                    (res_val (Coq_value_bool true))\n              else (match r.ref_base with\n                  | Coq_ref_base_type_value v ->\n                    let%object (s1, l) = (to_object s0 v) in\n                        object_delete s1 c l r.ref_name\n                          r.ref_strict\n                  | Coq_ref_base_type_env_loc l ->\n                    if r.ref_strict\n                    then run_error s0 c Coq_native_error_syntax\n                    else env_record_delete_binding s0 c l r.ref_name)\n        end\n      | Coq_unary_op_typeof ->\n        let%success (s1, rv)= (run_expr s c e) in begin\n            match rv with\n            | Coq_resvalue_empty ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s1\n                ("Empty result for a `typeof\\\' in [run_unary_op].")\n            | Coq_resvalue_value v ->\n              res_ter s1\n                (res_val (Coq_value_string (run_typeof_value s1 v)))\n            | Coq_resvalue_ref r ->\n              if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_undef\n              then res_ter s1\n                  (res_val (Coq_value_string ("undefined")))\n              else let%spec\n                  (s2, v) = (ref_get_value s1 c (Coq_resvalue_ref r)) in\n                     res_ter s2\n                       (res_val (Coq_value_string (run_typeof_value s2 v)))\n        end\n      | _ ->\n        let%spec (s1, v) = (run_expr_get_value s c e) in\n            match op with\n            | Coq_unary_op_void ->\n              res_ter s1 (res_val Coq_value_undef)\n            | Coq_unary_op_add -> to_number s1 v\n            | Coq_unary_op_neg ->\n              let%number (s2, n) = (to_number s1 v) in\n                  res_ter s2\n                    (res_val (Coq_value_number (JsNumber.neg n)))\n            | Coq_unary_op_bitwise_not ->\n              let%spec (s2, k) = (to_int32 s1 c v) in\n                  res_ter s2\n                    (res_val (Coq_value_number (JsNumber.int32_bitwise_not k)))\n            | Coq_unary_op_not ->\n              res_ter s1\n                (res_val (Coq_value_bool (not (to_boolean v))))\n            | _ ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s1\n                ("Undealt regular operator in [run_unary_op]."))\n\n(** val create_new_function_in :\n    state -> execution_ctx -> string list -> funcbody ->\n    result **)\n\nand create_new_function_in s c args bd =\n  creating_function_object s c args bd c.execution_ctx_lexical_env\n    c.execution_ctx_strict\n\n(** val init_object :\n    state -> execution_ctx -> object_loc -> propdefs -> result **)\n\nand init_object s c l _foo_ = match _foo_ with\n  | [] -> res_out s (res_val (Coq_value_object l))\n  | p :: pds_2 ->\n    let (pn, pb) = p in\n    let  x = (string_of_propname pn) in\n        let  follows = (fun s1 desc ->\n            let%success\n              (s2, rv) = (object_define_own_prop s1 c l x desc false) in  init_object s2 c l pds_2) in\n            match pb with\n            | Coq_propbody_val e0 ->\n              let%spec (s1, v0) = (run_expr_get_value s c e0) in\n                  let desc = { descriptor_value = (Some v0); descriptor_writable =\n                                                               (Some true); descriptor_get = None; descriptor_set = None;\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n            | Coq_propbody_get bd ->\n              let%value (s1, v0) = (create_new_function_in s c [] bd) in\n                  let desc = { descriptor_value = None; descriptor_writable = None;\n                               descriptor_get = (Some v0); descriptor_set = None;\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n            | Coq_propbody_set (args, bd) ->\n              let%value (s1, v0) = (create_new_function_in s c args bd) in\n                  let desc = { descriptor_value = None; descriptor_writable = None;\n                               descriptor_get = None; descriptor_set = (Some v0);\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n\n(** val run_array_element_list :\n    state -> execution_ctx -> object_loc -> expr option list ->\n    float -> result **)\n\nand run_array_element_list s c l oes n =\n  match oes with\n  | [] -> res_out s (res_val (Coq_value_object l))\n  | o :: oes_2 ->\n    (match o with\n     | Some e ->\n       let\n         loop_result = (fun s0 ->\n           run_array_element_list s0 c l oes_2 0.) in\n            let%spec (s0, v) = (run_expr_get_value s c e) in\n                let%value\n                   (s1, vlen) = (run_object_get s0 c l\n                     ("length")) in\n                      let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n                          let%string\n                             (s3, slen) = (to_string s2 (Coq_value_number (ilen +. n))) in\n                                let  desc = ({ attributes_data_value = v;\n                                              attributes_data_writable = true;\n                                              attributes_data_enumerable = true;\n                                              attributes_data_configurable = true }) in\n                                    let%bool\n                                       (s4, x) = (object_define_own_prop s3 c l slen\n                                         (descriptor_of_attributes (Coq_attributes_data_of\n                                                                      desc)) false) in\n                                          let%object (s5, l0) = (loop_result s4) in\n                                              res_ter s5 (res_val (Coq_value_object l0))\n     | None ->\n       let  firstIndex = (elision_head_count (None :: oes_2)) in\n           run_array_element_list s c l\n             (elision_head_remove (None :: oes_2)) (number_of_int firstIndex))\n\n(** val init_array :\n    state -> execution_ctx -> object_loc -> expr option list ->\n    result **)\n\nand init_array s c l oes =\n  let elementList = (elision_tail_remove oes) in\n  let elisionLength = (elision_tail_count oes) in\n  let%object (s0, l0) = (run_array_element_list s c l elementList 0.) in\n  let%value (s1, vlen) = (run_object_get s0 c l0 ("length")) in\n  let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n  let%spec (s3, len) = (to_uint32 s2 c (Coq_value_number (ilen +. number_of_int elisionLength))) in\n  let%not_throw (s4, x) = (object_put s3 c l0 ("length") (Coq_value_number len) throw_false) in\n  res_out s4 (res_val (Coq_value_object l0))\n\n(** val run_var_decl_item :\n    state -> execution_ctx -> prop_name -> expr option -> result **)\n\nand run_var_decl_item s c x _foo_ = match _foo_ with\n  | Some e ->\n    let%spec (s1, ir) = (identifier_resolution s c x) in\n    let%spec (s2, v) = (run_expr_get_value s1 c e) in\n    let%void s3 = (ref_put_value s2 c (Coq_resvalue_ref ir) v) in\n    res_out s3 (res_val (Coq_value_string x))\n  | None ->\n    res_out s (res_val (Coq_value_string x))\n\n(** val run_var_decl :\n    state -> execution_ctx -> (prop_name * expr option) list ->\n    result **)\n\nand run_var_decl s c _foo_ = match _foo_ with\n  | [] -> res_out s res_empty\n  | y :: xeos_2 ->\n    let (x, eo) = y in\n    let%value (s1, vname) = (run_var_decl_item s c x eo) in\n        run_var_decl s1 c xeos_2\n\n(** val run_list_expr :\n    state -> execution_ctx -> value list -> expr list -> value\n    list specres **)\n\nand run_list_expr s1 c vs _foo_ = match _foo_ with\n  | [] -> res_spec s1 (rev vs)\n  | e :: es_2 ->\n    let%spec (s2, v) = (run_expr_get_value s1 c e) in\n        run_list_expr s2 c (v :: vs) es_2\n\n(** val run_block :\n    state -> execution_ctx -> stat list -> result **)\n\nand run_block s c _foo_ = match _foo_ with\n  | [] -> res_ter s (res_normal Coq_resvalue_empty)\n  | t :: ts_rev_2 ->\n    let%success (s0, rv0)= (run_block s c ts_rev_2) in\n      ifx_success_state rv0 (run_stat s0 c t) (fun x x0 -> res_out x (res_normal x0))\n\nand run_binary_op_and s c e1 e2 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n  let b1 = (to_boolean v1) in\n  if not b1\n    then res_ter s1 (res_val v1)\n    else let%spec (s2, v) = (run_expr_get_value s1 c e2) in\n    res_ter s2 (res_val v)\n\nand run_binary_op_or s c e1 e2 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n  let b1 = (to_boolean v1) in\n  if b1\n    then res_ter s1 (res_val v1)\n    else let%spec (s2, v) = (run_expr_get_value s1 c e2) in\n    res_ter s2 (res_val v)\n\n(** val run_expr_binary_op :\n    state -> execution_ctx -> binary_op -> expr -> expr ->\n    result **)\n\nand run_expr_binary_op s c op e1 e2 =\n  match op with\n  | Coq_binary_op_and -> run_binary_op_and s c e1 e2\n  | Coq_binary_op_or -> run_binary_op_or s c e1 e2\n  | _ ->\n    let%spec (s1,v1) = run_expr_get_value s c e1 in\n    let%spec (s2,v2) = run_expr_get_value s1 c e2 in\n    run_binary_op s2 c op v1 v2\n\n(** val run_expr_access :\n    state -> execution_ctx -> expr -> expr -> result **)\n\n(* TODO DEPRECATEd\n   and run_expr_access s c e1 e2 =\n   let%spec (s1, v1) = (run_expr_get_value s c e1) in\n    let%spec (s2, v2) = (run_expr_get_value s1 c e2) in\n      if or_decidable (value_compare v1 Coq_value_undef)\n           (value_compare v1 Coq_value_null)\n      then run_error s2 Coq_native_error_type\n      else let%string (s3, x) = (to_string s2 c v2) in\n             res_ter s3\n               (res_ref (ref_create_value v1 x c.execution_ctx_strict))\n*)\n\nand run_expr_access s c e1 e2 =\n  let%spec (s1,v1) = run_expr_get_value s c e1 in\n  let%spec (s2,v2) = run_expr_get_value s1 c e2 in\n  if    (value_compare v1 Coq_value_undef)\n     || (value_compare v1 Coq_value_null)\n  then run_error s2 c Coq_native_error_type\n  else let%string (s3,x) = to_string s2 v2 in\n    res_ter s3 (res_ref (ref_create_value v1 x c.execution_ctx_strict))\n\n(** val run_expr_assign :\n    state -> execution_ctx -> binary_op option -> expr -> expr\n    -> result **)\n\nand run_expr_assign s c opo e1 e2 =\n  let%success (s1, rv1)= (run_expr s c e1) in\n  let follow = (fun s0 rv_2 ->\n    match rv_2 with\n    | Coq_resvalue_value v ->\n      let%void s_2= (ref_put_value s0 c rv1 v) in\n      res_out s_2 (res_val v)\n    | Coq_resvalue_empty ->\n      Debug.impossible_with_heap_because __LOC__ s0 "Non-value result in [run_expr_assign]."; Coq_result_impossible\n    | Coq_resvalue_ref r ->\n      Debug.impossible_with_heap_because __LOC__ s "Non-value result in [run_expr_assign]."; Coq_result_impossible\n    ) in\n  match opo with\n  | Some op ->\n    let%spec (s2, v1) = (ref_get_value s1 c rv1) in\n    let%spec (s3, v2) = (run_expr_get_value s2 c e2) in\n    let%success (s4, v) = (run_binary_op s3 c op v1 v2) in\n    follow s4 v\n  | None ->\n    let%spec (x, x0 )= (run_expr_get_value s1 c e2) in\n    follow x (Coq_resvalue_value x0)\n\n(** val run_expr_function :\n    state -> execution_ctx -> prop_name option -> string list\n    -> funcbody -> result **)\n\nand run_expr_function s c fo args bd =\n  match fo with\n  | Some fn ->\n    let p = (lexical_env_alloc_decl s c.execution_ctx_lexical_env) in\n    let (lex_2, s_2) = p in\n    let follow = fun l ->\n      let%some e = (env_record_binds_option s_2 l) in\n      let%void s1 = (env_record_create_immutable_binding s_2 l fn) in\n      let%object (s2, l0) = (creating_function_object s1 c args bd lex_2 (funcbody_is_strict bd)) in\n      let%void s3 = (env_record_initialize_immutable_binding s2 l fn (Coq_value_object l0)) in\n      res_out s3 (res_val (Coq_value_object l0))\n    in destr_list lex_2\n      (fun x -> Debug.impossible_with_heap_because __LOC__ s "Empty lexical environnment allocated in [run_expr_function]."; Coq_result_impossible)\n      (fun l x -> follow l) ()\n  | None ->\n    let lex = c.execution_ctx_lexical_env in\n    creating_function_object s c args bd lex (funcbody_is_strict bd)\n\n(** val entering_eval_code :\n    state -> execution_ctx -> bool -> funcbody -> (state ->\n    execution_ctx -> result) -> result **)\n\nand entering_eval_code s c direct bd k =\n  let str = ((funcbody_is_strict bd) || (direct && c.execution_ctx_strict)) in\n       let c_2 = (if direct then c else execution_ctx_initial str) in\n           let p = (if str\n              then lexical_env_alloc_decl s c_2.execution_ctx_lexical_env\n              else (c_2.execution_ctx_lexical_env, s)) in\n                 let (lex, s_2) = p in\n                 let c1 = (if str then execution_ctx_with_lex_same c_2 lex else c_2) in\n                      let p0 = (funcbody_prog bd) in\n                          let%void\n                             s1 = (execution_ctx_binding_inst s_2 c1 Coq_codetype_eval None\n                               p0 []) in  k s1 c1\n\n(** val run_eval :\n    state -> execution_ctx -> bool -> value list -> result **)\n\nand run_eval s c is_direct_call vs =\n  match get_arg 0 vs with\n  | Coq_value_undef ->\n    res_out s (res_val Coq_value_undef)\n  | Coq_value_null ->\n    res_out s (res_val Coq_value_null)\n  | Coq_value_bool b ->\n    res_out s (res_val (Coq_value_bool b))\n  | Coq_value_number n ->\n    res_out s (res_val (Coq_value_number n))\n  | Coq_value_string s0 ->\n    let str = (is_direct_call && c.execution_ctx_strict) in\n    (match parse_pickable s0 str with\n    | Some p0 ->\n       entering_eval_code s c is_direct_call (Coq_funcbody_intro (p0, s0))\n         (fun s1 c_2 ->\n           let%ter (s2, r) = (run_prog s1 c_2 p0) in\n           match r.res_type with\n           | Coq_restype_normal ->\n             ifx_empty_label s2 r (fun x ->\n               match r.res_value with\n               | Coq_resvalue_empty -> res_ter s2 (res_val Coq_value_undef)\n               | Coq_resvalue_value v -> res_ter s2 (res_val v)\n               | Coq_resvalue_ref r0 -> (Debug.impossible_with_heap_because __LOC__ s2\n                   "Reference found in the result of an `eval\\\' in [run_eval]."; Coq_result_impossible))\n           | Coq_restype_throw -> res_ter s2 (res_throw r.res_value)\n           | _ -> (Debug.impossible_with_heap_because __LOC__ s2\n               "Forbidden result type returned by an `eval\\\' in [run_eval]."; Coq_result_impossible))\n    | None -> run_error s c Coq_native_error_syntax)\n  | Coq_value_object o ->\n    res_out s (res_val (Coq_value_object o))\n\n(** val run_expr_call :\n    state -> execution_ctx -> expr -> expr list -> result **)\n\nand run_expr_call s c e1 e2s =\n  let is_eval_direct = (is_syntactic_eval e1) in\n  let%success (s1, rv)= (run_expr s c e1) in\n  let%spec (s2, f) = (ref_get_value s1 c rv) in\n  let%spec (s3, vs) = (run_list_expr s2 c [] e2s) in\n  match f with\n  | Coq_value_object l ->\n    if is_callable_dec s3 (Coq_value_object l)\n    then let  follow = (fun vthis ->\n        if object_loc_compare l (Coq_object_loc_prealloc\n                                      Coq_prealloc_global_eval)\n        then run_eval s3 c is_eval_direct vs\n        else run_call s3 c l vthis vs) in\n        match rv with\n        | Coq_resvalue_empty ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s3\n            ("[run_expr_call] unable to call an  empty result.")\n        | Coq_resvalue_value v ->\n          follow Coq_value_undef\n        | Coq_resvalue_ref r ->\n          (match r.ref_base with\n           | Coq_ref_base_type_value v ->\n             if   (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base)\n               || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_null)\n               || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_object)\n             then follow v\n             else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                 s3\n                 ("[run_expr_call] unable to call a non-property function.")\n           | Coq_ref_base_type_env_loc l0 ->\n             let%some v = (env_record_implicit_this_value s3 l0) in  follow v)\n    else run_error s3 c Coq_native_error_type\n  | _ -> run_error s3 c Coq_native_error_type\n\n(** val run_expr_conditionnal :\n    state -> execution_ctx -> expr -> expr -> expr -> result **)\n\nand run_expr_conditionnal s c e1 e2 e3 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n      let  b = (to_boolean v1) in\n          let  e = (if b then e2 else e3) in\n              let%spec (s0, r) = (run_expr_get_value s1 c e) in\n                  res_ter s0 (res_val r)\n\n(** val run_expr_new :\n    state -> execution_ctx -> expr -> expr list -> result **)\n\nand run_expr_new s c e1 e2s =\n  let%spec (s1, v) = (run_expr_get_value s c e1) in\n  let%spec (s2, args) = (run_list_expr s1 c [] e2s) in\n  match v with\n  | Coq_value_object l ->\n    let%some coo = (run_object_method object_construct_ s2 l) in\n    (match coo with\n    | Some co -> run_construct s2 c co l args\n    | None -> run_error s2 c Coq_native_error_type)\n  | _ -> run_error s2 c Coq_native_error_type\n\n(** val run_stat_label :\n    state -> execution_ctx -> label -> stat -> result **)\n\nand run_stat_label s c lab t =\n  let%break (s1, r1) = run_stat s c t in\n  res_out s1 (if label_compare r1.res_label lab then res_normal r1.res_value else r1)\n\n(** val run_stat_with :\n    state -> execution_ctx -> expr -> stat -> result **)\n\nand run_stat_with s c e1 t2 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n      let%object (s2, l) = (to_object s1 v1) in\n          let  lex = (c.execution_ctx_lexical_env) in\n              let\n                p = (lexical_env_alloc_object s2 lex l provide_this_true) in\n                   let (lex_2, s3) = p in\n                   let  c_2 = (execution_ctx_with_lex c lex_2) in\n                       run_stat s3 c_2 t2\n\n(** val run_stat_if :\n    state -> execution_ctx -> expr -> stat -> stat option ->\n    result **)\n\nand run_stat_if s c e1 t2 to0 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n  let b = (to_boolean v1) in\n  if b\n  then run_stat s1 c t2\n  else (match to0 with\n    | Some t3 -> run_stat s1 c t3\n    | None -> res_out s1 (res_normal Coq_resvalue_empty))\n\n(** val run_stat_while :\n    state -> execution_ctx -> resvalue -> label_set -> expr ->\n    stat -> result **)\n\nand run_stat_while s c rv labs e1 t2 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n      let  b = (to_boolean v1) in\n          if b\n          then let%ter (s2, r) = (run_stat s1 c t2) in\n              let\n                 rv_2 = (if not\n                    (resvalue_compare r.res_value Coq_resvalue_empty)\n                 then r.res_value\n                 else rv) in\n                    let  loop = (fun x ->\n                        run_stat_while s2 c rv_2 labs e1 t2) in\n                        if  (not (restype_compare r.res_type Coq_restype_continue))\n                         || (not (res_label_in r labs))\n                        then if\n                             (restype_compare r.res_type Coq_restype_break)\n                           && (res_label_in r labs)\n                          then res_ter s2 (res_normal rv_2)\n                          else if not\n                              (restype_compare r.res_type\n                                 Coq_restype_normal)\n                          then res_ter s2 r\n                          else loop ()\n                        else loop ()\n          else res_ter s1 (res_normal rv)\n\n(** val run_stat_switch_end :\n    state -> execution_ctx -> resvalue -> switchclause list ->\n    result **)\n\nand run_stat_switch_end s c rv _foo_ = match _foo_ with\n  | [] -> res_out s (res_normal rv)\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      ifx_success_state rv (run_block s c (rev ts)) (fun s1 rv1 ->\n          run_stat_switch_end s1 c rv1 scs_2)\n\n(** val run_stat_switch_no_default :\n    state -> execution_ctx -> value -> resvalue -> switchclause\n    list -> result **)\n\nand run_stat_switch_no_default s c vi rv _foo_ = match _foo_ with\n  | [] -> res_out s (res_normal rv)\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let%spec (s1, v1) = (run_expr_get_value s c e) in\n          let  b = (strict_equality_test v1 vi) in\n              if b\n              then let%success (s2, rv2)= (run_block s1 c (rev ts)) in\n                  run_stat_switch_end s2 c rv2 scs_2\n              else run_stat_switch_no_default s1 c vi rv scs_2\n\n(** val run_stat_switch_with_default_default :\n    state -> execution_ctx -> stat list -> switchclause list ->\n    result **)\n\nand run_stat_switch_with_default_default s c ts scs =\n  let%success (s1, rv)= (run_block s c (rev ts)) in\n      run_stat_switch_end s1 c rv scs\n\n(** val run_stat_switch_with_default_B :\n    state -> execution_ctx -> value -> resvalue -> stat list ->\n    switchclause list -> result **)\n\nand run_stat_switch_with_default_B s c vi rv ts0 scs = match scs with\n  | [] -> run_stat_switch_with_default_default s c ts0 scs\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let%spec (s1, v1) = (run_expr_get_value s c e) in\n          let  b = (strict_equality_test v1 vi) in\n              if b\n              then let%success (s2, rv2)= (run_block s1 c (rev ts)) in\n                  run_stat_switch_end s2 c rv2 scs_2\n              else run_stat_switch_with_default_B s1 c vi rv ts0 scs_2\n\n(** val run_stat_switch_with_default_A :\n    state -> execution_ctx -> bool -> value -> resvalue ->\n    switchclause list -> stat list -> switchclause list -> result **)\n\nand run_stat_switch_with_default_A s c found vi rv scs1 ts0 scs2 =\n  match scs1 with\n  | [] ->\n    if found\n    then run_stat_switch_with_default_default s c ts0 scs2\n    else run_stat_switch_with_default_B s c vi rv ts0 scs2\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let\n        follow = (fun s0 ->\n          ifx_success_state rv (run_block s0 c (rev ts)) (fun s1 rv0 ->\n              run_stat_switch_with_default_A s1 c true vi rv0 scs_2 ts0 scs2)) in\n           if found\n           then follow s\n           else let%spec (s1, v1) = (run_expr_get_value s c e) in\n               let  b = (strict_equality_test v1 vi) in\n                   if b\n                   then follow s1\n                   else run_stat_switch_with_default_A s1 c false vi rv\n                       scs_2 ts0 scs2\n\n(** val run_stat_switch :\n    state -> execution_ctx -> label_set -> expr -> switchbody ->\n    result **)\n\n(* ALTERNATIVE VERSION, WITH LESS FACTORIZATION\nand run_stat_switch s c labs e sb =\n  let%spec (s1, vi) = run_expr_get_value s c e in\n  match sb with\n  | Coq_switchbody_nodefault scs ->\n    let%success (s0, r) = begin\n      let%break (s2, r) =\n        run_stat_switch_no_default s1 c vi\n        Coq_resvalue_empty scs in\n      if res_label_in r labs\n      then res_out s2 (res_normal r.res_value)\n      else res_out s2 r\n      end in\n    res_ter s0 (res_normal r)\n  | Coq_switchbody_withdefault (scs1, ts, scs2) ->\n    let%success (s0, r) = begin\n      let%break (s2, r) =\n        run_stat_switch_with_default_A s1 c false vi\n         Coq_resvalue_empty scs1 ts scs2 in\n      if res_label_in r labs\n      then res_out s2 (res_normal r.res_value)\n      else res_out s2 r end in\n    res_ter s0 (res_normal r)\n*)\n\nand run_stat_switch s c labs e sb =\n  let%spec (s1, vi) = run_expr_get_value s c e in\n  let  follow = (fun w ->\n    let%success (s0, r) =\n      let%break (s2, r) = w in\n      if res_label_in r labs\n      then res_out s2 (res_normal r.res_value)\n      else res_out s2 r in\n    res_ter s0 (res_normal r)) in\n  match sb with\n  | Coq_switchbody_nodefault scs ->\n    follow (run_stat_switch_no_default s1 c vi\n              Coq_resvalue_empty scs)\n  | Coq_switchbody_withdefault (scs1, ts, scs2) ->\n    follow (run_stat_switch_with_default_A s1 c false vi\n              Coq_resvalue_empty scs1 ts scs2)\n\n(** val run_stat_do_while :\n    state -> execution_ctx -> resvalue -> label_set -> expr ->\n    stat -> result **)\n\nand run_stat_do_while s c rv labs e1 t2 =\n  let%ter (s1, r) = (run_stat s c t2) in\n      let\n         rv_2 = (if resvalue_compare r.res_value Coq_resvalue_empty\n         then rv\n         else r.res_value) in\n            let  loop = (fun x ->\n                let%spec (s2, v1) = (run_expr_get_value s1 c e1) in\n                    let  b = (to_boolean v1) in\n                        if b\n                        then run_stat_do_while s2 c rv_2 labs e1 t2\n                        else res_ter s2 (res_normal rv_2)) in\n                if  (restype_compare r.res_type Coq_restype_continue)\n                   && (res_label_in r labs)\n                then loop ()\n                else if\n                    (restype_compare r.res_type Coq_restype_break)\n                 && (res_label_in r labs)\n                then res_ter s1 (res_normal rv_2)\n                else if not\n                    (restype_compare r.res_type Coq_restype_normal)\n                then res_ter s1 r\n                else loop ()\n\n(** val run_stat_try :\n    state -> execution_ctx -> stat -> (prop_name * stat) option\n    -> stat option -> result **)\n\nand run_stat_try s c t1 t2o t3o =\n  let  finallycont = (fun s1 r ->\n      match t3o with\n      | Some t3 ->\n        let%success (s2, rv_2) = (run_stat s1 c t3) in  res_ter s2 r\n      | None -> res_ter s1 r) in\n      ifx_any_or_throw (run_stat s c t1) finallycont (fun s1 v ->\n          match t2o with\n          | Some y ->\n            let (x, t2) = y in\n            let  lex = (c.execution_ctx_lexical_env) in\n                let  p = (lexical_env_alloc_decl s1 lex) in\n                    let (lex_2, s_2) = p in\n                    (match lex_2 with\n                     | [] ->\n                       (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                         s_2\n                         ("Empty lexical environnment in [run_stat_try].")\n                     | l :: oldlex ->\n                       let%void\n                          s2= (env_record_create_set_mutable_binding s_2 c l x None v\n                            throw_irrelevant) in\n                             let c_2 = execution_ctx_with_lex c lex_2 in\n                             let%ter (s3, r) = (run_stat s2 c_2 t2) in finallycont s3 r)\n          | None -> finallycont s1 (res_throw (Coq_resvalue_value v)))\n\n(** val run_stat_throw :\n    state -> execution_ctx -> expr -> result **)\n\nand run_stat_throw s c e =\n  let%spec (s1, v1) = (run_expr_get_value s c e) in\n      res_ter s1 (res_throw (Coq_resvalue_value v1))\n\n(** val run_stat_return :\n    state -> execution_ctx -> expr option -> result **)\n\nand run_stat_return s c _foo_ = match _foo_ with\n  | Some e ->\n      let%spec (s1, v1) = (run_expr_get_value s c e) in\n      res_ter s1 (res_return (Coq_resvalue_value v1))\n  | None ->\n      res_out s (res_return (Coq_resvalue_value Coq_value_undef))\n\n(** val run_stat_for_loop :\n    state -> execution_ctx -> label_set -> resvalue -> expr\n    option -> expr option -> stat -> result **)\n\nand run_stat_for_loop s c labs rv eo2 eo3 t =\n  let  follows = (fun s0 ->\n      let%ter (s1, r) = (run_stat s0 c t) in\n          let\n             rv_2 = (if not\n                (resvalue_compare r.res_value Coq_resvalue_empty)\n             then r.res_value\n             else rv) in\n                let  loop = (fun s2 ->\n                    run_stat_for_loop s2 c labs rv_2 eo2 eo3 t) in\n                    if   (restype_compare r.res_type Coq_restype_break)\n                      && (res_label_in r labs)\n                    then res_ter s1 (res_normal rv_2)\n                    else if\n                         (restype_compare r.res_type Coq_restype_normal)\n                      || (    (restype_compare r.res_type Coq_restype_continue)\n                           && (res_label_in r labs))\n                    then (match eo3 with\n                        | Some e3 ->\n                          let%spec\n                            (s2, v3) = (run_expr_get_value s1 c e3) in loop s2\n                        | None -> loop s1)\n                    else res_ter s1 r) in\n      match eo2 with\n      | Some e2 ->\n        let%spec (s0, v2) = (run_expr_get_value s c e2) in\n            let  b = (to_boolean v2) in\n                if b then follows s0 else res_ter s0 (res_normal rv)\n      | None -> follows s\n\n(** val run_stat_for :\n    state -> execution_ctx -> label_set -> expr option -> expr\n    option -> expr option -> stat -> result **)\n\nand run_stat_for s c labs eo1 eo2 eo3 t =\n  let follows = fun s0 ->\n    run_stat_for_loop s0 c labs Coq_resvalue_empty eo2 eo3 t\n  in\n  (match eo1 with\n   | Some e1 ->\n     let%spec (s0, v1) = (run_expr_get_value s c e1) in follows s0\n   | None -> follows s)\n\n(** val run_stat_for_var :\n    state -> execution_ctx -> label_set -> (string * expr\n    option) list -> expr option -> expr option -> stat -> result **)\n\nand run_stat_for_var s c labs ds eo2 eo3 t =\n  let%ter (s0, r) = (run_stat s c (Coq_stat_var_decl ds)) in\n      run_stat_for_loop s0 c labs Coq_resvalue_empty eo2 eo3 t\n\n(** val run_expr : state -> execution_ctx -> expr -> result **)\n\nand run_expr s c _term_ = match _term_ with\n  | Coq_expr_this ->\n    res_out s (res_val c.execution_ctx_this_binding)\n  | Coq_expr_identifier x ->\n    let%spec (s0, r) = (identifier_resolution s c x) in\n    res_ter s0 (res_ref r)\n  | Coq_expr_literal i ->\n    res_out s (res_val (convert_literal_to_prim i))\n  | Coq_expr_object pds ->\n    let%object (s1, l) = run_construct_prealloc s c Coq_prealloc_object [] in\n    init_object s1 c l pds\n  | Coq_expr_array oes ->\n    let%object (s1, l) = run_construct_prealloc s c Coq_prealloc_array [] in\n    init_array s1 c l oes\n  | Coq_expr_function (fo, args, bd) -> run_expr_function s c fo args bd\n  | Coq_expr_access (e1, e2) -> run_expr_access s c e1 e2\n  | Coq_expr_member (e1, f) ->\n    run_expr s c (Coq_expr_access (e1, (Coq_expr_literal\n                                          (Coq_literal_string f))))\n  | Coq_expr_new (e1, e2s) -> run_expr_new s c e1 e2s\n  | Coq_expr_call (e1, e2s) -> run_expr_call s c e1 e2s\n  | Coq_expr_unary_op (op, e0) -> run_unary_op s c op e0\n  | Coq_expr_binary_op (e1, op, e2) -> run_expr_binary_op s c op e1 e2\n  | Coq_expr_conditional (e1, e2, e3) ->\n    run_expr_conditionnal s c e1 e2 e3\n  | Coq_expr_assign (e1, opo, e2) -> run_expr_assign s c opo e1 e2\n\n(** val run_stat : state -> execution_ctx -> stat -> result **)\n\nand run_stat s c _term_ = match _term_ with\n  | Coq_stat_expr e ->\n    let%spec (s0, r) = (run_expr_get_value s c e) in\n        res_ter s0 (res_val r)\n  | Coq_stat_label (lab, t0) ->\n    run_stat_label s c (Coq_label_string lab) t0\n  | Coq_stat_block ts -> run_block s c (rev ts)\n  | Coq_stat_var_decl xeos -> run_var_decl s c xeos\n  | Coq_stat_if (e1, t2, to0) -> run_stat_if s c e1 t2 to0\n  | Coq_stat_do_while (ls, t1, e2) ->\n    run_stat_do_while s c Coq_resvalue_empty ls e2 t1\n  | Coq_stat_while (ls, e1, t2) ->\n    run_stat_while s c Coq_resvalue_empty ls e1 t2\n  | Coq_stat_with (e1, t2) -> run_stat_with s c e1 t2\n  | Coq_stat_throw e -> run_stat_throw s c e\n  | Coq_stat_return eo -> run_stat_return s c eo\n  | Coq_stat_break so -> res_out s (res_break so)\n  | Coq_stat_continue so -> res_out s (res_continue so)\n  | Coq_stat_try (t1, t2o, t3o) -> run_stat_try s c t1 t2o t3o\n  | Coq_stat_for (ls, eo1, eo2, eo3, s0) ->\n    run_stat_for s c ls eo1 eo2 eo3 s0\n  | Coq_stat_for_var (ls, ds, eo2, eo3, s0) ->\n    run_stat_for_var s c ls ds eo2 eo3 s0\n  | Coq_stat_for_in (ls, e1, e2, s0) ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      ("stat_for_in")\n  | Coq_stat_for_in_var (ls, x, e1o, e2, s0) ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      ("stat_for_in_var")\n  | Coq_stat_debugger -> res_out s res_empty\n  | Coq_stat_switch (labs, e, sb) -> run_stat_switch s c labs e sb\n\n(** val run_elements :\n    state -> execution_ctx -> elements -> result **)\n\nand run_elements s c _foo_ = match _foo_ with\n  | [] -> res_out s (res_normal Coq_resvalue_empty)\n  | el :: els_rev_2 ->\n    let%success (s0, rv0)= (run_elements s c els_rev_2) in\n        match el with\n        | Coq_element_stat t ->\n          let%ter (s1, r1) = (run_stat s0 c t) in\n              let r2 = res_overwrite_value_if_empty rv0 r1 in\n              res_out s1 r2\n        | Coq_element_func_decl (name, args, bd) -> res_ter s0 (res_normal rv0)\n\n(** val run_prog : state -> execution_ctx -> prog -> result **)\n\nand run_prog s c _term_ = match _term_ with\n  | Coq_prog_intro (str, els) -> run_elements s c (rev els)\n\n(** val push :\n    state -> execution_ctx -> object_loc -> value list -> float\n    -> result **)\n\nand push s c l args ilen =\n  let vlen = ilen in\n      match args with\n      | [] ->\n        let%not_throw\n           (s0, x) = (object_put s c l ("length")\n             (Coq_value_number vlen) throw_true) in\n              res_out s0 (res_val (Coq_value_number vlen))\n      | v :: vs ->\n        let%string\n          (s0, slen) = (to_string s (Coq_value_number vlen)) in\n             let%not_throw  (s1, x) = (object_put s0 c l slen v throw_true) in\n                 push s1 c l vs (ilen +. 1.)\n\n(** val run_object_is_sealed :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_is_sealed s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some ext = (run_object_method object_extensible_ s l) in\n        res_ter s (res_val (Coq_value_bool (not ext)))\n  | x :: xs_2 ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          if attributes_configurable a\n          then res_ter s0 (res_val (Coq_value_bool false))\n          else run_object_is_sealed s0 c l xs_2\n\n(** val run_object_seal :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_seal s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some s0= (run_object_heap_set_extensible false s l) in\n        res_ter s0 (res_val (Coq_value_object l))\n  | x :: xs_2 ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_seal]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          let a_2 =\n            if attributes_configurable a\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         None; descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = (Some\n                                                                                         false) }\n              in\n              attributes_update a desc\n            else a\n          in\n          let%bool\n             (s1, x0) = (object_define_own_prop s0 c l x (descriptor_of_attributes a_2)\n               true) in run_object_seal s1 c l xs_2\n\n(** val run_object_freeze :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_freeze s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some s0= (run_object_heap_set_extensible false s l) in\n        res_ter s0 (res_val (Coq_value_object l))\n  | x :: xs_2 ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          let a_2 =\n            if (attributes_is_data_dec a) && (attributes_writable a)\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         (Some false); descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = None }\n              in\n              attributes_update a desc\n            else a\n          in\n          let a_3 =\n            if attributes_configurable a_2\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         None; descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = (Some\n                                                                                         false) }\n              in\n              attributes_update a_2 desc\n            else a_2\n          in\n          let%bool\n             (s1, x0) = (object_define_own_prop s0 c l x (descriptor_of_attributes a_3)\n               true) in run_object_freeze s1 c l xs_2\n\n(** val run_object_is_frozen :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_is_frozen s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some ext = (run_object_method object_extensible_ s l) in\n        res_ter s (res_val (Coq_value_bool (not ext)))\n  | x :: xs_2 ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l x) in\n        let  check_configurable = (fun a ->\n            if attributes_configurable a\n            then res_ter s0 (res_val (Coq_value_bool false))\n            else run_object_is_frozen s0 c l xs_2) in\n            match d with\n            | Coq_full_descriptor_undef ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s0\n                ("[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n            | Coq_full_descriptor_some a ->\n              (match a with\n               | Coq_attributes_data_of ad ->\n                 if attributes_writable (Coq_attributes_data_of ad)\n                 then res_ter s0 (res_val (Coq_value_bool false))\n                 else check_configurable (Coq_attributes_data_of ad)\n               | Coq_attributes_accessor_of aa ->\n                 check_configurable (Coq_attributes_accessor_of aa))\n\n(** val run_get_args_for_apply :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    value list specres **)\n\nand run_get_args_for_apply s c l index n =\n  if  index < n\n  then let%string\n       (s0, sindex) = (to_string s (Coq_value_number index)) in\n          let%value (s1, v) = (run_object_get s0 c l sindex) in\n              let\n\n                tail_args = (run_get_args_for_apply s1 c l (index +. 1.) n) in\n                   let%spec (s2, tail) = (tail_args) in res_spec s2 (v :: tail)\n  else res_spec s []\n\n(** val valueToStringForJoin :\n    state -> execution_ctx -> object_loc -> float -> string\n    specres **)\n\nand valueToStringForJoin s c l k =\n  let%string (s0, prop) = (to_string s (Coq_value_number k)) in\n  let%value (s1, v) = (run_object_get s0 c l prop) in\n  match v with\n  | Coq_value_undef -> res_spec s1 ""\n  | Coq_value_null -> res_spec s1 ""\n  | Coq_value_bool b ->\n    let%string (s2, s3) = (to_string s1 v) in res_spec s2 s3\n  | Coq_value_number n ->\n    let%string (s2, s3) = (to_string s1 v) in res_spec s2 s3\n  | Coq_value_string s2 ->\n    let%string (s3, s4) = (to_string s1 v) in res_spec s3 s4\n  | Coq_value_object o ->\n    let%string (s2, s3) = (to_string s1 v) in res_spec s2 s3\n\n(** val run_array_join_elements :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    string -> string -> result **)\n\nand run_array_join_elements s c l k length0 sep sR =\n  if  k < length0\n  then let  ss = (strappend sR sep) in\n      let  sE = (valueToStringForJoin s c l k) in\n          let%spec (s0, element) = (sE) in\n              let  sR0 = (strappend ss element) in\n                  run_array_join_elements s0 c l (k +. 1.)\n                    length0 sep sR0\n  else res_ter s (res_val (Coq_value_string sR))\n\n(** Definitions of prealloc (built-in) functions *)\n(** val run_call_prealloc :\n    state -> execution_ctx -> prealloc -> value -> value list ->\n    result **)\n\nand run_call_prealloc s c b vthis args =\n  match b with\n  | Coq_prealloc_global_is_finite ->\n    let  v = (get_arg 0 args) in\n    let%number (s0, n) = (to_number s v) in\n    res_ter s0 (res_val (Coq_value_bool (not ((JsNumber.isnan n) || (n === JsNumber.infinity) || (n === JsNumber.neg_infinity)))))\n  | Coq_prealloc_global_is_nan ->\n    let  v = (get_arg 0 args) in\n        let%number (s0, n) = (to_number s v) in\n            res_ter s0\n              (res_val (Coq_value_bool (JsNumber.isnan n)))\n  | Coq_prealloc_object ->\n    let  value0 = (get_arg 0 args) in begin\n        match value0 with\n        | Coq_value_undef -> run_construct_prealloc s c b args\n        | Coq_value_null -> run_construct_prealloc s c b args\n        | Coq_value_bool b0 -> to_object s value0\n        | Coq_value_number n -> to_object s value0\n        | Coq_value_string s0 -> to_object s value0\n        | Coq_value_object o -> to_object s value0\n    end\n  | Coq_prealloc_object_get_proto_of ->\n    let  v = (get_arg 0 args) in\n    builtin_object_get_prototype_of s c () vthis () v\n  | Coq_prealloc_object_get_own_prop_descriptor ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%string (s1, x) = (to_string s (get_arg 1 args)) in\n        let%spec (s2, d) = (run_object_get_own_prop s1 c l x) in\n        from_prop_descriptor s2 c d\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_define_prop ->\n    let o = (get_arg 0 args) in\n    let p = (get_arg 1 args) in\n    let attr = (get_arg 2 args) in begin\n      match o with\n      | Coq_value_object l ->\n        let%string (s1, name) = (to_string s p) in\n        let%spec (s2, desc) = (to_property_descriptor s1 attr) in\n        let%bool (s3, x) = (object_define_own_prop s2 c l name desc true) in\n        res_ter s3 (res_val (Coq_value_object l))\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_seal ->\n    let v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some _x_ = (object_properties_keys_as_list_option s l) in\n        run_object_seal s c l _x_\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_freeze ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some _x_ = (object_properties_keys_as_list_option s l) in\n        run_object_freeze s c l _x_\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_prevent_extensions ->\n    let  v = (get_arg 0 args) in\n    builtin_object_prevent_extensions s c () vthis () v\n  | Coq_prealloc_object_is_sealed ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some _x_ = (object_properties_keys_as_list_option s l) in  run_object_is_sealed s c l _x_\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_is_frozen ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some _x_ = (object_properties_keys_as_list_option s l) in  run_object_is_frozen s c l _x_\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_is_extensible ->\n    let  v = (get_arg 0 args) in\n    builtin_object_is_extensible s c () vthis () v\n  | Coq_prealloc_object_proto_to_string ->\n    (match vthis with\n     | Coq_value_undef ->\n       res_out s (res_val (Coq_value_string ("[object Undefined]")))\n     | Coq_value_null ->\n       res_out s (res_val (Coq_value_string ("[object Null]")))\n     | Coq_value_bool b0 ->\n       let%object (s1, l) = (to_object s vthis) in\n       let%some s0= (run_object_method object_class_ s1 l) in\n       res_ter s1 (res_val (Coq_value_string (strappend "[object " (strappend s0 "]"))))\n     | Coq_value_number n ->\n       let%object (s1, l) = (to_object s vthis) in\n       let%some s0= (run_object_method object_class_ s1 l) in\n       res_ter s1 (res_val (Coq_value_string (strappend "[object " (strappend s0 "]"))))\n     | Coq_value_string s0 ->\n       let%object (s1, l) = (to_object s vthis) in\n       let%some s2= (run_object_method object_class_ s1 l) in\n       res_ter s1 (res_val (Coq_value_string (strappend "[object " (strappend s2 "]"))))\n     | Coq_value_object o ->\n       let%object (s1, l) = (to_object s vthis) in\n       let%some s0= (run_object_method object_class_ s1 l) in\n       res_ter s1 (res_val (Coq_value_string (strappend "[object " (strappend s0 "]")))))\n  | Coq_prealloc_object_proto_value_of -> to_object s vthis\n  | Coq_prealloc_object_proto_has_own_prop ->\n    let  v = (get_arg 0 args) in\n        let%string (s1, x) = (to_string s v) in\n            let%object (s2, l) = (to_object s1 vthis) in\n                let%spec (s3, d) = (run_object_get_own_prop s2 c l x) in begin\n                    match d with\n                    | Coq_full_descriptor_undef ->\n                      res_ter s3 (res_val (Coq_value_bool false))\n                    | Coq_full_descriptor_some a ->\n                      res_ter s3 (res_val (Coq_value_bool true))\n    end\n  | Coq_prealloc_object_proto_is_prototype_of ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%object (s1, lo) = (to_object s vthis) in\n        object_proto_is_prototype_of s1 lo l\n      | _ ->\n        res_out s (res_val (Coq_value_bool false))\n    end\n  | Coq_prealloc_object_proto_prop_is_enumerable ->\n    let  v = (get_arg 0 args) in\n    let%string (s1, x) = (to_string s v) in\n    let%object (s2, l) = (to_object s1 vthis) in\n    let%spec (s3, d) = (run_object_get_own_prop s2 c l x) in begin\n      match d with\n      | Coq_full_descriptor_undef ->\n        res_ter s3 (res_val (Coq_value_bool false))\n      | Coq_full_descriptor_some a ->\n        res_ter s3 (res_val (Coq_value_bool (attributes_enumerable a)))\n    end\n  | Coq_prealloc_function_proto ->\n    res_out s (res_val Coq_value_undef)\n  | Coq_prealloc_function_proto_to_string ->\n    if is_callable_dec s vthis\n    then (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n        ("Function.prototype.toString() is implementation dependent.")\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_apply ->\n    let  thisArg = (get_arg 0 args) in\n    let  argArray = (get_arg 1 args) in\n    if is_callable_dec s vthis\n    then\n      (match vthis with\n      | Coq_value_object thisobj ->\n        (match argArray with\n        | Coq_value_undef -> run_call s c thisobj thisArg []\n        | Coq_value_null -> run_call s c thisobj thisArg []\n        | Coq_value_bool b0 -> run_error s c Coq_native_error_type\n        | Coq_value_number n -> run_error s c Coq_native_error_type\n        | Coq_value_string s0 -> run_error s c Coq_native_error_type\n        | Coq_value_object array ->\n          let%value (s0, v) = (run_object_get s c array ("length")) in\n          let%spec (s1, ilen) = (to_uint32 s0 c v) in\n          let%spec (s2, arguments_) = (run_get_args_for_apply s1 c array 0. ilen) in\n          run_call s2 c thisobj thisArg arguments_)\n      | _ ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("Value is callable, but isn\\\'t an object."))\n            else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_call ->\n    if is_callable_dec s vthis\n    then\n      (match vthis with\n      | Coq_value_object thisobj ->\n        let (thisArg, a) = get_arg_first_and_rest args in\n        run_call s c thisobj thisArg a\n      | _ ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("Value is callable, but isn\\\'t an object.")\n      )\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_bind ->\n    if is_callable_dec s vthis\n    then\n      (match vthis with\n      | Coq_value_object thisobj ->\n        let (vthisArg, a) = get_arg_first_and_rest args in\n        let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_object_proto)) ("Object")) in\n        let o2 = o1 in\n        let o3 = (object_with_details o2 None None None (Some thisobj) (Some vthisArg) (Some a) None) in\n        let o4 = (object_set_class o3 ("Function")) in\n        let o5 = (object_set_proto o4 (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_function_proto))) in\n        let o6 = (object_with_invokation o5 (Some Coq_construct_after_bind) (Some Coq_call_after_bind) (Some Coq_builtin_has_instance_after_bind)) in\n        let o7 = (object_set_extensible o6 true) in\n        let (l, s_2) = object_alloc s o7 in\n        let vlength = (\n          let%some class0 = (run_object_method object_class_ s_2 thisobj) in\n          if string_eq class0 ("Function")\n          then\n            let%number (s10, n) = (run_object_get s_2 c thisobj ("length")) in\n            let%spec (s11, ilen) = (to_int32 s10 c (Coq_value_number n)) in\n            if  ilen < (number_of_int (LibList.length a))\n            then res_spec s11 0.\n            else res_spec s11 (ilen -.  (number_of_int (LibList.length a)))\n          else res_spec s_2 0.) in\n        let%spec (s10, length0) = (vlength) in\n        let a0 = ({ attributes_data_value = (Coq_value_number  length0);\n                    attributes_data_writable = false;\n                    attributes_data_enumerable = false;\n                    attributes_data_configurable = false }) in\n        let%some s11 = (run_object_heap_map_properties s10 l\n          (fun p -> HeapStr.write p ("length") (Coq_attributes_data_of a0))) in\n        let vthrower = (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_throw_type_error)) in\n        let a1 = ({ attributes_accessor_get = vthrower;\n                    attributes_accessor_set = vthrower;\n                    attributes_accessor_enumerable = false;\n                    attributes_accessor_configurable = false }) in\n        let%bool (s12, x) = (object_define_own_prop s11 c l ("caller") (descriptor_of_attributes (Coq_attributes_accessor_of a1)) false) in\n        let%bool (s13, x0) = (object_define_own_prop s12 c l ("arguments") (descriptor_of_attributes (Coq_attributes_accessor_of a1)) false) in\n        res_ter s13 (res_val (Coq_value_object l))\n      | _ ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("Value is callable, but isn\\\'t an object.")\n      )\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_bool ->\n      let v = get_arg 0 args in\n      res_out s (res_val (Coq_value_bool (to_boolean v)))\n  | Coq_prealloc_bool_proto_to_string ->\n    (match vthis with\n     | Coq_value_undef -> run_error s c Coq_native_error_type\n     | Coq_value_null -> run_error s c Coq_native_error_type\n     | Coq_value_bool b0 -> res_ter s (res_val (Coq_value_string (if b0 then "true" else "false")))\n     | Coq_value_number n -> run_error s c Coq_native_error_type\n     | Coq_value_string s0 -> run_error s c Coq_native_error_type\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n           if string_eq s0 ("Boolean")\n           then ifx_some_or_default (run_object_method object_prim_value_ s l)\n             (run_error s c Coq_native_error_type) (fun wo ->\n               match wo with\n               | Some v ->\n                 (match v with\n                 | Coq_value_undef -> run_error s c Coq_native_error_type\n                 | Coq_value_null -> run_error s c Coq_native_error_type\n                 | Coq_value_bool b0 ->\n                   res_ter s\n                     (res_val (Coq_value_string (if b0 then "true" else "false")))\n                 | Coq_value_number n ->\n                   run_error s c Coq_native_error_type\n                 | Coq_value_string s1 ->\n                   run_error s c Coq_native_error_type\n                 | Coq_value_object o -> run_error s c Coq_native_error_type)\n               | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_bool_proto_value_of ->\n    (match vthis with\n     | Coq_value_undef -> run_error s c Coq_native_error_type\n     | Coq_value_null -> run_error s c Coq_native_error_type\n     | Coq_value_bool b0 ->\n       res_ter s (res_val (Coq_value_bool b0))\n     | Coq_value_number n -> run_error s c Coq_native_error_type\n     | Coq_value_string s0 -> run_error s c Coq_native_error_type\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n             if string_eq s0 ("Boolean")\n             then ifx_some_or_default (run_object_method object_prim_value_ s l)\n               (run_error s c Coq_native_error_type) (fun wo ->\n                 match wo with\n                 | Some v ->\n                   (match v with\n                    | Coq_value_undef -> run_error s c Coq_native_error_type\n                    | Coq_value_null -> run_error s c Coq_native_error_type\n                    | Coq_value_bool b0 -> res_ter s (res_val (Coq_value_bool b0))\n                    | Coq_value_number n -> run_error s c Coq_native_error_type\n                    | Coq_value_string s1 -> run_error s c Coq_native_error_type\n                    | Coq_value_object o -> run_error s c Coq_native_error_type)\n                 | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_number ->\n    if list_eq_nil_decidable args\n    then res_out s (res_val (Coq_value_number JsNumber.zero))\n    else let v = get_arg 0 args in to_number s v\n  | Coq_prealloc_number_proto_value_of ->\n    (match vthis with\n     | Coq_value_undef -> run_error s c Coq_native_error_type\n     | Coq_value_null -> run_error s c Coq_native_error_type\n     | Coq_value_bool b0 -> run_error s c Coq_native_error_type\n     | Coq_value_number n ->\n       res_ter s (res_val (Coq_value_number n))\n     | Coq_value_string s0 -> run_error s c Coq_native_error_type\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n             if string_eq s0 ("Number")\n             then ifx_some_or_default (run_object_method object_prim_value_ s l)\n                 (run_error s c Coq_native_error_type) (fun wo ->\n                     match wo with\n                     | Some v ->\n                       (match v with\n                        | Coq_value_undef -> run_error s c Coq_native_error_type\n                        | Coq_value_null -> run_error s c Coq_native_error_type\n                        | Coq_value_bool b0 -> run_error s c Coq_native_error_type\n                        | Coq_value_number n -> res_ter s (res_val (Coq_value_number n))\n                        | Coq_value_string s1 -> run_error s c Coq_native_error_type\n                        | Coq_value_object o -> run_error s c Coq_native_error_type)\n                     | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_array ->\n    run_construct_prealloc s c Coq_prealloc_array args\n  | Coq_prealloc_array_is_array ->\n    let  arg = (get_arg 0 args) in begin\n        match arg with\n        | Coq_value_object arg0 ->\n          let%some class0= (run_object_method object_class_ s arg0) in\n          if string_eq class0 ("Array")\n          then res_ter s (res_val (Coq_value_bool true))\n          else res_ter s (res_val (Coq_value_bool false))\n        | _ -> res_ter s (res_val (Coq_value_bool false))\n    end\n  | Coq_prealloc_array_proto_to_string ->\n    let%object (s0, array) = (to_object s vthis) in\n    let%value (s1, vfunc) = (run_object_get s0 c array ("join")) in\n    if is_callable_dec s1 vfunc\n    then (match vfunc with\n        | Coq_value_object func -> run_call s1 c func (Coq_value_object array) []\n        | _ ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s1\n            ("Value is callable, but isn\\\'t an object."))\n    else run_call_prealloc s1 c Coq_prealloc_object_proto_to_string (Coq_value_object array) []\n  | Coq_prealloc_array_proto_join ->\n    let  vsep = (get_arg 0 args) in\n    let%object (s0, l) = (to_object s vthis) in\n    let%value (s1, vlen) = (run_object_get s0 c l ("length")) in\n    let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n    let rsep = (if not (value_compare vsep Coq_value_undef) then vsep else Coq_value_string (",")) in\n    let%string (s3, sep) = (to_string s2 rsep) in\n    if ilen = 0.0\n    then res_ter s3 (res_val (Coq_value_string ""))\n    else\n      let sR = (valueToStringForJoin s3 c l 0.) in\n      let%spec (s4, sR0) = (sR) in\n      run_array_join_elements s4 c l 1. ilen sep sR0\n  | Coq_prealloc_array_proto_pop ->\n    let%object (s0, l) = (to_object s vthis) in\n    let%value (s1, vlen) = (run_object_get s0 c l ("length")) in\n    let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n    if ilen = 0.0\n    then\n      let%not_throw (s3, x) = (object_put s2 c l ("length") (Coq_value_number JsNumber.zero) throw_true) in\n      res_out s3 (res_val Coq_value_undef)\n    else\n      let%string (s3, sindx) = (to_string s2 (Coq_value_number (ilen -. 1.))) in\n      let%value (s4, velem) = (run_object_get s3 c l sindx) in\n      let%not_throw (s5, x) = (object_delete s4 c l sindx throw_true) in\n      let%not_throw (s6, x0) = (object_put s5 c l ("length") (Coq_value_string sindx) throw_true) in\n      res_out s6 (res_val velem)\n  | Coq_prealloc_array_proto_push ->\n    let%object (s0, l) = (to_object s vthis) in\n    let%value (s1, vlen) = (run_object_get s0 c l ("length")) in\n    let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n    push s2 c l args ilen\n  | Coq_prealloc_string ->\n    if list_eq_nil_decidable args\n    then res_ter s (res_val (Coq_value_string ""))\n    else\n      let value0 = (get_arg 0 args) in\n      let%string (s0, s1) = (to_string s value0) in\n      res_ter s0 (res_val (Coq_value_string s1))\n  | Coq_prealloc_string_proto_to_string ->\n    (match vthis with\n     | Coq_value_object l ->\n       let%some s0= (run_object_method object_class_ s l) in\n           if string_eq s0 ("String")\n           then run_object_prim_value s l\n           else run_error s c Coq_native_error_type\n     | _ ->\n       if type_compare (type_of vthis) Coq_type_string\n       then res_ter s (res_val vthis)\n       else run_error s c Coq_native_error_type\n    )\n  | Coq_prealloc_string_proto_value_of ->\n    (match vthis with\n     | Coq_value_object l ->\n       let%some s0= (run_object_method object_class_ s l) in\n           if string_eq s0 ("String")\n           then run_object_prim_value s l\n           else run_error s c Coq_native_error_type\n     | _ ->\n       if type_compare (type_of vthis) Coq_type_string\n       then res_ter s (res_val vthis)\n       else run_error s c Coq_native_error_type\n    )\n  | Coq_prealloc_error ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           Coq_prealloc_error_proto)) v\n  | Coq_prealloc_native_error ne ->\n    let  v = (get_arg 0 args) in\n    build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                       (Coq_prealloc_native_error_proto ne))) v\n  | Coq_prealloc_throw_type_error -> builtin_throw_type_error s c () () ()\n  | Coq_prealloc_proxy -> builtin_proxy_constructor s c () () Coq_value_undef (get_arg 0 args) (get_arg 1 args)\n  | Coq_prealloc_proxy_revocable -> builtin_proxy_revocable s c () () () (get_arg 0 args) (get_arg 1 args)\n  | _ ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      (strappend ("Call prealloc_") (strappend (string_of_prealloc b) (" not yet implemented")))\n\n(** val run_call :\n    state -> execution_ctx -> object_loc -> value -> value list\n    -> result **)\n\nand run_call s c l vthis args =\n  let%some co = run_object_method object_call_ s l in\n  let%some c0 = co in\n  match c0 with\n  | Coq_call_default -> entering_func_code s c l vthis args\n  | Coq_call_after_bind ->\n    let%some oarg = run_object_method object_bound_args_ s l in\n    let%some boundArgs = oarg in\n    let%some obnd = run_object_method object_bound_this_ s l in\n    let%some boundThis = obnd in\n    let%some otrg = run_object_method object_target_function_ s l in\n    let%some target = otrg in\n    let arguments_ = (LibList.append boundArgs args) in run_call s c target boundThis arguments_\n  | Coq_call_prealloc b -> run_call_prealloc s c b vthis args\n  | Coq_call_proxy -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val run_javascript_from_state : state -> prog -> result **)\n\nand run_javascript_from_state s p =\n  let c = execution_ctx_initial (prog_intro_strictness p) in\n  let%void s_2 = execution_ctx_binding_inst s c Coq_codetype_global None p [] in\n  run_prog s_2 c p\n\n(** val run_javascript_from_result : result -> prog -> result **)\n\nand run_javascript_from_result w p =\n  if_success w (fun s _ -> run_javascript_from_state s p)\n\n(** val run_javascript : prog -> result **)\n\nand run_javascript p =\n  run_javascript_from_state state_initial p\n'},
];
