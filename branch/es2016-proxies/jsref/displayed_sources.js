var tracer_files = [

/* --------------------- JsInterpreter.js --------------------- */
  { file: 'JsInterpreter.js', contents: 'var JsInterpreter = (function() {\nwith (Datatypes) {\nwith (JsCommon) {\nwith (JsCommonAux) {\nwith (JsInit) {\nwith (JsInterpreterMonads) {\nwith (JsSyntax) {\nwith (JsSyntaxAux) {\nwith (LibList) {\nwith (LibOption) {\nwith (LibProd) {\nwith (Shared) {\n\nvar convert_prim_to_number = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_undef":\n      return (JsNumber.nan);\n    case "Coq_value_null":\n      return (JsNumber.zero);\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      if (b) {\n        return (JsNumber.one);\n      } else {\n        return (JsNumber.zero);\n      }\n    case "Coq_value_number":\n      var n = _foo_.value;\n      return (n);\n    case "Coq_value_string":\n      var s = _foo_.value;\n      return (JsNumber.from_string(s));\n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar convert_number_to_integer = function (n) {\n  if (JsNumber.isnan(n)) {\n    return (JsNumber.zero);\n  } else {\n    if ((JsNumber.isposzero(n)\n        || (JsNumber.isnegzero(n)\n           || ((n === JsNumber.infinity) || (n === JsNumber.neg_infinity))))) {\n      return (n);\n    } else {\n      return ((JsNumber.sign(n) * JsNumber.floor(JsNumber.absolute(n))));\n    }\n  }\n};\n\n\n\nvar convert_bool_to_string = function (_foo_) {\n  switch (_foo_) {\n    case true:\n      return ("true");\n    case false:\n      return ("false");\n  }\n  \n};\n\n\n\nvar convert_prim_to_string = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_undef":\n      return ("undefined");\n    case "Coq_value_null":\n      return ("null");\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      return (convert_bool_to_string(b));\n    case "Coq_value_number":\n      var n = _foo_.value;\n      return (JsNumber.to_string(n));\n    case "Coq_value_string":\n      var s = _foo_.value;\n      return (s);\n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar equality_test_for_same_type = function (ty, v1, v2) {\n  switch (ty.tag) {\n    case "Coq_type_undef":\n      return (true);\n    case "Coq_type_null":\n      return (true);\n    case "Coq_type_bool":\n      return (value_compare(v1, v2));\n    case "Coq_type_number":\n      switch (v1.tag) {\n        case "Coq_value_undef":\n          return (false);\n        case "Coq_value_null":\n          return (false);\n        case "Coq_value_bool":\n          var b = v1.value;\n          return (false);\n        case "Coq_value_string":\n          var s = v1.value;\n          return (false);\n        case "Coq_value_number":\n          var n1 = v1.value;\n          switch (v2.tag) {\n            case "Coq_value_undef":\n              return (false);\n            case "Coq_value_null":\n              return (false);\n            case "Coq_value_bool":\n              var b = v2.value;\n              return (false);\n            case "Coq_value_string":\n              var s = v2.value;\n              return (false);\n            case "Coq_value_number":\n              var n2 = v2.value;\n              if (JsNumber.isnan(n1)) {\n                return (false);\n              } else {\n                if (JsNumber.isnan(n2)) {\n                  return (false);\n                } else {\n                  if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n                    return (true);\n                  } else {\n                    if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n                      return (true);\n                    } else {\n                      return ((n1 === n2));\n                    }\n                  }\n                }\n              }\n            case "Coq_value_object":\n              var o = v2.value;\n              return (false);\n          }\n          \n        case "Coq_value_object":\n          var o = v1.value;\n          return (false);\n      }\n      \n    case "Coq_type_string":\n      return (value_compare(v1, v2));\n    case "Coq_type_object":\n      return (value_compare(v1, v2));\n  }\n  \n};\n\n\n\nvar strict_equality_test = function (v1, v2) {\n  var ty1 = type_of(v1);\n  var ty2 = type_of(v2);\n  if (type_compare(ty1, ty2)) {\n    return (equality_test_for_same_type(ty1, v1, v2));\n  } else {\n    return (false);\n  }\n};\n\n\n\nvar inequality_test_number = function (n1, n2) {\n  if ((JsNumber.isnan(n1) || JsNumber.isnan(n2))) {\n    return (Coq_value_undef());\n  } else {\n    if ((n1 === n2)) {\n      return (Coq_value_bool(false));\n    } else {\n      if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n        return (Coq_value_bool(false));\n      } else {\n        if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n          return (Coq_value_bool(false));\n        } else {\n          if ((n1 === JsNumber.infinity)) {\n            return (Coq_value_bool(false));\n          } else {\n            if ((n2 === JsNumber.infinity)) {\n              return (Coq_value_bool(true));\n            } else {\n              if ((n2 === JsNumber.neg_infinity)) {\n                return (Coq_value_bool(false));\n              } else {\n                if ((n1 === JsNumber.neg_infinity)) {\n                  return (Coq_value_bool(true));\n                } else {\n                  return (Coq_value_bool((n1 < n2)));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n\n\nvar inequality_test_string = function (s1, s2) {\n  return (string_lt(s1, s2));\n};\n\n\n\nvar inequality_test_primitive = function (w1, w2) {\n  switch (w1.tag) {\n    case "Coq_value_undef":\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case "Coq_value_null":\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case "Coq_value_bool":\n      var b = w1.value;\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case "Coq_value_number":\n      var n = w1.value;\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case "Coq_value_string":\n      var s1 = w1.value;\n      switch (w2.tag) {\n        case "Coq_value_undef":\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case "Coq_value_null":\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case "Coq_value_bool":\n          var b = w2.value;\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case "Coq_value_number":\n          var n = w2.value;\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case "Coq_value_string":\n          var s2 = w2.value;\n          return (Coq_value_bool(inequality_test_string(s1, s2)));\n        default:\n          throw false;\n      }\n      \n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar typeof_prim = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_undef":\n      return ("undefined");\n    case "Coq_value_null":\n      return ("object");\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      return ("boolean");\n    case "Coq_value_number":\n      var n = _foo_.value;\n      return ("number");\n    case "Coq_value_string":\n      var s = _foo_.value;\n      return ("string");\n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar string_of_propname = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_propname_identifier":\n      var s = _foo_.value;\n      return (s);\n    case "Coq_propname_string":\n      var s = _foo_.value;\n      return (s);\n    case "Coq_propname_number":\n      var n = _foo_.value;\n      return (JsNumber.to_string(n));\n  }\n  \n};\n\nvar run_object_method = function (proj, s, l) {\n  return (LibOption.map(proj, object_binds_option(s, l)));\n};\n\n\n\n\n\nvar run_object_set_internal = function (prj, s, l, v) {\n  return (\n    LibOption.map(function (o) { return (object_write(s, l, prj(o, v)));},\n      object_binds_option(s, l)));\n};\n\n\n\nvar run_object_heap_set_extensible = function (b, s, l) {\n  return (run_object_set_internal(object_set_extensible, s, l, b));\n};\n\nvar build_error = function (s, c, vproto, vmsg) {\n  var o = object_new(vproto, "Error");\n  var _tuple_arg_1 = object_alloc(s, o);\n  var l = _tuple_arg_1[0], s_2 = _tuple_arg_1[1];\n  if (value_compare(vmsg, Coq_value_undef())) {\n    return (res_out(s_2, res_val(Coq_value_object(l))));\n  } else {\n    return (\n      if_value(to_string(s_2, c, vmsg), function(s_3, vstr) {\n          \n          var a = {\n            attributes_data_value: vstr,\n            attributes_data_writable: true,\n            attributes_data_enumerable: false,\n            attributes_data_configurable: true\n          };\n          return (\n            if_success(\n              object_define_own_prop(s_3, c, l, "message",\n                descriptor_of_attributes(Coq_attributes_data_of(a)),\n                throw_true), function(s_4, rv) {\n                \n                return (res_out(s_4, res_val(Coq_value_object(l))));}));}));\n  }\n};\n\nvar run_error = function (s, c, ne) {\n  return (\n    if_object(\n      build_error(s, c,\n        Coq_value_object(\n          Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))),\n        Coq_value_undef()), function(s_2, l) {\n        \n        return (\n          res_out(s_2, res_throw(Coq_resvalue_value(Coq_value_object(l)))));\n      }));\n};\n\nvar run_error_no_c = function (s, ne) {\n  return (run_error(s, execution_ctx_initial(true), ne));\n};\n\nvar object_has_internal_slot = function (s, l, prj) {\n  var slot_value = run_object_method(prj, s, l);\n  switch (slot_value.tag) {\n    case "None":\n      throw false;\n    case "Some":\n      var v = slot_value.value;\n      switch (v.tag) {\n        case "Some":\n          return (true);\n        case "None":\n          return (false);\n      }\n      \n  }\n  \n};\n\nvar object_has_internal_method = function (s, l, prj) {\n  return (object_has_internal_slot(s, l, prj));\n};\n\nvar object_internal_get_prototype_of = function (s, o) {\n  return (\n    if_some(run_object_method(object_get_prototype_of_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_get_prototype_of_default":\n            return (ordinary_object_internal_get_prototype_of(s, o));\n          case "Coq_builtin_get_prototype_of_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_internal_set_prototype_of = function (s, o, v) {\n  return (\n    if_some(run_object_method(object_set_prototype_of_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_set_prototype_of_default":\n            return (ordinary_object_internal_set_prototype_of(s, o, v));\n          case "Coq_builtin_set_prototype_of_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_internal_is_extensible = function (s, o) {\n  return (\n    if_some(run_object_method(object_is_extensible_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_is_extensible_default":\n            return (ordinary_object_internal_is_extensible(s, o));\n          case "Coq_builtin_is_extensible_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_internal_prevent_extensions = function (s, o) {\n  return (\n    if_some(run_object_method(object_prevent_extensions_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_prevent_extensions_default":\n            return (ordinary_object_internal_prevent_extensions(s, o));\n          case "Coq_builtin_prevent_extensions_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_internal_get_own_property = function (s, o, p) {\n  return (\n    if_some(run_object_method(object_get_own_prop_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_get_own_prop_default":\n            return (ordinary_object_internal_get_own_property(s, o, p));\n          case "Coq_builtin_get_own_prop_args_obj":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_get_own_prop_string":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_get_own_prop_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_internal_define_own_property = function (s, o, p, desc) {\n  return (\n    if_some(run_object_method(object_define_own_prop_, s, o),\n      function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_define_own_prop_default":\n            return (\n              ordinary_object_internal_define_own_property(s, o, p, desc));\n          case "Coq_builtin_define_own_prop_array":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_define_own_prop_args_obj":\n            return (Coq_result_not_yet_implemented());\n          case "Coq_builtin_define_own_prop_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_internal_has_property = function (s, o, p) {\n  return (\n    if_some(run_object_method(object_has_prop_, s, o), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_has_prop_default":\n            return (ordinary_has_property(s, o, p));\n          case "Coq_builtin_has_prop_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_internal_get = function (s, o, p, receiver) {\n  return (\n    if_some(run_object_method(object_get_, s, o), function(internal_method) {\n        \n        var dispatch_es5 = function (_pat_any_2) {\n          switch (p.tag) {\n            case "Coq_value_string":\n              var x = p.value;\n              return (\n                object_get_builtin(s, execution_ctx_initial(true),\n                  internal_method, Coq_value_object(o), o, x));\n            default:\n              throw false;\n          }\n          \n        };\n        switch (internal_method.tag) {\n          case "Coq_builtin_get_default":\n            return (dispatch_es5({}));\n          case "Coq_builtin_get_function":\n            return (dispatch_es5({}));\n          case "Coq_builtin_get_args_obj":\n            return (dispatch_es5({}));\n          case "Coq_builtin_get_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_internal_set = function (s, o, p, v, receiver) {\n  return (\n    if_some(run_object_method(object_set_, s, o), function(internal_method) {\n        \n        switch (internal_method.tag) {\n          case "Coq_builtin_set_default":\n            return (ordinary_object_internal_set(s, o, p, v, receiver));\n          case "Coq_builtin_set_proxy":\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar object_put = function (s, c, l, p, v, str) {\n  return (\n    object_internal_set(s, l, Coq_value_string(p), v, Coq_value_object(l)));\n};\n\nvar object_internal_call = function (s, o, thisArgument, argumentsList) {\n  return (\n    run_call(s, execution_ctx_initial(true), o, thisArgument, argumentsList));\n};\n\nvar get_base = ref_base;\n\nvar get_referenced_name = function (r) {\n  return (Coq_value_string(ref_name(r)));\n};\n\nvar is_strict_reference = ref_strict;\n\nvar has_primitive_base = function (r) {\n  return (\n    ref_kind_comparable(ref_kind_of(r), Coq_ref_kind_primitive_base()));\n};\n\nvar is_property_reference = function (r) {\n  return (\n    (_compare_JsCommon_ref_kind(ref_kind_of(r), Coq_ref_kind_object())\n    || has_primitive_base(r)));\n};\n\nvar is_unresolvable_reference = function (r) {\n  return (_compare_JsCommon_ref_kind(ref_kind_of(r), Coq_ref_kind_undef()));\n};\n\nvar is_super_reference = function (r) {\n  return (is_some(r.ref_this_value));\n};\n\nvar get_value = function (s, v) {\n  return (\n    if_success(v, function(_pat_any_5, v$) {\n        \n        if (!(\n              _compare_JsSyntax_resvalue_type(type_of_resvalue(v$),\n                Type_resvalue_ref()))) {\n          return (v);\n        } else {\n          var v = ref_of_resvalue(v$);\n          var base = get_base(v);\n          if (is_unresolvable_reference(v)) {\n            return (run_error_no_c(s, Coq_native_error_ref()));\n          } else {\n            if (is_property_reference(v)) {\n              var base = value_of_ref_base_type(base);\n              return (\n                let_ret((function () {\n                    if (has_primitive_base(v)) {\n                      return (\n                        check_assert_ret(\n                          (!(\n                             _compare_JsSyntax_value(base, Coq_value_undef()))\n                          || _compare_JsSyntax_value(base, Coq_value_null())),\n                          function(_pat_any_3) {\n                            \n                            return (\n                              assert_object_ret(to_object(s, base),\n                                function(s, base) {\n                                  \n                                  return (Continue([s, base]));}));}));\n                    } else {\n                      return (Continue([s, loc_of_value(base)]));\n                    }}()), function(_tuple_arg_4) {\n                    var s = _tuple_arg_4[0], base = _tuple_arg_4[1];\n                    \n                    return (\n                      object_internal_get(s, base, get_referenced_name(v),\n                        get_this_value(v)));}));\n            } else {\n              var base = env_loc_of_ref_base_type(base);\n              return (\n                get_binding_value(s, base, get_referenced_name(v),\n                  is_strict_reference(v)));\n            }\n          }\n        }}));\n};\n\nvar put_value = function (s, c, v, w) {\n  return (\n    if_success(v, function(_pat_any_9, v) {\n        \n        return (\n          if_value(w, function(_pat_any_8, w) {\n              \n              if (!(\n                    _compare_JsSyntax_resvalue_type(type_of_resvalue(v),\n                      Type_resvalue_ref()))) {\n                return (run_error_no_c(s, Coq_native_error_ref()));\n              } else {\n                var v = ref_of_resvalue(v);\n                var base = get_base(v);\n                if (is_unresolvable_reference(v)) {\n                  if (is_strict_reference(v)) {\n                    return (run_error_no_c(s, Coq_native_error_ref()));\n                  } else {\n                    var globalObj = get_global_object(s, c);\n                    return (\n                      set(s, globalObj, get_referenced_name(v), w,\n                        Coq_value_bool(false)));\n                  }\n                } else {\n                  if (is_property_reference(v)) {\n                    var base = value_of_ref_base_type(base);\n                    return (\n                      let_ret((function () {\n                          if (has_primitive_base(v)) {\n                            return (\n                              check_assert_ret(\n                                !(\n                                  (_compare_JsSyntax_value(base,\n                                     Coq_value_null())\n                                  || _compare_JsSyntax_value(base,\n                                       Coq_value_undef()))),\n                                function(_pat_any_6) {\n                                  \n                                  return (\n                                    assert_object_ret(to_object(s, base),\n                                      function(s, base) {\n                                        \n                                        return (Continue([s, base]));}));}));\n                          } else {\n                            return (Continue([s, loc_of_value(base)]));\n                          }}()), function(_tuple_arg_7) {\n                          var s = _tuple_arg_7[0], base = _tuple_arg_7[1];\n                          \n                          return (\n                            if_bool(\n                              object_internal_set(s, base,\n                                get_referenced_name(v), w, get_this_value(v)),\n                              function(s, succeeded) {\n                                \n                                if ((!(succeeded) && is_strict_reference(v))) {\n                                  return (\n                                    run_error_no_c(s,\n                                      Coq_native_error_type()));\n                                } else {\n                                  return (res_void(s));\n                                }}));}));\n                  } else {\n                    var base = env_loc_of_ref_base_type(base);\n                    return (\n                      set_mutable_binding(s, base, get_referenced_name(v), w,\n                        Coq_value_bool(is_strict_reference(v))));\n                  }\n                }\n              }}));}));\n};\n\nvar get_this_value = function (v) {\n  throw is_property_reference(v);\n  if (is_super_reference(v)) {\n    return (ref_this_value(v));\n  } else {\n    return (value_of_ref_base_type(get_base(v)));\n  }\n};\n\nvar is_accessor_descriptor = function (desc) {\n  switch (desc.tag) {\n    case "Descriptor_undef":\n      return (false);\n    case "Descriptor":\n      var desc = desc.descriptor;\n      return (\n        !(\n          (option_compare(value_compare, desc.descriptor_get, None())\n          && option_compare(value_compare, desc.descriptor_set, None()))));\n  }\n  \n};\n\nvar is_data_descriptor = function (desc) {\n  switch (desc.tag) {\n    case "Descriptor_undef":\n      return (false);\n    case "Descriptor":\n      var desc = desc.descriptor;\n      return (\n        !(\n          (option_compare(value_compare, desc.descriptor_value, None())\n          && option_compare(bool_eq, desc.descriptor_writable, None()))));\n  }\n  \n};\n\nvar is_generic_descriptor = function (desc) {\n  switch (desc.tag) {\n    case "Descriptor_undef":\n      return (false);\n    case "Descriptor":\n      return (\n        (!(is_accessor_descriptor(desc)) && !(is_data_descriptor(desc))));\n  }\n  \n};\n\nvar to_property_descriptor = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_object":\n      var l = _foo_.value;\n      var desc = descriptor_intro_empty;\n      return (\n        if_bool(has_property(s, _foo_, Coq_value_string("enumerable")),\n          function(s, hasEnumerable) {\n            \n            return (\n              if_spec((function () {\n                  if (hasEnumerable) {\n                    return (\n                      if_value(get(s, _foo_, Coq_value_string("enumerable")),\n                        function(s, v) {\n                          \n                          var enum = to_boolean(v);\n                          return (\n                            res_spec(s,\n                              descriptor_with_enumerable(desc, Some(enum))));\n                        }));\n                  } else {\n                    return (res_spec(s, desc));\n                  }}()), function(s, desc) {\n                  \n                  return (\n                    if_bool(\n                      has_property(s, _foo_,\n                        Coq_value_string("configurable")), function(s,\n                      hasConfigurable) {\n                        \n                        return (\n                          if_spec((function () {\n                              if (hasConfigurable) {\n                                return (\n                                  if_value(\n                                    get(s, _foo_,\n                                      Coq_value_string("configurable")),\n                                    function(s, v) {\n                                      \n                                      var conf = to_boolean(v);\n                                      return (\n                                        res_spec(s,\n                                          descriptor_with_configurable(desc,\n                                            Some(conf))));}));\n                              } else {\n                                return (res_spec(s, desc));\n                              }}()), function(s, desc) {\n                              \n                              return (\n                                if_bool(\n                                  has_property(s, _foo_,\n                                    Coq_value_string("value")), function(s,\n                                  hasValue) {\n                                    \n                                    return (\n                                      if_spec((function () {\n                                          if (hasValue) {\n                                            return (\n                                              if_value(\n                                                get(s, _foo_,\n                                                  Coq_value_string("value")),\n                                                function(s, value) {\n                                                  \n                                                  return (\n                                                    res_spec(s,\n                                                      descriptor_with_value(\n                                                        desc, Some(value))));\n                                                }));\n                                          } else {\n                                            return (res_spec(s, desc));\n                                          }}()), function(s, desc) {\n                                          \n                                          return (\n                                            if_bool(\n                                              has_property(s, _foo_,\n                                                Coq_value_string("writable")),\n                                              function(s, hasWritable) {\n                                                \n                                                return (\n                                                  if_spec((function () {\n                                                      if (hasValue) {\n                                                        return (\n                                                          if_value(\n                                                            get(s, _foo_,\n                                                              Coq_value_string(\n                                                                "writable")),\n                                                            function(s, v) {\n                                                              \n                                                              var writable = \n                                                              to_boolean(v);\n                                                              return (\n                                                                res_spec(s,\n                                                                  descriptor_with_writable(\n                                                                    desc,\n                                                                    Some(\n                                                                    writable))));\n                                                            }));\n                                                      } else {\n                                                        return (\n                                                          res_spec(s, desc));\n                                                      }}()), function(s,\n                                                    desc) {\n                                                      \n                                                      return (\n                                                        if_bool(\n                                                          has_property(s,\n                                                            _foo_,\n                                                            Coq_value_string(\n                                                              "get")),\n                                                          function(s,\n                                                          hasGet) {\n                                                            \n                                                            return (\n                                                              if_spec(\n                                                                (function () {\n                                                                  if (hasGet) {\n                                                                    return (\n                                                                    if_value(\n                                                                    get(s,\n                                                                    _foo_,\n                                                                    Coq_value_string(\n                                                                    "get")),\n                                                                    function(s,\n                                                                    getter) {\n                                                                    \n                                                                    if (\n                                                                    (\n                                                                    !(\n                                                                    is_callable(\n                                                                    s,\n                                                                    getter))\n                                                                    && \n                                                                    !(\n                                                                    _compare_JsSyntax_coq_type(\n                                                                    type_of(\n                                                                    getter),\n                                                                    Coq_type_undef(\n                                                                    ))))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    descriptor_with_get(\n                                                                    desc,\n                                                                    Some(\n                                                                    getter))));\n                                                                    }}));\n                                                                  } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s, desc));\n                                                                  }}()),\n                                                                function(s,\n                                                                desc) {\n                                                                  \n                                                                  return (\n                                                                    if_bool(\n                                                                    has_property(\n                                                                    s, _foo_,\n                                                                    Coq_value_string(\n                                                                    "set")),\n                                                                    function(s,\n                                                                    hasSet) {\n                                                                    \n                                                                    return (\n                                                                    if_spec(\n                                                                    (function () {\n                                                                    if (hasSet) {\n                                                                    return (\n                                                                    if_value(\n                                                                    get(s,\n                                                                    _foo_,\n                                                                    Coq_value_string(\n                                                                    "set")),\n                                                                    function(s,\n                                                                    setter) {\n                                                                    \n                                                                    if (\n                                                                    (\n                                                                    !(\n                                                                    is_callable(\n                                                                    s,\n                                                                    setter))\n                                                                    && \n                                                                    !(\n                                                                    _compare_JsSyntax_coq_type(\n                                                                    type_of(\n                                                                    setter),\n                                                                    Coq_type_undef(\n                                                                    ))))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s,\n                                                                    descriptor_with_set(\n                                                                    desc,\n                                                                    Some(\n                                                                    setter))));\n                                                                    }}));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s, desc));\n                                                                    }}()),\n                                                                    function(s,\n                                                                    desc) {\n                                                                    \n                                                                    if (\n                                                                    (\n                                                                    (\n                                                                    !(\n                                                                    _compare_option(\n                                                                    desc.descriptor_get,\n                                                                    None()))\n                                                                    || \n                                                                    !(\n                                                                    _compare_option(\n                                                                    desc.descriptor_set,\n                                                                    None())))\n                                                                    && \n                                                                    (\n                                                                    !(\n                                                                    _compare_option(\n                                                                    desc.descriptor_value,\n                                                                    None()))\n                                                                    || \n                                                                    !(\n                                                                    _compare_option(\n                                                                    desc.descriptor_writable,\n                                                                    None()))))) {\n                                                                    return (\n                                                                    run_error_no_c(\n                                                                    s,\n                                                                    Coq_native_error_type(\n                                                                    )));\n                                                                    } else {\n                                                                    return (\n                                                                    res_spec(\n                                                                    s, desc));\n                                                                    }}));}));\n                                                                }));}));}));\n                                              }));}));}));}));}));}));}));\n    default:\n      return (throw_result(run_error_no_c(s, Coq_native_error_type())));\n  }\n  \n};\n\nvar complete_property_descriptor = function (s, desc) {\n  var desc = descriptor_get_defined(desc);\n  var like = {\n    descriptor_value: Some(Coq_value_undef()),\n    descriptor_writable: Some(false),\n    descriptor_get: Some(Coq_value_undef()),\n    descriptor_set: Some(Coq_value_undef()),\n    descriptor_enumerable: Some(false),\n    descriptor_configurable: Some(false)\n  };\n  if ((is_generic_descriptor(Descriptor(desc))\n      || is_data_descriptor(Descriptor(desc)))) {\n    var desc = descriptor_with_value(desc, like.descriptor_value);\n    var desc = descriptor_with_writable(desc, like.descriptor_writable);\n  } else {\n    var desc = descriptor_with_get(desc, like.descriptor_get);\n    var desc = descriptor_with_set(desc, like.descriptor_set);\n  }\n  if (option_compare(bool_eq, desc.descriptor_enumerable, None())) {\n    var desc = descriptor_with_enumerable(desc, like.descriptor_enumerable);\n  } else {\n    var desc = desc;\n  }\n  if (option_compare(bool_eq, desc.descriptor_configurable, None())) {\n    var desc = descriptor_with_configurable(desc,\n                 like.descriptor_configurable);\n  } else {\n    var desc = desc;\n  }\n  return (desc);\n};\n\nvar to_boolean = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_undef":\n      return (false);\n    case "Coq_value_null":\n      return (false);\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      return (b);\n    case "Coq_value_number":\n      var n = _foo_.value;\n      if ((JsNumber.isposzero(n)\n          || (JsNumber.isnegzero(n) || JsNumber.isnan(n)))) {\n        return (false);\n      } else {\n        return (true);\n      }\n    case "Coq_value_string":\n      var s = _foo_.value;\n      if (string_eq(s, "")) {\n        return (false);\n      } else {\n        return (true);\n      }\n    case "Coq_value_object":\n      var o = _foo_.value;\n      return (true);\n  }\n  \n};\n\nvar is_callable = function (s, argument) {\n  switch (argument.tag) {\n    case "Coq_value_object":\n      var l = argument.value;\n      return (object_has_internal_method(s, l, object_call_));\n    default:\n      return (false);\n  }\n  \n};\n\nvar is_extensible = function (s, o) {\n  return (\n    check_assert((function () {\n        var _switch_arg_10 = type_of(o);\n        switch (_switch_arg_10.tag) {\n          case "Coq_type_object":\n            return (true);\n          default:\n            return (false);\n        }\n        }()), function(_pat_any_11) {\n        \n        switch (o.tag) {\n          case "Coq_value_object":\n            var l = o.value;\n            return (object_internal_is_extensible(s, l));\n          default:\n            throw false;\n        }\n        }));\n};\n\nvar is_property_key = function (argument) {\n  return (_compare_JsSyntax_coq_type(type_of(argument), Coq_type_string()));\n};\n\nvar same_value = function (x, y) {\n  if (!(type_compare(type_of(x), type_of(y)))) {\n    return (false);\n  } else {\n    var _switch_arg_12 = type_of(x);\n    switch (_switch_arg_12.tag) {\n      case "Coq_type_number":\n        switch (x.tag) {\n          case "Coq_value_number":\n            var n_x = x.value;\n            switch (y.tag) {\n              case "Coq_value_number":\n                var n_y = y.value;\n                if ((JsNumber.isnan(n_x) && JsNumber.isnan(n_y))) {\n                  return (true);\n                } else {\n                  if ((JsNumber.isposzero(n_x) && JsNumber.isnegzero(n_y))) {\n                    return (true);\n                  } else {\n                    if ((JsNumber.isnegzero(n_x) && JsNumber.isposzero(n_y))) {\n                      return (true);\n                    } else {\n                      return ((n_x === n_y));\n                    }\n                  }\n                }\n              default:\n                throw false;\n            }\n            \n          default:\n            throw false;\n        }\n        \n      default:\n        return (same_value_non_number(x, y));\n    }\n    \n  }\n};\n\nvar same_value_non_number = function (x, y) {\n  throw !(type_compare(type_of(x), Coq_type_number()));\n  throw type_compare(type_of(x), type_of(y));\n  switch (x.tag) {\n    case "Coq_value_undef":\n      return (true);\n    case "Coq_value_null":\n      return (true);\n    case "Coq_value_string":\n      var s_x = x.value;\n      switch (y.tag) {\n        case "Coq_value_string":\n          var s_y = y.value;\n          return (string_eq(s_x, s_y));\n        default:\n          throw false;\n      }\n      \n    case "Coq_value_bool":\n      var b_x = x.value;\n      switch (y.tag) {\n        case "Coq_value_bool":\n          var b_y = y.value;\n          return (bool_eq(b_x, b_y));\n        default:\n          throw false;\n      }\n      \n    case "Coq_value_object":\n      var l_x = x.value;\n      switch (y.tag) {\n        case "Coq_value_object":\n          var l_y = y.value;\n          return (object_loc_compare(l_x, l_y));\n        default:\n          throw false;\n      }\n      \n    default:\n      throw false;\n  }\n  \n};\n\nvar get = function (s, o, p) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_14) {\n        \n        return (\n          check_assert(is_property_key(p), function(_pat_any_13) {\n              \n              switch (o.tag) {\n                case "Coq_value_object":\n                  var l = o.value;\n                  return (object_internal_get(s, l, p, o));\n                default:\n                  throw false;\n              }\n              }));}));\n};\n\nvar get_v = function (s, v, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_15) {\n        \n        return (\n          if_object(to_object(s, v), function(s1, l) {\n              \n              return (object_internal_get(s1, l, p, v));}));}));\n};\n\nvar set = function (s, o, p, v, throw) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_18) {\n        \n        var l = loc_of_value(o);\n        return (\n          check_assert(is_property_key(p), function(_pat_any_17) {\n              \n              return (\n                check_assert(\n                  _compare_JsSyntax_coq_type(type_of(throw), Coq_type_bool()),\n                  function(_pat_any_16) {\n                    \n                    var throw = bool_of_value(throw);\n                    return (\n                      if_bool(object_internal_set(s, l, p, v, o), function(s,\n                        success) {\n                          \n                          if ((!(success) && throw)) {\n                            return (\n                              run_error_no_c(s, Coq_native_error_type()));\n                          } else {\n                            return (\n                              res_ter(s, res_val(Coq_value_bool(success))));\n                          }}));}));}));}));\n};\n\nvar create_data_property = function (s, o, p, v) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_20) {\n        \n        var o = loc_of_value(o);\n        return (\n          check_assert(is_property_key(p), function(_pat_any_19) {\n              \n              var newDesc = descriptor_intro_data(v, true, true, true);\n              return (object_internal_define_own_property(s, o, p, newDesc));\n            }));}));\n};\n\nvar get_method = function (s, v, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_22) {\n        \n        return (\n          if_value(get_v(s, v, p), function(s1, func) {\n              \n              var _switch_arg_21 = type_of(func);\n              switch (_switch_arg_21.tag) {\n                case "Coq_type_undef":\n                  return (res_out(s1, res_val(Coq_value_undef())));\n                case "Coq_type_null":\n                  return (res_out(s1, res_val(Coq_value_undef())));\n                default:\n                  var callable = is_callable(s1, func);\n                  if (!(callable)) {\n                    return (run_error_no_c(s1, Coq_native_error_type()));\n                  } else {\n                    return (res_out(s1, res_val(func)));\n                  }\n              }\n              }));}));\n};\n\nvar has_property = function (s, o, p) {\n  return (\n    check_assert(_compare_JsSyntax_coq_type(type_of(o), Coq_type_object()),\n      function(_pat_any_24) {\n        \n        return (\n          check_assert(is_property_key(p), function(_pat_any_23) {\n              \n              switch (o.tag) {\n                case "Coq_value_object":\n                  var l = o.value;\n                  return (object_internal_has_property(s, l, p));\n                default:\n                  throw false;\n              }\n              }));}));\n};\n\nvar call = function (s, f, v, argumentList) {\n  return (\n    if_some_or_apply_default(argumentList, mk_nil(),\n      function (argumentList) {\n        var callable = is_callable(s, f);\n        if (!(callable)) {\n          return (run_error_no_c(s, Coq_native_error_type()));\n        } else {\n          switch (f.tag) {\n            case "Coq_value_object":\n              var l = f.value;\n              return (object_internal_call(s, l, v, argumentList));\n            default:\n              throw false;\n          }\n          \n        }}));\n};\n\nvar set_mutable_binding = function (s, l, n, v, str) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var e = e.value;\n            return (decl_env_record_set_mutable_binding(s, l, e, n, v, str));\n          case "Coq_env_record_object":\n            var l = e.value, this = e.provide_this;\n            return (\n              object_env_record_set_mutable_binding(s, Coq_value_object(l),\n                this, n, v, str));\n        }\n        }));\n};\n\nvar get_binding_value = function (s, l, n, str) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var e = e.value;\n            return (decl_env_record_get_binding_value(s, e, n, str));\n          case "Coq_env_record_object":\n            var l = e.value, this = e.provide_this;\n            return (\n              object_env_record_get_binding_value(s, Coq_value_object(l),\n                this, n, str));\n        }\n        }));\n};\n\nvar binding_is_uninitialized = function (binding) {\n  var mutability = binding[0], unused = binding[1];\n  return (\n    mutability_compare(mutability, Coq_mutability_uninitialized_immutable()));\n};\n\nvar binding_is_mutable = function (binding) {\n  var mutability = binding[0], unused = binding[1];\n  return (\n    (_compare_JsSyntax_mutability(mutability, Coq_mutability_nondeletable())\n    || _compare_JsSyntax_mutability(mutability, Coq_mutability_deletable())));\n};\n\nvar decl_env_record_create_mutable_binding = function (s, l, envRec, n$, d) {\n  var n = string_of_value(n$);\n  var d = bool_of_value(d);\n  return (\n    check_assert(!(HeapStr.indom_dec(envRec, n)), function(_pat_any_25) {\n        \n        var s = env_record_write_decl_env(s, l, n, mutability_of_bool(d),\n                  Coq_value_undef());\n        return (res_void(s));}));\n};\n\nvar decl_env_record_initialize_binding = function (s, l, envRec, n$, v) {\n  var n = string_of_value(n$);\n  return (\n    if_some(HeapStr.read_option(envRec, n), function(binding) {\n        \n        var mutability = binding[0], unused = binding[1];\n        return (\n          check_assert(binding_is_uninitialized(binding),\n            function(_pat_any_26) {\n              \n              var s = env_record_write_decl_env(s, l, n, mutability, v);\n              return (res_void(s));}));}));\n};\n\nvar decl_env_record_set_mutable_binding = function (s, l, envRec, n$, v, str) {\n  var n = string_of_value(n$);\n  var str = bool_of_value(str);\n  if (!(HeapStr.indom_dec(envRec, n))) {\n    if (str) {\n      return (run_error_no_c(s, Coq_native_error_ref()));\n    } else {\n      return (\n        if_success(\n          decl_env_record_create_mutable_binding(s, l, envRec, n$,\n            Coq_value_bool(true)), function(s, _pat_any_28) {\n            \n            return (\n              if_success(\n                decl_env_record_initialize_binding(s, l, envRec, n$, v),\n                function(s, _pat_any_27) { \n                                           return (res_void(s));}));}));\n    }\n  } else {\n    return (\n      if_some(HeapStr.read_option(envRec, n), function(binding) {\n          \n          var mutability = binding[0], unused = binding[1];\n          if (binding_is_uninitialized(binding)) {\n            return (run_error_no_c(s, Coq_native_error_ref()));\n          } else {\n            return (\n              let_ret((function () {\n                  if (binding_is_mutable(binding)) {\n                    return (\n                      Continue(\n                        env_record_write_decl_env(s, l, n, mutability, v)));\n                  } else {\n                    if (str) {\n                      return (\n                        Return(run_error_no_c(s, Coq_native_error_type())));\n                    } else {\n                      return (Continue(s));\n                    }\n                  }}()), function(s) { \n                                       return (res_void(s));}));\n          }}));\n  }\n};\n\nvar decl_env_record_get_binding_value = function (s, envRec, n, str) {\n  var n = string_of_value(n);\n  return (\n    check_assert(HeapStr.indom_dec(envRec, n), function(_pat_any_29) {\n        \n        return (\n          if_some(HeapStr.read_option(envRec, n), function(binding) {\n              \n              var mutability = binding[0], v = binding[1];\n              if (mutability_compare(mutability,\n                    Coq_mutability_uninitialized_immutable())) {\n                return (run_error_no_c(s, Coq_native_error_ref()));\n              } else {\n                return (res_ter(s, res_val(v)));\n              }}));}));\n};\n\nvar object_env_record_set_mutable_binding = function (s, bindings, this, n, v, str) {\n  return (set(s, bindings, n, v, str));\n};\n\nvar object_env_record_get_binding_value = function (s, bindings, this, n, str) {\n  return (\n    if_bool(has_property(s, bindings, n), function(s, value) {\n        \n        if (!(value)) {\n          if (!(str)) {\n            return (res_ter(s, res_val(Coq_value_undef())));\n          } else {\n            return (run_error_no_c(s, Coq_native_error_ref()));\n          }\n        } else {\n          return (get(s, bindings, n));\n        }}));\n};\n\nvar get_global_object = function (s, ctx) {\n  var e = unsome_error(env_record_binds_option(s, env_loc_global_env_record));\n  switch (e.tag) {\n    case "Coq_env_record_object":\n      var l = e.value, this = e.provide_this;\n      return (Coq_value_object(l));\n    default:\n      throw false;\n  }\n  \n};\n\nvar ordinary_object_internal_get_prototype_of = function (s, o) {\n  return (\n    if_value(ordinary_get_prototype_of(s, o), function(s1, v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_get_prototype_of = function (s, o) {\n  return (\n    if_some(run_object_method(object_proto_, s, o), function(v) {\n        \n        return (res_spec(s, res_val(v)));}));\n};\n\nvar ordinary_object_internal_set_prototype_of = function (s, o, v) {\n  return (\n    if_value(ordinary_set_prototype_of(s, o, v), function(s1, v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_set_prototype_of = function (s, o, v) {\n  return (\n    check_assert((function () {\n        var _switch_arg_30 = type_of(v);\n        switch (_switch_arg_30.tag) {\n          case "Coq_type_object":\n            return (true);\n          case "Coq_type_null":\n            return (true);\n          default:\n            return (false);\n        }\n        }()), function(_pat_any_31) {\n        \n        return (\n          if_some(run_object_method(object_extensible_, s, o),\n            function(extensible) {\n              \n              return (\n                if_some(run_object_method(object_prototype_, s, o),\n                  function(current) {\n                    \n                    var sv = same_value(v, current);\n                    if (sv) {\n                      return (res_spec(s, res_val(Coq_value_bool(true))));\n                    } else {\n                      if (!(extensible)) {\n                        return (res_spec(s, res_val(Coq_value_bool(false))));\n                      } else {\n                        var repeat = function (p, done_) {\n                          if (!(done_)) {\n                            switch (p.tag) {\n                              case "Coq_value_null":\n                                return (repeat(p, true));\n                              case "Coq_value_object":\n                                var p_l = p.value;\n                                if (same_value(p, Coq_value_object(o))) {\n                                  return (\n                                    res_spec(s,\n                                      res_val(Coq_value_bool(false))));\n                                } else {\n                                  return (\n                                    if_some(\n                                      run_object_method(\n                                        object_get_prototype_of_, s, p_l),\n                                      function(gpo) {\n                                        \n                                        switch (gpo.tag) {\n                                          case "Coq_builtin_get_prototype_of_default":\n                                            return (\n                                              if_some(\n                                                run_object_method(\n                                                  object_prototype_, s, p_l),\n                                                function(prototype) {\n                                                  \n                                                  return (\n                                                    repeat(prototype, false));\n                                                }));\n                                          default:\n                                            return (repeat(p, true));\n                                        }\n                                        }));\n                                }\n                              default:\n                                throw false;\n                            }\n                            \n                          } else {\n                            return (\n                              if_some(\n                                run_object_set_internal(object_set_proto, s,\n                                  o, v), function(s$) {\n                                  \n                                  return (\n                                    res_spec(s$,\n                                      res_val(Coq_value_bool(true))));}));\n                          }\n                        };\n                        return (repeat(v, false));\n                      }\n                    }}));}));}));\n};\n\nvar ordinary_object_internal_is_extensible = function (s, o) {\n  return (\n    if_value(ordinary_is_extensible(s, o), function(s1, v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_is_extensible = function (s, o) {\n  return (\n    if_some(run_object_method(object_extensible_, s, o), function(b) {\n        \n        return (res_out(s, res_val(Coq_value_bool(b))));}));\n};\n\nvar ordinary_object_internal_prevent_extensions = function (s, o) {\n  return (\n    if_value(ordinary_prevent_extensions(s, o), function(s1, v) {\n        \n        return (res_out(s, res_val(v)));}));\n};\n\nvar ordinary_prevent_extensions = function (s, o) {\n  return (\n    if_some(run_object_set_internal(object_set_extensible, s, o, false),\n      function(s$) { \n                     return (res_spec(s, res_val(Coq_value_bool(true))));}));\n};\n\nvar ordinary_object_internal_get_own_property = function (s, o, p) {\n  return (ordinary_get_own_property(s, o, p));\n};\n\nvar ordinary_get_own_property = function (s, o, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_32) {\n        \n        var p = string_of_value(p);\n        if (!(object_property_exists(s, o, p))) {\n          return (res_spec(s, Descriptor_undef()));\n        } else {\n          var d = descriptor_intro_empty;\n          return (\n            if_some(object_retrieve_property(s, o, p), function(x) {\n                \n                switch (x.tag) {\n                  case "Coq_attributes_data_of":\n                    var x = x.value;\n                    var d = Object.assign({}, d, {\n                                descriptor_value: Some(\n                                                    x.attributes_data_value),\n                                descriptor_writable: Some(\n                                                       x.attributes_data_writable)\n                              });\n                    break;\n                  case "Coq_attributes_accessor_of":\n                    var x = x.value;\n                    var d = Object.assign({}, d, {\n                                descriptor_get: Some(\n                                                  x.attributes_accessor_get),\n                                descriptor_set: Some(\n                                                  x.attributes_accessor_set)\n                              });\n                    break;\n                }\n                \n                var d = Object.assign({}, d, {\n                            descriptor_enumerable: Some(\n                                                     attributes_enumerable(x))\n                          });\n                var d = Object.assign({}, d, {\n                            descriptor_configurable: Some(\n                                                       attributes_configurable(\n                                                         x))});\n                return (res_spec(s, Descriptor(d)));}));\n        }}));\n};\n\nvar ordinary_object_internal_define_own_property = function (s, o, p, desc) {\n  return (ordinary_define_own_property(s, o, p, desc));\n};\n\nvar ordinary_define_own_property = function (s, o, p, desc) {\n  return (\n    if_spec(object_internal_get_own_property(s, o, p), function(s, current) {\n        \n        return (\n          if_some(run_object_method(object_extensible_, s, o),\n            function(extensible) {\n              \n              return (\n                validate_and_apply_property_descriptor(s,\n                  Coq_value_object(o), p, extensible, desc, current));}));}));\n};\n\nvar is_compatible_property_descriptor = function (s, extensible, desc, current) {\n  return (\n    validate_and_apply_property_descriptor(s, Coq_value_undef(),\n      Coq_value_undef(), extensible, desc, current));\n};\n\nvar validate_and_apply_property_descriptor = function (s, o, p, extensible, desc, current) {\n  return (\n    check_assert((value_compare(o, Coq_value_undef()) || is_property_key(p)),\n      function(_pat_any_34) {\n        \n        var p = string_of_value(p);\n        switch (current.tag) {\n          case "Descriptor_undef":\n            if (!(extensible)) {\n              return (res_out(s, res_val(Coq_value_bool(false))));\n            } else {\n              return (\n                check_assert(extensible, function(_pat_any_33) {\n                    \n                    return (\n                      if_some((function () {\n                          switch (o.tag) {\n                            case "Coq_value_object":\n                              var l = o.value;\n                              if ((is_generic_descriptor(Descriptor(desc))\n                                  || is_data_descriptor(Descriptor(desc)))) {\n                                return (\n                                  object_set_property(s, l, p,\n                                    Coq_attributes_data_of(\n                                      attributes_data_of_descriptor(desc))));\n                              } else {\n                                return (\n                                  object_set_property(s, l, p,\n                                    Coq_attributes_accessor_of(\n                                      attributes_accessor_of_descriptor(desc))));\n                              }\n                            case "Coq_value_undef":\n                              return (Some(s));\n                            default:\n                              return (None());\n                          }\n                          }()), function(s) {\n                          \n                          return (res_ter(s, res_val(Coq_value_bool(true))));\n                        }));}));\n            }\n          case "Descriptor":\n            var current = current.descriptor;\n            return (\n              let_ret((function () {\n                  if (descriptor_is_empty(desc)) {\n                    return (\n                      Return(res_ter(s, res_val(Coq_value_bool(true)))));\n                  } else {\n                    return (Continue(s));\n                  }}()), function(s) {\n                  \n                  return (\n                    let_ret((function () {\n                        if (descriptor_contained_by(desc, current,\n                              same_value)) {\n                          return (\n                            Return(res_ter(s, res_val(Coq_value_bool(true)))));\n                        } else {\n                          return (Continue(s));\n                        }}()), function(s) {\n                        \n                        return (\n                          let_ret((function () {\n                              if (option_compare(bool_eq,\n                                    current.descriptor_configurable,\n                                    Some(false))) {\n                                if (option_compare(bool_eq,\n                                      desc.descriptor_configurable,\n                                      Some(true))) {\n                                  return (\n                                    Return(\n                                      res_ter(s,\n                                        res_val(Coq_value_bool(false)))));\n                                } else {\n                                  if ((is_some(desc.descriptor_enumerable)\n                                      && !(\n                                           some_compare(bool_eq,\n                                             current.descriptor_enumerable,\n                                             desc.descriptor_enumerable)))) {\n                                    return (\n                                      Return(\n                                        res_ter(s,\n                                          res_val(Coq_value_bool(false)))));\n                                  } else {\n                                    return (Continue(s));\n                                  }\n                                }\n                              } else {\n                                return (Continue(s));\n                              }}()), function(s) {\n                              \n                              return (\n                                let_ret((function () {\n                                    if (is_generic_descriptor(\n                                          Descriptor(desc))) {\n                                      return (Continue(s));\n                                    } else {\n                                      if (!(\n                                            bool_eq(\n                                              is_data_descriptor(\n                                                Descriptor(current)),\n                                              is_data_descriptor(\n                                                Descriptor(desc))))) {\n                                        if (option_compare(bool_eq,\n                                              current.descriptor_configurable,\n                                              Some(false))) {\n                                          return (\n                                            Return(\n                                              res_ter(s,\n                                                res_val(\n                                                  Coq_value_bool(false)))));\n                                        } else {\n                                          if (is_data_descriptor(\n                                                Descriptor(current))) {\n                                            var s = unsome_default(s,\n                                                      (function () {\n                                                        switch (o.tag) {\n                                                          case "Coq_value_object":\n                                                            var l = o.value;\n                                                            return (\n                                                              object_map_property(\n                                                                s, l, p,\n                                                                attributes_accessor_of_attributes_data));\n                                                          default:\n                                                            return (Some(s));\n                                                        }\n                                                        }()));\n                                            return (Continue(s));\n                                          } else {\n                                            var s = unsome_default(s,\n                                                      (function () {\n                                                        switch (o.tag) {\n                                                          case "Coq_value_object":\n                                                            var l = o.value;\n                                                            return (\n                                                              object_map_property(\n                                                                s, l, p,\n                                                                attributes_data_of_attributes_accessor));\n                                                          default:\n                                                            return (Some(s));\n                                                        }\n                                                        }()));\n                                            return (Continue(s));\n                                          }\n                                        }\n                                      } else {\n                                        if ((is_data_descriptor(\n                                               Descriptor(current))\n                                            && is_data_descriptor(\n                                                 Descriptor(desc)))) {\n                                          if (option_compare(bool_eq,\n                                                current.descriptor_configurable,\n                                                Some(false))) {\n                                            if ((option_compare(bool_eq,\n                                                   current.descriptor_writable,\n                                                   Some(false))\n                                                && option_compare(bool_eq,\n                                                     desc.descriptor_writable,\n                                                     Some(true)))) {\n                                              return (\n                                                Return(\n                                                  res_ter(s,\n                                                    res_val(\n                                                      Coq_value_bool(false)))));\n                                            } else {\n                                              if (option_compare(bool_eq,\n                                                    current.descriptor_writable,\n                                                    Some(false))) {\n                                                if ((is_some(\n                                                       desc.descriptor_value)\n                                                    && !(\n                                                         option_compare(\n                                                           same_value,\n                                                           desc.descriptor_value,\n                                                           current.descriptor_value)))) {\n                                                  return (\n                                                    Return(\n                                                      res_ter(s,\n                                                        res_val(\n                                                          Coq_value_bool(\n                                                            false)))));\n                                                } else {\n                                                  return (Continue(s));\n                                                }\n                                              } else {\n                                                return (Continue(s));\n                                              }\n                                            }\n                                          } else {\n                                            if (!(\n                                                  option_compare(bool_eq,\n                                                    current.descriptor_configurable,\n                                                    Some(true)))) {\n                                              return (\n                                                Return(\n                                                  spec_assertion_failure({})));\n                                            } else {\n                                              return (Continue(s));\n                                            }\n                                          }\n                                        } else {\n                                          if (!(\n                                                (is_accessor_descriptor(\n                                                   Descriptor(current))\n                                                && is_accessor_descriptor(\n                                                     Descriptor(desc))))) {\n                                            return (\n                                              Return(\n                                                spec_assertion_failure({})));\n                                          } else {\n                                            if (option_compare(bool_eq,\n                                                  current.descriptor_configurable,\n                                                  Some(false))) {\n                                              if ((is_some(\n                                                     desc.descriptor_set)\n                                                  && !(\n                                                       option_compare(\n                                                         same_value,\n                                                         desc.descriptor_set,\n                                                         current.descriptor_set)))) {\n                                                return (\n                                                  Return(\n                                                    res_ter(s,\n                                                      res_val(\n                                                        Coq_value_bool(false)))));\n                                              } else {\n                                                if ((is_some(\n                                                       desc.descriptor_get)\n                                                    && !(\n                                                         option_compare(\n                                                           same_value,\n                                                           desc.descriptor_get,\n                                                           current.descriptor_get)))) {\n                                                  return (\n                                                    Return(\n                                                      res_ter(s,\n                                                        res_val(\n                                                          Coq_value_bool(\n                                                            false)))));\n                                                } else {\n                                                  return (Continue(s));\n                                                }\n                                              }\n                                            } else {\n                                              return (Continue(s));\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }}()), function(s) {\n                                    \n                                    return (\n                                      if_some((function () {\n                                          switch (o.tag) {\n                                            case "Coq_value_object":\n                                              var l = o.value;\n                                              return (\n                                                object_map_property(s, l, p,\n                                                  function (a) {\n                                                    return (\n                                                      attributes_update(a,\n                                                        desc));}));\n                                            default:\n                                              return (Some(s));\n                                          }\n                                          }()), function(s) {\n                                          \n                                          return (\n                                            res_ter(s,\n                                              res_val(Coq_value_bool(true))));\n                                        }));}));}));}));}));\n        }\n        }));\n};\n\nvar ordinary_object_internal_has_property = function (s, o, p) {\n  return (ordinary_has_property(s, o, p));\n};\n\nvar ordinary_has_property = function (s, o, p) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_35) {\n        \n        return (\n          if_spec(object_internal_get_own_property(s, o, p), function(s,\n            hasOwn) {\n              \n              if (!(\n                    _compare_JsSyntax_undef_descriptor(hasOwn,\n                      Descriptor_undef()))) {\n                return (res_ter(s, res_val(Coq_value_bool(true))));\n              } else {\n                return (\n                  if_value(object_internal_get_prototype_of(s, o),\n                    function(s, parent) {\n                      \n                      if (!(\n                            _compare_JsSyntax_value(parent, Coq_value_null()))) {\n                        return (\n                          object_internal_has_property(s,\n                            loc_of_value(parent), p));\n                      } else {\n                        return (res_ter(s, res_val(Coq_value_bool(false))));\n                      }}));\n              }}));}));\n};\n\nvar ordinary_object_internal_set = function (s, o, p, v, receiver) {\n  return (ordinary_set(s, o, p, v, receiver));\n};\n\nvar ordinary_set = function (s, o, p, v, receiver) {\n  return (\n    check_assert(is_property_key(p), function(_pat_any_38) {\n        \n        return (\n          if_spec(object_internal_get_own_property(s, o, p), function(s,\n            ownDesc) {\n              \n              return (\n                let_ret((function () {\n                    if (_compare_JsSyntax_undef_descriptor(ownDesc,\n                          Descriptor_undef())) {\n                      return (\n                        if_value_ret(object_internal_get_prototype_of(s, o),\n                          function(s, parent) {\n                            \n                            if (!(\n                                  _compare_JsSyntax_value(parent,\n                                    Coq_value_null()))) {\n                              var parent = loc_of_value(parent);\n                              return (\n                                Return(\n                                  object_internal_set(s, parent, p, v,\n                                    receiver)));\n                            } else {\n                              return (\n                                Continue(\n                                  Descriptor({\n                                      descriptor_value: Some(\n                                                          Coq_value_undef()),\n                                      descriptor_writable: Some(false),\n                                      descriptor_get: None(),\n                                      descriptor_set: None(),\n                                      descriptor_enumerable: Some(true),\n                                      descriptor_configurable: Some(true)})));\n                            }}));\n                    } else {\n                      return (Continue(ownDesc));\n                    }}()), function(ownDesc) {\n                    \n                    if (is_data_descriptor(ownDesc)) {\n                      var ownDesc = descriptor_get_defined(ownDesc);\n                      return (\n                        if_some(ownDesc.descriptor_writable,\n                          function(writable) {\n                            \n                            if (writable) {\n                              return (\n                                res_ter(s, res_val(Coq_value_bool(false))));\n                            } else {\n                              if (!(\n                                    _compare_JsSyntax_coq_type(\n                                      type_of(receiver), Coq_type_object()))) {\n                                return (\n                                  res_ter(s, res_val(Coq_value_bool(false))));\n                              } else {\n                                var receiver = loc_of_value(receiver);\n                                return (\n                                  if_spec(\n                                    object_internal_get_own_property(s,\n                                      receiver, p), function(s,\n                                    existingDescriptor) {\n                                      \n                                      if (!(\n                                            _compare_JsSyntax_undef_descriptor(\n                                              existingDescriptor,\n                                              Descriptor_undef()))) {\n                                        if (is_accessor_descriptor(\n                                              existingDescriptor)) {\n                                          return (\n                                            res_ter(s,\n                                              res_val(Coq_value_bool(false))));\n                                        } else {\n                                          var existingDescriptor = descriptor_get_defined(\n                                                                    existingDescriptor);\n                                          return (\n                                            if_some(\n                                              existingDescriptor.descriptor_writable,\n                                              function(w) {\n                                                \n                                                if (!(w)) {\n                                                  return (\n                                                    res_ter(s,\n                                                      res_val(\n                                                        Coq_value_bool(false))));\n                                                } else {\n                                                  var valueDesc = descriptor_with_value(\n                                                                    descriptor_intro_empty,\n                                                                    Some(v));\n                                                  return (\n                                                    object_internal_define_own_property(\n                                                      s, receiver, p,\n                                                      valueDesc));\n                                                }}));\n                                        }\n                                      } else {\n                                        return (\n                                          create_data_property(s,\n                                            Coq_value_object(receiver), p, v));\n                                      }}));\n                              }\n                            }}));\n                    } else {\n                      return (\n                        check_assert(is_accessor_descriptor(ownDesc),\n                          function(_pat_any_37) {\n                            \n                            var ownDesc = descriptor_get_defined(ownDesc);\n                            return (\n                              if_some(ownDesc.descriptor_set,\n                                function(setter) {\n                                  \n                                  if (_compare_JsSyntax_value(setter,\n                                        Coq_value_undef())) {\n                                    return (\n                                      res_ter(s,\n                                        res_val(Coq_value_bool(false))));\n                                  } else {\n                                    return (\n                                      if_spec(\n                                        call(s, setter, receiver,\n                                          Some(mk_cons(v, mk_nil()))),\n                                        function(s, _pat_any_36) {\n                                          \n                                          return (\n                                            res_ter(s,\n                                              res_val(Coq_value_bool(true))));\n                                        }));\n                                  }}));}));\n                    }}));}));}));\n};\n\nvar ordinary_own_property_keys = function (s, c, l) {\n  return (\n    if_some(object_properties_keys_as_list_option(s, l), function(keys) {\n        \n        return (res_spec(s, keys));}));\n};\n\nvar object_has_prop = function (s, c, l, x) {\n  return (object_internal_has_property(s, l, Coq_value_string(x)));\n};\n\nvar out_error_or_void = function (s, c, str, ne) {\n  if (str) {\n    return (run_error(s, c, ne));\n  } else {\n    return (res_void(s));\n  }\n};\n\nvar out_error_or_cst = function (s, c, str, ne, v) {\n  if (str) {\n    return (run_error(s, c, ne));\n  } else {\n    return (res_out(s, res_val(v)));\n  }\n};\n\nvar object_get_builtin = function (s, c, b, vthis, l, x) {\n  var def = function (s0, l0) {\n    return (\n      if_spec(run_object_get_prop(s0, c, l0, x), function(s1, d) {\n          \n          switch (d.tag) {\n            case "Coq_full_descriptor_undef":\n              return (res_ter(s1, res_val(Coq_value_undef())));\n            case "Coq_full_descriptor_some":\n              var a = d.value;\n              switch (a.tag) {\n                case "Coq_attributes_data_of":\n                  var ad = a.value;\n                  return (res_ter(s1, res_val(ad.attributes_data_value)));\n                case "Coq_attributes_accessor_of":\n                  var aa = a.value;\n                  var _switch_arg_39 = aa.attributes_accessor_get;\n                  switch (_switch_arg_39.tag) {\n                    case "Coq_value_undef":\n                      return (res_ter(s1, res_val(Coq_value_undef())));\n                    case "Coq_value_null":\n                      return (Coq_result_impossible());\n                    case "Coq_value_bool":\n                      var b0 = _switch_arg_39.value;\n                      return (Coq_result_impossible());\n                    case "Coq_value_number":\n                      var n = _switch_arg_39.value;\n                      return (Coq_result_impossible());\n                    case "Coq_value_string":\n                      var s2 = _switch_arg_39.value;\n                      return (Coq_result_impossible());\n                    case "Coq_value_object":\n                      var lf = _switch_arg_39.value;\n                      return (run_call(s1, c, lf, vthis, mk_nil()));\n                  }\n                  \n              }\n              \n          }\n          }));\n  };\n  var function0 = function (s0) {\n    return (\n      if_value(def(s0, l), function(s_2, v) {\n          \n          if (spec_function_get_error_case_dec(s_2, x, v)) {\n            return (run_error(s_2, c, Coq_native_error_type()));\n          } else {\n            return (res_ter(s_2, res_val(v)));\n          }}));\n  };\n  switch (b.tag) {\n    case "Coq_builtin_get_default":\n      return (def(s, l));\n    case "Coq_builtin_get_function":\n      return (function0(s));\n    case "Coq_builtin_get_args_obj":\n      return (\n        if_some(run_object_method(object_parameter_map_, s, l),\n          function(lmapo) {\n            \n            return (\n              if_some(lmapo, function(lmap) {\n                  \n                  return (\n                    if_spec(run_object_get_own_prop(s, c, lmap, x),\n                      function(s0, d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (function0(s0));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (run_object_get(s0, c, lmap, x));\n                        }\n                        }));}));}));\n    default:\n      return (Coq_result_not_yet_implemented());\n  }\n  \n};\n\nvar run_object_get = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_, s, l), function(b) {\n        \n        return (object_get_builtin(s, c, b, Coq_value_object(l), l, x));}));\n};\n\nvar run_object_get_prop = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_prop_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_get_prop_default":\n            return (\n              if_spec(run_object_get_own_prop(s, c, l, x), function(s1, d) {\n                  \n                  if (full_descriptor_compare(d, Coq_full_descriptor_undef())) {\n                    return (\n                      if_some(run_object_method(object_proto_, s1, l),\n                        function(proto) {\n                          \n                          switch (proto.tag) {\n                            case "Coq_value_null":\n                              return (\n                                res_spec(s1, Coq_full_descriptor_undef()));\n                            case "Coq_value_object":\n                              var lproto = proto.value;\n                              return (run_object_get_prop(s1, c, lproto, x));\n                            default:\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s1,\n                                  "Found a non-object or null value as a prototype in [run_object_get_prop]."));\n                          }\n                          }));\n                  } else {\n                    return (res_spec(s1, d));\n                  }}));\n        }\n        }));\n};\n\nvar object_proto_is_prototype_of = function (s, l0, l) {\n  return (\n    if_some(run_object_method(object_proto_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_value_null":\n            return (res_out(s, res_val(Coq_value_bool(false))));\n          case "Coq_value_object":\n            var l_2 = b.value;\n            if (object_loc_compare(l_2, l0)) {\n              return (res_out(s, res_val(Coq_value_bool(true))));\n            } else {\n              return (object_proto_is_prototype_of(s, l0, l_2));\n            }\n          default:\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[run_object_method] returned a non-object in [object_proto_is_prototype_of_body]."));\n        }\n        }));\n};\n\nvar object_default_value = function (s, c, l, prefo) {\n  return (\n    if_some(run_object_method(object_default_value_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_default_value_default":\n            var gpref = unsome_default(Coq_preftype_number(), prefo);\n            var lpref = other_preftypes(gpref);\n            var sub0 = function (s_2, x, k) {\n              return (\n                if_value(run_object_get(s_2, c, l, x), function(s1, vfo) {\n                    \n                    return (\n                      if_some(run_callable(s1, vfo), function(co) {\n                          \n                          switch (co.tag) {\n                            case "Some":\n                              var b0 = co.value;\n                              return (\n                                if_object(res_out(s1, res_val(vfo)),\n                                  function(s2, lfunc) {\n                                    \n                                    return (\n                                      if_value(\n                                        run_call(s2, c, lfunc,\n                                          Coq_value_object(l), mk_nil()),\n                                        function(s3, v) {\n                                          \n                                          switch (v.tag) {\n                                            case "Coq_value_object":\n                                              var l0 = v.value;\n                                              return (k(s3));\n                                            default:\n                                              return (\n                                                res_out(s3, res_val(v)));\n                                          }\n                                          }));}));\n                            case "None":\n                              return (k(s1));\n                          }\n                          }));}));\n            };\n            var gmeth = method_of_preftype(gpref);\n            return (\n              sub0(s, gmeth, function (s_2) {\n                  var lmeth = method_of_preftype(lpref);\n                  return (\n                    sub0(s_2, lmeth, function (s_3) {\n                        return (run_error(s_3, c, Coq_native_error_type()));\n                      }));}));\n        }\n        }));\n};\n\nvar to_primitive = function (s, c, v, prefo) {\n  switch (v.tag) {\n    case "Coq_value_object":\n      var l = v.value;\n      return (\n        if_prim(object_default_value(s, c, l, prefo), function(s0, r) {\n            \n            return (res_ter(s0, res_val(r)));}));\n    default:\n      return (res_out(s, res_val(v)));\n  }\n  \n};\n\nvar to_number = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_object":\n      var l = _foo_.value;\n      return (\n        if_prim(\n          to_primitive(s, c, Coq_value_object(l),\n            Some(Coq_preftype_number())), function(s1, w) {\n            \n            return (\n              res_ter(s1,\n                res_val(Coq_value_number(convert_prim_to_number(w)))));}));\n    default:\n      return (\n        res_out(s, res_val(Coq_value_number(convert_prim_to_number(_foo_)))));\n  }\n  \n};\n\nvar to_integer = function (s, c, v) {\n  return (\n    if_number(to_number(s, c, v), function(s1, n) {\n        \n        return (\n          res_ter(s1,\n            res_val(Coq_value_number(convert_number_to_integer(n)))));}));\n};\n\nvar to_int32 = function (s, c, v) {\n  return (\n    if_number(to_number(s, c, v), function(s_2, n) {\n        \n        return (res_spec(s_2, JsNumber.to_int32(n)));}));\n};\n\nvar to_uint32 = function (s, c, v) {\n  return (\n    if_number(to_number(s, c, v), function(s_2, n) {\n        \n        return (res_spec(s_2, JsNumber.to_uint32(n)));}));\n};\n\nvar to_string = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_object":\n      var l = _foo_.value;\n      return (\n        if_prim(\n          to_primitive(s, c, Coq_value_object(l),\n            Some(Coq_preftype_string())), function(s1, w) {\n            \n            return (\n              res_ter(s1,\n                res_val(Coq_value_string(convert_prim_to_string(w)))));}));\n    default:\n      return (\n        res_out(s, res_val(Coq_value_string(convert_prim_to_string(_foo_)))));\n  }\n  \n};\n\nvar run_object_define_own_prop_array_loop = function (s, c, l, newLen, oldLen, newLenDesc, newWritable, throwcont, def) {\n  if ((newLen < oldLen)) {\n    var oldLen_2 = (oldLen - 1.);\n    return (\n      if_string(to_string(s, c, Coq_value_number(oldLen_2)), function(s0,\n        slen) {\n          \n          return (\n            if_bool(object_delete(s0, c, l, slen, false), function(s1,\n              deleteSucceeded) {\n                \n                if (!(deleteSucceeded)) {\n                  var newLenDesc0 = descriptor_with_value(newLenDesc,\n                                      Some(Coq_value_number((oldLen_2 + 1.))));\n                  if (!(newWritable)) {\n                    var newLenDesc1 = descriptor_with_writable(newLenDesc0,\n                                        Some(false));\n                  } else {\n                    var newLenDesc1 = newLenDesc0;\n                  }\n                  return (\n                    if_bool(def(s1, "length", newLenDesc1, false),\n                      function(s2, x) {\n                        \n                        return (\n                          out_error_or_cst(s2, c, throwcont,\n                            Coq_native_error_type(), Coq_value_bool(false)));\n                      }));\n                } else {\n                  return (\n                    run_object_define_own_prop_array_loop(s1, c, l, newLen,\n                      oldLen_2, newLenDesc, newWritable, throwcont, def));\n                }}));}));\n  } else {\n    if (!(newWritable)) {\n      return (\n        def(s, "length", {\n            descriptor_value: None(),\n            descriptor_writable: Some(false),\n            descriptor_get: None(),\n            descriptor_set: None(),\n            descriptor_enumerable: None(),\n            descriptor_configurable: None()}, false));\n    } else {\n      return (res_ter(s, res_val(Coq_value_bool(true))));\n    }\n  }\n};\n\nvar object_define_own_prop = function (s, c, l, x, desc, throwcont) {\n  var reject = function (s0, throwcont0) {\n    return (\n      out_error_or_cst(s0, c, throwcont0, Coq_native_error_type(),\n        Coq_value_bool(false)));\n  };\n  var def = function (s, p, d, _pat_any_40) {\n    return (ordinary_define_own_property(s, l, Coq_value_string(p), d));\n  };\n  return (\n    if_some(run_object_method(object_define_own_prop_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_define_own_prop_default":\n            return (\n              object_internal_define_own_property(s, l, Coq_value_string(x),\n                desc));\n          case "Coq_builtin_define_own_prop_array":\n            return (\n              if_spec(run_object_get_own_prop(s, c, l, "length"),\n                function(s0, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (\n                        function (s, m) {\n                            Debug.impossible_with_heap_because(__LOC__, s, m);\n                            return (Coq_result_impossible());}(s0,\n                          "Array length property descriptor cannot be undefined."));\n                    case "Coq_full_descriptor_some":\n                      var attr = d.value;\n                      switch (attr.tag) {\n                        case "Coq_attributes_data_of":\n                          var a = attr.value;\n                          var oldLen = a.attributes_data_value;\n                          switch (oldLen.tag) {\n                            case "Coq_value_object":\n                              var l0 = oldLen.value;\n                              Debug.impossible_with_heap_because(__LOC__, s0,\n                                "Spec asserts length of array is number.");\n                              return (Coq_result_impossible());\n                            default:\n                              var oldLen0 = JsNumber.to_uint32(\n                                              convert_prim_to_number(oldLen));\n                              var descValueOpt = desc.descriptor_value;\n                              if (string_eq(x, "length")) {\n                                switch (descValueOpt.tag) {\n                                  case "Some":\n                                    var descValue = descValueOpt.value;\n                                    return (\n                                      if_spec(to_uint32(s0, c, descValue),\n                                        function(s1, newLen) {\n                                          \n                                          return (\n                                            if_number(\n                                              to_number(s1, c, descValue),\n                                              function(s2, newLenN) {\n                                                \n                                                if (!((newLen === newLenN))) {\n                                                  return (\n                                                    run_error(s2, c,\n                                                      Coq_native_error_range(\n                                                        )));\n                                                } else {\n                                                  var newLenDesc = descriptor_with_value(\n                                                                    desc,\n                                                                    Some(\n                                                                    Coq_value_number(\n                                                                    newLen)));\n                                                  if (le_int_decidable(\n                                                        oldLen0, newLen)) {\n                                                    return (\n                                                      def(s2, "length",\n                                                        newLenDesc,\n                                                        throwcont));\n                                                  } else {\n                                                    if (!(\n                                                          a.attributes_data_writable)) {\n                                                      return (\n                                                        reject(s2, throwcont));\n                                                    } else {\n                                                      var _switch_arg_41 = newLenDesc.descriptor_writable;\n                                                      switch (_switch_arg_41.tag) {\n                                                        case "Some":\n                                                          var b0 = _switch_arg_41.value;\n                                                          if (b0) {\n                                                            var newWritable = true;\n                                                          } else {\n                                                            var newWritable = false;\n                                                          }\n                                                          break;\n                                                        case "None":\n                                                          var newWritable = true;\n                                                          break;\n                                                      }\n                                                      \n                                                      if (!(newWritable)) {\n                                                        var newLenDesc0 = \n                                                        descriptor_with_writable(\n                                                          newLenDesc,\n                                                          Some(true));\n                                                      } else {\n                                                        var newLenDesc0 = newLenDesc;\n                                                      }\n                                                      return (\n                                                        if_bool(\n                                                          def(s2, "length",\n                                                            newLenDesc0,\n                                                            throwcont),\n                                                          function(s3,\n                                                          succ) {\n                                                            \n                                                            if (!(succ)) {\n                                                              return (\n                                                                res_ter(s3,\n                                                                  res_val(\n                                                                    Coq_value_bool(\n                                                                    false))));\n                                                            } else {\n                                                              return (\n                                                                run_object_define_own_prop_array_loop(\n                                                                  s3, c, l,\n                                                                  newLen,\n                                                                  oldLen0,\n                                                                  newLenDesc0,\n                                                                  newWritable,\n                                                                  throwcont,\n                                                                  def));\n                                                            }}));\n                                                    }\n                                                  }\n                                                }}));}));\n                                  case "None":\n                                    return (\n                                      def(s0, "length", desc, throwcont));\n                                }\n                                \n                              } else {\n                                return (\n                                  if_spec(\n                                    to_uint32(s0, c, Coq_value_string(x)),\n                                    function(s1, ilen) {\n                                      \n                                      return (\n                                        if_string(\n                                          to_string(s1, c,\n                                            Coq_value_number(ilen)),\n                                          function(s2, slen) {\n                                            \n                                            if ((string_eq(x, slen)\n                                                && !((ilen == 4294967295.)))) {\n                                              return (\n                                                if_spec(\n                                                  to_uint32(s2, c,\n                                                    Coq_value_string(x)),\n                                                  function(s3, index) {\n                                                    \n                                                    if ((le_int_decidable(\n                                                           oldLen0, index)\n                                                        && !(\n                                                             a.attributes_data_writable))) {\n                                                      return (\n                                                        reject(s3, throwcont));\n                                                    } else {\n                                                      return (\n                                                        if_bool(\n                                                          def(s3, x, desc,\n                                                            false),\n                                                          function(s4, b0) {\n                                                            \n                                                            if (!(b0)) {\n                                                              return (\n                                                                reject(s4,\n                                                                  throwcont));\n                                                            } else {\n                                                              if (le_int_decidable(\n                                                                    oldLen0,\n                                                                    index)) {\n                                                                var a0 = \n                                                                descriptor_with_value(\n                                                                  descriptor_of_attributes(\n                                                                    Coq_attributes_data_of(\n                                                                    a)),\n                                                                  Some(\n                                                                    Coq_value_number(\n                                                                    (index\n                                                                    + 1.))));\n                                                                return (\n                                                                  def(s4,\n                                                                    "length",\n                                                                    a0,\n                                                                    false));\n                                                              } else {\n                                                                return (\n                                                                  res_ter(s4,\n                                                                    res_val(\n                                                                    Coq_value_bool(\n                                                                    true))));\n                                                              }\n                                                            }}));\n                                                    }}));\n                                            } else {\n                                              return (\n                                                def(s2, x, desc, throwcont));\n                                            }}));}));\n                              }\n                          }\n                          \n                        case "Coq_attributes_accessor_of":\n                          var a = attr.value;\n                          return (\n                            function (s, m) {\n                                Debug.impossible_with_heap_because(__LOC__,\n                                  s, m);\n                                return (Coq_result_impossible());}(s0,\n                              "Array length property descriptor cannot be accessor."));\n                      }\n                      \n                  }\n                  }));\n          case "Coq_builtin_define_own_prop_args_obj":\n            return (\n              if_some(run_object_method(object_parameter_map_, s, l),\n                function(lmapo) {\n                  \n                  return (\n                    if_some(lmapo, function(lmap) {\n                        \n                        return (\n                          if_spec(run_object_get_own_prop(s, c, lmap, x),\n                            function(s0, d) {\n                              \n                              return (\n                                if_bool(def(s0, x, desc, false), function(s1,\n                                  b0) {\n                                    \n                                    if (b0) {\n                                      var follow = function (s2) {\n                                        return (\n                                          res_ter(s2,\n                                            res_val(Coq_value_bool(true))));\n                                      };\n                                      switch (d.tag) {\n                                        case "Coq_full_descriptor_undef":\n                                          return (follow(s1));\n                                        case "Coq_full_descriptor_some":\n                                          var a = d.value;\n                                          if (is_accessor_descriptor(\n                                                Descriptor(desc))) {\n                                            return (\n                                              if_bool(\n                                                object_delete(s1, c, lmap, x,\n                                                  false), function(s2, x0) {\n                                                  \n                                                  return (follow(s2));}));\n                                          } else {\n                                            var follow0 = function (s2) {\n                                              if (option_compare(bool_eq,\n                                                    desc.descriptor_writable,\n                                                    Some(false))) {\n                                                return (\n                                                  if_bool(\n                                                    object_delete(s2, c,\n                                                      lmap, x, false),\n                                                    function(s3, x0) {\n                                                      \n                                                      return (follow(s3));}));\n                                              } else {\n                                                return (follow(s2));\n                                              }\n                                            };\n                                            var _switch_arg_42 = desc.descriptor_value;\n                                            switch (_switch_arg_42.tag) {\n                                              case "Some":\n                                                var v = _switch_arg_42.value;\n                                                return (\n                                                  if_void(\n                                                    object_put(s1, c, lmap,\n                                                      x, v, throwcont),\n                                                    function(s2) {\n                                                      \n                                                      return (follow0(s2));}));\n                                              case "None":\n                                                return (follow0(s1));\n                                            }\n                                            \n                                          }\n                                      }\n                                      \n                                    } else {\n                                      return (reject(s1, throwcont));\n                                    }}));}));}));}));\n          default:\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar prim_new_object = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      var o1 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_bool_proto())),\n                 "Boolean");\n      var o = object_with_primitive_value(o1, Coq_value_bool(b));\n      var _tuple_arg_43 = object_alloc(s, o);\n      var l = _tuple_arg_43[0], s1 = _tuple_arg_43[1];\n      return (res_out(s1, res_val(Coq_value_object(l))));\n    case "Coq_value_number":\n      var n = _foo_.value;\n      var o1 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_number_proto())),\n                 "Number");\n      var o = object_with_primitive_value(o1, Coq_value_number(n));\n      var _tuple_arg_44 = object_alloc(s, o);\n      var l = _tuple_arg_44[0], s1 = _tuple_arg_44[1];\n      return (res_out(s1, res_val(Coq_value_object(l))));\n    case "Coq_value_string":\n      var s0 = _foo_.value;\n      var o2 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_string_proto())),\n                 "String");\n      var o1 = object_with_get_own_property(o2,\n                 Coq_builtin_get_own_prop_string());\n      var o = object_with_primitive_value(o1, Coq_value_string(s0));\n      var _tuple_arg_45 = object_alloc(s, o);\n      var l = _tuple_arg_45[0], s1 = _tuple_arg_45[1];\n      return (\n        if_some(\n          run_object_heap_map_properties(s1, l, function (p) {\n              return (\n                HeapStr.write(p, "length",\n                  Coq_attributes_data_of(\n                    attributes_data_intro_constant(\n                      Coq_value_number(number_of_int(strlength(s0)))))));}),\n          function(s_2) {\n            \n            return (res_ter(s_2, res_val(Coq_value_object(l))));}));\n    default:\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "[prim_new_object] received an null or undef."));\n  }\n  \n};\n\nvar to_object = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_undef":\n      return (run_error_no_c(s, Coq_native_error_type()));\n    case "Coq_value_null":\n      return (run_error_no_c(s, Coq_native_error_type()));\n    case "Coq_value_bool":\n      var b = _foo_.value;\n      return (prim_new_object(s, _foo_));\n    case "Coq_value_number":\n      var n = _foo_.value;\n      return (prim_new_object(s, _foo_));\n    case "Coq_value_string":\n      var s0 = _foo_.value;\n      return (prim_new_object(s, _foo_));\n    case "Coq_value_object":\n      var l = _foo_.value;\n      return (res_out(s, res_val(Coq_value_object(l))));\n  }\n  \n};\n\nvar run_object_prim_value = function (s, l) {\n  return (\n    if_some(run_object_method(object_prim_value_, s, l), function(ov) {\n        \n        return (\n          if_some(ov, function(v) { \n                                    return (res_ter(s, res_val(v)));}));}));\n};\n\nvar prim_value_get = function (s, c, v, x) {\n  return (\n    if_object(to_object(s, v), function(s_2, l) {\n        \n        return (\n          object_get_builtin(s_2, c, Coq_builtin_get_default(), v, l, x));}));\n};\n\nvar env_record_has_binding = function (s, c, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              res_out(s, res_val(Coq_value_bool(HeapStr.indom_dec(ed, x)))));\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (object_has_prop(s, c, l0, x));\n        }\n        }));\n};\n\nvar lexical_env_get_identifier_ref = function (s, c, x, x0, str) {\n  switch (x.tag) {\n    case "[]":\n      return (res_spec(s, ref_create_value(Coq_value_undef(), x0, str)));\n    case "::":\n      var l = x.head, x_2 = x.tail;\n      return (\n        if_bool(env_record_has_binding(s, c, l, x0), function(s1, has) {\n            \n            if (has) {\n              return (res_spec(s1, ref_create_env_loc(l, x0, str)));\n            } else {\n              return (lexical_env_get_identifier_ref(s1, c, x_2, x0, str));\n            }}));\n  }\n  \n};\n\nvar object_delete_default = function (s, c, l, x, str) {\n  return (\n    if_spec(run_object_get_own_prop(s, c, l, x), function(s1, d) {\n        \n        switch (d.tag) {\n          case "Coq_full_descriptor_undef":\n            return (res_ter(s1, res_val(Coq_value_bool(true))));\n          case "Coq_full_descriptor_some":\n            var a = d.value;\n            if (attributes_configurable(a)) {\n              return (\n                if_some(\n                  run_object_heap_map_properties(s1, l, function (p) {\n                      return (HeapStr.rem(p, x));}), function(s_2) {\n                    \n                    return (res_ter(s_2, res_val(Coq_value_bool(true))));}));\n            } else {\n              return (\n                out_error_or_cst(s1, c, str, Coq_native_error_type(),\n                  Coq_value_bool(false)));\n            }\n        }\n        }));\n};\n\nvar object_delete = function (s, c, l, x, str) {\n  return (\n    if_some(run_object_method(object_delete_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_delete_default":\n            return (object_delete_default(s, c, l, x, str));\n          case "Coq_builtin_delete_args_obj":\n            return (\n              if_some(run_object_method(object_parameter_map_, s, l),\n                function(mo) {\n                  \n                  return (\n                    if_some(mo, function(m) {\n                        \n                        return (\n                          if_spec(run_object_get_own_prop(s, c, m, x),\n                            function(s1, d) {\n                              \n                              return (\n                                if_bool(\n                                  object_delete_default(s1, c, l, x, str),\n                                  function(s2, b0) {\n                                    \n                                    if (b0) {\n                                      switch (d.tag) {\n                                        case "Coq_full_descriptor_undef":\n                                          return (\n                                            res_ter(s2,\n                                              res_val(Coq_value_bool(b0))));\n                                        case "Coq_full_descriptor_some":\n                                          var a = d.value;\n                                          return (\n                                            if_bool(\n                                              object_delete(s2, c, m, x,\n                                                false), function(s3, b_2) {\n                                                \n                                                return (\n                                                  res_ter(s3,\n                                                    res_val(\n                                                      Coq_value_bool(b0))));\n                                              }));\n                                      }\n                                      \n                                    } else {\n                                      return (\n                                        res_ter(s2,\n                                          res_val(Coq_value_bool(b0))));\n                                    }}));}));}));}));\n          default:\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar env_record_delete_binding = function (s, c, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            var _switch_arg_46 = HeapStr.read_option(ed, x);\n            switch (_switch_arg_46.tag) {\n              case "Some":\n                var p = _switch_arg_46.value;\n                var mu = p[0], v = p[1];\n                switch (mu.tag) {\n                  case "Coq_mutability_uninitialized_immutable":\n                    return (res_out(s, res_val(Coq_value_bool(false))));\n                  case "Coq_mutability_immutable":\n                    return (res_out(s, res_val(Coq_value_bool(false))));\n                  case "Coq_mutability_nondeletable":\n                    return (res_out(s, res_val(Coq_value_bool(false))));\n                  case "Coq_mutability_deletable":\n                    var s_2 = env_record_write(s, l,\n                                Coq_env_record_decl(\n                                  decl_env_record_rem(ed, x)));\n                    return (res_out(s_2, res_val(Coq_value_bool(true))));\n                }\n                \n              case "None":\n                return (res_out(s, res_val(Coq_value_bool(true))));\n            }\n            \n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (object_delete(s, c, l0, x, throw_false));\n        }\n        }));\n};\n\nvar env_record_implicit_this_value = function (s, l) {\n  return (\n    ifx_some_or_default(env_record_binds_option(s, l), None(), function (e) {\n        return (\n          Some((function () {\n              switch (e.tag) {\n                case "Coq_env_record_decl":\n                  var ed = e.value;\n                  return (Coq_value_undef());\n                case "Coq_env_record_object":\n                  var l0 = e.value, provide_this = e.provide_this;\n                  if (provide_this) {\n                    return (Coq_value_object(l0));\n                  } else {\n                    return (Coq_value_undef());\n                  }\n              }\n              }())));}));\n};\n\nvar identifier_resolution = function (s, c, x) {\n  var x0 = c.execution_ctx_lexical_env;\n  var str = c.execution_ctx_strict;\n  return (lexical_env_get_identifier_ref(s, c, x0, x, str));\n};\n\nvar env_record_get_binding_value = function (s, c, l, x, str) {\n  return (get_binding_value(s, l, Coq_value_string(x), str));\n};\n\nvar ref_get_value = function (s, c, _foo_) {\n  return (\n    if_value(get_value(s, res_ter(s, res_normal(_foo_))), function(s, v) {\n        \n        return (res_spec(s, v));}));\n};\n\nvar run_expr_get_value = function (s, c, e) {\n  return (\n    if_value(get_value(s, run_expr(s, c, e)), function(s, v) {\n        \n        return (res_spec(s, v));}));\n};\n\nvar env_record_set_mutable_binding = function (s, c, l, x, v, str) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              if_some(HeapStr.read_option(ed, x), function(rm) {\n                  \n                  var mu = rm[0], v_old = rm[1];\n                  if (!(mutability_compare(mu, Coq_mutability_immutable()))) {\n                    return (\n                      res_void(env_record_write_decl_env(s, l, x, mu, v)));\n                  } else {\n                    return (\n                      out_error_or_void(s, c, str, Coq_native_error_type()));\n                  }}));\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (object_put(s, c, l0, x, v, str));\n        }\n        }));\n};\n\nvar prim_value_put = function (s, c, w, x, v, str) {\n  throw false;\n};\n\nvar ref_put_value = function (s, c, rv, v) {\n  switch (rv.tag) {\n    case "Coq_resvalue_empty":\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "[ref_put_value] received an empty result."));\n    case "Coq_resvalue_value":\n      var v0 = rv.value;\n      return (run_error(s, c, Coq_native_error_ref()));\n    case "Coq_resvalue_ref":\n      var r = rv.ref;\n      if (ref_kind_comparable(ref_kind_of(r), Coq_ref_kind_undef())) {\n        if (r.ref_strict) {\n          return (run_error(s, c, Coq_native_error_ref()));\n        } else {\n          return (\n            object_put(s, c, Coq_object_loc_prealloc(Coq_prealloc_global()),\n              r.ref_name, v, throw_false));\n        }\n      } else {\n        if ((ref_kind_comparable(ref_kind_of(r),\n               Coq_ref_kind_primitive_base())\n            || (ref_kind_comparable(ref_kind_of(r), Coq_ref_kind_null())\n               || ref_kind_comparable(ref_kind_of(r), Coq_ref_kind_object())))) {\n          var _switch_arg_48 = r.ref_base;\n          switch (_switch_arg_48.tag) {\n            case "Coq_ref_base_type_value":\n              var v_2 = _switch_arg_48.value;\n              if (ref_kind_comparable(ref_kind_of(r),\n                    Coq_ref_kind_primitive_base())) {\n                switch (v_2.tag) {\n                  case "Coq_value_object":\n                    var o = v_2.value;\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s,\n                        "[ref_put_value] impossible case"));\n                  default:\n                    return (\n                      prim_value_put(s, c, v_2, r.ref_name, v, r.ref_strict));\n                }\n                \n              } else {\n                switch (v_2.tag) {\n                  case "Coq_value_object":\n                    var l = v_2.value;\n                    return (\n                      object_put(s, c, l, r.ref_name, v, r.ref_strict));\n                  default:\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s,\n                        "[ref_put_value] impossible case"));\n                }\n                \n              }\n            case "Coq_ref_base_type_env_loc":\n              var l = _switch_arg_48.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "[ref_put_value] contradicts ref_is_property"));\n          }\n          \n        } else {\n          var _switch_arg_47 = r.ref_base;\n          switch (_switch_arg_47.tag) {\n            case "Coq_ref_base_type_value":\n              var v0 = _switch_arg_47.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "[ref_put_value] impossible spec"));\n            case "Coq_ref_base_type_env_loc":\n              var l = _switch_arg_47.value;\n              return (\n                env_record_set_mutable_binding(s, c, l, r.ref_name, v,\n                  r.ref_strict));\n          }\n          \n        }\n      }\n  }\n  \n};\n\nvar env_record_create_mutable_binding = function (s, c, l, x, deletable_opt) {\n  var deletable = unsome_default(false, deletable_opt);\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            if (HeapStr.indom_dec(ed, x)) {\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Already declared environnment record in [env_record_create_mutable_binding]."));\n            } else {\n              var s_2 = env_record_write_decl_env(s, l, x,\n                          mutability_of_bool(deletable), Coq_value_undef());\n              return (res_void(s_2));\n            }\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (\n              if_bool(object_has_prop(s, c, l0, x), function(s1, has) {\n                  \n                  if (has) {\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s1,\n                        "Already declared binding in [env_record_create_mutable_binding]."));\n                  } else {\n                    var a = {\n                      attributes_data_value: Coq_value_undef(),\n                      attributes_data_writable: true,\n                      attributes_data_enumerable: true,\n                      attributes_data_configurable: deletable\n                    };\n                    return (\n                      if_success(\n                        object_define_own_prop(s1, c, l0, x,\n                          descriptor_of_attributes(Coq_attributes_data_of(a)),\n                          throw_true), function(s2, rv) {\n                          \n                          return (res_void(s2));}));\n                  }}));\n        }\n        }));\n};\n\nvar env_record_create_set_mutable_binding = function (s, c, l, x, deletable_opt, v, str) {\n  return (\n    if_void(env_record_create_mutable_binding(s, c, l, x, deletable_opt),\n      function(s0) {\n        \n        return (env_record_set_mutable_binding(s0, c, l, x, v, str));}));\n};\n\nvar env_record_create_immutable_binding = function (s, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            if (HeapStr.indom_dec(ed, x)) {\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Already declared environnment record in [env_record_create_immutable_binding]."));\n            } else {\n              return (\n                res_void(\n                  env_record_write_decl_env(s, l, x,\n                    Coq_mutability_uninitialized_immutable(),\n                    Coq_value_undef())));\n            }\n          case "Coq_env_record_object":\n            var o = e.value, p = e.provide_this;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[env_record_create_immutable_binding] received an environnment record object."));\n        }\n        }));\n};\n\nvar env_record_initialize_immutable_binding = function (s, l, x, v) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              if_some(decl_env_record_option(ed, x), function(evs) {\n                  \n                  if (prod_compare(mutability_compare, value_compare, evs,\n                        [Coq_mutability_uninitialized_immutable(), Coq_value_undef(\n                                                                    )])) {\n                    var s_2 = env_record_write_decl_env(s, l, x,\n                                Coq_mutability_immutable(), v);\n                    return (res_void(s_2));\n                  } else {\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s,\n                        "Non suitable binding in [env_record_initialize_immutable_binding]."));\n                  }}));\n          case "Coq_env_record_object":\n            var o = e.value, p = e.provide_this;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[env_record_initialize_immutable_binding] received an environnment record object."));\n        }\n        }));\n};\n\nvar call_object_new = function (s, c, v) {\n  var _switch_arg_49 = type_of(v);\n  switch (_switch_arg_49.tag) {\n    case "Coq_type_undef":\n      var o = object_new(\n                Coq_value_object(\n                  Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                "Object");\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      return (res_out(s_2, res_val(Coq_value_object(l))));\n    case "Coq_type_null":\n      var o = object_new(\n                Coq_value_object(\n                  Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                "Object");\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      return (res_out(s_2, res_val(Coq_value_object(l))));\n    case "Coq_type_bool":\n      return (to_object(s, v));\n    case "Coq_type_number":\n      return (to_object(s, v));\n    case "Coq_type_string":\n      return (to_object(s, v));\n    case "Coq_type_object":\n      return (res_out(s, res_val(v)));\n  }\n  \n};\n\nvar array_args_map_loop = function (s, c, l, args, ind) {\n  switch (args.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var h = args.head, rest = args.tail;\n      return (\n        if_some(\n          run_object_heap_map_properties(s, l, function (p) {\n              return (\n                HeapStr.write(p, JsNumber.to_string(ind),\n                  Coq_attributes_data_of(attributes_data_intro_all_true(h))));\n            }), function(s_2) {\n            \n            return (array_args_map_loop(s_2, c, l, rest, (ind + 1.)));}));\n  }\n  \n};\n\nvar run_construct_prealloc = function (s, c, b, args) {\n  switch (b.tag) {\n    case "Coq_prealloc_object":\n      var v = get_arg(0, args);\n      return (call_object_new(s, c, v));\n    case "Coq_prealloc_bool":\n      var v = get_arg(0, args);\n      var b0 = to_boolean(v);\n      var o1 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_bool_proto())),\n                 "Boolean");\n      var o = object_with_primitive_value(o1, Coq_value_bool(b0));\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      return (res_out(s_2, res_val(Coq_value_object(l))));\n    case "Coq_prealloc_number":\n      var follow = function (s_2, v) {\n        var o1 = object_new(\n                   Coq_value_object(\n                     Coq_object_loc_prealloc(Coq_prealloc_number_proto())),\n                   "Number");\n        var o = object_with_primitive_value(o1, v);\n        var _tuple_arg_50 = object_alloc(s_2, o);\n        var l = _tuple_arg_50[0], s1 = _tuple_arg_50[1];\n        return (res_out(s1, res_val(Coq_value_object(l))));\n      };\n      if (list_eq_nil_decidable(args)) {\n        return (follow(s, Coq_value_number(JsNumber.zero)));\n      } else {\n        var v = get_arg(0, args);\n        return (\n          if_number(to_number(s, c, v), function(x, x0) {\n              \n              return (follow(x, Coq_value_number(x0)));}));\n      }\n    case "Coq_prealloc_array":\n      var o_2 = object_new(\n                  Coq_value_object(\n                    Coq_object_loc_prealloc(Coq_prealloc_array_proto())),\n                  "Array");\n      var o = object_for_array(o_2, Coq_builtin_define_own_prop_array());\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      var follow = function (s_3, length0) {\n        return (\n          if_some(\n            run_object_heap_map_properties(s_3, l, function (p0) {\n                return (\n                  HeapStr.write(p0, "length",\n                    Coq_attributes_data_of({\n                        attributes_data_value: Coq_value_number(length0),\n                        attributes_data_writable: true,\n                        attributes_data_enumerable: false,\n                        attributes_data_configurable: false})));}),\n            function(s0) {\n              \n              return (res_ter(s0, res_val(Coq_value_object(l))));}));\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 1)) {\n        var v = get_arg(0, args);\n        switch (v.tag) {\n          case "Coq_value_undef":\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p1) {\n                    return (\n                      HeapStr.write(p1, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n          case "Coq_value_null":\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p1) {\n                    return (\n                      HeapStr.write(p1, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n          case "Coq_value_bool":\n            var b0 = v.value;\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p1) {\n                    return (\n                      HeapStr.write(p1, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n          case "Coq_value_number":\n            var vlen = v.value;\n            return (\n              if_spec(to_uint32(s_2, c, Coq_value_number(vlen)), function(s0,\n                ilen) {\n                  \n                  if ((ilen === vlen)) {\n                    return (follow(s0, ilen));\n                  } else {\n                    return (run_error(s0, c, Coq_native_error_range()));\n                  }}));\n          case "Coq_value_string":\n            var s0 = v.value;\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p1) {\n                    return (\n                      HeapStr.write(p1, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s1) { \n                               return (follow(s1, 1.0));}));\n          case "Coq_value_object":\n            var o0 = v.value;\n            return (\n              if_some(\n                run_object_heap_map_properties(s_2, l, function (p0) {\n                    return (\n                      HeapStr.write(p0, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n        }\n        \n      } else {\n        return (\n          if_some(\n            run_object_heap_map_properties(s_2, l, function (p0) {\n                return (\n                  HeapStr.write(p0, "length",\n                    Coq_attributes_data_of({\n                        attributes_data_value: Coq_value_number(\n                                                 number_of_int(arg_len)),\n                        attributes_data_writable: true,\n                        attributes_data_enumerable: false,\n                        attributes_data_configurable: false})));}),\n            function(s0) {\n              \n              return (\n                if_void(array_args_map_loop(s0, c, l, args, 0.),\n                  function(s1) {\n                    \n                    return (res_ter(s1, res_val(Coq_value_object(l))));}));}));\n      }\n    case "Coq_prealloc_string":\n      var o2 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_string_proto())),\n                 "String");\n      var o1 = object_with_get_own_property(o2,\n                 Coq_builtin_get_own_prop_string());\n      var follow = function (s0, s1) {\n        var o = object_with_primitive_value(o1, Coq_value_string(s1));\n        var _tuple_arg_51 = object_alloc(s0, o);\n        var l = _tuple_arg_51[0], s2 = _tuple_arg_51[1];\n        var lenDesc = attributes_data_intro_constant(\n                        Coq_value_number(number_of_int(strlength(s1))));\n        return (\n          if_some(\n            run_object_heap_map_properties(s2, l, function (p) {\n                return (\n                  HeapStr.write(p, "length", Coq_attributes_data_of(lenDesc)));\n              }), function(s_2) {\n              \n              return (res_ter(s_2, res_val(Coq_value_object(l))));}));\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 0)) {\n        return (follow(s, ""));\n      } else {\n        var arg = get_arg(0, args);\n        return (\n          if_string(to_string(s, c, arg), function(s0, s1) {\n              \n              return (follow(s0, s1));}));\n      }\n    case "Coq_prealloc_error":\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_error_proto())), v));\n    case "Coq_prealloc_native_error":\n      var ne = b.error;\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))), v));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}(\n          strappend("Construct prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented."))));\n  }\n  \n};\n\nvar run_construct_default = function (s, c, l, args) {\n  return (\n    if_value(run_object_get(s, c, l, "prototype"), function(s1, v1) {\n        \n        if (type_compare(type_of(v1), Coq_type_object())) {\n          var vproto = v1;\n        } else {\n          var vproto = Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_object_proto()));\n        }\n        var o = object_new(vproto, "Object");\n        var p = object_alloc(s1, o);\n        var l_2 = p[0], s2 = p[1];\n        return (\n          if_value(run_call(s2, c, l, Coq_value_object(l_2), args),\n            function(s3, v2) {\n              \n              if (type_compare(type_of(v2), Coq_type_object())) {\n                var vr = v2;\n              } else {\n                var vr = Coq_value_object(l_2);\n              }\n              return (res_ter(s3, res_val(vr)));}));}));\n};\n\nvar run_construct = function (s, c, co, l, args) {\n  switch (co.tag) {\n    case "Coq_construct_default":\n      return (run_construct_default(s, c, l, args));\n    case "Coq_construct_after_bind":\n      return (\n        if_some(run_object_method(object_target_function_, s, l),\n          function(otrg) {\n            \n            return (\n              if_some(otrg, function(target) {\n                  \n                  return (\n                    if_some(run_object_method(object_construct_, s, target),\n                      function(oco) {\n                        \n                        switch (oco.tag) {\n                          case "Some":\n                            var co0 = oco.value;\n                            return (\n                              if_some(\n                                run_object_method(object_bound_args_, s, l),\n                                function(oarg) {\n                                  \n                                  return (\n                                    if_some(oarg, function(boundArgs) {\n                                        \n                                        var arguments_ = LibList.append(\n                                                           boundArgs, args);\n                                        return (\n                                          run_construct(s, c, co0, target,\n                                            arguments_));}));}));\n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));}));}));\n    case "Coq_construct_prealloc":\n      var b = co.prealloc;\n      return (run_construct_prealloc(s, c, b, args));\n    default:\n      return (Coq_result_not_yet_implemented());\n  }\n  \n};\n\nvar run_call_default = function (s, c, lf) {\n  var def = res_out(s, res_val(Coq_value_undef()));\n  return (\n    if_some(run_object_method(object_code_, s, lf), function(oC) {\n        \n        switch (oC.tag) {\n          case "Some":\n            var bd = oC.value;\n            if (list_eq_nil_decidable(prog_elements(funcbody_prog(bd)))) {\n              return (def);\n            } else {\n              return (\n                ifx_success_or_return(run_prog(s, c, funcbody_prog(bd)),\n                  function (s_2) {\n                    return (res_out(s_2, res_val(Coq_value_undef())));},\n                  function (s_2, rv) { return (res_out(s_2, res_normal(rv)));\n                  }));\n            }\n          case "None":\n            return (def);\n        }\n        }));\n};\n\nvar creating_function_object_proto = function (s, c, l) {\n  return (\n    if_object(run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n      function(s1, lproto) {\n        \n        var a1 = {\n          attributes_data_value: Coq_value_object(l),\n          attributes_data_writable: true,\n          attributes_data_enumerable: false,\n          attributes_data_configurable: true\n        };\n        return (\n          if_bool(\n            object_define_own_prop(s1, c, lproto, "constructor",\n              descriptor_of_attributes(Coq_attributes_data_of(a1)), false),\n            function(s2, b) {\n              \n              var a2 = {\n                attributes_data_value: Coq_value_object(lproto),\n                attributes_data_writable: true,\n                attributes_data_enumerable: false,\n                attributes_data_configurable: false\n              };\n              return (\n                object_define_own_prop(s2, c, l, "prototype",\n                  descriptor_of_attributes(Coq_attributes_data_of(a2)),\n                  false));}));}));\n};\n\nvar creating_function_object = function (s, c, names, bd, x, str) {\n  var o = object_new(\n            Coq_value_object(\n              Coq_object_loc_prealloc(Coq_prealloc_function_proto())),\n            "Function");\n  var o1 = object_with_get(o, Coq_builtin_get_function());\n  var o2 = object_with_invokation(o1, Some(Coq_construct_default()),\n             Some(Coq_call_default()),\n             Some(Coq_builtin_has_instance_function()));\n  var o3 = object_with_details(o2, Some(x), Some(names), Some(bd), None(),\n             None(), None(), None());\n  var p = object_alloc(s, o3);\n  var l = p[0], s1 = p[1];\n  var a1 = {\n    attributes_data_value: Coq_value_number(\n                             number_of_int(LibList.length(names))),\n    attributes_data_writable: false,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  return (\n    if_bool(\n      object_define_own_prop(s1, c, l, "length",\n        descriptor_of_attributes(Coq_attributes_data_of(a1)), false),\n      function(s2, b2) {\n        \n        return (\n          if_bool(creating_function_object_proto(s2, c, l), function(s3,\n            b3) {\n              \n              if (!(str)) {\n                return (res_ter(s3, res_val(Coq_value_object(l))));\n              } else {\n                var vthrower = Coq_value_object(\n                                 Coq_object_loc_prealloc(\n                                   Coq_prealloc_throw_type_error()));\n                var a2 = {\n                  attributes_accessor_get: vthrower,\n                  attributes_accessor_set: vthrower,\n                  attributes_accessor_enumerable: false,\n                  attributes_accessor_configurable: false\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s3, c, l, "caller",\n                      descriptor_of_attributes(\n                        Coq_attributes_accessor_of(a2)), false), function(s4,\n                    b4) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s4, c, l, "arguments",\n                            descriptor_of_attributes(\n                              Coq_attributes_accessor_of(a2)), false),\n                          function(s5, b5) {\n                            \n                            return (\n                              res_ter(s5, res_val(Coq_value_object(l))));}));\n                    }));\n              }}));}));\n};\n\nvar binding_inst_formal_params = function (s, c, l, args, names, str) {\n  switch (names.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var argname = names.head, names_2 = names.tail;\n      var v = hd(Coq_value_undef(), args);\n      var args_2 = tl(args);\n      return (\n        if_bool(env_record_has_binding(s, c, l, argname), function(s1, hb) {\n            \n            var follow = function (s_2) {\n              return (\n                if_void(\n                  env_record_set_mutable_binding(s_2, c, l, argname, v, str),\n                  function(s_3) {\n                    \n                    return (\n                      binding_inst_formal_params(s_3, c, l, args_2, names_2,\n                        str));}));\n            };\n            if (hb) {\n              return (follow(s1));\n            } else {\n              return (\n                if_void(\n                  env_record_create_mutable_binding(s1, c, l, argname,\n                    None()), function(s2) { \n                                            return (follow(s2));}));\n            }}));\n  }\n  \n};\n\nvar binding_inst_function_decls = function (s, c, l, fds, str, bconfig) {\n  switch (fds.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var fd = fds.head, fds_2 = fds.tail;\n      var fbd = fd.funcdecl_body;\n      var str_fd = funcbody_is_strict(fbd);\n      var fparams = fd.funcdecl_parameters;\n      var fname = fd.funcdecl_name;\n      return (\n        if_object(\n          creating_function_object(s, c, fparams, fbd,\n            c.execution_ctx_variable_env, str_fd), function(s1, fo) {\n            \n            var follow = function (s2) {\n              return (\n                if_void(\n                  env_record_set_mutable_binding(s2, c, l, fname,\n                    Coq_value_object(fo), str), function(s3) {\n                    \n                    return (\n                      binding_inst_function_decls(s3, c, l, fds_2, str,\n                        bconfig));}));\n            };\n            return (\n              if_bool(env_record_has_binding(s1, c, l, fname), function(s2,\n                has) {\n                  \n                  if (has) {\n                    if (nat_eq(l, env_loc_global_env_record)) {\n                      return (\n                        if_spec(\n                          run_object_get_prop(s2, c,\n                            Coq_object_loc_prealloc(Coq_prealloc_global()),\n                            fname), function(s3, d) {\n                            \n                            switch (d.tag) {\n                              case "Coq_full_descriptor_undef":\n                                return (\n                                  function (s, m) {\n                                      Debug.impossible_with_heap_because(\n                                        __LOC__, s, m);\n                                      return (Coq_result_impossible());}(s3,\n                                    "Undefined full descriptor in [binding_inst_function_decls]."));\n                              case "Coq_full_descriptor_some":\n                                var a = d.value;\n                                if (attributes_configurable(a)) {\n                                  var a_2 = {\n                                    attributes_data_value: Coq_value_undef(),\n                                    attributes_data_writable: true,\n                                    attributes_data_enumerable: true,\n                                    attributes_data_configurable: bconfig\n                                  };\n                                  return (\n                                    if_bool(\n                                      object_define_own_prop(s3, c,\n                                        Coq_object_loc_prealloc(\n                                          Coq_prealloc_global()), fname,\n                                        descriptor_of_attributes(\n                                          Coq_attributes_data_of(a_2)), true),\n                                      function(s0, x) { \n                                                        return (follow(s0));\n                                      }));\n                                } else {\n                                  if ((is_accessor_descriptor(\n                                         Descriptor(\n                                           descriptor_of_attributes(a)))\n                                      || (!(attributes_writable(a))\n                                         || !(attributes_enumerable(a))))) {\n                                    return (\n                                      run_error(s3, c,\n                                        Coq_native_error_type()));\n                                  } else {\n                                    return (follow(s3));\n                                  }\n                                }\n                            }\n                            }));\n                    } else {\n                      return (follow(s2));\n                    }\n                  } else {\n                    return (\n                      if_void(\n                        env_record_create_mutable_binding(s2, c, l, fname,\n                          Some(bconfig)), function(s3) { \n                                                         return (follow(s3));\n                        }));\n                  }}));}));\n  }\n  \n};\n\nvar make_arg_getter = function (s, c, x, x0) {\n  var xbd = strappend("return ", strappend(x, ";"));\n  var bd = Coq_funcbody_intro(\n             Coq_prog_intro(true,\n               mk_cons(\n                 Coq_element_stat(\n                   Coq_stat_return(Some(Coq_expr_identifier(x)))), mk_nil())),\n             xbd);\n  return (creating_function_object(s, c, mk_nil(), bd, x0, true));\n};\n\nvar make_arg_setter = function (s, c, x, x0) {\n  var xparam = strappend(x, "_arg");\n  var xbd = strappend(x, strappend(" = ", strappend(xparam, ";")));\n  var bd = Coq_funcbody_intro(\n             Coq_prog_intro(true,\n               mk_cons(\n                 Coq_element_stat(\n                   Coq_stat_expr(\n                     Coq_expr_assign(Coq_expr_identifier(x), None(),\n                       Coq_expr_identifier(xparam)))), mk_nil())), xbd);\n  return (\n    creating_function_object(s, c, mk_cons(xparam, mk_nil()), bd, x0, true));\n};\n\nvar arguments_object_map_loop = function (s, c, l, xs, len, args, x, str, lmap, xsmap) {\n  return (\n    function (fO, fS, n) {\n        if (int_eq(n, 0)) {\n          return (fO({}));\n        } else {\n          return (fS((n - 1)));\n        }}(function (_pat_any_52) {\n        if (list_eq_nil_decidable(xsmap)) {\n          return (res_void(s));\n        } else {\n          return (\n            if_some(object_binds_option(s, l), function(o) {\n                \n                var o_2 = object_for_args_object(o, lmap,\n                            Coq_builtin_get_args_obj(),\n                            Coq_builtin_get_own_prop_args_obj(),\n                            Coq_builtin_define_own_prop_args_obj(),\n                            Coq_builtin_delete_args_obj());\n                return (res_void(object_write(s, l, o_2)));}));\n        }}, function (len_2) {\n        var tdl = take_drop_last(args);\n        var rmlargs = tdl[0], largs = tdl[1];\n        var arguments_object_map_loop_2 = function (s0, xsmap0) {\n          return (\n            arguments_object_map_loop(s0, c, l, xs, len_2, rmlargs, x, str,\n              lmap, xsmap0));\n        };\n        var a = attributes_data_intro_all_true(largs);\n        return (\n          if_bool(\n            object_define_own_prop(s, c, l,\n              convert_prim_to_string(Coq_value_number(number_of_int(len_2))),\n              descriptor_of_attributes(Coq_attributes_data_of(a)), false),\n            function(s1, b) {\n              \n              if (ge_nat_decidable(len_2, LibList.length(xs))) {\n                return (arguments_object_map_loop_2(s1, xsmap));\n              } else {\n                var dummy = "";\n                var x0 = nth_def(dummy, len_2, xs);\n                if ((str || mem_decide(string_eq, x0, xsmap))) {\n                  return (arguments_object_map_loop_2(s1, xsmap));\n                } else {\n                  return (\n                    if_object(make_arg_getter(s1, c, x0, x), function(s2,\n                      lgetter) {\n                        \n                        return (\n                          if_object(make_arg_setter(s2, c, x0, x),\n                            function(s3, lsetter) {\n                              \n                              var a_2 = {\n                                attributes_accessor_get: Coq_value_object(\n                                                           lgetter),\n                                attributes_accessor_set: Coq_value_object(\n                                                           lsetter),\n                                attributes_accessor_enumerable: false,\n                                attributes_accessor_configurable: true\n                              };\n                              return (\n                                if_bool(\n                                  object_define_own_prop(s3, c, lmap,\n                                    convert_prim_to_string(\n                                      Coq_value_number(number_of_int(len_2))),\n                                    descriptor_of_attributes(\n                                      Coq_attributes_accessor_of(a_2)),\n                                    false), function(s4, b_2) {\n                                    \n                                    return (\n                                      arguments_object_map_loop_2(s4,\n                                        mk_cons(x0, xsmap)));}));}));}));\n                }\n              }}));}, len));\n};\n\nvar arguments_object_map = function (s, c, l, xs, args, x, str) {\n  return (\n    if_object(run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n      function(s_2, lmap) {\n        \n        return (\n          arguments_object_map_loop(s_2, c, l, xs, LibList.length(args),\n            args, x, str, lmap, mk_nil()));}));\n};\n\nvar create_arguments_object = function (s, c, lf, xs, args, x, str) {\n  var o = object_create_builtin(\n            Coq_value_object(\n              Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n            "Arguments", Heap.empty);\n  var p = object_alloc(s, o);\n  var l = p[0], s_2 = p[1];\n  var a = {\n    attributes_data_value: Coq_value_number(\n                             number_of_int(LibList.length(args))),\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  return (\n    if_bool(\n      object_define_own_prop(s_2, c, l, "length",\n        descriptor_of_attributes(Coq_attributes_data_of(a)), false),\n      function(s1, b) {\n        \n        return (\n          if_void(arguments_object_map(s1, c, l, xs, args, x, str),\n            function(s2) {\n              \n              if (str) {\n                var vthrower = Coq_value_object(\n                                 Coq_object_loc_prealloc(\n                                   Coq_prealloc_throw_type_error()));\n                var a0 = {\n                  attributes_accessor_get: vthrower,\n                  attributes_accessor_set: vthrower,\n                  attributes_accessor_enumerable: false,\n                  attributes_accessor_configurable: false\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s2, c, l, "caller",\n                      descriptor_of_attributes(\n                        Coq_attributes_accessor_of(a0)), false), function(s3,\n                    b_2) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s3, c, l, "callee",\n                            descriptor_of_attributes(\n                              Coq_attributes_accessor_of(a0)), false),\n                          function(s4, b_3) {\n                            \n                            return (\n                              res_ter(s4, res_val(Coq_value_object(l))));}));\n                    }));\n              } else {\n                var a0 = {\n                  attributes_data_value: Coq_value_object(lf),\n                  attributes_data_writable: true,\n                  attributes_data_enumerable: false,\n                  attributes_data_configurable: true\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s2, c, l, "callee",\n                      descriptor_of_attributes(Coq_attributes_data_of(a0)),\n                      false), function(s3, b_2) {\n                      \n                      return (res_ter(s3, res_val(Coq_value_object(l))));}));\n              }}));}));\n};\n\nvar binding_inst_arg_obj = function (s, c, lf, p, xs, args, l) {\n  var arguments_ = "arguments";\n  var str = prog_intro_strictness(p);\n  return (\n    if_object(\n      create_arguments_object(s, c, lf, xs, args,\n        c.execution_ctx_variable_env, str), function(s1, largs) {\n        \n        if (str) {\n          return (\n            if_void(env_record_create_immutable_binding(s1, l, arguments_),\n              function(s2) {\n                \n                return (\n                  env_record_initialize_immutable_binding(s2, l, arguments_,\n                    Coq_value_object(largs)));}));\n        } else {\n          return (\n            env_record_create_set_mutable_binding(s1, c, l, arguments_,\n              None(), Coq_value_object(largs), false));\n        }}));\n};\n\nvar binding_inst_var_decls = function (s, c, l, vds, bconfig, str) {\n  switch (vds.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var vd = vds.head, vds_2 = vds.tail;\n      var bivd = function (s0) {\n        return (binding_inst_var_decls(s0, c, l, vds_2, bconfig, str));\n      };\n      return (\n        if_bool(env_record_has_binding(s, c, l, vd), function(s1, has) {\n            \n            if (has) {\n              return (bivd(s1));\n            } else {\n              return (\n                if_void(\n                  env_record_create_set_mutable_binding(s1, c, l, vd,\n                    Some(bconfig), Coq_value_undef(), str), function(s2) {\n                    \n                    return (bivd(s2));}));\n            }}));\n  }\n  \n};\n\nvar execution_ctx_binding_inst = function (s, c, ct, funco, p, args) {\n  var _switch_arg_53 = c.execution_ctx_variable_env;\n  switch (_switch_arg_53.tag) {\n    case "[]":\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst]."));\n    case "::":\n      var l = _switch_arg_53.head, l0 = _switch_arg_53.tail;\n      var str = prog_intro_strictness(p);\n      var follow = function (s_2, names) {\n        var bconfig = codetype_compare(ct, Coq_codetype_eval());\n        var fds = prog_funcdecl(p);\n        return (\n          if_void(binding_inst_function_decls(s_2, c, l, fds, str, bconfig),\n            function(s1) {\n              \n              return (\n                if_bool(env_record_has_binding(s1, c, l, "arguments"),\n                  function(s2, bdefined) {\n                    \n                    var follow2 = function (s10) {\n                      var vds = prog_vardecl(p);\n                      return (\n                        binding_inst_var_decls(s10, c, l, vds, bconfig, str));\n                    };\n                    switch (ct.tag) {\n                      case "Coq_codetype_func":\n                        switch (funco.tag) {\n                          case "Some":\n                            var func = funco.value;\n                            if (bdefined) {\n                              return (follow2(s2));\n                            } else {\n                              return (\n                                if_void(\n                                  binding_inst_arg_obj(s2, c, func, p, names,\n                                    args, l), function(s3) {\n                                    \n                                    return (follow2(s3));}));\n                            }\n                          case "None":\n                            if (bdefined) {\n                              return (follow2(s2));\n                            } else {\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s2,\n                                  "Weird `arguments\' object in [execution_ctx_binding_inst]."));\n                            }\n                        }\n                        \n                      case "Coq_codetype_global":\n                        return (follow2(s2));\n                      case "Coq_codetype_eval":\n                        return (follow2(s2));\n                    }\n                    }));}));\n      };\n      switch (ct.tag) {\n        case "Coq_codetype_func":\n          switch (funco.tag) {\n            case "Some":\n              var func = funco.value;\n              return (\n                if_some(\n                  run_object_method(object_formal_parameters_, s, func),\n                  function(nameso) {\n                    \n                    return (\n                      if_some(nameso, function(names) {\n                          \n                          return (\n                            if_void(\n                              binding_inst_formal_params(s, c, l, args,\n                                names, str), function(s_2) {\n                                \n                                return (follow(s_2, names));}));}));}));\n            case "None":\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent functionnal code type in [execution_ctx_binding_inst]."));\n          }\n          \n        case "Coq_codetype_global":\n          switch (funco.tag) {\n            case "Some":\n              var o = funco.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case "None":\n              return (follow(s, mk_nil()));\n          }\n          \n        case "Coq_codetype_eval":\n          switch (funco.tag) {\n            case "Some":\n              var o = funco.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case "None":\n              return (follow(s, mk_nil()));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar entering_func_code = function (s, c, lf, vthis, args) {\n  return (\n    if_some(run_object_method(object_code_, s, lf), function(bdo) {\n        \n        return (\n          if_some(bdo, function(bd) {\n              \n              var str = funcbody_is_strict(bd);\n              var follow = function (s_2, vthis_2) {\n                return (\n                  if_some(run_object_method(object_scope_, s_2, lf),\n                    function(lexo) {\n                      \n                      return (\n                        if_some(lexo, function(lex) {\n                            \n                            var p = lexical_env_alloc_decl(s_2, lex);\n                            var lex_2 = p[0], s1 = p[1];\n                            var c_2 = execution_ctx_intro_same(lex_2,\n                                        vthis_2, str);\n                            return (\n                              if_void(\n                                execution_ctx_binding_inst(s1, c_2,\n                                  Coq_codetype_func(), Some(lf),\n                                  funcbody_prog(bd), args), function(s2) {\n                                  \n                                  return (run_call_default(s2, c_2, lf));}));\n                          }));}));\n              };\n              if (str) {\n                return (follow(s, vthis));\n              } else {\n                switch (vthis.tag) {\n                  case "Coq_value_undef":\n                    return (\n                      follow(s,\n                        Coq_value_object(\n                          Coq_object_loc_prealloc(Coq_prealloc_global()))));\n                  case "Coq_value_null":\n                    return (\n                      follow(s,\n                        Coq_value_object(\n                          Coq_object_loc_prealloc(Coq_prealloc_global()))));\n                  case "Coq_value_bool":\n                    var b = vthis.value;\n                    return (\n                      if_value(to_object(s, vthis), function(s2, v) {\n                          \n                          return (follow(s2, v));}));\n                  case "Coq_value_number":\n                    var n = vthis.value;\n                    return (\n                      if_value(to_object(s, vthis), function(s2, v) {\n                          \n                          return (follow(s2, v));}));\n                  case "Coq_value_string":\n                    var s0 = vthis.value;\n                    return (\n                      if_value(to_object(s, vthis), function(s2, v) {\n                          \n                          return (follow(s2, v));}));\n                  case "Coq_value_object":\n                    var lthis = vthis.value;\n                    return (follow(s, vthis));\n                }\n                \n              }}));}));\n};\n\nvar run_object_get_own_prop = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_own_prop_, s, l), function(b) {\n        \n        var def = function (s_2) {\n          return (\n            if_some(run_object_method(object_properties_, s_2, l),\n              function(p) {\n                \n                return (\n                  res_spec(s_2,\n                    ifx_some_or_default(\n                      convert_option_attributes(HeapStr.read_option(p, x)),\n                      Coq_full_descriptor_undef(), function (x) { return (x);\n                      })));}));\n        };\n        switch (b.tag) {\n          case "Coq_builtin_get_own_prop_default":\n            return (def(s));\n          case "Coq_builtin_get_own_prop_args_obj":\n            return (\n              if_spec(def(s), function(s1, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (res_spec(s1, Coq_full_descriptor_undef()));\n                    case "Coq_full_descriptor_some":\n                      var a = d.value;\n                      return (\n                        if_some(\n                          run_object_method(object_parameter_map_, s1, l),\n                          function(lmapo) {\n                            \n                            return (\n                              if_some(lmapo, function(lmap) {\n                                  \n                                  return (\n                                    if_spec(\n                                      run_object_get_own_prop(s1, c, lmap, x),\n                                      function(s2, d0) {\n                                        \n                                        var follow = function (s_2, a0) {\n                                          return (\n                                            res_spec(s_2,\n                                              Coq_full_descriptor_some(a0)));\n                                        };\n                                        switch (d0.tag) {\n                                          case "Coq_full_descriptor_undef":\n                                            return (follow(s2, a));\n                                          case "Coq_full_descriptor_some":\n                                            var amap = d0.value;\n                                            return (\n                                              if_value(\n                                                run_object_get(s2, c, lmap,\n                                                  x), function(s3, v) {\n                                                  \n                                                  switch (a.tag) {\n                                                    case "Coq_attributes_data_of":\n                                                      var ad = a.value;\n                                                      return (\n                                                        follow(s3,\n                                                          Coq_attributes_data_of(\n                                                            attributes_data_with_value(\n                                                              ad, v))));\n                                                    case "Coq_attributes_accessor_of":\n                                                      var aa = a.value;\n                                                      Debug.impossible_with_heap_because(\n                                                        __LOC__, s3,\n                                                        "[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens.");\n                                                      return (\n                                                        Coq_result_impossible(\n                                                          ));\n                                                  }\n                                                  }));\n                                        }\n                                        }));}));}));\n                  }\n                  }));\n          case "Coq_builtin_get_own_prop_string":\n            return (\n              if_spec(def(s), function(s0, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (\n                        if_spec(to_int32(s0, c, Coq_value_string(x)),\n                          function(s1, k) {\n                            \n                            return (\n                              if_string(\n                                to_string(s1, c,\n                                  Coq_value_number(JsNumber.absolute(k))),\n                                function(s2, s3) {\n                                  \n                                  if (!(string_eq(x, s3))) {\n                                    return (\n                                      res_spec(s2,\n                                        Coq_full_descriptor_undef()));\n                                  } else {\n                                    return (\n                                      if_string(run_object_prim_value(s2, l),\n                                        function(s4, str) {\n                                          \n                                          return (\n                                            if_spec(\n                                              to_int32(s4, c,\n                                                Coq_value_string(x)),\n                                              function(s5, k0) {\n                                                \n                                                var len = number_of_int(\n                                                            strlength(str));\n                                                if (le_int_decidable(len, k0)) {\n                                                  return (\n                                                    res_spec(s5,\n                                                      Coq_full_descriptor_undef(\n                                                        )));\n                                                } else {\n                                                  var resultStr = string_sub(\n                                                                    str,\n                                                                    int_of_number(\n                                                                    k0), 1);\n                                                  var a = {\n                                                    attributes_data_value: \n                                                    Coq_value_string(\n                                                      resultStr),\n                                                    attributes_data_writable: false,\n                                                    attributes_data_enumerable: true,\n                                                    attributes_data_configurable: false\n                                                  };\n                                                  return (\n                                                    res_spec(s5,\n                                                      Coq_full_descriptor_some(\n                                                        Coq_attributes_data_of(\n                                                          a))));\n                                                }}));}));\n                                  }}));}));\n                    case "Coq_full_descriptor_some":\n                      var a = d.value;\n                      return (res_spec(s0, d));\n                  }\n                  }));\n          default:\n            return (Coq_result_not_yet_implemented());\n        }\n        }));\n};\n\nvar run_function_has_instance = function (s, c, lv, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_object":\n      var lo = _foo_.value;\n      return (\n        if_some(run_object_method(object_proto_, s, lv), function(vproto) {\n            \n            switch (vproto.tag) {\n              case "Coq_value_null":\n                return (res_ter(s, res_val(Coq_value_bool(false))));\n              case "Coq_value_object":\n                var proto = vproto.value;\n                if (object_loc_compare(proto, lo)) {\n                  return (res_ter(s, res_val(Coq_value_bool(true))));\n                } else {\n                  return (\n                    run_function_has_instance(s, c, proto,\n                      Coq_value_object(lo)));\n                }\n              default:\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s,\n                    "Primitive found in the prototype chain in [run_object_has_instance_loop]."));\n            }\n            }));\n    default:\n      return (run_error(s, c, Coq_native_error_type()));\n  }\n  \n};\n\nvar run_object_has_instance = function (s, c, b, l, v) {\n  switch (b.tag) {\n    case "Coq_builtin_has_instance_function":\n      switch (v.tag) {\n        case "Coq_value_object":\n          var lv = v.value;\n          return (\n            if_value(run_object_get(s, c, l, "prototype"), function(s1,\n              vproto) {\n                \n                switch (vproto.tag) {\n                  case "Coq_value_object":\n                    var lproto = vproto.value;\n                    return (\n                      run_function_has_instance(s1, c, lv,\n                        Coq_value_object(lproto)));\n                  default:\n                    return (run_error(s1, c, Coq_native_error_type()));\n                }\n                }));\n        default:\n          return (res_out(s, res_val(Coq_value_bool(false))));\n      }\n      \n    case "Coq_builtin_has_instance_after_bind":\n      return (\n        if_some(run_object_method(object_target_function_, s, l),\n          function(ol) {\n            \n            return (\n              if_some(ol, function(l0) {\n                  \n                  return (\n                    if_some(run_object_method(object_has_instance_, s, l0),\n                      function(ob) {\n                        \n                        switch (ob.tag) {\n                          case "Some":\n                            var b0 = ob.value;\n                            return (\n                              run_object_has_instance(s, c, b0, l0, v));\n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));}));}));\n  }\n  \n};\n\nvar from_prop_descriptor = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_full_descriptor_undef":\n      return (res_out(s, res_val(Coq_value_undef())));\n    case "Coq_full_descriptor_some":\n      var a = _foo_.value;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n          function(s1, l) {\n            \n            var follow = function (s0, x) {\n              var a1 = attributes_data_intro_all_true(\n                         Coq_value_bool(attributes_enumerable(a)));\n              return (\n                if_bool(\n                  object_define_own_prop(s0, c, l, "enumerable",\n                    descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                    throw_false), function(s0_2, x0) {\n                    \n                    var a2 = attributes_data_intro_all_true(\n                               Coq_value_bool(attributes_configurable(a)));\n                    return (\n                      if_bool(\n                        object_define_own_prop(s0_2, c, l, "configurable",\n                          descriptor_of_attributes(\n                            Coq_attributes_data_of(a2)), throw_false),\n                        function(s_2, x1) {\n                          \n                          return (\n                            res_ter(s_2, res_val(Coq_value_object(l))));}));\n                  }));\n            };\n            switch (a.tag) {\n              case "Coq_attributes_data_of":\n                var ad = a.value;\n                var a1 = attributes_data_intro_all_true(\n                           ad.attributes_data_value);\n                return (\n                  if_bool(\n                    object_define_own_prop(s1, c, l, "value",\n                      descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                      throw_false), function(s2, x) {\n                      \n                      var a2 = attributes_data_intro_all_true(\n                                 Coq_value_bool(ad.attributes_data_writable));\n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, "writable",\n                            descriptor_of_attributes(\n                              Coq_attributes_data_of(a2)), throw_false),\n                          function(s3, v) { \n                                            return (follow(s3, v));}));}));\n              case "Coq_attributes_accessor_of":\n                var aa = a.value;\n                var a1 = attributes_data_intro_all_true(\n                           aa.attributes_accessor_get);\n                return (\n                  if_bool(\n                    object_define_own_prop(s1, c, l, "get",\n                      descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                      throw_false), function(s2, x) {\n                      \n                      var a2 = attributes_data_intro_all_true(\n                                 aa.attributes_accessor_set);\n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, "set",\n                            descriptor_of_attributes(\n                              Coq_attributes_data_of(a2)), throw_false),\n                          function(s3, v) { \n                                            return (follow(s3, v));}));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_equal = function (s, c, v1, v2) {\n  var conv_number = function (s0, v) {\n    return (to_number(s0, c, v));\n  };\n  var conv_primitive = function (s0, v) {\n    return (to_primitive(s0, c, v, None()));\n  };\n  var checkTypesThen = function (s0, v3, v4, k) {\n    var ty1 = type_of(v3);\n    var ty2 = type_of(v4);\n    if (type_compare(ty1, ty2)) {\n      return (\n        res_out(s0,\n          res_val(Coq_value_bool(equality_test_for_same_type(ty1, v3, v4)))));\n    } else {\n      return (k(ty1, ty2));\n    }\n  };\n  return (\n    checkTypesThen(s, v1, v2, function (ty1, ty2) {\n        var dc_conv = function (v3, f, v4) {\n          return (\n            if_value(f(s, v4), function(s0, v2_2) {\n                \n                return (run_equal(s0, c, v3, v2_2));}));\n        };\n        var so = function (b) {\n          return (res_out(s, res_val(Coq_value_bool(b))));\n        };\n        if ((type_compare(ty1, Coq_type_null())\n            && type_compare(ty2, Coq_type_undef()))) {\n          return (so(true));\n        } else {\n          if ((type_compare(ty1, Coq_type_undef())\n              && type_compare(ty2, Coq_type_null()))) {\n            return (so(true));\n          } else {\n            if ((type_compare(ty1, Coq_type_number())\n                && type_compare(ty2, Coq_type_string()))) {\n              return (dc_conv(v1, conv_number, v2));\n            } else {\n              if ((type_compare(ty1, Coq_type_string())\n                  && type_compare(ty2, Coq_type_number()))) {\n                return (dc_conv(v2, conv_number, v1));\n              } else {\n                if (type_compare(ty1, Coq_type_bool())) {\n                  return (dc_conv(v2, conv_number, v1));\n                } else {\n                  if (type_compare(ty2, Coq_type_bool())) {\n                    return (dc_conv(v1, conv_number, v2));\n                  } else {\n                    if (((type_compare(ty1, Coq_type_string())\n                         || type_compare(ty1, Coq_type_number()))\n                        && type_compare(ty2, Coq_type_object()))) {\n                      return (dc_conv(v1, conv_primitive, v2));\n                    } else {\n                      if ((type_compare(ty1, Coq_type_object())\n                          && (type_compare(ty2, Coq_type_string())\n                             || type_compare(ty2, Coq_type_number())))) {\n                        return (dc_conv(v2, conv_primitive, v1));\n                      } else {\n                        return (so(false));\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }}));\n};\n\nvar convert_twice = function (ifv, kC, s, v1, v2) {\n  return (\n    ifv(kC(s, v1), function (s1, vc1) {\n        return (\n          ifv(kC(s1, v2), function (s2, vc2) {\n              return (res_spec(s2, [vc1, vc2]));}));}));\n};\n\nvar convert_twice_primitive = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_prim, function (s0, v) {\n        return (to_primitive(s0, c, v, None()));}, s, v1, v2));\n};\n\nvar convert_twice_number = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_number, function (s0, v) {\n        return (to_number(s0, c, v));}, s, v1, v2));\n};\n\nvar convert_twice_string = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_string, function (s0, v) {\n        return (to_string(s0, c, v));}, s, v1, v2));\n};\n\nvar issome = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var t = _foo_.value;\n      return (true);\n    case "None":\n      return (false);\n  }\n  \n};\n\nvar run_binary_op_add = function (s, c, v1, v2) {\n  return (\n    if_spec(convert_twice_primitive(s, c, v1, v2), function(s1,\n      _tuple_arg_56) {\n        var w1 = _tuple_arg_56[0], w2 = _tuple_arg_56[1];\n        \n        if ((type_compare(type_of(w1), Coq_type_string())\n            || type_compare(type_of(w2), Coq_type_string()))) {\n          return (\n            if_spec(convert_twice_string(s1, c, w1, w2), function(s2,\n              _tuple_arg_55) {\n                var str1 = _tuple_arg_55[0], str2 = _tuple_arg_55[1];\n                \n                return (\n                  res_out(s2,\n                    res_val(Coq_value_string(strappend(str1, str2)))));}));\n        } else {\n          return (\n            if_spec(convert_twice_number(s1, c, w1, w2), function(s2,\n              _tuple_arg_54) {\n                var n1 = _tuple_arg_54[0], n2 = _tuple_arg_54[1];\n                \n                return (res_out(s2, res_val(Coq_value_number((n1 + n2)))));}));\n        }}));\n};\n\nvar run_binary_op_arith = function (mathop, s, c, v1, v2) {\n  return (\n    if_spec(convert_twice_number(s, c, v1, v2), function(s1, nn) {\n        \n        var n1 = nn[0], n2 = nn[1];\n        return (res_out(s1, res_val(Coq_value_number(mathop(n1, n2)))));}));\n};\n\nvar run_binary_op_shift = function (b_unsigned, mathop, s, c, v1, v2) {\n  if (b_unsigned) {\n    var conv = to_uint32;\n  } else {\n    var conv = to_int32;\n  }\n  return (\n    if_spec(conv(s, c, v1), function(s1, k1) {\n        \n        return (\n          if_spec(to_uint32(s1, c, v2), function(s2, k2) {\n              \n              var k2_2 = JsNumber.modulo_32(k2);\n              return (\n                res_ter(s2, res_val(Coq_value_number(mathop(k1, k2_2)))));}));\n      }));\n};\n\nvar run_binary_op_bitwise = function (mathop, s, c, v1, v2) {\n  return (\n    if_spec(to_int32(s, c, v1), function(s1, k1) {\n        \n        return (\n          if_spec(to_int32(s1, c, v2), function(s2, k2) {\n              \n              return (\n                res_ter(s2, res_val(Coq_value_number(mathop(k1, k2)))));}));\n      }));\n};\n\nvar run_binary_op_compare = function (b_swap, b_neg, s, c, v1, v2) {\n  return (\n    if_spec(convert_twice_primitive(s, c, v1, v2), function(s1, ww) {\n        \n        var w1 = ww[0], w2 = ww[1];\n        if (b_swap) {\n          var p = [w2, w1];\n        } else {\n          var p = [w1, w2];\n        }\n        var wa = p[0], wb = p[1];\n        var wr = inequality_test_primitive(wa, wb);\n        if (value_compare(wr, Coq_value_undef())) {\n          return (res_out(s1, res_val(Coq_value_bool(false))));\n        } else {\n          if ((b_neg && value_compare(wr, Coq_value_bool(true)))) {\n            return (res_out(s1, res_val(Coq_value_bool(false))));\n          } else {\n            if ((b_neg && value_compare(wr, Coq_value_bool(false)))) {\n              return (res_out(s1, res_val(Coq_value_bool(true))));\n            } else {\n              return (res_out(s1, res_val(wr)));\n            }\n          }\n        }}));\n};\n\nvar run_binary_op_instanceof = function (s, c, v1, v2) {\n  switch (v2.tag) {\n    case "Coq_value_object":\n      var l = v2.value;\n      return (\n        if_some(run_object_method(object_has_instance_, s, l), function(b) {\n            \n            switch (b.tag) {\n              case "None":\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Some":\n                var has_instance_id = b.value;\n                return (\n                  run_object_has_instance(s, c, has_instance_id, l, v1));\n            }\n            }));\n    default:\n      return (run_error(s, c, Coq_native_error_type()));\n  }\n  \n};\n\nvar run_binary_op_in = function (s, c, v1, v2) {\n  switch (v2.tag) {\n    case "Coq_value_object":\n      var l = v2.value;\n      return (\n        if_string(to_string(s, c, v1), function(s2, x) {\n            \n            return (object_has_prop(s2, c, l, x));}));\n    default:\n      return (run_error(s, c, Coq_native_error_type()));\n  }\n  \n};\n\nvar run_binary_op = function (s, c, op, v1, v2) {\n  switch (op.tag) {\n    case "Coq_binary_op_mult":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x * y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_div":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x / y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_mod":\n      return (\n        run_binary_op_arith(function (x, y) { return (JsNumber.fmod(x, y));},\n          s, c, v1, v2));\n    case "Coq_binary_op_sub":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x - y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_lt":\n      return (run_binary_op_compare(false, false, s, c, v1, v2));\n    case "Coq_binary_op_gt":\n      return (run_binary_op_compare(true, false, s, c, v1, v2));\n    case "Coq_binary_op_le":\n      return (run_binary_op_compare(true, true, s, c, v1, v2));\n    case "Coq_binary_op_ge":\n      return (run_binary_op_compare(false, true, s, c, v1, v2));\n    case "Coq_binary_op_left_shift":\n      return (\n        run_binary_op_shift(false, JsNumber.int32_left_shift, s, c, v1, v2));\n    case "Coq_binary_op_right_shift":\n      return (\n        run_binary_op_shift(false, JsNumber.int32_right_shift, s, c, v1, v2));\n    case "Coq_binary_op_unsigned_right_shift":\n      return (\n        run_binary_op_shift(true, JsNumber.uint32_right_shift, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_and":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_and, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_or":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_or, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_xor":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_xor, s, c, v1, v2));\n    case "Coq_binary_op_add":\n      return (run_binary_op_add(s, c, v1, v2));\n    case "Coq_binary_op_instanceof":\n      return (run_binary_op_instanceof(s, c, v1, v2));\n    case "Coq_binary_op_in":\n      return (run_binary_op_in(s, c, v1, v2));\n    case "Coq_binary_op_equal":\n      return (run_equal(s, c, v1, v2));\n    case "Coq_binary_op_disequal":\n      return (\n        if_bool(run_equal(s, c, v1, v2), function(s0, b0) {\n            \n            return (res_ter(s0, res_val(Coq_value_bool(!(b0)))));}));\n    case "Coq_binary_op_strict_equal":\n      return (\n        res_out(s, res_val(Coq_value_bool(strict_equality_test(v1, v2)))));\n    case "Coq_binary_op_strict_disequal":\n      return (\n        res_out(s, res_val(Coq_value_bool(!(strict_equality_test(v1, v2))))));\n    case "Coq_binary_op_coma":\n      return (res_out(s, res_val(v2)));\n    case "Coq_binary_op_and":\n      return (Coq_result_impossible());\n    case "Coq_binary_op_or":\n      return (Coq_result_impossible());\n  }\n  \n};\n\nvar run_prepost_op = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_unary_op_delete":\n      return (None());\n    case "Coq_unary_op_void":\n      return (None());\n    case "Coq_unary_op_typeof":\n      return (None());\n    case "Coq_unary_op_post_incr":\n      return (Some([add_one, false]));\n    case "Coq_unary_op_post_decr":\n      return (Some([sub_one, false]));\n    case "Coq_unary_op_pre_incr":\n      return (Some([add_one, true]));\n    case "Coq_unary_op_pre_decr":\n      return (Some([sub_one, true]));\n    case "Coq_unary_op_add":\n      return (None());\n    case "Coq_unary_op_neg":\n      return (None());\n    case "Coq_unary_op_bitwise_not":\n      return (None());\n    case "Coq_unary_op_not":\n      return (None());\n  }\n  \n};\n\nvar run_typeof_value = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_object":\n      var l = _foo_.value;\n      if (is_callable_dec(s, Coq_value_object(l))) {\n        return ("function");\n      } else {\n        return ("object");\n      }\n    default:\n      return (typeof_prim(_foo_));\n  }\n  \n};\n\nvar run_unary_op = function (s, c, op, e) {\n  if (prepost_unary_op_dec(op)) {\n    return (\n      if_success(run_expr(s, c, e), function(s1, rv1) {\n          \n          return (\n            if_spec(ref_get_value(s1, c, rv1), function(s2, v2) {\n                \n                return (\n                  if_number(to_number(s2, c, v2), function(s3, n1) {\n                      \n                      return (\n                        if_some(run_prepost_op(op), function(po) {\n                            \n                            var number_op = po[0], is_pre = po[1];\n                            var n2 = number_op(n1);\n                            var v = Coq_value_number((function () {\n                                        if (is_pre) {\n                                          return (n2);\n                                        } else {\n                                          return (n1);\n                                        }}()));\n                            return (\n                              if_void(\n                                ref_put_value(s3, c, rv1,\n                                  Coq_value_number(n2)), function(s4) {\n                                  \n                                  return (res_out(s4, res_val(v)));}));}));}));\n              }));}));\n  } else {\n    switch (op.tag) {\n      case "Coq_unary_op_delete":\n        return (\n          if_success(run_expr(s, c, e), function(s0, rv) {\n              \n              switch (rv.tag) {\n                case "Coq_resvalue_empty":\n                  return (res_ter(s0, res_val(Coq_value_bool(true))));\n                case "Coq_resvalue_value":\n                  var v = rv.value;\n                  return (res_ter(s0, res_val(Coq_value_bool(true))));\n                case "Coq_resvalue_ref":\n                  var r = rv.ref;\n                  if (ref_kind_comparable(ref_kind_of(r),\n                        Coq_ref_kind_undef())) {\n                    if (r.ref_strict) {\n                      return (run_error(s0, c, Coq_native_error_syntax()));\n                    } else {\n                      return (res_ter(s0, res_val(Coq_value_bool(true))));\n                    }\n                  } else {\n                    var _switch_arg_57 = r.ref_base;\n                    switch (_switch_arg_57.tag) {\n                      case "Coq_ref_base_type_value":\n                        var v = _switch_arg_57.value;\n                        return (\n                          if_object(to_object(s0, v), function(s1, l) {\n                              \n                              return (\n                                object_delete(s1, c, l, r.ref_name,\n                                  r.ref_strict));}));\n                      case "Coq_ref_base_type_env_loc":\n                        var l = _switch_arg_57.value;\n                        if (r.ref_strict) {\n                          return (\n                            run_error(s0, c, Coq_native_error_syntax()));\n                        } else {\n                          return (\n                            env_record_delete_binding(s0, c, l, r.ref_name));\n                        }\n                    }\n                    \n                  }\n              }\n              }));\n      case "Coq_unary_op_typeof":\n        return (\n          if_success(run_expr(s, c, e), function(s1, rv) {\n              \n              switch (rv.tag) {\n                case "Coq_resvalue_empty":\n                  return (\n                    function (s, m) {\n                        Debug.impossible_with_heap_because(__LOC__, s, m);\n                        return (Coq_result_impossible());}(s1,\n                      "Empty result for a `typeof\' in [run_unary_op]."));\n                case "Coq_resvalue_value":\n                  var v = rv.value;\n                  return (\n                    res_ter(s1,\n                      res_val(Coq_value_string(run_typeof_value(s1, v)))));\n                case "Coq_resvalue_ref":\n                  var r = rv.ref;\n                  if (ref_kind_comparable(ref_kind_of(r),\n                        Coq_ref_kind_undef())) {\n                    return (\n                      res_ter(s1, res_val(Coq_value_string("undefined"))));\n                  } else {\n                    return (\n                      if_spec(ref_get_value(s1, c, Coq_resvalue_ref(r)),\n                        function(s2, v) {\n                          \n                          return (\n                            res_ter(s2,\n                              res_val(\n                                Coq_value_string(run_typeof_value(s2, v)))));\n                        }));\n                  }\n              }\n              }));\n      default:\n        return (\n          if_spec(run_expr_get_value(s, c, e), function(s1, v) {\n              \n              switch (op.tag) {\n                case "Coq_unary_op_void":\n                  return (res_ter(s1, res_val(Coq_value_undef())));\n                case "Coq_unary_op_add":\n                  return (to_number(s1, c, v));\n                case "Coq_unary_op_neg":\n                  return (\n                    if_number(to_number(s1, c, v), function(s2, n) {\n                        \n                        return (\n                          res_ter(s2,\n                            res_val(Coq_value_number(JsNumber.neg(n)))));}));\n                case "Coq_unary_op_bitwise_not":\n                  return (\n                    if_spec(to_int32(s1, c, v), function(s2, k) {\n                        \n                        return (\n                          res_ter(s2,\n                            res_val(\n                              Coq_value_number(JsNumber.int32_bitwise_not(k)))));\n                      }));\n                case "Coq_unary_op_not":\n                  return (\n                    res_ter(s1, res_val(Coq_value_bool(!(to_boolean(v))))));\n                default:\n                  return (\n                    function (s, m) {\n                        Debug.impossible_with_heap_because(__LOC__, s, m);\n                        return (Coq_result_impossible());}(s1,\n                      "Undealt regular operator in [run_unary_op]."));\n              }\n              }));\n    }\n    \n  }\n};\n\nvar create_new_function_in = function (s, c, args, bd) {\n  return (\n    creating_function_object(s, c, args, bd, c.execution_ctx_lexical_env,\n      c.execution_ctx_strict));\n};\n\nvar init_object = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_val(Coq_value_object(l))));\n    case "::":\n      var p = _foo_.head, pds_2 = _foo_.tail;\n      var pn = p[0], pb = p[1];\n      var x = string_of_propname(pn);\n      var follows = function (s1, desc) {\n        return (\n          if_success(object_define_own_prop(s1, c, l, x, desc, false),\n            function(s2, rv) { \n                               return (init_object(s2, c, l, pds_2));}));\n      };\n      switch (pb.tag) {\n        case "Coq_propbody_val":\n          var e0 = pb.expr;\n          return (\n            if_spec(run_expr_get_value(s, c, e0), function(s1, v0) {\n                \n                var desc = {\n                  descriptor_value: Some(v0),\n                  descriptor_writable: Some(true),\n                  descriptor_get: None(),\n                  descriptor_set: None(),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n        case "Coq_propbody_get":\n          var bd = pb.body;\n          return (\n            if_value(create_new_function_in(s, c, mk_nil(), bd), function(s1,\n              v0) {\n                \n                var desc = {\n                  descriptor_value: None(),\n                  descriptor_writable: None(),\n                  descriptor_get: Some(v0),\n                  descriptor_set: None(),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n        case "Coq_propbody_set":\n          var args = pb.names, bd = pb.body;\n          return (\n            if_value(create_new_function_in(s, c, args, bd), function(s1,\n              v0) {\n                \n                var desc = {\n                  descriptor_value: None(),\n                  descriptor_writable: None(),\n                  descriptor_get: None(),\n                  descriptor_set: Some(v0),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n      }\n      \n  }\n  \n};\n\nvar run_array_element_list = function (s, c, l, oes, n) {\n  switch (oes.tag) {\n    case "[]":\n      return (res_out(s, res_val(Coq_value_object(l))));\n    case "::":\n      var o = oes.head, oes_2 = oes.tail;\n      switch (o.tag) {\n        case "Some":\n          var e = o.value;\n          var loop_result = function (s0) {\n            return (run_array_element_list(s0, c, l, oes_2, 0.));\n          };\n          return (\n            if_spec(run_expr_get_value(s, c, e), function(s0, v) {\n                \n                return (\n                  if_value(run_object_get(s0, c, l, "length"), function(s1,\n                    vlen) {\n                      \n                      return (\n                        if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                            \n                            return (\n                              if_string(\n                                to_string(s2, c,\n                                  Coq_value_number((ilen + n))), function(s3,\n                                slen) {\n                                  \n                                  var desc = {\n                                    attributes_data_value: v,\n                                    attributes_data_writable: true,\n                                    attributes_data_enumerable: true,\n                                    attributes_data_configurable: true\n                                  };\n                                  return (\n                                    if_bool(\n                                      object_define_own_prop(s3, c, l, slen,\n                                        descriptor_of_attributes(\n                                          Coq_attributes_data_of(desc)),\n                                        false), function(s4, x) {\n                                        \n                                        return (\n                                          if_object(loop_result(s4),\n                                            function(s5, l0) {\n                                              \n                                              return (\n                                                res_ter(s5,\n                                                  res_val(\n                                                    Coq_value_object(l0))));\n                                            }));}));}));}));}));}));\n        case "None":\n          var firstIndex = elision_head_count(mk_cons(None(), oes_2));\n          return (\n            run_array_element_list(s, c, l,\n              elision_head_remove(mk_cons(None(), oes_2)),\n              number_of_int(firstIndex)));\n      }\n      \n  }\n  \n};\n\nvar init_array = function (s, c, l, oes) {\n  var elementList = elision_tail_remove(oes);\n  var elisionLength = elision_tail_count(oes);\n  return (\n    if_object(run_array_element_list(s, c, l, elementList, 0.), function(s0,\n      l0) {\n        \n        return (\n          if_value(run_object_get(s0, c, l0, "length"), function(s1, vlen) {\n              \n              return (\n                if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                    \n                    return (\n                      if_spec(\n                        to_uint32(s2, c,\n                          Coq_value_number(\n                            (ilen + number_of_int(elisionLength)))),\n                        function(s3, len) {\n                          \n                          return (\n                            if_not_throw(\n                              object_put(s3, c, l0, "length",\n                                Coq_value_number(len), throw_false),\n                              function(s4, x) {\n                                \n                                return (\n                                  res_out(s4, res_val(Coq_value_object(l0))));\n                              }));}));}));}));}));\n};\n\nvar run_var_decl_item = function (s, c, x, _foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var e = _foo_.value;\n      return (\n        if_spec(identifier_resolution(s, c, x), function(s1, ir) {\n            \n            return (\n              if_spec(run_expr_get_value(s1, c, e), function(s2, v) {\n                  \n                  return (\n                    if_void(ref_put_value(s2, c, Coq_resvalue_ref(ir), v),\n                      function(s3) {\n                        \n                        return (res_out(s3, res_val(Coq_value_string(x))));}));\n                }));}));\n    case "None":\n      return (res_out(s, res_val(Coq_value_string(x))));\n  }\n  \n};\n\nvar run_var_decl = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_empty));\n    case "::":\n      var y = _foo_.head, xeos_2 = _foo_.tail;\n      var x = y[0], eo = y[1];\n      return (\n        if_value(run_var_decl_item(s, c, x, eo), function(s1, vname) {\n            \n            return (run_var_decl(s1, c, xeos_2));}));\n  }\n  \n};\n\nvar run_list_expr = function (s1, c, vs, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_spec(s1, rev(vs)));\n    case "::":\n      var e = _foo_.head, es_2 = _foo_.tail;\n      return (\n        if_spec(run_expr_get_value(s1, c, e), function(s2, v) {\n            \n            return (run_list_expr(s2, c, mk_cons(v, vs), es_2));}));\n  }\n  \n};\n\nvar run_block = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_ter(s, res_normal(Coq_resvalue_empty())));\n    case "::":\n      var t = _foo_.head, ts_rev_2 = _foo_.tail;\n      return (\n        if_success(run_block(s, c, ts_rev_2), function(s0, rv0) {\n            \n            return (\n              ifx_success_state(rv0, run_stat(s0, c, t), function (x, x0) {\n                  return (res_out(x, res_normal(x0)));}));}));\n  }\n  \n};\n\nvar run_binary_op_and = function (s, c, e1, e2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b1 = to_boolean(v1);\n        if (!(b1)) {\n          return (res_ter(s1, res_val(v1)));\n        } else {\n          return (\n            if_spec(run_expr_get_value(s1, c, e2), function(s2, v) {\n                \n                return (res_ter(s2, res_val(v)));}));\n        }}));\n};\n\nvar run_binary_op_or = function (s, c, e1, e2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b1 = to_boolean(v1);\n        if (b1) {\n          return (res_ter(s1, res_val(v1)));\n        } else {\n          return (\n            if_spec(run_expr_get_value(s1, c, e2), function(s2, v) {\n                \n                return (res_ter(s2, res_val(v)));}));\n        }}));\n};\n\nvar run_expr_binary_op = function (s, c, op, e1, e2) {\n  switch (op.tag) {\n    case "Coq_binary_op_and":\n      return (run_binary_op_and(s, c, e1, e2));\n    case "Coq_binary_op_or":\n      return (run_binary_op_or(s, c, e1, e2));\n    default:\n      return (\n        if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n            \n            return (\n              if_spec(run_expr_get_value(s1, c, e2), function(s2, v2) {\n                  \n                  return (run_binary_op(s2, c, op, v1, v2));}));}));\n  }\n  \n};\n\nvar run_expr_access = function (s, c, e1, e2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        return (\n          if_spec(run_expr_get_value(s1, c, e2), function(s2, v2) {\n              \n              if ((value_compare(v1, Coq_value_undef())\n                  || value_compare(v1, Coq_value_null()))) {\n                return (run_error(s2, c, Coq_native_error_type()));\n              } else {\n                return (\n                  if_string(to_string(s2, c, v2), function(s3, x) {\n                      \n                      return (\n                        res_ter(s3,\n                          res_ref(\n                            ref_create_value(v1, x, c.execution_ctx_strict))));\n                    }));\n              }}));}));\n};\n\nvar run_expr_assign = function (s, c, opo, e1, e2) {\n  return (\n    if_success(run_expr(s, c, e1), function(s1, rv1) {\n        \n        var follow = function (s0, rv_2) {\n          switch (rv_2.tag) {\n            case "Coq_resvalue_value":\n              var v = rv_2.value;\n              return (\n                if_void(ref_put_value(s0, c, rv1, v), function(s_2) {\n                    \n                    return (res_out(s_2, res_val(v)));}));\n            case "Coq_resvalue_empty":\n              Debug.impossible_with_heap_because(__LOC__, s0,\n                "Non-value result in [run_expr_assign].");\n              return (Coq_result_impossible());\n            case "Coq_resvalue_ref":\n              var r = rv_2.ref;\n              Debug.impossible_with_heap_because(__LOC__, s,\n                "Non-value result in [run_expr_assign].");\n              return (Coq_result_impossible());\n          }\n          \n        };\n        switch (opo.tag) {\n          case "Some":\n            var op = opo.value;\n            return (\n              if_spec(ref_get_value(s1, c, rv1), function(s2, v1) {\n                  \n                  return (\n                    if_spec(run_expr_get_value(s2, c, e2), function(s3, v2) {\n                        \n                        return (\n                          if_success(run_binary_op(s3, c, op, v1, v2),\n                            function(s4, v) { \n                                              return (follow(s4, v));}));}));\n                }));\n          case "None":\n            return (\n              if_spec(run_expr_get_value(s1, c, e2), function(x, x0) {\n                  \n                  return (follow(x, Coq_resvalue_value(x0)));}));\n        }\n        }));\n};\n\nvar run_expr_function = function (s, c, fo, args, bd) {\n  switch (fo.tag) {\n    case "Some":\n      var fn = fo.value;\n      var p = lexical_env_alloc_decl(s, c.execution_ctx_lexical_env);\n      var lex_2 = p[0], s_2 = p[1];\n      var follow = function (l) {\n        return (\n          if_some(env_record_binds_option(s_2, l), function(e) {\n              \n              return (\n                if_void(env_record_create_immutable_binding(s_2, l, fn),\n                  function(s1) {\n                    \n                    return (\n                      if_object(\n                        creating_function_object(s1, c, args, bd, lex_2,\n                          funcbody_is_strict(bd)), function(s2, l0) {\n                          \n                          return (\n                            if_void(\n                              env_record_initialize_immutable_binding(s2, l,\n                                fn, Coq_value_object(l0)), function(s3) {\n                                \n                                return (\n                                  res_out(s3, res_val(Coq_value_object(l0))));\n                              }));}));}));}));\n      };\n      return (\n        destr_list(lex_2, function (x) {\n            Debug.impossible_with_heap_because(__LOC__, s,\n              "Empty lexical environnment allocated in [run_expr_function].");\n            return (Coq_result_impossible());}, function (l, x) {\n            return (follow(l));}, {}));\n    case "None":\n      var lex = c.execution_ctx_lexical_env;\n      return (\n        creating_function_object(s, c, args, bd, lex, funcbody_is_strict(bd)));\n  }\n  \n};\n\nvar entering_eval_code = function (s, c, direct, bd, k) {\n  var str = (funcbody_is_strict(bd) || (direct && c.execution_ctx_strict));\n  if (direct) {\n    var c_2 = c;\n  } else {\n    var c_2 = execution_ctx_initial(str);\n  }\n  if (str) {\n    var p = lexical_env_alloc_decl(s, c_2.execution_ctx_lexical_env);\n  } else {\n    var p = [c_2.execution_ctx_lexical_env, s];\n  }\n  var lex = p[0], s_2 = p[1];\n  if (str) {\n    var c1 = execution_ctx_with_lex_same(c_2, lex);\n  } else {\n    var c1 = c_2;\n  }\n  var p0 = funcbody_prog(bd);\n  return (\n    if_void(\n      execution_ctx_binding_inst(s_2, c1, Coq_codetype_eval(), None(), p0,\n        mk_nil()), function(s1) { \n                                  return (k(s1, c1));}));\n};\n\nvar run_eval = function (s, c, is_direct_call, vs) {\n  var _switch_arg_58 = get_arg(0, vs);\n  switch (_switch_arg_58.tag) {\n    case "Coq_value_undef":\n      return (res_out(s, res_val(Coq_value_undef())));\n    case "Coq_value_null":\n      return (res_out(s, res_val(Coq_value_null())));\n    case "Coq_value_bool":\n      var b = _switch_arg_58.value;\n      return (res_out(s, res_val(Coq_value_bool(b))));\n    case "Coq_value_number":\n      var n = _switch_arg_58.value;\n      return (res_out(s, res_val(Coq_value_number(n))));\n    case "Coq_value_string":\n      var s0 = _switch_arg_58.value;\n      var str = (is_direct_call && c.execution_ctx_strict);\n      var _switch_arg_59 = parse_pickable(s0, str);\n      switch (_switch_arg_59.tag) {\n        case "Some":\n          var p0 = _switch_arg_59.value;\n          return (\n            entering_eval_code(s, c, is_direct_call,\n              Coq_funcbody_intro(p0, s0), function (s1, c_2) {\n                return (\n                  if_ter(run_prog(s1, c_2, p0), function(s2, r) {\n                      \n                      var _switch_arg_60 = r.res_type;\n                      switch (_switch_arg_60.tag) {\n                        case "Coq_restype_normal":\n                          return (\n                            ifx_empty_label(s2, r, function (x) {\n                                var _switch_arg_61 = r.res_value;\n                                switch (_switch_arg_61.tag) {\n                                  case "Coq_resvalue_empty":\n                                    return (\n                                      res_ter(s2, res_val(Coq_value_undef())));\n                                  case "Coq_resvalue_value":\n                                    var v = _switch_arg_61.value;\n                                    return (res_ter(s2, res_val(v)));\n                                  case "Coq_resvalue_ref":\n                                    var r0 = _switch_arg_61.ref;\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s2,\n                                      "Reference found in the result of an `eval\' in [run_eval].");\n                                    return (Coq_result_impossible());\n                                }\n                                }));\n                        case "Coq_restype_throw":\n                          return (res_ter(s2, res_throw(r.res_value)));\n                        default:\n                          Debug.impossible_with_heap_because(__LOC__, s2,\n                            "Forbidden result type returned by an `eval\' in [run_eval].");\n                          return (Coq_result_impossible());\n                      }\n                      }));}));\n        case "None":\n          return (run_error(s, c, Coq_native_error_syntax()));\n      }\n      \n    case "Coq_value_object":\n      var o = _switch_arg_58.value;\n      return (res_out(s, res_val(Coq_value_object(o))));\n  }\n  \n};\n\nvar run_expr_call = function (s, c, e1, e2s) {\n  var is_eval_direct = is_syntactic_eval(e1);\n  return (\n    if_success(run_expr(s, c, e1), function(s1, rv) {\n        \n        return (\n          if_spec(ref_get_value(s1, c, rv), function(s2, f) {\n              \n              return (\n                if_spec(run_list_expr(s2, c, mk_nil(), e2s), function(s3,\n                  vs) {\n                    \n                    switch (f.tag) {\n                      case "Coq_value_object":\n                        var l = f.value;\n                        if (is_callable_dec(s3, Coq_value_object(l))) {\n                          var follow = function (vthis) {\n                            if (object_loc_compare(l,\n                                  Coq_object_loc_prealloc(\n                                    Coq_prealloc_global_eval()))) {\n                              return (run_eval(s3, c, is_eval_direct, vs));\n                            } else {\n                              return (run_call(s3, c, l, vthis, vs));\n                            }\n                          };\n                          switch (rv.tag) {\n                            case "Coq_resvalue_empty":\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s3,\n                                  "[run_expr_call] unable to call an  empty result."));\n                            case "Coq_resvalue_value":\n                              var v = rv.value;\n                              return (follow(Coq_value_undef()));\n                            case "Coq_resvalue_ref":\n                              var r = rv.ref;\n                              var _switch_arg_62 = r.ref_base;\n                              switch (_switch_arg_62.tag) {\n                                case "Coq_ref_base_type_value":\n                                  var v = _switch_arg_62.value;\n                                  if ((ref_kind_comparable(ref_kind_of(r),\n                                         Coq_ref_kind_primitive_base())\n                                      || (ref_kind_comparable(ref_kind_of(r),\n                                            Coq_ref_kind_null())\n                                         || ref_kind_comparable(\n                                              ref_kind_of(r),\n                                              Coq_ref_kind_object())))) {\n                                    return (follow(v));\n                                  } else {\n                                    return (\n                                      function (s, m) {\n                                          Debug.impossible_with_heap_because(\n                                            __LOC__, s, m);\n                                          return (Coq_result_impossible());}(\n                                        s3,\n                                        "[run_expr_call] unable to call a non-property function."));\n                                  }\n                                case "Coq_ref_base_type_env_loc":\n                                  var l0 = _switch_arg_62.value;\n                                  return (\n                                    if_some(\n                                      env_record_implicit_this_value(s3, l0),\n                                      function(v) { \n                                                    return (follow(v));}));\n                              }\n                              \n                          }\n                          \n                        } else {\n                          return (run_error(s3, c, Coq_native_error_type()));\n                        }\n                      default:\n                        return (run_error(s3, c, Coq_native_error_type()));\n                    }\n                    }));}));}));\n};\n\nvar run_expr_conditionnal = function (s, c, e1, e2, e3) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = to_boolean(v1);\n        if (b) {\n          var e = e2;\n        } else {\n          var e = e3;\n        }\n        return (\n          if_spec(run_expr_get_value(s1, c, e), function(s0, r) {\n              \n              return (res_ter(s0, res_val(r)));}));}));\n};\n\nvar run_expr_new = function (s, c, e1, e2s) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v) {\n        \n        return (\n          if_spec(run_list_expr(s1, c, mk_nil(), e2s), function(s2, args) {\n              \n              switch (v.tag) {\n                case "Coq_value_object":\n                  var l = v.value;\n                  return (\n                    if_some(run_object_method(object_construct_, s2, l),\n                      function(coo) {\n                        \n                        switch (coo.tag) {\n                          case "Some":\n                            var co = coo.value;\n                            return (run_construct(s2, c, co, l, args));\n                          case "None":\n                            return (\n                              run_error(s2, c, Coq_native_error_type()));\n                        }\n                        }));\n                default:\n                  return (run_error(s2, c, Coq_native_error_type()));\n              }\n              }));}));\n};\n\nvar run_stat_label = function (s, c, lab, t) {\n  return (\n    if_break(run_stat(s, c, t), function(s1, r1) {\n        \n        return (\n          res_out(s1, (function () {\n              if (label_compare(r1.res_label, lab)) {\n                return (res_normal(r1.res_value));\n              } else {\n                return (r1);\n              }}())));}));\n};\n\nvar run_stat_with = function (s, c, e1, t2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        return (\n          if_object(to_object(s1, v1), function(s2, l) {\n              \n              var lex = c.execution_ctx_lexical_env;\n              var p = lexical_env_alloc_object(s2, lex, l, provide_this_true);\n              var lex_2 = p[0], s3 = p[1];\n              var c_2 = execution_ctx_with_lex(c, lex_2);\n              return (run_stat(s3, c_2, t2));}));}));\n};\n\nvar run_stat_if = function (s, c, e1, t2, to0) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = to_boolean(v1);\n        if (b) {\n          return (run_stat(s1, c, t2));\n        } else {\n          switch (to0.tag) {\n            case "Some":\n              var t3 = to0.value;\n              return (run_stat(s1, c, t3));\n            case "None":\n              return (res_out(s1, res_normal(Coq_resvalue_empty())));\n          }\n          \n        }}));\n};\n\nvar run_stat_while = function (s, c, rv, labs, e1, t2) {\n  return (\n    if_spec(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = to_boolean(v1);\n        if (b) {\n          return (\n            if_ter(run_stat(s1, c, t2), function(s2, r) {\n                \n                if (!(resvalue_compare(r.res_value, Coq_resvalue_empty()))) {\n                  var rv_2 = r.res_value;\n                } else {\n                  var rv_2 = rv;\n                }\n                var loop = function (x) {\n                  return (run_stat_while(s2, c, rv_2, labs, e1, t2));\n                };\n                if ((!(restype_compare(r.res_type, Coq_restype_continue()))\n                    || !(res_label_in(r, labs)))) {\n                  if ((restype_compare(r.res_type, Coq_restype_break())\n                      && res_label_in(r, labs))) {\n                    return (res_ter(s2, res_normal(rv_2)));\n                  } else {\n                    if (!(restype_compare(r.res_type, Coq_restype_normal()))) {\n                      return (res_ter(s2, r));\n                    } else {\n                      return (loop({}));\n                    }\n                  }\n                } else {\n                  return (loop({}));\n                }}));\n        } else {\n          return (res_ter(s1, res_normal(rv)));\n        }}));\n};\n\nvar run_stat_switch_end = function (s, c, rv, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_normal(rv)));\n    case "::":\n      var y = _foo_.head, scs_2 = _foo_.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            ifx_success_state(rv, run_block(s, c, rev(ts)),\n              function (s1, rv1) {\n                return (run_stat_switch_end(s1, c, rv1, scs_2));}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_no_default = function (s, c, vi, rv, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_normal(rv)));\n    case "::":\n      var y = _foo_.head, scs_2 = _foo_.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n                \n                var b = strict_equality_test(v1, vi);\n                if (b) {\n                  return (\n                    if_success(run_block(s1, c, rev(ts)), function(s2, rv2) {\n                        \n                        return (run_stat_switch_end(s2, c, rv2, scs_2));}));\n                } else {\n                  return (run_stat_switch_no_default(s1, c, vi, rv, scs_2));\n                }}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_default = function (s, c, ts, scs) {\n  return (\n    if_success(run_block(s, c, rev(ts)), function(s1, rv) {\n        \n        return (run_stat_switch_end(s1, c, rv, scs));}));\n};\n\nvar run_stat_switch_with_default_B = function (s, c, vi, rv, ts0, scs) {\n  switch (scs.tag) {\n    case "[]":\n      return (run_stat_switch_with_default_default(s, c, ts0, scs));\n    case "::":\n      var y = scs.head, scs_2 = scs.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n                \n                var b = strict_equality_test(v1, vi);\n                if (b) {\n                  return (\n                    if_success(run_block(s1, c, rev(ts)), function(s2, rv2) {\n                        \n                        return (run_stat_switch_end(s2, c, rv2, scs_2));}));\n                } else {\n                  return (\n                    run_stat_switch_with_default_B(s1, c, vi, rv, ts0, scs_2));\n                }}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_A = function (s, c, found, vi, rv, scs1, ts0, scs2) {\n  switch (scs1.tag) {\n    case "[]":\n      if (found) {\n        return (run_stat_switch_with_default_default(s, c, ts0, scs2));\n      } else {\n        return (run_stat_switch_with_default_B(s, c, vi, rv, ts0, scs2));\n      }\n    case "::":\n      var y = scs1.head, scs_2 = scs1.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          var follow = function (s0) {\n            return (\n              ifx_success_state(rv, run_block(s0, c, rev(ts)),\n                function (s1, rv0) {\n                  return (\n                    run_stat_switch_with_default_A(s1, c, true, vi, rv0,\n                      scs_2, ts0, scs2));}));\n          };\n          if (found) {\n            return (follow(s));\n          } else {\n            return (\n              if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n                  \n                  var b = strict_equality_test(v1, vi);\n                  if (b) {\n                    return (follow(s1));\n                  } else {\n                    return (\n                      run_stat_switch_with_default_A(s1, c, false, vi, rv,\n                        scs_2, ts0, scs2));\n                  }}));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch = function (s, c, labs, e, sb) {\n  return (\n    if_spec(run_expr_get_value(s, c, e), function(s1, vi) {\n        \n        var follow = function (w) {\n          return (\n            if_success(\n              if_break(w, function(s2, r) {\n                  \n                  if (res_label_in(r, labs)) {\n                    return (res_out(s2, res_normal(r.res_value)));\n                  } else {\n                    return (res_out(s2, r));\n                  }}), function(s0, r) { \n                                         return (res_ter(s0, res_normal(r)));\n              }));\n        };\n        switch (sb.tag) {\n          case "Coq_switchbody_nodefault":\n            var scs = sb.clauses;\n            return (\n              follow(\n                run_stat_switch_no_default(s1, c, vi, Coq_resvalue_empty(),\n                  scs)));\n          case "Coq_switchbody_withdefault":\n            var scs1 = sb.clauses_before, ts = sb.clause_default,\n              scs2 = sb.clauses_after;\n            return (\n              follow(\n                run_stat_switch_with_default_A(s1, c, false, vi,\n                  Coq_resvalue_empty(), scs1, ts, scs2)));\n        }\n        }));\n};\n\nvar run_stat_do_while = function (s, c, rv, labs, e1, t2) {\n  return (\n    if_ter(run_stat(s, c, t2), function(s1, r) {\n        \n        if (resvalue_compare(r.res_value, Coq_resvalue_empty())) {\n          var rv_2 = rv;\n        } else {\n          var rv_2 = r.res_value;\n        }\n        var loop = function (x) {\n          return (\n            if_spec(run_expr_get_value(s1, c, e1), function(s2, v1) {\n                \n                var b = to_boolean(v1);\n                if (b) {\n                  return (run_stat_do_while(s2, c, rv_2, labs, e1, t2));\n                } else {\n                  return (res_ter(s2, res_normal(rv_2)));\n                }}));\n        };\n        if ((restype_compare(r.res_type, Coq_restype_continue())\n            && res_label_in(r, labs))) {\n          return (loop({}));\n        } else {\n          if ((restype_compare(r.res_type, Coq_restype_break())\n              && res_label_in(r, labs))) {\n            return (res_ter(s1, res_normal(rv_2)));\n          } else {\n            if (!(restype_compare(r.res_type, Coq_restype_normal()))) {\n              return (res_ter(s1, r));\n            } else {\n              return (loop({}));\n            }\n          }\n        }}));\n};\n\nvar run_stat_try = function (s, c, t1, t2o, t3o) {\n  var finallycont = function (s1, r) {\n    switch (t3o.tag) {\n      case "Some":\n        var t3 = t3o.value;\n        return (\n          if_success(run_stat(s1, c, t3), function(s2, rv_2) {\n              \n              return (res_ter(s2, r));}));\n      case "None":\n        return (res_ter(s1, r));\n    }\n    \n  };\n  return (\n    ifx_any_or_throw(run_stat(s, c, t1), finallycont, function (s1, v) {\n        switch (t2o.tag) {\n          case "Some":\n            var y = t2o.value;\n            var x = y[0], t2 = y[1];\n            var lex = c.execution_ctx_lexical_env;\n            var p = lexical_env_alloc_decl(s1, lex);\n            var lex_2 = p[0], s_2 = p[1];\n            switch (lex_2.tag) {\n              case "[]":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s_2,\n                    "Empty lexical environnment in [run_stat_try]."));\n              case "::":\n                var l = lex_2.head, oldlex = lex_2.tail;\n                return (\n                  if_void(\n                    env_record_create_set_mutable_binding(s_2, c, l, x,\n                      None(), v, throw_irrelevant), function(s2) {\n                      \n                      var c_2 = execution_ctx_with_lex(c, lex_2);\n                      return (\n                        if_ter(run_stat(s2, c_2, t2), function(s3, r) {\n                            \n                            return (finallycont(s3, r));}));}));\n            }\n            \n          case "None":\n            return (finallycont(s1, res_throw(Coq_resvalue_value(v))));\n        }\n        }));\n};\n\nvar run_stat_throw = function (s, c, e) {\n  return (\n    if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n        \n        return (res_ter(s1, res_throw(Coq_resvalue_value(v1))));}));\n};\n\nvar run_stat_return = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var e = _foo_.value;\n      return (\n        if_spec(run_expr_get_value(s, c, e), function(s1, v1) {\n            \n            return (res_ter(s1, res_return(Coq_resvalue_value(v1))));}));\n    case "None":\n      return (res_out(s, res_return(Coq_resvalue_value(Coq_value_undef()))));\n  }\n  \n};\n\nvar run_stat_for_loop = function (s, c, labs, rv, eo2, eo3, t) {\n  var follows = function (s0) {\n    return (\n      if_ter(run_stat(s0, c, t), function(s1, r) {\n          \n          if (!(resvalue_compare(r.res_value, Coq_resvalue_empty()))) {\n            var rv_2 = r.res_value;\n          } else {\n            var rv_2 = rv;\n          }\n          var loop = function (s2) {\n            return (run_stat_for_loop(s2, c, labs, rv_2, eo2, eo3, t));\n          };\n          if ((restype_compare(r.res_type, Coq_restype_break())\n              && res_label_in(r, labs))) {\n            return (res_ter(s1, res_normal(rv_2)));\n          } else {\n            if ((restype_compare(r.res_type, Coq_restype_normal())\n                || (restype_compare(r.res_type, Coq_restype_continue())\n                   && res_label_in(r, labs)))) {\n              switch (eo3.tag) {\n                case "Some":\n                  var e3 = eo3.value;\n                  return (\n                    if_spec(run_expr_get_value(s1, c, e3), function(s2, v3) {\n                        \n                        return (loop(s2));}));\n                case "None":\n                  return (loop(s1));\n              }\n              \n            } else {\n              return (res_ter(s1, r));\n            }\n          }}));\n  };\n  switch (eo2.tag) {\n    case "Some":\n      var e2 = eo2.value;\n      return (\n        if_spec(run_expr_get_value(s, c, e2), function(s0, v2) {\n            \n            var b = to_boolean(v2);\n            if (b) {\n              return (follows(s0));\n            } else {\n              return (res_ter(s0, res_normal(rv)));\n            }}));\n    case "None":\n      return (follows(s));\n  }\n  \n};\n\nvar run_stat_for = function (s, c, labs, eo1, eo2, eo3, t) {\n  var follows = function (s0) {\n    return (\n      run_stat_for_loop(s0, c, labs, Coq_resvalue_empty(), eo2, eo3, t));\n  };\n  switch (eo1.tag) {\n    case "Some":\n      var e1 = eo1.value;\n      return (\n        if_spec(run_expr_get_value(s, c, e1), function(s0, v1) {\n            \n            return (follows(s0));}));\n    case "None":\n      return (follows(s));\n  }\n  \n};\n\nvar run_stat_for_var = function (s, c, labs, ds, eo2, eo3, t) {\n  return (\n    if_ter(run_stat(s, c, Coq_stat_var_decl(ds)), function(s0, r) {\n        \n        return (\n          run_stat_for_loop(s0, c, labs, Coq_resvalue_empty(), eo2, eo3, t));\n      }));\n};\n\nvar run_expr = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_expr_this":\n      return (res_out(s, res_val(c.execution_ctx_this_binding)));\n    case "Coq_expr_identifier":\n      var x = _term_.name;\n      return (\n        if_spec(identifier_resolution(s, c, x), function(s0, r) {\n            \n            return (res_ter(s0, res_ref(r)));}));\n    case "Coq_expr_literal":\n      var i = _term_.value;\n      return (res_out(s, res_val(convert_literal_to_prim(i))));\n    case "Coq_expr_object":\n      var pds = _term_.fields;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n          function(s1, l) { \n                            return (init_object(s1, c, l, pds));}));\n    case "Coq_expr_array":\n      var oes = _term_.elements;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_array(), mk_nil()),\n          function(s1, l) { \n                            return (init_array(s1, c, l, oes));}));\n    case "Coq_expr_function":\n      var fo = _term_.func_name_opt, args = _term_.arg_names,\n        bd = _term_.body;\n      return (run_expr_function(s, c, fo, args, bd));\n    case "Coq_expr_access":\n      var e1 = _term_.obj, e2 = _term_.field;\n      return (run_expr_access(s, c, e1, e2));\n    case "Coq_expr_member":\n      var e1 = _term_.obj, f = _term_.field_name;\n      return (\n        run_expr(s, c,\n          Coq_expr_access(e1, Coq_expr_literal(Coq_literal_string(f)))));\n    case "Coq_expr_new":\n      var e1 = _term_.func, e2s = _term_.args;\n      return (run_expr_new(s, c, e1, e2s));\n    case "Coq_expr_call":\n      var e1 = _term_.func, e2s = _term_.args;\n      return (run_expr_call(s, c, e1, e2s));\n    case "Coq_expr_unary_op":\n      var op = _term_.op, e0 = _term_.arg;\n      return (run_unary_op(s, c, op, e0));\n    case "Coq_expr_binary_op":\n      var e1 = _term_.arg1, op = _term_.op, e2 = _term_.arg2;\n      return (run_expr_binary_op(s, c, op, e1, e2));\n    case "Coq_expr_conditional":\n      var e1 = _term_.cond, e2 = _term_.then_branch, e3 = _term_.else_branch;\n      return (run_expr_conditionnal(s, c, e1, e2, e3));\n    case "Coq_expr_assign":\n      var e1 = _term_.left_expr, opo = _term_.op_opt, e2 = _term_.right_expr;\n      return (run_expr_assign(s, c, opo, e1, e2));\n  }\n  \n};\n\nvar run_stat = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_stat_expr":\n      var e = _term_.expr;\n      return (\n        if_spec(run_expr_get_value(s, c, e), function(s0, r) {\n            \n            return (res_ter(s0, res_val(r)));}));\n    case "Coq_stat_label":\n      var lab = _term_.label, t0 = _term_.stat;\n      return (run_stat_label(s, c, Coq_label_string(lab), t0));\n    case "Coq_stat_block":\n      var ts = _term_.stats;\n      return (run_block(s, c, rev(ts)));\n    case "Coq_stat_var_decl":\n      var xeos = _term_.decls;\n      return (run_var_decl(s, c, xeos));\n    case "Coq_stat_if":\n      var e1 = _term_.cond, t2 = _term_.then_branch,\n        to0 = _term_.else_branch;\n      return (run_stat_if(s, c, e1, t2, to0));\n    case "Coq_stat_do_while":\n      var ls = _term_.labels, t1 = _term_.body, e2 = _term_.cond;\n      return (run_stat_do_while(s, c, Coq_resvalue_empty(), ls, e2, t1));\n    case "Coq_stat_while":\n      var ls = _term_.labels, e1 = _term_.cond, t2 = _term_.body;\n      return (run_stat_while(s, c, Coq_resvalue_empty(), ls, e1, t2));\n    case "Coq_stat_with":\n      var e1 = _term_.obj, t2 = _term_.stat;\n      return (run_stat_with(s, c, e1, t2));\n    case "Coq_stat_throw":\n      var e = _term_.arg;\n      return (run_stat_throw(s, c, e));\n    case "Coq_stat_return":\n      var eo = _term_.arg_opt;\n      return (run_stat_return(s, c, eo));\n    case "Coq_stat_break":\n      var so = _term_.label;\n      return (res_out(s, res_break(so)));\n    case "Coq_stat_continue":\n      var so = _term_.label;\n      return (res_out(s, res_continue(so)));\n    case "Coq_stat_try":\n      var t1 = _term_.body, t2o = _term_.catch_stats_opt,\n        t3o = _term_.finally_opt;\n      return (run_stat_try(s, c, t1, t2o, t3o));\n    case "Coq_stat_for":\n      var ls = _term_.labels, eo1 = _term_.init, eo2 = _term_.cond,\n        eo3 = _term_.step, s0 = _term_.body;\n      return (run_stat_for(s, c, ls, eo1, eo2, eo3, s0));\n    case "Coq_stat_for_var":\n      var ls = _term_.labels, ds = _term_.init, eo2 = _term_.cond,\n        eo3 = _term_.step, s0 = _term_.body;\n      return (run_stat_for_var(s, c, ls, ds, eo2, eo3, s0));\n    case "Coq_stat_for_in":\n      var ls = _term_.labels, e1 = _term_.id, e2 = _term_.obj,\n        s0 = _term_.body;\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}("stat_for_in"));\n    case "Coq_stat_for_in_var":\n      var ls = _term_.labels, x = _term_.id, e1o = _term_.init,\n        e2 = _term_.obj, s0 = _term_.body;\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}("stat_for_in_var"));\n    case "Coq_stat_debugger":\n      return (res_out(s, res_empty));\n    case "Coq_stat_switch":\n      var labs = _term_.labels, e = _term_.arg, sb = _term_.body;\n      return (run_stat_switch(s, c, labs, e, sb));\n  }\n  \n};\n\nvar run_elements = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_out(s, res_normal(Coq_resvalue_empty())));\n    case "::":\n      var el = _foo_.head, els_rev_2 = _foo_.tail;\n      return (\n        if_success(run_elements(s, c, els_rev_2), function(s0, rv0) {\n            \n            switch (el.tag) {\n              case "Coq_element_stat":\n                var t = el.stat;\n                return (\n                  if_ter(run_stat(s0, c, t), function(s1, r1) {\n                      \n                      var r2 = res_overwrite_value_if_empty(rv0, r1);\n                      return (res_out(s1, r2));}));\n              case "Coq_element_func_decl":\n                var name = el.func_name, args = el.arg_names, bd = el.body;\n                return (res_ter(s0, res_normal(rv0)));\n            }\n            }));\n  }\n  \n};\n\nvar run_prog = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_prog_intro":\n      var str = _term_.strictness, els = _term_.elements;\n      return (run_elements(s, c, rev(els)));\n  }\n  \n};\n\nvar push = function (s, c, l, args, ilen) {\n  var vlen = ilen;\n  switch (args.tag) {\n    case "[]":\n      return (\n        if_not_throw(\n          object_put(s, c, l, "length", Coq_value_number(vlen), throw_true),\n          function(s0, x) {\n            \n            return (res_out(s0, res_val(Coq_value_number(vlen))));}));\n    case "::":\n      var v = args.head, vs = args.tail;\n      return (\n        if_string(to_string(s, c, Coq_value_number(vlen)), function(s0,\n          slen) {\n            \n            return (\n              if_not_throw(object_put(s0, c, l, slen, v, throw_true),\n                function(s1, x) { \n                                  return (push(s1, c, l, vs, (ilen + 1.)));}));\n          }));\n  }\n  \n};\n\nvar run_object_is_sealed = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_method(object_extensible_, s, l), function(ext) {\n            \n            return (res_ter(s, res_val(Coq_value_bool(!(ext)))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_spec(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if (attributes_configurable(a)) {\n                  return (res_ter(s0, res_val(Coq_value_bool(false))));\n                } else {\n                  return (run_object_is_sealed(s0, c, l, xs_2));\n                }\n            }\n            }));\n  }\n  \n};\n\nvar run_object_seal = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_heap_set_extensible(false, s, l), function(s0) {\n            \n            return (res_ter(s0, res_val(Coq_value_object(l))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_spec(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_seal]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if (attributes_configurable(a)) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: None(),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: Some(false)\n                  };\n                  var a_2 = attributes_update(a, desc);\n                } else {\n                  var a_2 = a;\n                }\n                return (\n                  if_bool(\n                    object_define_own_prop(s0, c, l, x,\n                      descriptor_of_attributes(a_2), true), function(s1,\n                    x0) { \n                          return (run_object_seal(s1, c, l, xs_2));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_object_freeze = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_heap_set_extensible(false, s, l), function(s0) {\n            \n            return (res_ter(s0, res_val(Coq_value_object(l))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_spec(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if ((attributes_is_data_dec(a) && attributes_writable(a))) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: Some(false),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: None()\n                  };\n                  var a_2 = attributes_update(a, desc);\n                } else {\n                  var a_2 = a;\n                }\n                if (attributes_configurable(a_2)) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: None(),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: Some(false)\n                  };\n                  var a_3 = attributes_update(a_2, desc);\n                } else {\n                  var a_3 = a_2;\n                }\n                return (\n                  if_bool(\n                    object_define_own_prop(s0, c, l, x,\n                      descriptor_of_attributes(a_3), true), function(s1,\n                    x0) { \n                          return (run_object_freeze(s1, c, l, xs_2));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_object_is_frozen = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_method(object_extensible_, s, l), function(ext) {\n            \n            return (res_ter(s, res_val(Coq_value_bool(!(ext)))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_spec(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            var check_configurable = function (a) {\n              if (attributes_configurable(a)) {\n                return (res_ter(s0, res_val(Coq_value_bool(false))));\n              } else {\n                return (run_object_is_frozen(s0, c, l, xs_2));\n              }\n            };\n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                switch (a.tag) {\n                  case "Coq_attributes_data_of":\n                    var ad = a.value;\n                    if (attributes_writable(Coq_attributes_data_of(ad))) {\n                      return (res_ter(s0, res_val(Coq_value_bool(false))));\n                    } else {\n                      return (\n                        check_configurable(Coq_attributes_data_of(ad)));\n                    }\n                  case "Coq_attributes_accessor_of":\n                    var aa = a.value;\n                    return (\n                      check_configurable(Coq_attributes_accessor_of(aa)));\n                }\n                \n            }\n            }));\n  }\n  \n};\n\nvar run_get_args_for_apply = function (s, c, l, index, n) {\n  if ((index < n)) {\n    return (\n      if_string(to_string(s, c, Coq_value_number(index)), function(s0,\n        sindex) {\n          \n          return (\n            if_value(run_object_get(s0, c, l, sindex), function(s1, v) {\n                \n                var tail_args = run_get_args_for_apply(s1, c, l,\n                                  (index + 1.), n);\n                return (\n                  if_spec(tail_args, function(s2, tail) {\n                      \n                      return (res_spec(s2, mk_cons(v, tail)));}));}));}));\n  } else {\n    return (res_spec(s, mk_nil()));\n  }\n};\n\nvar valueToStringForJoin = function (s, c, l, k) {\n  return (\n    if_string(to_string(s, c, Coq_value_number(k)), function(s0, prop) {\n        \n        return (\n          if_value(run_object_get(s0, c, l, prop), function(s1, v) {\n              \n              switch (v.tag) {\n                case "Coq_value_undef":\n                  return (res_spec(s1, ""));\n                case "Coq_value_null":\n                  return (res_spec(s1, ""));\n                case "Coq_value_bool":\n                  var b = v.value;\n                  return (\n                    if_string(to_string(s1, c, v), function(s2, s3) {\n                        \n                        return (res_spec(s2, s3));}));\n                case "Coq_value_number":\n                  var n = v.value;\n                  return (\n                    if_string(to_string(s1, c, v), function(s2, s3) {\n                        \n                        return (res_spec(s2, s3));}));\n                case "Coq_value_string":\n                  var s2 = v.value;\n                  return (\n                    if_string(to_string(s1, c, v), function(s3, s4) {\n                        \n                        return (res_spec(s3, s4));}));\n                case "Coq_value_object":\n                  var o = v.value;\n                  return (\n                    if_string(to_string(s1, c, v), function(s2, s3) {\n                        \n                        return (res_spec(s2, s3));}));\n              }\n              }));}));\n};\n\nvar run_array_join_elements = function (s, c, l, k, length0, sep, sR) {\n  if ((k < length0)) {\n    var ss = strappend(sR, sep);\n    var sE = valueToStringForJoin(s, c, l, k);\n    return (\n      if_spec(sE, function(s0, element) {\n          \n          var sR0 = strappend(ss, element);\n          return (\n            run_array_join_elements(s0, c, l, (k + 1.), length0, sep, sR0));\n        }));\n  } else {\n    return (res_ter(s, res_val(Coq_value_string(sR))));\n  }\n};\n\nvar run_call_prealloc = function (s, c, b, vthis, args) {\n  switch (b.tag) {\n    case "Coq_prealloc_global_is_finite":\n      var v = get_arg(0, args);\n      return (\n        if_number(to_number(s, c, v), function(s0, n) {\n            \n            return (\n              res_ter(s0,\n                res_val(\n                  Coq_value_bool(\n                    !(\n                      (JsNumber.isnan(n)\n                      || ((n === JsNumber.infinity)\n                         || (n === JsNumber.neg_infinity))))))));}));\n    case "Coq_prealloc_global_is_nan":\n      var v = get_arg(0, args);\n      return (\n        if_number(to_number(s, c, v), function(s0, n) {\n            \n            return (res_ter(s0, res_val(Coq_value_bool(JsNumber.isnan(n)))));\n          }));\n    case "Coq_prealloc_object":\n      var value0 = get_arg(0, args);\n      switch (value0.tag) {\n        case "Coq_value_undef":\n          return (run_construct_prealloc(s, c, b, args));\n        case "Coq_value_null":\n          return (run_construct_prealloc(s, c, b, args));\n        case "Coq_value_bool":\n          var b0 = value0.value;\n          return (to_object(s, value0));\n        case "Coq_value_number":\n          var n = value0.value;\n          return (to_object(s, value0));\n        case "Coq_value_string":\n          var s0 = value0.value;\n          return (to_object(s, value0));\n        case "Coq_value_object":\n          var o = value0.value;\n          return (to_object(s, value0));\n      }\n      \n    case "Coq_prealloc_object_get_proto_of":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(run_object_method(object_proto_, s, l), function(proto) {\n                \n                return (res_ter(s, res_val(proto)));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_get_own_prop_descriptor":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_string(to_string(s, c, get_arg(1, args)), function(s1, x) {\n                \n                return (\n                  if_spec(run_object_get_own_prop(s1, c, l, x), function(s2,\n                    d) { \n                         return (from_prop_descriptor(s2, c, d));}));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_define_prop":\n      var o = get_arg(0, args);\n      var p = get_arg(1, args);\n      var attr = get_arg(2, args);\n      switch (o.tag) {\n        case "Coq_value_object":\n          var l = o.value;\n          return (\n            if_string(to_string(s, c, p), function(s1, name) {\n                \n                return (\n                  if_spec(to_property_descriptor(s1, attr), function(s2,\n                    desc) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, name, desc, true),\n                          function(s3, x) {\n                            \n                            return (\n                              res_ter(s3, res_val(Coq_value_object(l))));}));\n                    }));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_seal":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_seal(s, c, l, _x_));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_freeze":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_freeze(s, c, l, _x_));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_prevent_extensions":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_binds_option(s, l), function(o) {\n                \n                var o1 = object_with_extension(o, false);\n                var s_2 = object_write(s, l, o1);\n                return (res_ter(s_2, res_val(Coq_value_object(l))));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_is_sealed":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_is_sealed(s, c, l, _x_));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_is_frozen":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_is_frozen(s, c, l, _x_));}));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_is_extensible":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(run_object_method(object_extensible_, s, l),\n              function(r) { \n                            return (res_ter(s, res_val(Coq_value_bool(r))));\n              }));\n        default:\n          return (run_error(s, c, Coq_native_error_type()));\n      }\n      \n    case "Coq_prealloc_object_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_undef":\n          return (\n            res_out(s, res_val(Coq_value_string("[object Undefined]"))));\n        case "Coq_value_null":\n          return (res_out(s, res_val(Coq_value_string("[object Null]"))));\n        case "Coq_value_bool":\n          var b0 = vthis.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s0) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_string(\n                              strappend("[object ", strappend(s0, "]"))))));\n                    }));}));\n        case "Coq_value_number":\n          var n = vthis.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s0) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_string(\n                              strappend("[object ", strappend(s0, "]"))))));\n                    }));}));\n        case "Coq_value_string":\n          var s0 = vthis.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s2) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_string(\n                              strappend("[object ", strappend(s2, "]"))))));\n                    }));}));\n        case "Coq_value_object":\n          var o = vthis.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s0) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_string(\n                              strappend("[object ", strappend(s0, "]"))))));\n                    }));}));\n      }\n      \n    case "Coq_prealloc_object_proto_value_of":\n      return (to_object(s, vthis));\n    case "Coq_prealloc_object_proto_has_own_prop":\n      var v = get_arg(0, args);\n      return (\n        if_string(to_string(s, c, v), function(s1, x) {\n            \n            return (\n              if_object(to_object(s1, vthis), function(s2, l) {\n                  \n                  return (\n                    if_spec(run_object_get_own_prop(s2, c, l, x),\n                      function(s3, d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (\n                              res_ter(s3, res_val(Coq_value_bool(false))));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (\n                              res_ter(s3, res_val(Coq_value_bool(true))));\n                        }\n                        }));}));}));\n    case "Coq_prealloc_object_proto_is_prototype_of":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_object(to_object(s, vthis), function(s1, lo) {\n                \n                return (object_proto_is_prototype_of(s1, lo, l));}));\n        default:\n          return (res_out(s, res_val(Coq_value_bool(false))));\n      }\n      \n    case "Coq_prealloc_object_proto_prop_is_enumerable":\n      var v = get_arg(0, args);\n      return (\n        if_string(to_string(s, c, v), function(s1, x) {\n            \n            return (\n              if_object(to_object(s1, vthis), function(s2, l) {\n                  \n                  return (\n                    if_spec(run_object_get_own_prop(s2, c, l, x),\n                      function(s3, d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (\n                              res_ter(s3, res_val(Coq_value_bool(false))));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (\n                              res_ter(s3,\n                                res_val(\n                                  Coq_value_bool(attributes_enumerable(a)))));\n                        }\n                        }));}));}));\n    case "Coq_prealloc_function_proto":\n      return (res_out(s, res_val(Coq_value_undef())));\n    case "Coq_prealloc_function_proto_to_string":\n      if (is_callable_dec(s, vthis)) {\n        return (\n          function (s) {\n              Debug.not_yet_implemented_because(__LOC__, s);\n              return (Coq_result_not_yet_implemented());}(\n            "Function.prototype.toString() is implementation dependent."));\n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_apply":\n      var thisArg = get_arg(0, args);\n      var argArray = get_arg(1, args);\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            switch (argArray.tag) {\n              case "Coq_value_undef":\n                return (run_call(s, c, thisobj, thisArg, mk_nil()));\n              case "Coq_value_null":\n                return (run_call(s, c, thisobj, thisArg, mk_nil()));\n              case "Coq_value_bool":\n                var b0 = argArray.value;\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Coq_value_number":\n                var n = argArray.value;\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Coq_value_string":\n                var s0 = argArray.value;\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Coq_value_object":\n                var array = argArray.value;\n                return (\n                  if_value(run_object_get(s, c, array, "length"),\n                    function(s0, v) {\n                      \n                      return (\n                        if_spec(to_uint32(s0, c, v), function(s1, ilen) {\n                            \n                            return (\n                              if_spec(\n                                run_get_args_for_apply(s1, c, array, 0.,\n                                  ilen), function(s2, arguments_) {\n                                  \n                                  return (\n                                    run_call(s2, c, thisobj, thisArg,\n                                      arguments_));}));}));}));\n            }\n            \n          default:\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_call":\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            var _tuple_arg_63 = get_arg_first_and_rest(args);\n            var thisArg = _tuple_arg_63[0], a = _tuple_arg_63[1];\n            return (run_call(s, c, thisobj, thisArg, a));\n          default:\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_bind":\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            var _tuple_arg_64 = get_arg_first_and_rest(args);\n            var vthisArg = _tuple_arg_64[0], a = _tuple_arg_64[1];\n            var o1 = object_new(\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                       "Object");\n            var o2 = object_with_get(o1, Coq_builtin_get_function());\n            var o3 = object_with_details(o2, None(), None(), None(),\n                       Some(thisobj), Some(vthisArg), Some(a), None());\n            var o4 = object_set_class(o3, "Function");\n            var o5 = object_set_proto(o4,\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(\n                           Coq_prealloc_function_proto())));\n            var o6 = object_with_invokation(o5,\n                       Some(Coq_construct_after_bind()),\n                       Some(Coq_call_after_bind()),\n                       Some(Coq_builtin_has_instance_after_bind()));\n            var o7 = object_set_extensible(o6, true);\n            var _tuple_arg_65 = object_alloc(s, o7);\n            var l = _tuple_arg_65[0], s_2 = _tuple_arg_65[1];\n            var vlength = if_some(\n                            run_object_method(object_class_, s_2, thisobj),\n                            function(class0) {\n                              \n                              if (string_eq(class0, "Function")) {\n                                return (\n                                  if_number(\n                                    run_object_get(s_2, c, thisobj, "length"),\n                                    function(s10, n) {\n                                      \n                                      return (\n                                        if_spec(\n                                          to_int32(s10, c,\n                                            Coq_value_number(n)),\n                                          function(s11, ilen) {\n                                            \n                                            if ((ilen\n                                                < number_of_int(\n                                                    LibList.length(a)))) {\n                                              return (res_spec(s11, 0.));\n                                            } else {\n                                              return (\n                                                res_spec(s11,\n                                                  (ilen\n                                                  - number_of_int(\n                                                      LibList.length(a)))));\n                                            }}));}));\n                              } else {\n                                return (res_spec(s_2, 0.));\n                              }});\n            return (\n              if_spec(vlength, function(s10, length0) {\n                  \n                  var a0 = {\n                    attributes_data_value: Coq_value_number(length0),\n                    attributes_data_writable: false,\n                    attributes_data_enumerable: false,\n                    attributes_data_configurable: false\n                  };\n                  return (\n                    if_some(\n                      run_object_heap_map_properties(s10, l, function (p) {\n                          return (\n                            HeapStr.write(p, "length",\n                              Coq_attributes_data_of(a0)));}),\n                      function(s11) {\n                        \n                        var vthrower = Coq_value_object(\n                                         Coq_object_loc_prealloc(\n                                           Coq_prealloc_throw_type_error()));\n                        var a1 = {\n                          attributes_accessor_get: vthrower,\n                          attributes_accessor_set: vthrower,\n                          attributes_accessor_enumerable: false,\n                          attributes_accessor_configurable: false\n                        };\n                        return (\n                          if_bool(\n                            object_define_own_prop(s11, c, l, "caller",\n                              descriptor_of_attributes(\n                                Coq_attributes_accessor_of(a1)), false),\n                            function(s12, x) {\n                              \n                              return (\n                                if_bool(\n                                  object_define_own_prop(s12, c, l,\n                                    "arguments",\n                                    descriptor_of_attributes(\n                                      Coq_attributes_accessor_of(a1)), false),\n                                  function(s13, x0) {\n                                    \n                                    return (\n                                      res_ter(s13,\n                                        res_val(Coq_value_object(l))));}));}));\n                      }));}));\n          default:\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_bool":\n      var v = get_arg(0, args);\n      return (res_out(s, res_val(Coq_value_bool(to_boolean(v)))));\n    case "Coq_prealloc_bool_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_undef":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_null":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_bool":\n          var b0 = vthis.value;\n          return (\n            res_ter(s, res_val(Coq_value_string(convert_bool_to_string(b0)))));\n        case "Coq_value_number":\n          var n = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_string":\n          var s0 = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_undef":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_null":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_bool":\n                                var b0 = v.value;\n                                return (\n                                  res_ter(s,\n                                    res_val(\n                                      Coq_value_string(\n                                        convert_bool_to_string(b0)))));\n                              case "Coq_value_number":\n                                var n = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_string":\n                                var s1 = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_bool_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_undef":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_null":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_bool":\n          var b0 = vthis.value;\n          return (res_ter(s, res_val(Coq_value_bool(b0))));\n        case "Coq_value_number":\n          var n = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_string":\n          var s0 = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_undef":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_null":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_bool":\n                                var b0 = v.value;\n                                return (\n                                  res_ter(s, res_val(Coq_value_bool(b0))));\n                              case "Coq_value_number":\n                                var n = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_string":\n                                var s1 = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_number":\n      if (list_eq_nil_decidable(args)) {\n        return (res_out(s, res_val(Coq_value_number(JsNumber.zero))));\n      } else {\n        var v = get_arg(0, args);return (to_number(s, c, v));\n      }\n    case "Coq_prealloc_number_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_undef":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_null":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_bool":\n          var b0 = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_number":\n          var n = vthis.value;\n          return (res_ter(s, res_val(Coq_value_number(n))));\n        case "Coq_value_string":\n          var s0 = vthis.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Number")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_undef":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_null":\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_bool":\n                                var b0 = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_number":\n                                var n = v.value;\n                                return (\n                                  res_ter(s, res_val(Coq_value_number(n))));\n                              case "Coq_value_string":\n                                var s1 = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_array":\n      return (run_construct_prealloc(s, c, Coq_prealloc_array(), args));\n    case "Coq_prealloc_array_is_array":\n      var arg = get_arg(0, args);\n      switch (arg.tag) {\n        case "Coq_value_object":\n          var arg0 = arg.value;\n          return (\n            if_some(run_object_method(object_class_, s, arg0),\n              function(class0) {\n                \n                if (string_eq(class0, "Array")) {\n                  return (res_ter(s, res_val(Coq_value_bool(true))));\n                } else {\n                  return (res_ter(s, res_val(Coq_value_bool(false))));\n                }}));\n        default:\n          return (res_ter(s, res_val(Coq_value_bool(false))));\n      }\n      \n    case "Coq_prealloc_array_proto_to_string":\n      return (\n        if_object(to_object(s, vthis), function(s0, array) {\n            \n            return (\n              if_value(run_object_get(s0, c, array, "join"), function(s1,\n                vfunc) {\n                  \n                  if (is_callable_dec(s1, vfunc)) {\n                    switch (vfunc.tag) {\n                      case "Coq_value_object":\n                        var func = vfunc.value;\n                        return (\n                          run_call(s1, c, func, Coq_value_object(array),\n                            mk_nil()));\n                      default:\n                        return (\n                          function (s, m) {\n                              Debug.impossible_with_heap_because(__LOC__, s,\n                                m);\n                              return (Coq_result_impossible());}(s1,\n                            "Value is callable, but isn\'t an object."));\n                    }\n                    \n                  } else {\n                    return (\n                      run_call_prealloc(s1, c,\n                        Coq_prealloc_object_proto_to_string(),\n                        Coq_value_object(array), mk_nil()));\n                  }}));}));\n    case "Coq_prealloc_array_proto_join":\n      var vsep = get_arg(0, args);\n      return (\n        if_object(to_object(s, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        if (!(value_compare(vsep, Coq_value_undef()))) {\n                          var rsep = vsep;\n                        } else {\n                          var rsep = Coq_value_string(",");\n                        }\n                        return (\n                          if_string(to_string(s2, c, rsep), function(s3,\n                            sep) {\n                              \n                              if ((ilen == 0.0)) {\n                                return (\n                                  res_ter(s3, res_val(Coq_value_string(""))));\n                              } else {\n                                var sR = valueToStringForJoin(s3, c, l, 0.);\n                                return (\n                                  if_spec(sR, function(s4, sR0) {\n                                      \n                                      return (\n                                        run_array_join_elements(s4, c, l, 1.,\n                                          ilen, sep, sR0));}));\n                              }}));}));}));}));\n    case "Coq_prealloc_array_proto_pop":\n      return (\n        if_object(to_object(s, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        if ((ilen == 0.0)) {\n                          return (\n                            if_not_throw(\n                              object_put(s2, c, l, "length",\n                                Coq_value_number(JsNumber.zero), throw_true),\n                              function(s3, x) {\n                                \n                                return (\n                                  res_out(s3, res_val(Coq_value_undef())));}));\n                        } else {\n                          return (\n                            if_string(\n                              to_string(s2, c, Coq_value_number((ilen - 1.))),\n                              function(s3, sindx) {\n                                \n                                return (\n                                  if_value(run_object_get(s3, c, l, sindx),\n                                    function(s4, velem) {\n                                      \n                                      return (\n                                        if_not_throw(\n                                          object_delete_default(s4, c, l,\n                                            sindx, throw_true), function(s5,\n                                          x) {\n                                            \n                                            return (\n                                              if_not_throw(\n                                                object_put(s5, c, l,\n                                                  "length",\n                                                  Coq_value_string(sindx),\n                                                  throw_true), function(s6,\n                                                x0) {\n                                                  \n                                                  return (\n                                                    res_out(s6,\n                                                      res_val(velem)));}));}));\n                                    }));}));\n                        }}));}));}));\n    case "Coq_prealloc_array_proto_push":\n      return (\n        if_object(to_object(s, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_spec(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        return (push(s2, c, l, args, ilen));}));}));}));\n    case "Coq_prealloc_string":\n      if (list_eq_nil_decidable(args)) {\n        return (res_ter(s, res_val(Coq_value_string(""))));\n      } else {\n        var value0 = get_arg(0, args);\n        return (\n          if_string(to_string(s, c, value0), function(s0, s1) {\n              \n              return (res_ter(s0, res_val(Coq_value_string(s1))));}));\n      }\n    case "Coq_prealloc_string_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            if_some(run_object_method(object_class_, s, l), function(s0) {\n                \n                if (string_eq(s0, "String")) {\n                  return (run_object_prim_value(s, l));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n        default:\n          if (type_compare(type_of(vthis), Coq_type_string())) {\n            return (res_ter(s, res_val(vthis)));\n          } else {\n            return (run_error(s, c, Coq_native_error_type()));\n          }\n      }\n      \n    case "Coq_prealloc_string_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            if_some(run_object_method(object_class_, s, l), function(s0) {\n                \n                if (string_eq(s0, "String")) {\n                  return (run_object_prim_value(s, l));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n        default:\n          if (type_compare(type_of(vthis), Coq_type_string())) {\n            return (res_ter(s, res_val(vthis)));\n          } else {\n            return (run_error(s, c, Coq_native_error_type()));\n          }\n      }\n      \n    case "Coq_prealloc_error":\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_error_proto())), v));\n    case "Coq_prealloc_native_error":\n      var ne = b.error;\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))), v));\n    case "Coq_prealloc_throw_type_error":\n      return (run_error(s, c, Coq_native_error_type()));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}(\n          strappend("Call prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented"))));\n  }\n  \n};\n\nvar run_call = function (s, c, l, vthis, args) {\n  return (\n    if_some(run_object_method(object_call_, s, l), function(co) {\n        \n        return (\n          if_some(co, function(c0) {\n              \n              switch (c0.tag) {\n                case "Coq_call_default":\n                  return (entering_func_code(s, c, l, vthis, args));\n                case "Coq_call_after_bind":\n                  return (\n                    if_some(run_object_method(object_bound_args_, s, l),\n                      function(oarg) {\n                        \n                        return (\n                          if_some(oarg, function(boundArgs) {\n                              \n                              return (\n                                if_some(\n                                  run_object_method(object_bound_this_, s, l),\n                                  function(obnd) {\n                                    \n                                    return (\n                                      if_some(obnd, function(boundThis) {\n                                          \n                                          return (\n                                            if_some(\n                                              run_object_method(\n                                                object_target_function_, s,\n                                                l), function(otrg) {\n                                                \n                                                return (\n                                                  if_some(otrg,\n                                                    function(target) {\n                                                      \n                                                      var arguments_ = \n                                                      LibList.append(\n                                                        boundArgs, args);\n                                                      return (\n                                                        run_call(s, c,\n                                                          target, boundThis,\n                                                          arguments_));}));}));\n                                        }));}));}));}));\n                case "Coq_call_prealloc":\n                  var b = c0.prealloc;\n                  return (run_call_prealloc(s, c, b, vthis, args));\n                case "Coq_call_proxy":\n                  return (Coq_result_not_yet_implemented());\n              }\n              }));}));\n};\n\nvar run_javascript_from_state = function (s, p) {\n  var c = execution_ctx_initial(prog_intro_strictness(p));\n  return (\n    if_void(\n      execution_ctx_binding_inst(s, c, Coq_codetype_global(), None(), p,\n        mk_nil()), function(s_2) { \n                                   return (run_prog(s_2, c, p));}));\n};\n\nvar run_javascript_from_result = function (w, p) {\n  return (\n    if_success(w, function(s, _pat_any_66) {\n        \n        return (run_javascript_from_state(s, p));}));\n};\n\nvar run_javascript = function (p) {\n  return (run_javascript_from_state(state_initial, p));\n};\n}// end of with Datatypes\n}// end of with JsCommon\n}// end of with JsCommonAux\n}// end of with JsInit\n}// end of with JsInterpreterMonads\n}// end of with JsSyntax\n}// end of with JsSyntaxAux\n}// end of with LibList\n}// end of with LibOption\n}// end of with LibProd\n}// end of with Shared\n\nreturn {\n  convert_prim_to_number: convert_prim_to_number, \n  convert_number_to_integer: convert_number_to_integer, \n  convert_bool_to_string: convert_bool_to_string, \n  convert_prim_to_string: convert_prim_to_string, \n  equality_test_for_same_type: equality_test_for_same_type, \n  strict_equality_test: strict_equality_test, \n  inequality_test_number: inequality_test_number, \n  inequality_test_string: inequality_test_string, \n  inequality_test_primitive: inequality_test_primitive, \n  typeof_prim: typeof_prim, \n  string_of_propname: string_of_propname, \n  run_object_method: run_object_method, \n  run_object_set_internal: run_object_set_internal, \n  run_object_heap_set_extensible: run_object_heap_set_extensible, \n  build_error: build_error, \n  run_error: run_error, \n  run_error_no_c: run_error_no_c, \n  object_has_internal_slot: object_has_internal_slot, \n  object_has_internal_method: object_has_internal_method, \n  object_internal_get_prototype_of: object_internal_get_prototype_of, \n  object_internal_set_prototype_of: object_internal_set_prototype_of, \n  object_internal_is_extensible: object_internal_is_extensible, \n  object_internal_prevent_extensions: object_internal_prevent_extensions, \n  object_internal_get_own_property: object_internal_get_own_property, \n  object_internal_define_own_property: object_internal_define_own_property, \n  object_internal_has_property: object_internal_has_property, \n  object_internal_get: object_internal_get, \n  object_internal_set: object_internal_set, \n  object_put: object_put, \n  object_internal_call: object_internal_call, \n  get_base: get_base, \n  get_referenced_name: get_referenced_name, \n  is_strict_reference: is_strict_reference, \n  has_primitive_base: has_primitive_base, \n  is_property_reference: is_property_reference, \n  is_unresolvable_reference: is_unresolvable_reference, \n  is_super_reference: is_super_reference, \n  get_value: get_value, \n  put_value: put_value, \n  get_this_value: get_this_value, \n  is_accessor_descriptor: is_accessor_descriptor, \n  is_data_descriptor: is_data_descriptor, \n  is_generic_descriptor: is_generic_descriptor, \n  to_property_descriptor: to_property_descriptor, \n  complete_property_descriptor: complete_property_descriptor, \n  to_boolean: to_boolean, \n  is_callable: is_callable, \n  is_extensible: is_extensible, \n  is_property_key: is_property_key, \n  same_value: same_value, \n  same_value_non_number: same_value_non_number, \n  get: get, \n  get_v: get_v, \n  set: set, \n  create_data_property: create_data_property, \n  get_method: get_method, \n  has_property: has_property, \n  call: call, \n  set_mutable_binding: set_mutable_binding, \n  get_binding_value: get_binding_value, \n  binding_is_uninitialized: binding_is_uninitialized, \n  binding_is_mutable: binding_is_mutable, \n  decl_env_record_create_mutable_binding: decl_env_record_create_mutable_binding, \n  decl_env_record_initialize_binding: decl_env_record_initialize_binding, \n  decl_env_record_set_mutable_binding: decl_env_record_set_mutable_binding, \n  decl_env_record_get_binding_value: decl_env_record_get_binding_value, \n  object_env_record_set_mutable_binding: object_env_record_set_mutable_binding, \n  object_env_record_get_binding_value: object_env_record_get_binding_value, \n  get_global_object: get_global_object, \n  ordinary_object_internal_get_prototype_of: ordinary_object_internal_get_prototype_of, \n  ordinary_get_prototype_of: ordinary_get_prototype_of, \n  ordinary_object_internal_set_prototype_of: ordinary_object_internal_set_prototype_of, \n  ordinary_set_prototype_of: ordinary_set_prototype_of, \n  ordinary_object_internal_is_extensible: ordinary_object_internal_is_extensible, \n  ordinary_is_extensible: ordinary_is_extensible, \n  ordinary_object_internal_prevent_extensions: ordinary_object_internal_prevent_extensions, \n  ordinary_prevent_extensions: ordinary_prevent_extensions, \n  ordinary_object_internal_get_own_property: ordinary_object_internal_get_own_property, \n  ordinary_get_own_property: ordinary_get_own_property, \n  ordinary_object_internal_define_own_property: ordinary_object_internal_define_own_property, \n  ordinary_define_own_property: ordinary_define_own_property, \n  is_compatible_property_descriptor: is_compatible_property_descriptor, \n  validate_and_apply_property_descriptor: validate_and_apply_property_descriptor, \n  ordinary_object_internal_has_property: ordinary_object_internal_has_property, \n  ordinary_has_property: ordinary_has_property, \n  ordinary_object_internal_set: ordinary_object_internal_set, \n  ordinary_set: ordinary_set, \n  ordinary_own_property_keys: ordinary_own_property_keys, \n  object_has_prop: object_has_prop, \n  out_error_or_void: out_error_or_void, \n  out_error_or_cst: out_error_or_cst, \n  object_get_builtin: object_get_builtin, \n  run_object_get: run_object_get, \n  run_object_get_prop: run_object_get_prop, \n  object_proto_is_prototype_of: object_proto_is_prototype_of, \n  object_default_value: object_default_value, \n  to_primitive: to_primitive, \n  to_number: to_number, \n  to_integer: to_integer, \n  to_int32: to_int32, \n  to_uint32: to_uint32, \n  to_string: to_string, \n  run_object_define_own_prop_array_loop: run_object_define_own_prop_array_loop, \n  object_define_own_prop: object_define_own_prop, \n  prim_new_object: prim_new_object, \n  to_object: to_object, \n  run_object_prim_value: run_object_prim_value, \n  prim_value_get: prim_value_get, \n  env_record_has_binding: env_record_has_binding, \n  lexical_env_get_identifier_ref: lexical_env_get_identifier_ref, \n  object_delete_default: object_delete_default, \n  object_delete: object_delete, \n  env_record_delete_binding: env_record_delete_binding, \n  env_record_implicit_this_value: env_record_implicit_this_value, \n  identifier_resolution: identifier_resolution, \n  env_record_get_binding_value: env_record_get_binding_value, \n  ref_get_value: ref_get_value, \n  run_expr_get_value: run_expr_get_value, \n  env_record_set_mutable_binding: env_record_set_mutable_binding, \n  prim_value_put: prim_value_put, \n  ref_put_value: ref_put_value, \n  env_record_create_mutable_binding: env_record_create_mutable_binding, \n  env_record_create_set_mutable_binding: env_record_create_set_mutable_binding, \n  env_record_create_immutable_binding: env_record_create_immutable_binding, \n  env_record_initialize_immutable_binding: env_record_initialize_immutable_binding, \n  call_object_new: call_object_new, \n  array_args_map_loop: array_args_map_loop, \n  run_construct_prealloc: run_construct_prealloc, \n  run_construct_default: run_construct_default, \n  run_construct: run_construct, \n  run_call_default: run_call_default, \n  creating_function_object_proto: creating_function_object_proto, \n  creating_function_object: creating_function_object, \n  binding_inst_formal_params: binding_inst_formal_params, \n  binding_inst_function_decls: binding_inst_function_decls, \n  make_arg_getter: make_arg_getter, \n  make_arg_setter: make_arg_setter, \n  arguments_object_map_loop: arguments_object_map_loop, \n  arguments_object_map: arguments_object_map, \n  create_arguments_object: create_arguments_object, \n  binding_inst_arg_obj: binding_inst_arg_obj, \n  binding_inst_var_decls: binding_inst_var_decls, \n  execution_ctx_binding_inst: execution_ctx_binding_inst, \n  entering_func_code: entering_func_code, \n  run_object_get_own_prop: run_object_get_own_prop, \n  run_function_has_instance: run_function_has_instance, \n  run_object_has_instance: run_object_has_instance, \n  from_prop_descriptor: from_prop_descriptor, \n  run_equal: run_equal, \n  convert_twice: convert_twice, \n  convert_twice_primitive: convert_twice_primitive, \n  convert_twice_number: convert_twice_number, \n  convert_twice_string: convert_twice_string, \n  issome: issome, \n  run_binary_op_add: run_binary_op_add, \n  run_binary_op_arith: run_binary_op_arith, \n  run_binary_op_shift: run_binary_op_shift, \n  run_binary_op_bitwise: run_binary_op_bitwise, \n  run_binary_op_compare: run_binary_op_compare, \n  run_binary_op_instanceof: run_binary_op_instanceof, \n  run_binary_op_in: run_binary_op_in, \n  run_binary_op: run_binary_op, \n  run_prepost_op: run_prepost_op, \n  run_typeof_value: run_typeof_value, \n  run_unary_op: run_unary_op, \n  create_new_function_in: create_new_function_in, \n  init_object: init_object, \n  run_array_element_list: run_array_element_list, \n  init_array: init_array, \n  run_var_decl_item: run_var_decl_item, \n  run_var_decl: run_var_decl, \n  run_list_expr: run_list_expr, \n  run_block: run_block, \n  run_binary_op_and: run_binary_op_and, \n  run_binary_op_or: run_binary_op_or, \n  run_expr_binary_op: run_expr_binary_op, \n  run_expr_access: run_expr_access, \n  run_expr_assign: run_expr_assign, \n  run_expr_function: run_expr_function, \n  entering_eval_code: entering_eval_code, \n  run_eval: run_eval, \n  run_expr_call: run_expr_call, \n  run_expr_conditionnal: run_expr_conditionnal, \n  run_expr_new: run_expr_new, \n  run_stat_label: run_stat_label, \n  run_stat_with: run_stat_with, \n  run_stat_if: run_stat_if, \n  run_stat_while: run_stat_while, \n  run_stat_switch_end: run_stat_switch_end, \n  run_stat_switch_no_default: run_stat_switch_no_default, \n  run_stat_switch_with_default_default: run_stat_switch_with_default_default, \n  run_stat_switch_with_default_B: run_stat_switch_with_default_B, \n  run_stat_switch_with_default_A: run_stat_switch_with_default_A, \n  run_stat_switch: run_stat_switch, \n  run_stat_do_while: run_stat_do_while, \n  run_stat_try: run_stat_try, \n  run_stat_throw: run_stat_throw, \n  run_stat_return: run_stat_return, \n  run_stat_for_loop: run_stat_for_loop, \n  run_stat_for: run_stat_for, \n  run_stat_for_var: run_stat_for_var, \n  run_expr: run_expr, \n  run_stat: run_stat, \n  run_elements: run_elements, \n  run_prog: run_prog, \n  push: push, \n  run_object_is_sealed: run_object_is_sealed, \n  run_object_seal: run_object_seal, \n  run_object_freeze: run_object_freeze, \n  run_object_is_frozen: run_object_is_frozen, \n  run_get_args_for_apply: run_get_args_for_apply, \n  valueToStringForJoin: valueToStringForJoin, \n  run_array_join_elements: run_array_join_elements, \n  run_call_prealloc: run_call_prealloc, \n  run_call: run_call, \n  run_javascript_from_state: run_javascript_from_state, \n  run_javascript_from_result: run_javascript_from_result, \n  run_javascript: run_javascript};\n})();\n'},

/* --------------------- JsInterpreter.pseudo --------------------- */
  { file: 'JsInterpreter.pseudo', contents: 'var JsInterpreter = (function() {\nwith (Datatypes) {\nwith (JsCommon) {\nwith (JsCommonAux) {\nwith (JsInit) {\nwith (JsInterpreterMonads) {\nwith (JsSyntax) {\nwith (JsSyntaxAux) {\nwith (LibList) {\nwith (LibOption) {\nwith (LibProd) {\nwith (Shared) {\n\nvar convert_prim_to_number = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_undef:\n      return (JsNumber.nan);\n    case Coq_value_null:\n      return (JsNumber.zero);\n    case Coq_value_bool(b):\n      if (b) {\n        return (JsNumber.one);\n      } else {\n        return (JsNumber.zero);\n      }\n    case Coq_value_number(n):\n      return (n);\n    case Coq_value_string(s):\n      return (JsNumber.from_string(s));\n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar convert_number_to_integer = function (n) {\n  if (JsNumber.isnan(n)) {\n    return (JsNumber.zero);\n  } else {\n    if ((JsNumber.isposzero(n)\n        || (JsNumber.isnegzero(n)\n           || ((n === JsNumber.infinity) || (n === JsNumber.neg_infinity))))) {\n      return (n);\n    } else {\n      return ((JsNumber.sign(n) * JsNumber.floor(JsNumber.absolute(n))));\n    }\n  }\n};\n\n\n\nvar convert_bool_to_string = function (_foo_) {\n  switch (_foo_) {\n    case true:\n      return ("true");\n    case false:\n      return ("false");\n  }\n  \n};\n\n\n\nvar convert_prim_to_string = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_undef:\n      return ("undefined");\n    case Coq_value_null:\n      return ("null");\n    case Coq_value_bool(b):\n      return (convert_bool_to_string(b));\n    case Coq_value_number(n):\n      return (JsNumber.to_string(n));\n    case Coq_value_string(s):\n      return (s);\n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar equality_test_for_same_type = function (ty, v1, v2) {\n  switch (ty) {\n    case Coq_type_undef:\n      return (true);\n    case Coq_type_null:\n      return (true);\n    case Coq_type_bool:\n      return (value_compare(v1, v2));\n    case Coq_type_number:\n      switch (v1) {\n        case Coq_value_undef:\n          return (false);\n        case Coq_value_null:\n          return (false);\n        case Coq_value_bool(b):\n          return (false);\n        case Coq_value_string(s):\n          return (false);\n        case Coq_value_number(n1):\n          switch (v2) {\n            case Coq_value_undef:\n              return (false);\n            case Coq_value_null:\n              return (false);\n            case Coq_value_bool(b):\n              return (false);\n            case Coq_value_string(s):\n              return (false);\n            case Coq_value_number(n2):\n              if (JsNumber.isnan(n1)) {\n                return (false);\n              } else {\n                if (JsNumber.isnan(n2)) {\n                  return (false);\n                } else {\n                  if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n                    return (true);\n                  } else {\n                    if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n                      return (true);\n                    } else {\n                      return ((n1 === n2));\n                    }\n                  }\n                }\n              }\n            case Coq_value_object(o):\n              return (false);\n          }\n          \n        case Coq_value_object(o):\n          return (false);\n      }\n      \n    case Coq_type_string:\n      return (value_compare(v1, v2));\n    case Coq_type_object:\n      return (value_compare(v1, v2));\n  }\n  \n};\n\n\n\nvar strict_equality_test = function (v1, v2) {\n  var ty1 = type_of(v1);\n  var ty2 = type_of(v2);\n  if (type_compare(ty1, ty2)) {\n    return (equality_test_for_same_type(ty1, v1, v2));\n  } else {\n    return (false);\n  }\n};\n\n\n\nvar inequality_test_number = function (n1, n2) {\n  if ((JsNumber.isnan(n1) || JsNumber.isnan(n2))) {\n    return (Value_undef);\n  } else {\n    if ((n1 === n2)) {\n      return (Value_bool(false));\n    } else {\n      if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n        return (Value_bool(false));\n      } else {\n        if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n          return (Value_bool(false));\n        } else {\n          if ((n1 === JsNumber.infinity)) {\n            return (Value_bool(false));\n          } else {\n            if ((n2 === JsNumber.infinity)) {\n              return (Value_bool(true));\n            } else {\n              if ((n2 === JsNumber.neg_infinity)) {\n                return (Value_bool(false));\n              } else {\n                if ((n1 === JsNumber.neg_infinity)) {\n                  return (Value_bool(true));\n                } else {\n                  return (Value_bool((n1 < n2)));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n\n\nvar inequality_test_string = function (s1, s2) {\n  return (string_lt(s1, s2));\n};\n\n\n\nvar inequality_test_primitive = function (w1, w2) {\n  switch (w1) {\n    case Coq_value_undef:\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case Coq_value_null:\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case Coq_value_bool(b):\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case Coq_value_number(n):\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case Coq_value_string(s1):\n      switch (w2) {\n        case Coq_value_undef:\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case Coq_value_null:\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case Coq_value_bool(b):\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case Coq_value_number(n):\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case Coq_value_string(s2):\n          return (Value_bool(inequality_test_string(s1, s2)));\n        default:\n          throw false;\n      }\n      \n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar typeof_prim = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_undef:\n      return ("undefined");\n    case Coq_value_null:\n      return ("object");\n    case Coq_value_bool(b):\n      return ("boolean");\n    case Coq_value_number(n):\n      return ("number");\n    case Coq_value_string(s):\n      return ("string");\n    default:\n      throw false;\n  }\n  \n};\n\n\n\nvar string_of_propname = function (_foo_) {\n  switch (_foo_) {\n    case Coq_propname_identifier(s):\n      return (s);\n    case Coq_propname_string(s):\n      return (s);\n    case Coq_propname_number(n):\n      return (JsNumber.to_string(n));\n  }\n  \n};\n\nvar run_object_method = function (proj, l) {\n  return (LibOption.map(proj, object_binds_option(l)));\n};\n\n\n\n\n\nvar run_object_set_internal = function (prj, l, v) {\n  return (\n    LibOption.map(function (o) { return (object_write(l, prj(o, v)));},\n      object_binds_option(l)));\n};\n\n\n\nvar run_object_heap_set_extensible = function (b, l) {\n  return (run_object_set_internal(object_set_extensible, l, b));\n};\n\nvar build_error = function (vproto, vmsg) {\n  var o = object_new(vproto, "Error");\n  var (l, s_2) = object_alloc(o);\n  if (value_compare(vmsg, Value_undef)) {\n    return (l);\n  } else {\n    var%value vstr = to_string(vmsg);\n    var a = {\n      attributes_data_value: vstr,\n      attributes_data_writable: true,\n      attributes_data_enumerable: false,\n      attributes_data_configurable: true\n    };\n    var%success rv = object_define_own_prop(l, "message",\n                       descriptor_of_attributes(a), throw_true);\n    return (l);\n  }\n};\n\nvar run_error = function (ne) {\n  var%object l = build_error(Prealloc_native_error_proto(ne), Value_undef);\n  return (res_throw(l));\n};\n\nvar run_error_no_c = function (ne) {\n  return (run_error(execution_ctx_initial(true), ne));\n};\n\nvar object_has_internal_slot = function (l, prj) {\n  var slot_value = run_object_method(prj, l);\n  switch (slot_value) {\n    case None:\n      throw false;\n    case Some(v):\n      switch (v) {\n        case Some:\n          return (true);\n        case None:\n          return (false);\n      }\n      \n  }\n  \n};\n\nvar object_has_internal_method = function (l, prj) {\n  return (object_has_internal_slot(l, prj));\n};\n\nvar object_internal_get_prototype_of = function (o) {\n  var%some internal_method = run_object_method(object_get_prototype_of_, o);\n  switch (internal_method) {\n    case Coq_builtin_get_prototype_of_default:\n      return (ordinary_object_internal_get_prototype_of(o));\n    case Coq_builtin_get_prototype_of_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_internal_set_prototype_of = function (o, v) {\n  var%some internal_method = run_object_method(object_set_prototype_of_, o);\n  switch (internal_method) {\n    case Coq_builtin_set_prototype_of_default:\n      return (ordinary_object_internal_set_prototype_of(o, v));\n    case Coq_builtin_set_prototype_of_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_internal_is_extensible = function (o) {\n  var%some internal_method = run_object_method(object_is_extensible_, o);\n  switch (internal_method) {\n    case Coq_builtin_is_extensible_default:\n      return (ordinary_object_internal_is_extensible(o));\n    case Coq_builtin_is_extensible_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_internal_prevent_extensions = function (o) {\n  var%some internal_method = run_object_method(object_prevent_extensions_, o);\n  switch (internal_method) {\n    case Coq_builtin_prevent_extensions_default:\n      return (ordinary_object_internal_prevent_extensions(o));\n    case Coq_builtin_prevent_extensions_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_internal_get_own_property = function (o, p) {\n  var%some internal_method = run_object_method(object_get_own_prop_, o);\n  switch (internal_method) {\n    case Coq_builtin_get_own_prop_default:\n      return (ordinary_object_internal_get_own_property(o, p));\n    case Coq_builtin_get_own_prop_args_obj:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_get_own_prop_string:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_get_own_prop_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_internal_define_own_property = function (o, p, desc) {\n  var%some internal_method = run_object_method(object_define_own_prop_, o);\n  switch (internal_method) {\n    case Coq_builtin_define_own_prop_default:\n      return (ordinary_object_internal_define_own_property(o, p, desc));\n    case Coq_builtin_define_own_prop_array:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_define_own_prop_args_obj:\n      return (Result_not_yet_implemented);\n    case Coq_builtin_define_own_prop_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_internal_has_property = function (o, p) {\n  var%some b = run_object_method(object_has_prop_, o);\n  switch (b) {\n    case Coq_builtin_has_prop_default:\n      return (ordinary_has_property(o, p));\n    case Coq_builtin_has_prop_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_internal_get = function (o, p, receiver) {\n  var%some internal_method = run_object_method(object_get_, o);\n  var dispatch_es5 = function (_pat_any_1) {\n    switch (p) {\n      case Coq_value_string(x):\n        return (\n          object_get_builtin(execution_ctx_initial(true), internal_method, o,\n            o, x));\n      default:\n        throw false;\n    }\n    \n  };\n  switch (internal_method) {\n    case Coq_builtin_get_default:\n      return (dispatch_es5({}));\n    case Coq_builtin_get_function:\n      return (dispatch_es5({}));\n    case Coq_builtin_get_args_obj:\n      return (dispatch_es5({}));\n    case Coq_builtin_get_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_internal_set = function (o, p, v, receiver) {\n  var%some internal_method = run_object_method(object_set_, o);\n  switch (internal_method) {\n    case Coq_builtin_set_default:\n      return (ordinary_object_internal_set(o, p, v, receiver));\n    case Coq_builtin_set_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar object_put = function (l, p, v, str) {\n  return (object_internal_set(l, Value_string(p), v, l));\n};\n\nvar object_internal_call = function (o, thisArgument, argumentsList) {\n  return (\n    run_call(execution_ctx_initial(true), o, thisArgument, argumentsList));\n};\n\nvar get_base = ref_base;\n\nvar get_referenced_name = function (r) {\n  return (Value_string(ref_name(r)));\n};\n\nvar is_strict_reference = ref_strict;\n\nvar has_primitive_base = function (r) {\n  return (ref_kind_comparable(ref_kind_of(r), Ref_kind_primitive_base));\n};\n\nvar is_property_reference = function (r) {\n  return (\n    (_compare_JsCommon_ref_kind(ref_kind_of(r), Ref_kind_object)\n    || has_primitive_base(r)));\n};\n\nvar is_unresolvable_reference = function (r) {\n  return (_compare_JsCommon_ref_kind(ref_kind_of(r), Ref_kind_undef));\n};\n\nvar is_super_reference = function (r) {\n  return (is_some(r.ref_this_value));\n};\n\nvar get_value = function (v) {\n  var%success v$ = v;\n  if (!(\n        _compare_JsSyntax_resvalue_type(type_of_resvalue(v$),\n          Type_resvalue_ref))) {\n    return (v);\n  } else {\n    var v = ref_of_resvalue(v$);\n    var base = get_base(v);\n    if (is_unresolvable_reference(v)) {\n      return (run_error_no_c(Native_error_ref));\n    } else {\n      if (is_property_reference(v)) {\n        var base = value_of_ref_base_type(base);\n        var%_ret (s, base) = (function () {\n            if (has_primitive_base(v)) {\n              var%ck_assert_ret _pat_any_2 = (!(\n                                                _compare_JsSyntax_value(base,\n                                                  Value_undef))\n                                             || _compare_JsSyntax_value(base,\n                                                  Value_null));\n              var%ert_object_ret base = to_object(base);\n              return (Continue([s, base]));\n            } else {\n              return (Continue([s, loc_of_value(base)]));\n            }}());\n        return (\n          object_internal_get(base, get_referenced_name(v),\n            get_this_value(v)));\n      } else {\n        var base = env_loc_of_ref_base_type(base);\n        return (\n          get_binding_value(base, get_referenced_name(v),\n            is_strict_reference(v)));\n      }\n    }\n  }\n};\n\nvar put_value = function (c, v, w) {\n  var%success v = v;\n  var%value w = w;\n  if (!(\n        _compare_JsSyntax_resvalue_type(type_of_resvalue(v),\n          Type_resvalue_ref))) {\n    return (run_error_no_c(Native_error_ref));\n  } else {\n    var v = ref_of_resvalue(v);\n    var base = get_base(v);\n    if (is_unresolvable_reference(v)) {\n      if (is_strict_reference(v)) {\n        return (run_error_no_c(Native_error_ref));\n      } else {\n        var globalObj = get_global_object(c);\n        return (\n          set(globalObj, get_referenced_name(v), w, Value_bool(false)));\n      }\n    } else {\n      if (is_property_reference(v)) {\n        var base = value_of_ref_base_type(base);\n        var%_ret (s, base) = (function () {\n            if (has_primitive_base(v)) {\n              var%ck_assert_ret _pat_any_4 = !(\n                                               (_compare_JsSyntax_value(base,\n                                                  Value_null)\n                                               || _compare_JsSyntax_value(\n                                                    base, Value_undef)));\n              var%ert_object_ret base = to_object(base);\n              return (Continue([s, base]));\n            } else {\n              return (Continue([s, loc_of_value(base)]));\n            }}());\n        var%bool succeeded = object_internal_set(base,\n                               get_referenced_name(v), w, get_this_value(v));\n        if ((!(succeeded) && is_strict_reference(v))) {\n          return (run_error_no_c(Native_error_type));\n        } else {\n          return (res_void());\n        }\n      } else {\n        var base = env_loc_of_ref_base_type(base);\n        return (\n          set_mutable_binding(base, get_referenced_name(v), w,\n            Value_bool(is_strict_reference(v))));\n      }\n    }\n  }\n};\n\nvar get_this_value = function (v) {\n  throw is_property_reference(v);\n  if (is_super_reference(v)) {\n    return (ref_this_value(v));\n  } else {\n    return (value_of_ref_base_type(get_base(v)));\n  }\n};\n\nvar is_accessor_descriptor = function (desc) {\n  switch (desc) {\n    case Descriptor_undef:\n      return (false);\n    case Descriptor(desc):\n      return (\n        !(\n          (option_compare(value_compare, desc.descriptor_get, None)\n          && option_compare(value_compare, desc.descriptor_set, None))));\n  }\n  \n};\n\nvar is_data_descriptor = function (desc) {\n  switch (desc) {\n    case Descriptor_undef:\n      return (false);\n    case Descriptor(desc):\n      return (\n        !(\n          (option_compare(value_compare, desc.descriptor_value, None)\n          && option_compare(bool_eq, desc.descriptor_writable, None))));\n  }\n  \n};\n\nvar is_generic_descriptor = function (desc) {\n  switch (desc) {\n    case Descriptor_undef:\n      return (false);\n    case Descriptor:\n      return (\n        (!(is_accessor_descriptor(desc)) && !(is_data_descriptor(desc))));\n  }\n  \n};\n\nvar to_property_descriptor = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_object(l):\n      var desc = descriptor_intro_empty;\n      var%bool hasEnumerable = has_property(_foo_,\n                                 Value_string("enumerable"));\n      var%spec desc = (function () {\n          if (hasEnumerable) {\n            var%value v = get(_foo_, Value_string("enumerable"));\n            var enum = to_boolean(v);\n            return (descriptor_with_enumerable(desc, Some(enum)));\n          } else {\n            return (desc);\n          }}());\n      var%bool hasConfigurable = has_property(_foo_,\n                                   Value_string("configurable"));\n      var%spec desc = (function () {\n          if (hasConfigurable) {\n            var%value v = get(_foo_, Value_string("configurable"));\n            var conf = to_boolean(v);\n            return (descriptor_with_configurable(desc, Some(conf)));\n          } else {\n            return (desc);\n          }}());\n      var%bool hasValue = has_property(_foo_, Value_string("value"));\n      var%spec desc = (function () {\n          if (hasValue) {\n            var%value value = get(_foo_, Value_string("value"));\n            return (descriptor_with_value(desc, Some(value)));\n          } else {\n            return (desc);\n          }}());\n      var%bool hasWritable = has_property(_foo_, Value_string("writable"));\n      var%spec desc = (function () {\n          if (hasValue) {\n            var%value v = get(_foo_, Value_string("writable"));\n            var writable = to_boolean(v);\n            return (descriptor_with_writable(desc, Some(writable)));\n          } else {\n            return (desc);\n          }}());\n      var%bool hasGet = has_property(_foo_, Value_string("get"));\n      var%spec desc = (function () {\n          if (hasGet) {\n            var%value getter = get(_foo_, Value_string("get"));\n            if ((!(is_callable(getter))\n                && !(_compare_JsSyntax_coq_type(type_of(getter), Type_undef)))) {\n              return (run_error_no_c(Native_error_type));\n            } else {\n              return (descriptor_with_get(desc, Some(getter)));\n            }\n          } else {\n            return (desc);\n          }}());\n      var%bool hasSet = has_property(_foo_, Value_string("set"));\n      var%spec desc = (function () {\n          if (hasSet) {\n            var%value setter = get(_foo_, Value_string("set"));\n            if ((!(is_callable(setter))\n                && !(_compare_JsSyntax_coq_type(type_of(setter), Type_undef)))) {\n              return (run_error_no_c(Native_error_type));\n            } else {\n              return (descriptor_with_set(desc, Some(setter)));\n            }\n          } else {\n            return (desc);\n          }}());\n      if (((!(_compare_option(desc.descriptor_get, None))\n           || !(_compare_option(desc.descriptor_set, None)))\n          && (!(_compare_option(desc.descriptor_value, None))\n             || !(_compare_option(desc.descriptor_writable, None))))) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        return (desc);\n      }\n    default:\n      return (throw_result(run_error_no_c(Native_error_type)));\n  }\n  \n};\n\nvar complete_property_descriptor = function (s, desc) {\n  var desc = descriptor_get_defined(desc);\n  var like = {\n    descriptor_value: Some(Value_undef),\n    descriptor_writable: Some(false),\n    descriptor_get: Some(Value_undef),\n    descriptor_set: Some(Value_undef),\n    descriptor_enumerable: Some(false),\n    descriptor_configurable: Some(false)\n  };\n  if ((is_generic_descriptor(Descriptor(desc))\n      || is_data_descriptor(Descriptor(desc)))) {\n    var desc = descriptor_with_value(desc, like.descriptor_value);\n    var desc = descriptor_with_writable(desc, like.descriptor_writable);\n  } else {\n    var desc = descriptor_with_get(desc, like.descriptor_get);\n    var desc = descriptor_with_set(desc, like.descriptor_set);\n  }\n  if (option_compare(bool_eq, desc.descriptor_enumerable, None)) {\n    var desc = descriptor_with_enumerable(desc, like.descriptor_enumerable);\n  } else {\n    var desc = desc;\n  }\n  if (option_compare(bool_eq, desc.descriptor_configurable, None)) {\n    var desc = descriptor_with_configurable(desc,\n                 like.descriptor_configurable);\n  } else {\n    var desc = desc;\n  }\n  return (desc);\n};\n\nvar to_boolean = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_undef:\n      return (false);\n    case Coq_value_null:\n      return (false);\n    case Coq_value_bool(b):\n      return (b);\n    case Coq_value_number(n):\n      if ((JsNumber.isposzero(n)\n          || (JsNumber.isnegzero(n) || JsNumber.isnan(n)))) {\n        return (false);\n      } else {\n        return (true);\n      }\n    case Coq_value_string(s):\n      if (string_eq(s, "")) {\n        return (false);\n      } else {\n        return (true);\n      }\n    case Coq_value_object(o):\n      return (true);\n  }\n  \n};\n\nvar is_callable = function (argument) {\n  switch (argument) {\n    case Coq_value_object(l):\n      return (object_has_internal_method(l, object_call_));\n    default:\n      return (false);\n  }\n  \n};\n\nvar is_extensible = function (o) {\n  var%ck_assert _pat_any_6 = (function () {\n      switch (type_of(o)) {\n        case Coq_type_object:\n          return (true);\n        default:\n          return (false);\n      }\n      }());\n  switch (o) {\n    case Coq_value_object(l):\n      return (object_internal_is_extensible(l));\n    default:\n      throw false;\n  }\n  \n};\n\nvar is_property_key = function (argument) {\n  return (_compare_JsSyntax_coq_type(type_of(argument), Type_string));\n};\n\nvar same_value = function (x, y) {\n  if (!(type_compare(type_of(x), type_of(y)))) {\n    return (false);\n  } else {\n    switch (type_of(x)) {\n      case Coq_type_number:\n        switch (x) {\n          case Coq_value_number(n_x):\n            switch (y) {\n              case Coq_value_number(n_y):\n                if ((JsNumber.isnan(n_x) && JsNumber.isnan(n_y))) {\n                  return (true);\n                } else {\n                  if ((JsNumber.isposzero(n_x) && JsNumber.isnegzero(n_y))) {\n                    return (true);\n                  } else {\n                    if ((JsNumber.isnegzero(n_x) && JsNumber.isposzero(n_y))) {\n                      return (true);\n                    } else {\n                      return ((n_x === n_y));\n                    }\n                  }\n                }\n              default:\n                throw false;\n            }\n            \n          default:\n            throw false;\n        }\n        \n      default:\n        return (same_value_non_number(x, y));\n    }\n    \n  }\n};\n\nvar same_value_non_number = function (x, y) {\n  throw !(type_compare(type_of(x), Type_number));\n  throw type_compare(type_of(x), type_of(y));\n  switch (x) {\n    case Coq_value_undef:\n      return (true);\n    case Coq_value_null:\n      return (true);\n    case Coq_value_string(s_x):\n      switch (y) {\n        case Coq_value_string(s_y):\n          return (string_eq(s_x, s_y));\n        default:\n          throw false;\n      }\n      \n    case Coq_value_bool(b_x):\n      switch (y) {\n        case Coq_value_bool(b_y):\n          return (bool_eq(b_x, b_y));\n        default:\n          throw false;\n      }\n      \n    case Coq_value_object(l_x):\n      switch (y) {\n        case Coq_value_object(l_y):\n          return (object_loc_compare(l_x, l_y));\n        default:\n          throw false;\n      }\n      \n    default:\n      throw false;\n  }\n  \n};\n\nvar get = function (o, p) {\n  var%ck_assert _pat_any_8 = _compare_JsSyntax_coq_type(type_of(o),\n                               Type_object);\n  var%ck_assert _pat_any_7 = is_property_key(p);\n  switch (o) {\n    case Coq_value_object(l):\n      return (object_internal_get(l, p, o));\n    default:\n      throw false;\n  }\n  \n};\n\nvar get_v = function (v, p) {\n  var%ck_assert _pat_any_9 = is_property_key(p);\n  var%object l = to_object(v);\n  return (object_internal_get(l, p, v));\n};\n\nvar set = function (o, p, v, throw) {\n  var%ck_assert _pat_any_12 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var l = loc_of_value(o);\n  var%ck_assert _pat_any_11 = is_property_key(p);\n  var%ck_assert _pat_any_10 = _compare_JsSyntax_coq_type(type_of(throw),\n                                Type_bool);\n  var throw = bool_of_value(throw);\n  var%bool success = object_internal_set(l, p, v, o);\n  if ((!(success) && throw)) {\n    return (run_error_no_c(Native_error_type));\n  } else {\n    return (Value_bool(success));\n  }\n};\n\nvar create_data_property = function (o, p, v) {\n  var%ck_assert _pat_any_14 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var o = loc_of_value(o);\n  var%ck_assert _pat_any_13 = is_property_key(p);\n  var newDesc = descriptor_intro_data(v, true, true, true);\n  return (object_internal_define_own_property(o, p, newDesc));\n};\n\nvar get_method = function (v, p) {\n  var%ck_assert _pat_any_15 = is_property_key(p);\n  var%value func = get_v(v, p);\n  switch (type_of(func)) {\n    case Coq_type_undef:\n      return (Value_undef);\n    case Coq_type_null:\n      return (Value_undef);\n    default:\n      var callable = is_callable(func);\n      if (!(callable)) {\n        return (run_error_no_c(Native_error_type));\n      } else {\n        return (func);\n      }\n  }\n  \n};\n\nvar has_property = function (o, p) {\n  var%ck_assert _pat_any_17 = _compare_JsSyntax_coq_type(type_of(o),\n                                Type_object);\n  var%ck_assert _pat_any_16 = is_property_key(p);\n  switch (o) {\n    case Coq_value_object(l):\n      return (object_internal_has_property(l, p));\n    default:\n      throw false;\n  }\n  \n};\n\nvar call = function (f, v, argumentList) {\n  return (\n    if_some_or_apply_default(argumentList, mk_nil, function (argumentList) {\n        var callable = is_callable(f);\n        if (!(callable)) {\n          return (run_error_no_c(Native_error_type));\n        } else {\n          switch (f) {\n            case Coq_value_object(l):\n              return (object_internal_call(l, v, argumentList));\n            default:\n              throw false;\n          }\n          \n        }}));\n};\n\nvar set_mutable_binding = function (l, n, v, str) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(e):\n      return (decl_env_record_set_mutable_binding(l, e, n, v, str));\n    case Coq_env_record_object(l, this):\n      return (object_env_record_set_mutable_binding(l, this, n, v, str));\n  }\n  \n};\n\nvar get_binding_value = function (l, n, str) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(e):\n      return (decl_env_record_get_binding_value(e, n, str));\n    case Coq_env_record_object(l, this):\n      return (object_env_record_get_binding_value(l, this, n, str));\n  }\n  \n};\n\nvar binding_is_uninitialized = function (binding) {\n  var (mutability, unused) = binding;\n  return (\n    mutability_compare(mutability, Mutability_uninitialized_immutable));\n};\n\nvar binding_is_mutable = function (binding) {\n  var (mutability, unused) = binding;\n  return (\n    (_compare_JsSyntax_mutability(mutability, Mutability_nondeletable)\n    || _compare_JsSyntax_mutability(mutability, Mutability_deletable)));\n};\n\nvar decl_env_record_create_mutable_binding = function (l, envRec, n$, d) {\n  var n = string_of_value(n$);\n  var d = bool_of_value(d);\n  var%ck_assert _pat_any_18 = !(HeapStr.indom_dec(envRec, n));\n  var s = env_record_write_decl_env(l, n, mutability_of_bool(d), Value_undef);\n  return (res_void());\n};\n\nvar decl_env_record_initialize_binding = function (l, envRec, n$, v) {\n  var n = string_of_value(n$);\n  var%some binding = HeapStr.read_option(envRec, n);\n  var (mutability, unused) = binding;\n  var%ck_assert _pat_any_19 = binding_is_uninitialized(binding);\n  var s = env_record_write_decl_env(l, n, mutability, v);\n  return (res_void());\n};\n\nvar decl_env_record_set_mutable_binding = function (l, envRec, n$, v, str) {\n  var n = string_of_value(n$);\n  var str = bool_of_value(str);\n  if (!(HeapStr.indom_dec(envRec, n))) {\n    if (str) {\n      return (run_error_no_c(Native_error_ref));\n    } else {\n      var%success _pat_any_21 = decl_env_record_create_mutable_binding(l,\n                                  envRec, n$, Value_bool(true));\n      var%success _pat_any_20 = decl_env_record_initialize_binding(l, envRec,\n                                  n$, v);\n      return (res_void());\n    }\n  } else {\n    var%some binding = HeapStr.read_option(envRec, n);\n    var (mutability, unused) = binding;\n    if (binding_is_uninitialized(binding)) {\n      return (run_error_no_c(Native_error_ref));\n    } else {\n      var%_ret _ = (function () {\n          if (binding_is_mutable(binding)) {\n            return (\n              Continue(env_record_write_decl_env(l, n, mutability, v)));\n          } else {\n            if (str) {\n              return (Return(run_error_no_c(Native_error_type)));\n            } else {\n              return (Continue);\n            }\n          }}());\n      return (res_void());\n    }\n  }\n};\n\nvar decl_env_record_get_binding_value = function (envRec, n, str) {\n  var n = string_of_value(n);\n  var%ck_assert _pat_any_22 = HeapStr.indom_dec(envRec, n);\n  var%some binding = HeapStr.read_option(envRec, n);\n  var (mutability, v) = binding;\n  if (mutability_compare(mutability, Mutability_uninitialized_immutable)) {\n    return (run_error_no_c(Native_error_ref));\n  } else {\n    return (v);\n  }\n};\n\nvar object_env_record_set_mutable_binding = function (bindings, this, n, v, str) {\n  return (set(bindings, n, v, str));\n};\n\nvar object_env_record_get_binding_value = function (bindings, this, n, str) {\n  var%bool value = has_property(bindings, n);\n  if (!(value)) {\n    if (!(str)) {\n      return (Value_undef);\n    } else {\n      return (run_error_no_c(Native_error_ref));\n    }\n  } else {\n    return (get(bindings, n));\n  }\n};\n\nvar get_global_object = function (ctx) {\n  var e = unsome_error(env_record_binds_option(env_loc_global_env_record));\n  switch (e) {\n    case Coq_env_record_object(l, this):\n      return (l);\n    default:\n      throw false;\n  }\n  \n};\n\nvar ordinary_object_internal_get_prototype_of = function (o) {\n  var%value v = ordinary_get_prototype_of(o);\n  return (v);\n};\n\nvar ordinary_get_prototype_of = function (o) {\n  var%some v = run_object_method(object_proto_, o);\n  return (v);\n};\n\nvar ordinary_object_internal_set_prototype_of = function (o, v) {\n  var%value v = ordinary_set_prototype_of(o, v);\n  return (v);\n};\n\nvar ordinary_set_prototype_of = function (o, v) {\n  var%ck_assert _pat_any_23 = (function () {\n      switch (type_of(v)) {\n        case Coq_type_object:\n          return (true);\n        case Coq_type_null:\n          return (true);\n        default:\n          return (false);\n      }\n      }());\n  var%some extensible = run_object_method(object_extensible_, o);\n  var%some current = run_object_method(object_prototype_, o);\n  var sv = same_value(v, current);\n  if (sv) {\n    return (Value_bool(true));\n  } else {\n    if (!(extensible)) {\n      return (Value_bool(false));\n    } else {\n      var repeat = function (p, done_) {\n        if (!(done_)) {\n          switch (p) {\n            case Coq_value_null:\n              return (repeat(p, true));\n            case Coq_value_object(p_l):\n              if (same_value(p, o)) {\n                return (Value_bool(false));\n              } else {\n                var%some gpo = run_object_method(object_get_prototype_of_,\n                                 p_l);\n                switch (gpo) {\n                  case Coq_builtin_get_prototype_of_default:\n                    var%some prototype = run_object_method(object_prototype_,\n                                           p_l);\n                    return (repeat(prototype, false));\n                  default:\n                    return (repeat(p, true));\n                }\n                \n              }\n            default:\n              throw false;\n          }\n          \n        } else {\n          var%some _ = run_object_set_internal(object_set_proto, o, v);\n          return (Value_bool(true));\n        }\n      };\n      return (repeat(v, false));\n    }\n  }\n};\n\nvar ordinary_object_internal_is_extensible = function (o) {\n  var%value v = ordinary_is_extensible(o);\n  return (v);\n};\n\nvar ordinary_is_extensible = function (o) {\n  var%some b = run_object_method(object_extensible_, o);\n  return (Value_bool(b));\n};\n\nvar ordinary_object_internal_prevent_extensions = function (o) {\n  var%value v = ordinary_prevent_extensions(o);\n  return (v);\n};\n\nvar ordinary_prevent_extensions = function (o) {\n  var%some _ = run_object_set_internal(object_set_extensible, o, false);\n  return (Value_bool(true));\n};\n\nvar ordinary_object_internal_get_own_property = function (o, p) {\n  return (ordinary_get_own_property(o, p));\n};\n\nvar ordinary_get_own_property = function (o, p) {\n  var%ck_assert _pat_any_24 = is_property_key(p);\n  var p = string_of_value(p);\n  if (!(object_property_exists(o, p))) {\n    return (Descriptor_undef);\n  } else {\n    var d = descriptor_intro_empty;\n    var%some x = object_retrieve_property(o, p);\n    switch (x) {\n      case Coq_attributes_data_of(x):\n        var d = Object.assign({}, d, {\n                    descriptor_value: Some(x.attributes_data_value),\n                    descriptor_writable: Some(x.attributes_data_writable)});\n        break;\n      case Coq_attributes_accessor_of(x):\n        var d = Object.assign({}, d, {\n                    descriptor_get: Some(x.attributes_accessor_get),\n                    descriptor_set: Some(x.attributes_accessor_set)});\n        break;\n    }\n    \n    var d = Object.assign({}, d, {\n                descriptor_enumerable: Some(attributes_enumerable(x))});\n    var d = Object.assign({}, d, {\n                descriptor_configurable: Some(attributes_configurable(x))});\n    return (Descriptor(d));\n  }\n};\n\nvar ordinary_object_internal_define_own_property = function (o, p, desc) {\n  return (ordinary_define_own_property(o, p, desc));\n};\n\nvar ordinary_define_own_property = function (o, p, desc) {\n  var%spec current = object_internal_get_own_property(o, p);\n  var%some extensible = run_object_method(object_extensible_, o);\n  return (\n    validate_and_apply_property_descriptor(o, p, extensible, desc, current));\n};\n\nvar is_compatible_property_descriptor = function (extensible, desc, current) {\n  return (\n    validate_and_apply_property_descriptor(Value_undef, Value_undef,\n      extensible, desc, current));\n};\n\nvar validate_and_apply_property_descriptor = function (o, p, extensible, desc, current) {\n  var%ck_assert _pat_any_26 = (value_compare(o, Value_undef)\n                              || is_property_key(p));\n  var p = string_of_value(p);\n  switch (current) {\n    case Descriptor_undef:\n      if (!(extensible)) {\n        return (Value_bool(false));\n      } else {\n        var%ck_assert _pat_any_25 = extensible;\n        var%some _ = (function () {\n            switch (o) {\n              case Coq_value_object(l):\n                if ((is_generic_descriptor(Descriptor(desc))\n                    || is_data_descriptor(Descriptor(desc)))) {\n                  return (\n                    object_set_property(l, p,\n                      attributes_data_of_descriptor(desc)));\n                } else {\n                  return (\n                    object_set_property(l, p,\n                      attributes_accessor_of_descriptor(desc)));\n                }\n              case Coq_value_undef:\n                return (Some);\n              default:\n                return (None);\n            }\n            }());\n        return (Value_bool(true));\n      }\n    case Descriptor(current):\n      var%_ret _ = (function () {\n          if (descriptor_is_empty(desc)) {\n            return (Return(Value_bool(true)));\n          } else {\n            return (Continue);\n          }}());\n      var%_ret _ = (function () {\n          if (descriptor_contained_by(desc, current, same_value)) {\n            return (Return(Value_bool(true)));\n          } else {\n            return (Continue);\n          }}());\n      var%_ret _ = (function () {\n          if (option_compare(bool_eq, current.descriptor_configurable,\n                Some(false))) {\n            if (option_compare(bool_eq, desc.descriptor_configurable,\n                  Some(true))) {\n              return (Return(Value_bool(false)));\n            } else {\n              if ((is_some(desc.descriptor_enumerable)\n                  && !(\n                       some_compare(bool_eq, current.descriptor_enumerable,\n                         desc.descriptor_enumerable)))) {\n                return (Return(Value_bool(false)));\n              } else {\n                return (Continue);\n              }\n            }\n          } else {\n            return (Continue);\n          }}());\n      var%_ret _ = (function () {\n          if (is_generic_descriptor(Descriptor(desc))) {\n            return (Continue);\n          } else {\n            if (!(\n                  bool_eq(is_data_descriptor(Descriptor(current)),\n                    is_data_descriptor(Descriptor(desc))))) {\n              if (option_compare(bool_eq, current.descriptor_configurable,\n                    Some(false))) {\n                return (Return(Value_bool(false)));\n              } else {\n                if (is_data_descriptor(Descriptor(current))) {\n                  var s = unsome_default((function () {\n                              switch (o) {\n                                case Coq_value_object(l):\n                                  return (\n                                    object_map_property(l, p,\n                                      attributes_accessor_of_attributes_data));\n                                default:\n                                  return (Some);\n                              }\n                              }()));\n                  return (Continue);\n                } else {\n                  var s = unsome_default((function () {\n                              switch (o) {\n                                case Coq_value_object(l):\n                                  return (\n                                    object_map_property(l, p,\n                                      attributes_data_of_attributes_accessor));\n                                default:\n                                  return (Some);\n                              }\n                              }()));\n                  return (Continue);\n                }\n              }\n            } else {\n              if ((is_data_descriptor(Descriptor(current))\n                  && is_data_descriptor(Descriptor(desc)))) {\n                if (option_compare(bool_eq, current.descriptor_configurable,\n                      Some(false))) {\n                  if ((option_compare(bool_eq, current.descriptor_writable,\n                         Some(false))\n                      && option_compare(bool_eq, desc.descriptor_writable,\n                           Some(true)))) {\n                    return (Return(Value_bool(false)));\n                  } else {\n                    if (option_compare(bool_eq, current.descriptor_writable,\n                          Some(false))) {\n                      if ((is_some(desc.descriptor_value)\n                          && !(\n                               option_compare(same_value,\n                                 desc.descriptor_value,\n                                 current.descriptor_value)))) {\n                        return (Return(Value_bool(false)));\n                      } else {\n                        return (Continue);\n                      }\n                    } else {\n                      return (Continue);\n                    }\n                  }\n                } else {\n                  if (!(\n                        option_compare(bool_eq,\n                          current.descriptor_configurable, Some(true)))) {\n                    return (Return(spec_assertion_failure({})));\n                  } else {\n                    return (Continue);\n                  }\n                }\n              } else {\n                if (!(\n                      (is_accessor_descriptor(Descriptor(current))\n                      && is_accessor_descriptor(Descriptor(desc))))) {\n                  return (Return(spec_assertion_failure({})));\n                } else {\n                  if (option_compare(bool_eq,\n                        current.descriptor_configurable, Some(false))) {\n                    if ((is_some(desc.descriptor_set)\n                        && !(\n                             option_compare(same_value, desc.descriptor_set,\n                               current.descriptor_set)))) {\n                      return (Return(Value_bool(false)));\n                    } else {\n                      if ((is_some(desc.descriptor_get)\n                          && !(\n                               option_compare(same_value,\n                                 desc.descriptor_get, current.descriptor_get)))) {\n                        return (Return(Value_bool(false)));\n                      } else {\n                        return (Continue);\n                      }\n                    }\n                  } else {\n                    return (Continue);\n                  }\n                }\n              }\n            }\n          }}());\n      var%some _ = (function () {\n          switch (o) {\n            case Coq_value_object(l):\n              return (\n                object_map_property(l, p, function (a) {\n                    return (attributes_update(a, desc));}));\n            default:\n              return (Some);\n          }\n          }());\n      return (Value_bool(true));\n  }\n  \n};\n\nvar ordinary_object_internal_has_property = function (o, p) {\n  return (ordinary_has_property(o, p));\n};\n\nvar ordinary_has_property = function (o, p) {\n  var%ck_assert _pat_any_27 = is_property_key(p);\n  var%spec hasOwn = object_internal_get_own_property(o, p);\n  if (!(_compare_JsSyntax_undef_descriptor(hasOwn, Descriptor_undef))) {\n    return (Value_bool(true));\n  } else {\n    var%value parent = object_internal_get_prototype_of(o);\n    if (!(_compare_JsSyntax_value(parent, Value_null))) {\n      return (object_internal_has_property(loc_of_value(parent), p));\n    } else {\n      return (Value_bool(false));\n    }\n  }\n};\n\nvar ordinary_object_internal_set = function (o, p, v, receiver) {\n  return (ordinary_set(o, p, v, receiver));\n};\n\nvar ordinary_set = function (o, p, v, receiver) {\n  var%ck_assert _pat_any_30 = is_property_key(p);\n  var%spec ownDesc = object_internal_get_own_property(o, p);\n  var%_ret ownDesc = (function () {\n      if (_compare_JsSyntax_undef_descriptor(ownDesc, Descriptor_undef)) {\n        var%value_ret parent = object_internal_get_prototype_of(o);\n        if (!(_compare_JsSyntax_value(parent, Value_null))) {\n          var parent = loc_of_value(parent);\n          return (Return(object_internal_set(parent, p, v, receiver)));\n        } else {\n          return (\n            Continue(\n              Descriptor({\n                  descriptor_value: Some(Value_undef),\n                  descriptor_writable: Some(false),\n                  descriptor_get: None,\n                  descriptor_set: None,\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)})));\n        }\n      } else {\n        return (Continue(ownDesc));\n      }}());\n  if (is_data_descriptor(ownDesc)) {\n    var ownDesc = descriptor_get_defined(ownDesc);\n    var%some writable = ownDesc.descriptor_writable;\n    if (writable) {\n      return (Value_bool(false));\n    } else {\n      if (!(_compare_JsSyntax_coq_type(type_of(receiver), Type_object))) {\n        return (Value_bool(false));\n      } else {\n        var receiver = loc_of_value(receiver);\n        var%spec existingDescriptor = object_internal_get_own_property(\n                                        receiver, p);\n        if (!(\n              _compare_JsSyntax_undef_descriptor(existingDescriptor,\n                Descriptor_undef))) {\n          if (is_accessor_descriptor(existingDescriptor)) {\n            return (Value_bool(false));\n          } else {\n            var existingDescriptor = descriptor_get_defined(\n                                       existingDescriptor);\n            var%some w = existingDescriptor.descriptor_writable;\n            if (!(w)) {\n              return (Value_bool(false));\n            } else {\n              var valueDesc = descriptor_with_value(descriptor_intro_empty,\n                                Some(v));\n              return (\n                object_internal_define_own_property(receiver, p, valueDesc));\n            }\n          }\n        } else {\n          return (create_data_property(receiver, p, v));\n        }\n      }\n    }\n  } else {\n    var%ck_assert _pat_any_29 = is_accessor_descriptor(ownDesc);\n    var ownDesc = descriptor_get_defined(ownDesc);\n    var%some setter = ownDesc.descriptor_set;\n    if (_compare_JsSyntax_value(setter, Value_undef)) {\n      return (Value_bool(false));\n    } else {\n      var%spec _pat_any_28 = call(setter, receiver, Some(mk_cons(v, mk_nil)));\n      return (Value_bool(true));\n    }\n  }\n};\n\nvar ordinary_own_property_keys = function (c, l) {\n  var%some keys = object_properties_keys_as_list_option(l);\n  return (keys);\n};\n\nvar object_has_prop = function (l, x) {\n  return (object_internal_has_property(l, Value_string(x)));\n};\n\nvar out_error_or_void = function (str, ne) {\n  if (str) {\n    return (run_error(ne));\n  } else {\n    return (res_void());\n  }\n};\n\nvar out_error_or_cst = function (str, ne, v) {\n  if (str) {\n    return (run_error(ne));\n  } else {\n    return (v);\n  }\n};\n\nvar object_get_builtin = function (b, vthis, l, x) {\n  var def = function (l0) {\n    var%spec d = run_object_get_prop(l0, x);\n    switch (d) {\n      case Coq_full_descriptor_undef:\n        return (Value_undef);\n      case Coq_full_descriptor_some(a):\n        switch (a) {\n          case Coq_attributes_data_of(ad):\n            return (ad.attributes_data_value);\n          case Coq_attributes_accessor_of(aa):\n            switch (aa.attributes_accessor_get) {\n              case Coq_value_undef:\n                return (Value_undef);\n              case Coq_value_null:\n                return (Result_impossible);\n              case Coq_value_bool(b0):\n                return (Result_impossible);\n              case Coq_value_number(n):\n                return (Result_impossible);\n              case Coq_value_string(s2):\n                return (Result_impossible);\n              case Coq_value_object(lf):\n                return (run_call(lf, vthis, mk_nil));\n            }\n            \n        }\n        \n    }\n    \n  };\n  var function0 = function () {\n    var%value v = def(l);\n    if (spec_function_get_error_case_dec(x, v)) {\n      return (run_error(Native_error_type));\n    } else {\n      return (v);\n    }\n  };\n  switch (b) {\n    case Coq_builtin_get_default:\n      return (def(l));\n    case Coq_builtin_get_function:\n      return (function0());\n    case Coq_builtin_get_args_obj:\n      var%some lmapo = run_object_method(object_parameter_map_, l);\n      var%some lmap = lmapo;\n      var%spec d = run_object_get_own_prop(lmap, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (function0());\n        case Coq_full_descriptor_some(a):\n          return (run_object_get(lmap, x));\n      }\n      \n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar run_object_get = function (l, x) {\n  var%some b = run_object_method(object_get_, l);\n  return (object_get_builtin(b, l, l, x));\n};\n\nvar run_object_get_prop = function (l, x) {\n  var%some b = run_object_method(object_get_prop_, l);\n  switch (b) {\n    case Coq_builtin_get_prop_default:\n      var%spec d = run_object_get_own_prop(l, x);\n      if (full_descriptor_compare(d, Full_descriptor_undef)) {\n        var%some proto = run_object_method(object_proto_, l);\n        switch (proto) {\n          case Coq_value_null:\n            return (Full_descriptor_undef);\n          case Coq_value_object(lproto):\n            return (run_object_get_prop(lproto, x));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Found a non-object or null value as a prototype in [run_object_get_prop]."));\n        }\n        \n      } else {\n        return (d);\n      }\n  }\n  \n};\n\nvar object_proto_is_prototype_of = function (l0, l) {\n  var%some b = run_object_method(object_proto_, l);\n  switch (b) {\n    case Coq_value_null:\n      return (Value_bool(false));\n    case Coq_value_object(l_2):\n      if (object_loc_compare(l_2, l0)) {\n        return (Value_bool(true));\n      } else {\n        return (object_proto_is_prototype_of(l0, l_2));\n      }\n    default:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[run_object_method] returned a non-object in [object_proto_is_prototype_of_body]."));\n  }\n  \n};\n\nvar object_default_value = function (l, prefo) {\n  var%some b = run_object_method(object_default_value_, l);\n  switch (b) {\n    case Coq_builtin_default_value_default:\n      var gpref = unsome_default(Preftype_number, prefo);\n      var lpref = other_preftypes(gpref);\n      var sub0 = function (x, k) {\n        var%value vfo = run_object_get(l, x);\n        var%some co = run_callable(vfo);\n        switch (co) {\n          case Some(b0):\n            var%object lfunc = vfo;\n            var%value v = run_call(lfunc, l, mk_nil);\n            switch (v) {\n              case Coq_value_object(l0):\n                return (k());\n              default:\n                return (v);\n            }\n            \n          case None:\n            return (k());\n        }\n        \n      };\n      var gmeth = method_of_preftype(gpref);\n      return (\n        sub0(gmeth, function () {\n            var lmeth = method_of_preftype(lpref);\n            return (\n              sub0(lmeth, function () {\n                  return (run_error(Native_error_type));}));}));\n  }\n  \n};\n\nvar to_primitive = function (v, prefo) {\n  switch (v) {\n    case Coq_value_object(l):\n      var%prim r = object_default_value(l, prefo);\n      return (r);\n    default:\n      return (v);\n  }\n  \n};\n\nvar to_number = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_object(l):\n      var%prim w = to_primitive(l, Some(Preftype_number));\n      return (Value_number(convert_prim_to_number(w)));\n    default:\n      return (Value_number(convert_prim_to_number(_foo_)));\n  }\n  \n};\n\nvar to_integer = function (v) {\n  var%number n = to_number(v);\n  return (Value_number(convert_number_to_integer(n)));\n};\n\nvar to_int32 = function (v) {\n  var%number n = to_number(v);\n  return (JsNumber.to_int32(n));\n};\n\nvar to_uint32 = function (v) {\n  var%number n = to_number(v);\n  return (JsNumber.to_uint32(n));\n};\n\nvar to_string = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_object(l):\n      var%prim w = to_primitive(l, Some(Preftype_string));\n      return (Value_string(convert_prim_to_string(w)));\n    default:\n      return (Value_string(convert_prim_to_string(_foo_)));\n  }\n  \n};\n\nvar run_object_define_own_prop_array_loop = function (l, newLen, oldLen, newLenDesc, newWritable, throwcont, def) {\n  if ((newLen < oldLen)) {\n    var oldLen_2 = (oldLen - 1.);\n    var%string slen = to_string(Value_number(oldLen_2));\n    var%bool deleteSucceeded = object_delete(l, slen, false);\n    if (!(deleteSucceeded)) {\n      var newLenDesc0 = descriptor_with_value(newLenDesc,\n                          Some(Value_number((oldLen_2 + 1.))));\n      if (!(newWritable)) {\n        var newLenDesc1 = descriptor_with_writable(newLenDesc0, Some(false));\n      } else {\n        var newLenDesc1 = newLenDesc0;\n      }\n      var%bool x = def("length", newLenDesc1, false);\n      return (\n        out_error_or_cst(throwcont, Native_error_type, Value_bool(false)));\n    } else {\n      return (\n        run_object_define_own_prop_array_loop(l, newLen, oldLen_2,\n          newLenDesc, newWritable, throwcont, def));\n    }\n  } else {\n    if (!(newWritable)) {\n      return (\n        def("length", {\n            descriptor_value: None,\n            descriptor_writable: Some(false),\n            descriptor_get: None,\n            descriptor_set: None,\n            descriptor_enumerable: None,\n            descriptor_configurable: None}, false));\n    } else {\n      return (Value_bool(true));\n    }\n  }\n};\n\nvar object_define_own_prop = function (l, x, desc, throwcont) {\n  var reject = function (throwcont0) {\n    return (\n      out_error_or_cst(throwcont0, Native_error_type, Value_bool(false)));\n  };\n  var def = function (p, d, _pat_any_31) {\n    return (ordinary_define_own_property(l, Value_string(p), d));\n  };\n  var%some b = run_object_method(object_define_own_prop_, l);\n  switch (b) {\n    case Coq_builtin_define_own_prop_default:\n      return (object_internal_define_own_property(l, Value_string(x), desc));\n    case Coq_builtin_define_own_prop_array:\n      var%spec d = run_object_get_own_prop(l, "length");\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "Array length property descriptor cannot be undefined."));\n        case Coq_full_descriptor_some(attr):\n          switch (attr) {\n            case Coq_attributes_data_of(a):\n              var oldLen = a.attributes_data_value;\n              switch (oldLen) {\n                case Coq_value_object(l0):\n                  Debug.impossible_with_heap_because(__LOC__,\n                    "Spec asserts length of array is number.");\n                  return (Result_impossible);\n                default:\n                  var oldLen0 = JsNumber.to_uint32(\n                                  convert_prim_to_number(oldLen));\n                  var descValueOpt = desc.descriptor_value;\n                  if (string_eq(x, "length")) {\n                    switch (descValueOpt) {\n                      case Some(descValue):\n                        var%spec newLen = to_uint32(descValue);\n                        var%number newLenN = to_number(descValue);\n                        if (!((newLen === newLenN))) {\n                          return (run_error(Native_error_range));\n                        } else {\n                          var newLenDesc = descriptor_with_value(desc,\n                                             Some(Value_number(newLen)));\n                          if (le_int_decidable(oldLen0, newLen)) {\n                            return (def("length", newLenDesc, throwcont));\n                          } else {\n                            if (!(a.attributes_data_writable)) {\n                              return (reject(throwcont));\n                            } else {\n                              switch (newLenDesc.descriptor_writable) {\n                                case Some(b0):\n                                  if (b0) {\n                                    var newWritable = true;\n                                  } else {\n                                    var newWritable = false;\n                                  }\n                                  break;\n                                case None:\n                                  var newWritable = true;\n                                  break;\n                              }\n                              \n                              if (!(newWritable)) {\n                                var newLenDesc0 = descriptor_with_writable(\n                                                    newLenDesc, Some(true));\n                              } else {\n                                var newLenDesc0 = newLenDesc;\n                              }\n                              var%bool succ = def("length", newLenDesc0,\n                                                throwcont);\n                              if (!(succ)) {\n                                return (Value_bool(false));\n                              } else {\n                                return (\n                                  run_object_define_own_prop_array_loop(l,\n                                    newLen, oldLen0, newLenDesc0,\n                                    newWritable, throwcont, def));\n                              }\n                            }\n                          }\n                        }\n                      case None:\n                        return (def("length", desc, throwcont));\n                    }\n                    \n                  } else {\n                    var%spec ilen = to_uint32(Value_string(x));\n                    var%string slen = to_string(Value_number(ilen));\n                    if ((string_eq(x, slen) && !((ilen == 4294967295.)))) {\n                      var%spec index = to_uint32(Value_string(x));\n                      if ((le_int_decidable(oldLen0, index)\n                          && !(a.attributes_data_writable))) {\n                        return (reject(throwcont));\n                      } else {\n                        var%bool b0 = def(x, desc, false);\n                        if (!(b0)) {\n                          return (reject(throwcont));\n                        } else {\n                          if (le_int_decidable(oldLen0, index)) {\n                            var a0 = descriptor_with_value(\n                                       descriptor_of_attributes(a),\n                                       Some(Value_number((index + 1.))));\n                            return (def("length", a0, false));\n                          } else {\n                            return (Value_bool(true));\n                          }\n                        }\n                      }\n                    } else {\n                      return (def(x, desc, throwcont));\n                    }\n                  }\n              }\n              \n            case Coq_attributes_accessor_of(a):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Array length property descriptor cannot be accessor."));\n          }\n          \n      }\n      \n    case Coq_builtin_define_own_prop_args_obj:\n      var%some lmapo = run_object_method(object_parameter_map_, l);\n      var%some lmap = lmapo;\n      var%spec d = run_object_get_own_prop(lmap, x);\n      var%bool b0 = def(x, desc, false);\n      if (b0) {\n        var follow = function () {\n          return (Value_bool(true));\n        };\n        switch (d) {\n          case Coq_full_descriptor_undef:\n            return (follow());\n          case Coq_full_descriptor_some(a):\n            if (is_accessor_descriptor(Descriptor(desc))) {\n              var%bool x0 = object_delete(lmap, x, false);\n              return (follow());\n            } else {\n              var follow0 = function () {\n                if (option_compare(bool_eq, desc.descriptor_writable,\n                      Some(false))) {\n                  var%bool x0 = object_delete(lmap, x, false);\n                  return (follow());\n                } else {\n                  return (follow());\n                }\n              };\n              switch (desc.descriptor_value) {\n                case Some(v):\n                  var%void _ = object_put(lmap, x, v, throwcont);\n                  return (follow0());\n                case None:\n                  return (follow0());\n              }\n              \n            }\n        }\n        \n      } else {\n        return (reject(throwcont));\n      }\n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar prim_new_object = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_bool(b):\n      var o1 = object_new(Prealloc_bool_proto, "Boolean");\n      var o = object_with_primitive_value(o1, Value_bool(b));\n      var (l, s1) = object_alloc(o);\n      return (l);\n    case Coq_value_number(n):\n      var o1 = object_new(Prealloc_number_proto, "Number");\n      var o = object_with_primitive_value(o1, Value_number(n));\n      var (l, s1) = object_alloc(o);\n      return (l);\n    case Coq_value_string(s0):\n      var o2 = object_new(Prealloc_string_proto, "String");\n      var o1 = object_with_get_own_property(o2, Builtin_get_own_prop_string);\n      var o = object_with_primitive_value(o1, Value_string(s0));\n      var (l, s1) = object_alloc(o);\n      var%some _ = run_object_heap_map_properties(l, function (p) {\n                       return (\n                         HeapStr.write(p, "length",\n                           attributes_data_intro_constant(\n                             Value_number(strlength(s0)))));});\n      return (l);\n    default:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[prim_new_object] received an null or undef."));\n  }\n  \n};\n\nvar to_object = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_undef:\n      return (run_error_no_c(Native_error_type));\n    case Coq_value_null:\n      return (run_error_no_c(Native_error_type));\n    case Coq_value_bool(b):\n      return (prim_new_object(_foo_));\n    case Coq_value_number(n):\n      return (prim_new_object(_foo_));\n    case Coq_value_string(s0):\n      return (prim_new_object(_foo_));\n    case Coq_value_object(l):\n      return (l);\n  }\n  \n};\n\nvar run_object_prim_value = function (l) {\n  var%some ov = run_object_method(object_prim_value_, l);\n  var%some v = ov;\n  return (v);\n};\n\nvar prim_value_get = function (v, x) {\n  var%object l = to_object(v);\n  return (object_get_builtin(Builtin_get_default, v, l, x));\n};\n\nvar env_record_has_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      return (Value_bool(HeapStr.indom_dec(ed, x)));\n    case Coq_env_record_object(l0, pt):\n      return (object_has_prop(l0, x));\n  }\n  \n};\n\nvar lexical_env_get_identifier_ref = function (x, x0, str) {\n  switch (x) {\n    case []:\n      return (ref_create_value(Value_undef, x0, str));\n    case (l::x_2):\n      var%bool has = env_record_has_binding(l, x0);\n      if (has) {\n        return (ref_create_env_loc(l, x0, str));\n      } else {\n        return (lexical_env_get_identifier_ref(x_2, x0, str));\n      }\n  }\n  \n};\n\nvar object_delete_default = function (l, x, str) {\n  var%spec d = run_object_get_own_prop(l, x);\n  switch (d) {\n    case Coq_full_descriptor_undef:\n      return (Value_bool(true));\n    case Coq_full_descriptor_some(a):\n      if (attributes_configurable(a)) {\n        var%some _ = run_object_heap_map_properties(l, function (p) {\n                         return (HeapStr.rem(p, x));});\n        return (Value_bool(true));\n      } else {\n        return (out_error_or_cst(str, Native_error_type, Value_bool(false)));\n      }\n  }\n  \n};\n\nvar object_delete = function (l, x, str) {\n  var%some b = run_object_method(object_delete_, l);\n  switch (b) {\n    case Coq_builtin_delete_default:\n      return (object_delete_default(l, x, str));\n    case Coq_builtin_delete_args_obj:\n      var%some mo = run_object_method(object_parameter_map_, l);\n      var%some m = mo;\n      var%spec d = run_object_get_own_prop(m, x);\n      var%bool b0 = object_delete_default(l, x, str);\n      if (b0) {\n        switch (d) {\n          case Coq_full_descriptor_undef:\n            return (Value_bool(b0));\n          case Coq_full_descriptor_some(a):\n            var%bool b_2 = object_delete(m, x, false);\n            return (Value_bool(b0));\n        }\n        \n      } else {\n        return (Value_bool(b0));\n      }\n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar env_record_delete_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      switch (HeapStr.read_option(ed, x)) {\n        case Some(p):\n          var (mu, v) = p;\n          switch (mu) {\n            case Coq_mutability_uninitialized_immutable:\n              return (Value_bool(false));\n            case Coq_mutability_immutable:\n              return (Value_bool(false));\n            case Coq_mutability_nondeletable:\n              return (Value_bool(false));\n            case Coq_mutability_deletable:\n              var s_2 = env_record_write(l, decl_env_record_rem(ed, x));\n              return (Value_bool(true));\n          }\n          \n        case None:\n          return (Value_bool(true));\n      }\n      \n    case Coq_env_record_object(l0, pt):\n      return (object_delete(l0, x, throw_false));\n  }\n  \n};\n\nvar env_record_implicit_this_value = function (l) {\n  return (\n    ifx_some_or_default(env_record_binds_option(l), None, function (e) {\n        return (\n          Some((function () {\n              switch (e) {\n                case Coq_env_record_decl(ed):\n                  return (Value_undef);\n                case Coq_env_record_object(l0, provide_this):\n                  if (provide_this) {\n                    return (l0);\n                  } else {\n                    return (Value_undef);\n                  }\n              }\n              }())));}));\n};\n\nvar identifier_resolution = function (x) {\n  var x0 = c.execution_ctx_lexical_env;\n  var str = c.execution_ctx_strict;\n  return (lexical_env_get_identifier_ref(x0, x, str));\n};\n\nvar env_record_get_binding_value = function (c, l, x, str) {\n  return (get_binding_value(l, Value_string(x), str));\n};\n\nvar ref_get_value = function (_foo_) {\n  var%value v = get_value(_foo_);\n  return (v);\n};\n\nvar run_expr_get_value = function (e) {\n  var%value v = get_value(run_expr(e));\n  return (v);\n};\n\nvar env_record_set_mutable_binding = function (l, x, v, str) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      var%some rm = HeapStr.read_option(ed, x);\n      var (mu, v_old) = rm;\n      if (!(mutability_compare(mu, Mutability_immutable))) {\n        return (res_void(env_record_write_decl_env(l, x, mu, v)));\n      } else {\n        return (out_error_or_void(str, Native_error_type));\n      }\n    case Coq_env_record_object(l0, pt):\n      return (object_put(l0, x, v, str));\n  }\n  \n};\n\nvar prim_value_put = function (w, x, v, str) {\n  throw false;\n};\n\nvar ref_put_value = function (rv, v) {\n  switch (rv) {\n    case Coq_resvalue_empty:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[ref_put_value] received an empty result."));\n    case Coq_resvalue_value(v0):\n      return (run_error(Native_error_ref));\n    case Coq_resvalue_ref(r):\n      if (ref_kind_comparable(ref_kind_of(r), Ref_kind_undef)) {\n        if (r.ref_strict) {\n          return (run_error(Native_error_ref));\n        } else {\n          return (object_put(Prealloc_global, r.ref_name, v, throw_false));\n        }\n      } else {\n        if ((ref_kind_comparable(ref_kind_of(r), Ref_kind_primitive_base)\n            || (ref_kind_comparable(ref_kind_of(r), Ref_kind_null)\n               || ref_kind_comparable(ref_kind_of(r), Ref_kind_object)))) {\n          switch (r.ref_base) {\n            case Coq_ref_base_type_value(v_2):\n              if (ref_kind_comparable(ref_kind_of(r),\n                    Ref_kind_primitive_base)) {\n                switch (v_2) {\n                  case Coq_value_object(o):\n                    return (\n                      function (m) {\n                          Debug.impossible_with_heap_because(__LOC__, m);\n                          return (Result_impossible);}(\n                        "[ref_put_value] impossible case"));\n                  default:\n                    return (\n                      prim_value_put(v_2, r.ref_name, v, r.ref_strict));\n                }\n                \n              } else {\n                switch (v_2) {\n                  case Coq_value_object(l):\n                    return (object_put(l, r.ref_name, v, r.ref_strict));\n                  default:\n                    return (\n                      function (m) {\n                          Debug.impossible_with_heap_because(__LOC__, m);\n                          return (Result_impossible);}(\n                        "[ref_put_value] impossible case"));\n                }\n                \n              }\n            case Coq_ref_base_type_env_loc(l):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "[ref_put_value] contradicts ref_is_property"));\n          }\n          \n        } else {\n          switch (r.ref_base) {\n            case Coq_ref_base_type_value(v0):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "[ref_put_value] impossible spec"));\n            case Coq_ref_base_type_env_loc(l):\n              return (\n                env_record_set_mutable_binding(l, r.ref_name, v,\n                  r.ref_strict));\n          }\n          \n        }\n      }\n  }\n  \n};\n\nvar env_record_create_mutable_binding = function (l, x, deletable_opt) {\n  var deletable = unsome_default(false, deletable_opt);\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      if (HeapStr.indom_dec(ed, x)) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared environnment record in [env_record_create_mutable_binding]."));\n      } else {\n        var s_2 = env_record_write_decl_env(l, x,\n                    mutability_of_bool(deletable), Value_undef);\n        return (res_void());\n      }\n    case Coq_env_record_object(l0, pt):\n      var%bool has = object_has_prop(l0, x);\n      if (has) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared binding in [env_record_create_mutable_binding]."));\n      } else {\n        var a = {\n          attributes_data_value: Value_undef,\n          attributes_data_writable: true,\n          attributes_data_enumerable: true,\n          attributes_data_configurable: deletable\n        };\n        var%success rv = object_define_own_prop(l0, x,\n                           descriptor_of_attributes(a), throw_true);\n        return (res_void());\n      }\n  }\n  \n};\n\nvar env_record_create_set_mutable_binding = function (l, x, deletable_opt, v, str) {\n  var%void _ = env_record_create_mutable_binding(l, x, deletable_opt);\n  return (env_record_set_mutable_binding(l, x, v, str));\n};\n\nvar env_record_create_immutable_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      if (HeapStr.indom_dec(ed, x)) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared environnment record in [env_record_create_immutable_binding]."));\n      } else {\n        return (\n          res_void(\n            env_record_write_decl_env(l, x,\n              Mutability_uninitialized_immutable, Value_undef)));\n      }\n    case Coq_env_record_object(o, p):\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[env_record_create_immutable_binding] received an environnment record object."));\n  }\n  \n};\n\nvar env_record_initialize_immutable_binding = function (l, x, v) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      var%some evs = decl_env_record_option(ed, x);\n      if (prod_compare(mutability_compare, value_compare, evs,\n            [Mutability_uninitialized_immutable, Value_undef])) {\n        var s_2 = env_record_write_decl_env(l, x, Mutability_immutable, v);\n        return (res_void());\n      } else {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Non suitable binding in [env_record_initialize_immutable_binding]."));\n      }\n    case Coq_env_record_object(o, p):\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[env_record_initialize_immutable_binding] received an environnment record object."));\n  }\n  \n};\n\nvar call_object_new = function (v) {\n  switch (type_of(v)) {\n    case Coq_type_undef:\n      var o = object_new(Prealloc_object_proto, "Object");\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      return (l);\n    case Coq_type_null:\n      var o = object_new(Prealloc_object_proto, "Object");\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      return (l);\n    case Coq_type_bool:\n      return (to_object(v));\n    case Coq_type_number:\n      return (to_object(v));\n    case Coq_type_string:\n      return (to_object(v));\n    case Coq_type_object:\n      return (v);\n  }\n  \n};\n\nvar array_args_map_loop = function (l, args, ind) {\n  switch (args) {\n    case []:\n      return (res_void());\n    case (h::rest):\n      var%some _ = run_object_heap_map_properties(l, function (p) {\n                       return (\n                         HeapStr.write(p, JsNumber.to_string(ind),\n                           attributes_data_intro_all_true(h)));});\n      return (array_args_map_loop(l, rest, (ind + 1.)));\n  }\n  \n};\n\nvar run_construct_prealloc = function (b, args) {\n  switch (b) {\n    case Coq_prealloc_object:\n      var v = get_arg(0, args);\n      return (call_object_new(v));\n    case Coq_prealloc_bool:\n      var v = get_arg(0, args);\n      var b0 = to_boolean(v);\n      var o1 = object_new(Prealloc_bool_proto, "Boolean");\n      var o = object_with_primitive_value(o1, Value_bool(b0));\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      return (l);\n    case Coq_prealloc_number:\n      var follow = function (v) {\n        var o1 = object_new(Prealloc_number_proto, "Number");\n        var o = object_with_primitive_value(o1, v);\n        var (l, s1) = object_alloc(o);\n        return (l);\n      };\n      if (list_eq_nil_decidable(args)) {\n        return (follow(Value_number(JsNumber.zero)));\n      } else {\n        var v = get_arg(0, args);\n        var%number x0 = to_number(v);\n        return (follow(Value_number(x0)));\n      }\n    case Coq_prealloc_array:\n      var o_2 = object_new(Prealloc_array_proto, "Array");\n      var o = object_for_array(o_2, Builtin_define_own_prop_array);\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      var follow = function (length0) {\n        var%some _ = run_object_heap_map_properties(l, function (p0) {\n                         return (\n                           HeapStr.write(p0, "length", {\n                               attributes_data_value: Value_number(length0),\n                               attributes_data_writable: true,\n                               attributes_data_enumerable: false,\n                               attributes_data_configurable: false}));});\n        return (l);\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 1)) {\n        var v = get_arg(0, args);\n        switch (v) {\n          case Coq_value_undef:\n            var%some _ = run_object_heap_map_properties(l, function (p1) {\n                             return (\n                               HeapStr.write(p1, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n          case Coq_value_null:\n            var%some _ = run_object_heap_map_properties(l, function (p1) {\n                             return (\n                               HeapStr.write(p1, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n          case Coq_value_bool(b0):\n            var%some _ = run_object_heap_map_properties(l, function (p1) {\n                             return (\n                               HeapStr.write(p1, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n          case Coq_value_number(vlen):\n            var%spec ilen = to_uint32(Value_number(vlen));\n            if ((ilen === vlen)) {\n              return (follow(ilen));\n            } else {\n              return (run_error(Native_error_range));\n            }\n          case Coq_value_string(s0):\n            var%some _ = run_object_heap_map_properties(l, function (p1) {\n                             return (\n                               HeapStr.write(p1, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n          case Coq_value_object(o0):\n            var%some _ = run_object_heap_map_properties(l, function (p0) {\n                             return (\n                               HeapStr.write(p0, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n        }\n        \n      } else {\n        var%some _ = run_object_heap_map_properties(l, function (p0) {\n                         return (\n                           HeapStr.write(p0, "length", {\n                               attributes_data_value: Value_number(arg_len),\n                               attributes_data_writable: true,\n                               attributes_data_enumerable: false,\n                               attributes_data_configurable: false}));});\n        var%void _ = array_args_map_loop(l, args, 0.);\n        return (l);\n      }\n    case Coq_prealloc_string:\n      var o2 = object_new(Prealloc_string_proto, "String");\n      var o1 = object_with_get_own_property(o2, Builtin_get_own_prop_string);\n      var follow = function (s1) {\n        var o = object_with_primitive_value(o1, Value_string(s1));\n        var (l, s2) = object_alloc(o);\n        var lenDesc = attributes_data_intro_constant(\n                        Value_number(strlength(s1)));\n        var%some _ = run_object_heap_map_properties(l, function (p) {\n                         return (HeapStr.write(p, "length", lenDesc));});\n        return (l);\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 0)) {\n        return (follow(""));\n      } else {\n        var arg = get_arg(0, args);\n        var%string s1 = to_string(arg);\n        return (follow(s1));\n      }\n    case Coq_prealloc_error:\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_error_proto, v));\n    case Coq_prealloc_native_error(ne):\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_native_error_proto(ne), v));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}(\n          strappend("Construct prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented."))));\n  }\n  \n};\n\nvar run_construct_default = function (l, args) {\n  var%value v1 = run_object_get(l, "prototype");\n  if (type_compare(type_of(v1), Type_object)) {\n    var vproto = v1;\n  } else {\n    var vproto = Prealloc_object_proto;\n  }\n  var o = object_new(vproto, "Object");\n  var p = object_alloc(o);\n  var (l_2, s2) = p;\n  var%value v2 = run_call(l, l_2, args);\n  if (type_compare(type_of(v2), Type_object)) {\n    var vr = v2;\n  } else {\n    var vr = l_2;\n  }\n  return (vr);\n};\n\nvar run_construct = function (co, l, args) {\n  switch (co) {\n    case Coq_construct_default:\n      return (run_construct_default(l, args));\n    case Coq_construct_after_bind:\n      var%some otrg = run_object_method(object_target_function_, l);\n      var%some target = otrg;\n      var%some oco = run_object_method(object_construct_, target);\n      switch (oco) {\n        case Some(co0):\n          var%some oarg = run_object_method(object_bound_args_, l);\n          var%some boundArgs = oarg;\n          var arguments_ = LibList.append(boundArgs, args);\n          return (run_construct(co0, target, arguments_));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_construct_prealloc(b):\n      return (run_construct_prealloc(b, args));\n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar run_call_default = function (lf) {\n  var def = Value_undef;\n  var%some oC = run_object_method(object_code_, lf);\n  switch (oC) {\n    case Some(bd):\n      if (list_eq_nil_decidable(prog_elements(funcbody_prog(bd)))) {\n        return (def);\n      } else {\n        return (\n          ifx_success_or_return(run_prog(funcbody_prog(bd)), function () {\n              return (Value_undef);}, function (rv) { return (rv);}));\n      }\n    case None:\n      return (def);\n  }\n  \n};\n\nvar creating_function_object_proto = function (l) {\n  var%object lproto = run_construct_prealloc(Prealloc_object, mk_nil);\n  var a1 = {\n    attributes_data_value: l,\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  var%bool b = object_define_own_prop(lproto, "constructor",\n                 descriptor_of_attributes(a1), false);\n  var a2 = {\n    attributes_data_value: lproto,\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  return (\n    object_define_own_prop(l, "prototype", descriptor_of_attributes(a2),\n      false));\n};\n\nvar creating_function_object = function (names, bd, x, str) {\n  var o = object_new(Prealloc_function_proto, "Function");\n  var o1 = object_with_get(o, Builtin_get_function);\n  var o2 = object_with_invokation(o1, Some(Construct_default),\n             Some(Call_default), Some(Builtin_has_instance_function));\n  var o3 = object_with_details(o2, Some(x), Some(names), Some(bd), None,\n             None, None, None);\n  var p = object_alloc(o3);\n  var (l, s1) = p;\n  var a1 = {\n    attributes_data_value: Value_number(LibList.length(names)),\n    attributes_data_writable: false,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  var%bool b2 = object_define_own_prop(l, "length",\n                  descriptor_of_attributes(a1), false);\n  var%bool b3 = creating_function_object_proto(l);\n  if (!(str)) {\n    return (l);\n  } else {\n    var vthrower = Prealloc_throw_type_error;\n    var a2 = {\n      attributes_accessor_get: vthrower,\n      attributes_accessor_set: vthrower,\n      attributes_accessor_enumerable: false,\n      attributes_accessor_configurable: false\n    };\n    var%bool b4 = object_define_own_prop(l, "caller",\n                    descriptor_of_attributes(a2), false);\n    var%bool b5 = object_define_own_prop(l, "arguments",\n                    descriptor_of_attributes(a2), false);\n    return (l);\n  }\n};\n\nvar binding_inst_formal_params = function (l, args, names, str) {\n  switch (names) {\n    case []:\n      return (res_void());\n    case (argname::names_2):\n      var v = hd(Value_undef, args);\n      var args_2 = tl(args);\n      var%bool hb = env_record_has_binding(l, argname);\n      var follow = function () {\n        var%void _ = env_record_set_mutable_binding(l, argname, v, str);\n        return (binding_inst_formal_params(l, args_2, names_2, str));\n      };\n      if (hb) {\n        return (follow());\n      } else {\n        var%void _ = env_record_create_mutable_binding(l, argname, None);\n        return (follow());\n      }\n  }\n  \n};\n\nvar binding_inst_function_decls = function (l, fds, str, bconfig) {\n  switch (fds) {\n    case []:\n      return (res_void());\n    case (fd::fds_2):\n      var fbd = fd.funcdecl_body;\n      var str_fd = funcbody_is_strict(fbd);\n      var fparams = fd.funcdecl_parameters;\n      var fname = fd.funcdecl_name;\n      var%object fo = creating_function_object(fparams, fbd,\n                        c.execution_ctx_variable_env, str_fd);\n      var follow = function () {\n        var%void _ = env_record_set_mutable_binding(l, fname, fo, str);\n        return (binding_inst_function_decls(l, fds_2, str, bconfig));\n      };\n      var%bool has = env_record_has_binding(l, fname);\n      if (has) {\n        if (nat_eq(l, env_loc_global_env_record)) {\n          var%spec d = run_object_get_prop(Prealloc_global, fname);\n          switch (d) {\n            case Coq_full_descriptor_undef:\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Undefined full descriptor in [binding_inst_function_decls]."));\n            case Coq_full_descriptor_some(a):\n              if (attributes_configurable(a)) {\n                var a_2 = {\n                  attributes_data_value: Value_undef,\n                  attributes_data_writable: true,\n                  attributes_data_enumerable: true,\n                  attributes_data_configurable: bconfig\n                };\n                var%bool x = object_define_own_prop(Prealloc_global, fname,\n                               descriptor_of_attributes(a_2), true);\n                return (follow());\n              } else {\n                if ((is_accessor_descriptor(\n                       Descriptor(descriptor_of_attributes(a)))\n                    || (!(attributes_writable(a))\n                       || !(attributes_enumerable(a))))) {\n                  return (run_error(Native_error_type));\n                } else {\n                  return (follow());\n                }\n              }\n          }\n          \n        } else {\n          return (follow());\n        }\n      } else {\n        var%void _ = env_record_create_mutable_binding(l, fname,\n                       Some(bconfig));\n        return (follow());\n      }\n  }\n  \n};\n\nvar make_arg_getter = function (x, x0) {\n  var xbd = strappend("return ", strappend(x, ";"));\n  var bd = Funcbody_intro(\n             Prog_intro(true,\n               mk_cons(Element_stat(Stat_return(Some(Expr_identifier(x)))),\n                 mk_nil)), xbd);\n  return (creating_function_object(mk_nil, bd, x0, true));\n};\n\nvar make_arg_setter = function (x, x0) {\n  var xparam = strappend(x, "_arg");\n  var xbd = strappend(x, strappend(" = ", strappend(xparam, ";")));\n  var bd = Funcbody_intro(\n             Prog_intro(true,\n               mk_cons(\n                 Element_stat(\n                   Stat_expr(\n                     Expr_assign(Expr_identifier(x), None,\n                       Expr_identifier(xparam)))), mk_nil)), xbd);\n  return (creating_function_object(mk_cons(xparam, mk_nil), bd, x0, true));\n};\n\nvar arguments_object_map_loop = function (l, xs, len, args, x, str, lmap, xsmap) {\n  return (\n    function (fO, fS, n) {\n        if (int_eq(n, 0)) {\n          return (fO({}));\n        } else {\n          return (fS((n - 1)));\n        }}(function (_pat_any_32) {\n        if (list_eq_nil_decidable(xsmap)) {\n          return (res_void());\n        } else {\n          var%some o = object_binds_option(l);\n          var o_2 = object_for_args_object(o, lmap, Builtin_get_args_obj,\n                      Builtin_get_own_prop_args_obj,\n                      Builtin_define_own_prop_args_obj,\n                      Builtin_delete_args_obj);\n          return (res_void(object_write(l, o_2)));\n        }}, function (len_2) {\n        var tdl = take_drop_last(args);\n        var (rmlargs, largs) = tdl;\n        var arguments_object_map_loop_2 = function (xsmap0) {\n          return (\n            arguments_object_map_loop(l, xs, len_2, rmlargs, x, str, lmap,\n              xsmap0));\n        };\n        var a = attributes_data_intro_all_true(largs);\n        var%bool b = object_define_own_prop(l,\n                       convert_prim_to_string(Value_number(len_2)),\n                       descriptor_of_attributes(a), false);\n        if (ge_nat_decidable(len_2, LibList.length(xs))) {\n          return (arguments_object_map_loop_2(xsmap));\n        } else {\n          var dummy = "";\n          var x0 = nth_def(dummy, len_2, xs);\n          if ((str || mem_decide(string_eq, x0, xsmap))) {\n            return (arguments_object_map_loop_2(xsmap));\n          } else {\n            var%object lgetter = make_arg_getter(x0, x);\n            var%object lsetter = make_arg_setter(x0, x);\n            var a_2 = {\n              attributes_accessor_get: lgetter,\n              attributes_accessor_set: lsetter,\n              attributes_accessor_enumerable: false,\n              attributes_accessor_configurable: true\n            };\n            var%bool b_2 = object_define_own_prop(lmap,\n                             convert_prim_to_string(Value_number(len_2)),\n                             descriptor_of_attributes(a_2), false);\n            return (arguments_object_map_loop_2(mk_cons(x0, xsmap)));\n          }\n        }}, len));\n};\n\nvar arguments_object_map = function (l, xs, args, x, str) {\n  var%object lmap = run_construct_prealloc(Prealloc_object, mk_nil);\n  return (\n    arguments_object_map_loop(l, xs, LibList.length(args), args, x, str,\n      lmap, mk_nil));\n};\n\nvar create_arguments_object = function (lf, xs, args, x, str) {\n  var o = object_create_builtin(Prealloc_object_proto, "Arguments",\n            Heap.empty);\n  var p = object_alloc(o);\n  var (l, s_2) = p;\n  var a = {\n    attributes_data_value: Value_number(LibList.length(args)),\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  var%bool b = object_define_own_prop(l, "length",\n                 descriptor_of_attributes(a), false);\n  var%void _ = arguments_object_map(l, xs, args, x, str);\n  if (str) {\n    var vthrower = Prealloc_throw_type_error;\n    var a0 = {\n      attributes_accessor_get: vthrower,\n      attributes_accessor_set: vthrower,\n      attributes_accessor_enumerable: false,\n      attributes_accessor_configurable: false\n    };\n    var%bool b_2 = object_define_own_prop(l, "caller",\n                     descriptor_of_attributes(a0), false);\n    var%bool b_3 = object_define_own_prop(l, "callee",\n                     descriptor_of_attributes(a0), false);\n    return (l);\n  } else {\n    var a0 = {\n      attributes_data_value: lf,\n      attributes_data_writable: true,\n      attributes_data_enumerable: false,\n      attributes_data_configurable: true\n    };\n    var%bool b_2 = object_define_own_prop(l, "callee",\n                     descriptor_of_attributes(a0), false);\n    return (l);\n  }\n};\n\nvar binding_inst_arg_obj = function (lf, p, xs, args, l) {\n  var arguments_ = "arguments";\n  var str = prog_intro_strictness(p);\n  var%object largs = create_arguments_object(lf, xs, args,\n                       c.execution_ctx_variable_env, str);\n  if (str) {\n    var%void _ = env_record_create_immutable_binding(l, arguments_);\n    return (env_record_initialize_immutable_binding(l, arguments_, largs));\n  } else {\n    return (\n      env_record_create_set_mutable_binding(l, arguments_, None, largs,\n        false));\n  }\n};\n\nvar binding_inst_var_decls = function (l, vds, bconfig, str) {\n  switch (vds) {\n    case []:\n      return (res_void());\n    case (vd::vds_2):\n      var bivd = function () {\n        return (binding_inst_var_decls(l, vds_2, bconfig, str));\n      };\n      var%bool has = env_record_has_binding(l, vd);\n      if (has) {\n        return (bivd());\n      } else {\n        var%void _ = env_record_create_set_mutable_binding(l, vd,\n                       Some(bconfig), Value_undef, str);\n        return (bivd());\n      }\n  }\n  \n};\n\nvar execution_ctx_binding_inst = function (ct, funco, p, args) {\n  switch (c.execution_ctx_variable_env) {\n    case []:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst]."));\n    case (l::l0):\n      var str = prog_intro_strictness(p);\n      var follow = function (names) {\n        var bconfig = codetype_compare(ct, Codetype_eval);\n        var fds = prog_funcdecl(p);\n        var%void _ = binding_inst_function_decls(l, fds, str, bconfig);\n        var%bool bdefined = env_record_has_binding(l, "arguments");\n        var follow2 = function () {\n          var vds = prog_vardecl(p);\n          return (binding_inst_var_decls(l, vds, bconfig, str));\n        };\n        switch (ct) {\n          case Coq_codetype_func:\n            switch (funco) {\n              case Some(func):\n                if (bdefined) {\n                  return (follow2());\n                } else {\n                  var%void _ = binding_inst_arg_obj(func, p, names, args, l);\n                  return (follow2());\n                }\n              case None:\n                if (bdefined) {\n                  return (follow2());\n                } else {\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "Weird `arguments\' object in [execution_ctx_binding_inst]."));\n                }\n            }\n            \n          case Coq_codetype_global:\n            return (follow2());\n          case Coq_codetype_eval:\n            return (follow2());\n        }\n        \n      };\n      switch (ct) {\n        case Coq_codetype_func:\n          switch (funco) {\n            case Some(func):\n              var%some nameso = run_object_method(object_formal_parameters_,\n                                  func);\n              var%some names = nameso;\n              var%void _ = binding_inst_formal_params(l, args, names, str);\n              return (follow(names));\n            case None:\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent functionnal code type in [execution_ctx_binding_inst]."));\n          }\n          \n        case Coq_codetype_global:\n          switch (funco) {\n            case Some(o):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case None:\n              return (follow(mk_nil));\n          }\n          \n        case Coq_codetype_eval:\n          switch (funco) {\n            case Some(o):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case None:\n              return (follow(mk_nil));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar entering_func_code = function (lf, vthis, args) {\n  var%some bdo = run_object_method(object_code_, lf);\n  var%some bd = bdo;\n  var str = funcbody_is_strict(bd);\n  var follow = function (vthis_2) {\n    var%some lexo = run_object_method(object_scope_, lf);\n    var%some lex = lexo;\n    var p = lexical_env_alloc_decl(lex);\n    var (lex_2, s1) = p;\n    var c_2 = execution_ctx_intro_same(lex_2, vthis_2, str);\n    var%void _ = execution_ctx_binding_inst(Codetype_func, Some(lf),\n                   funcbody_prog(bd), args);\n    return (run_call_default(lf));\n  };\n  if (str) {\n    return (follow(vthis));\n  } else {\n    switch (vthis) {\n      case Coq_value_undef:\n        return (follow(Prealloc_global));\n      case Coq_value_null:\n        return (follow(Prealloc_global));\n      case Coq_value_bool(b):\n        var%value v = to_object(vthis);\n        return (follow(v));\n      case Coq_value_number(n):\n        var%value v = to_object(vthis);\n        return (follow(v));\n      case Coq_value_string(s0):\n        var%value v = to_object(vthis);\n        return (follow(v));\n      case Coq_value_object(lthis):\n        return (follow(vthis));\n    }\n    \n  }\n};\n\nvar run_object_get_own_prop = function (l, x) {\n  var%some b = run_object_method(object_get_own_prop_, l);\n  var def = function () {\n    var%some p = run_object_method(object_properties_, l);\n    return (\n      ifx_some_or_default(\n        convert_option_attributes(HeapStr.read_option(p, x)),\n        Full_descriptor_undef, function (x) { return (x);}));\n  };\n  switch (b) {\n    case Coq_builtin_get_own_prop_default:\n      return (def());\n    case Coq_builtin_get_own_prop_args_obj:\n      var%spec d = def();\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (Full_descriptor_undef);\n        case Coq_full_descriptor_some(a):\n          var%some lmapo = run_object_method(object_parameter_map_, l);\n          var%some lmap = lmapo;\n          var%spec d0 = run_object_get_own_prop(lmap, x);\n          var follow = function (a0) {\n            return (a0);\n          };\n          switch (d0) {\n            case Coq_full_descriptor_undef:\n              return (follow(a));\n            case Coq_full_descriptor_some(amap):\n              var%value v = run_object_get(lmap, x);\n              switch (a) {\n                case Coq_attributes_data_of(ad):\n                  return (follow(attributes_data_with_value(ad, v)));\n                case Coq_attributes_accessor_of(aa):\n                  Debug.impossible_with_heap_because(__LOC__,\n                    "[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens.");\n                  return (Result_impossible);\n              }\n              \n          }\n          \n      }\n      \n    case Coq_builtin_get_own_prop_string:\n      var%spec d = def();\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          var%spec k = to_int32(Value_string(x));\n          var%string s3 = to_string(Value_number(JsNumber.absolute(k)));\n          if (!(string_eq(x, s3))) {\n            return (Full_descriptor_undef);\n          } else {\n            var%string str = run_object_prim_value(l);\n            var%spec k0 = to_int32(Value_string(x));\n            var len = strlength(str);\n            if (le_int_decidable(len, k0)) {\n              return (Full_descriptor_undef);\n            } else {\n              var resultStr = string_sub(str, int_of_number(k0), 1);\n              var a = {\n                attributes_data_value: Value_string(resultStr),\n                attributes_data_writable: false,\n                attributes_data_enumerable: true,\n                attributes_data_configurable: false\n              };\n              return (a);\n            }\n          }\n        case Coq_full_descriptor_some(a):\n          return (d);\n      }\n      \n    default:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar run_function_has_instance = function (lv, _foo_) {\n  switch (_foo_) {\n    case Coq_value_object(lo):\n      var%some vproto = run_object_method(object_proto_, lv);\n      switch (vproto) {\n        case Coq_value_null:\n          return (Value_bool(false));\n        case Coq_value_object(proto):\n          if (object_loc_compare(proto, lo)) {\n            return (Value_bool(true));\n          } else {\n            return (run_function_has_instance(proto, lo));\n          }\n        default:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "Primitive found in the prototype chain in [run_object_has_instance_loop]."));\n      }\n      \n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_object_has_instance = function (b, l, v) {\n  switch (b) {\n    case Coq_builtin_has_instance_function:\n      switch (v) {\n        case Coq_value_object(lv):\n          var%value vproto = run_object_get(l, "prototype");\n          switch (vproto) {\n            case Coq_value_object(lproto):\n              return (run_function_has_instance(lv, lproto));\n            default:\n              return (run_error(Native_error_type));\n          }\n          \n        default:\n          return (Value_bool(false));\n      }\n      \n    case Coq_builtin_has_instance_after_bind:\n      var%some ol = run_object_method(object_target_function_, l);\n      var%some l0 = ol;\n      var%some ob = run_object_method(object_has_instance_, l0);\n      switch (ob) {\n        case Some(b0):\n          return (run_object_has_instance(b0, l0, v));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n  }\n  \n};\n\nvar from_prop_descriptor = function (_foo_) {\n  switch (_foo_) {\n    case Coq_full_descriptor_undef:\n      return (Value_undef);\n    case Coq_full_descriptor_some(a):\n      var%object l = run_construct_prealloc(Prealloc_object, mk_nil);\n      var follow = function (x) {\n        var a1 = attributes_data_intro_all_true(\n                   Value_bool(attributes_enumerable(a)));\n        var%bool x0 = object_define_own_prop(l, "enumerable",\n                        descriptor_of_attributes(a1), throw_false);\n        var a2 = attributes_data_intro_all_true(\n                   Value_bool(attributes_configurable(a)));\n        var%bool x1 = object_define_own_prop(l, "configurable",\n                        descriptor_of_attributes(a2), throw_false);\n        return (l);\n      };\n      switch (a) {\n        case Coq_attributes_data_of(ad):\n          var a1 = attributes_data_intro_all_true(ad.attributes_data_value);\n          var%bool x = object_define_own_prop(l, "value",\n                         descriptor_of_attributes(a1), throw_false);\n          var a2 = attributes_data_intro_all_true(\n                     Value_bool(ad.attributes_data_writable));\n          var%bool v = object_define_own_prop(l, "writable",\n                         descriptor_of_attributes(a2), throw_false);\n          return (follow(v));\n        case Coq_attributes_accessor_of(aa):\n          var a1 = attributes_data_intro_all_true(aa.attributes_accessor_get);\n          var%bool x = object_define_own_prop(l, "get",\n                         descriptor_of_attributes(a1), throw_false);\n          var a2 = attributes_data_intro_all_true(aa.attributes_accessor_set);\n          var%bool v = object_define_own_prop(l, "set",\n                         descriptor_of_attributes(a2), throw_false);\n          return (follow(v));\n      }\n      \n  }\n  \n};\n\nvar run_equal = function (v1, v2) {\n  var conv_number = function (v) {\n    return (to_number(v));\n  };\n  var conv_primitive = function (v) {\n    return (to_primitive(v, None));\n  };\n  var checkTypesThen = function (v3, v4, k) {\n    var ty1 = type_of(v3);\n    var ty2 = type_of(v4);\n    if (type_compare(ty1, ty2)) {\n      return (Value_bool(equality_test_for_same_type(ty1, v3, v4)));\n    } else {\n      return (k(ty1, ty2));\n    }\n  };\n  return (\n    checkTypesThen(v1, v2, function (ty1, ty2) {\n        var dc_conv = function (v3, f, v4) {\n          var%value v2_2 = f(v4);\n          return (run_equal(v3, v2_2));\n        };\n        var so = function (b) {\n          return (Value_bool(b));\n        };\n        if ((type_compare(ty1, Type_null) && type_compare(ty2, Type_undef))) {\n          return (so(true));\n        } else {\n          if ((type_compare(ty1, Type_undef) && type_compare(ty2, Type_null))) {\n            return (so(true));\n          } else {\n            if ((type_compare(ty1, Type_number)\n                && type_compare(ty2, Type_string))) {\n              return (dc_conv(v1, conv_number, v2));\n            } else {\n              if ((type_compare(ty1, Type_string)\n                  && type_compare(ty2, Type_number))) {\n                return (dc_conv(v2, conv_number, v1));\n              } else {\n                if (type_compare(ty1, Type_bool)) {\n                  return (dc_conv(v2, conv_number, v1));\n                } else {\n                  if (type_compare(ty2, Type_bool)) {\n                    return (dc_conv(v1, conv_number, v2));\n                  } else {\n                    if (((type_compare(ty1, Type_string)\n                         || type_compare(ty1, Type_number))\n                        && type_compare(ty2, Type_object))) {\n                      return (dc_conv(v1, conv_primitive, v2));\n                    } else {\n                      if ((type_compare(ty1, Type_object)\n                          && (type_compare(ty2, Type_string)\n                             || type_compare(ty2, Type_number)))) {\n                        return (dc_conv(v2, conv_primitive, v1));\n                      } else {\n                        return (so(false));\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }}));\n};\n\nvar convert_twice = function (ifv, kC, v1, v2) {\n  return (\n    ifv(kC(v1), function (vc1) {\n        return (ifv(kC(v2), function (vc2) { return ([vc1, vc2]);}));}));\n};\n\nvar convert_twice_primitive = function (v1, v2) {\n  return (\n    convert_twice(ifx_prim, function (v) { return (to_primitive(v, None));},\n      v1, v2));\n};\n\nvar convert_twice_number = function (v1, v2) {\n  return (\n    convert_twice(ifx_number, function (v) { return (to_number(v));}, v1, v2));\n};\n\nvar convert_twice_string = function (v1, v2) {\n  return (\n    convert_twice(ifx_string, function (v) { return (to_string(v));}, v1, v2));\n};\n\nvar issome = function (_foo_) {\n  switch (_foo_) {\n    case Some(t):\n      return (true);\n    case None:\n      return (false);\n  }\n  \n};\n\nvar run_binary_op_add = function (v1, v2) {\n  var%spec (w1, w2) = convert_twice_primitive(v1, v2);\n  if ((type_compare(type_of(w1), Type_string)\n      || type_compare(type_of(w2), Type_string))) {\n    var%spec (str1, str2) = convert_twice_string(w1, w2);\n    return (Value_string(strappend(str1, str2)));\n  } else {\n    var%spec (n1, n2) = convert_twice_number(w1, w2);\n    return (Value_number((n1 + n2)));\n  }\n};\n\nvar run_binary_op_arith = function (mathop, v1, v2) {\n  var%spec nn = convert_twice_number(v1, v2);\n  var (n1, n2) = nn;\n  return (Value_number(mathop(n1, n2)));\n};\n\nvar run_binary_op_shift = function (b_unsigned, mathop, v1, v2) {\n  if (b_unsigned) {\n    var conv = to_uint32;\n  } else {\n    var conv = to_int32;\n  }\n  var%spec k1 = conv(v1);\n  var%spec k2 = to_uint32(v2);\n  var k2_2 = JsNumber.modulo_32(k2);\n  return (Value_number(mathop(k1, k2_2)));\n};\n\nvar run_binary_op_bitwise = function (mathop, v1, v2) {\n  var%spec k1 = to_int32(v1);\n  var%spec k2 = to_int32(v2);\n  return (Value_number(mathop(k1, k2)));\n};\n\nvar run_binary_op_compare = function (b_swap, b_neg, v1, v2) {\n  var%spec ww = convert_twice_primitive(v1, v2);\n  var (w1, w2) = ww;\n  if (b_swap) {\n    var p = [w2, w1];\n  } else {\n    var p = [w1, w2];\n  }\n  var (wa, wb) = p;\n  var wr = inequality_test_primitive(wa, wb);\n  if (value_compare(wr, Value_undef)) {\n    return (Value_bool(false));\n  } else {\n    if ((b_neg && value_compare(wr, Value_bool(true)))) {\n      return (Value_bool(false));\n    } else {\n      if ((b_neg && value_compare(wr, Value_bool(false)))) {\n        return (Value_bool(true));\n      } else {\n        return (wr);\n      }\n    }\n  }\n};\n\nvar run_binary_op_instanceof = function (v1, v2) {\n  switch (v2) {\n    case Coq_value_object(l):\n      var%some b = run_object_method(object_has_instance_, l);\n      switch (b) {\n        case None:\n          return (run_error(Native_error_type));\n        case Some(has_instance_id):\n          return (run_object_has_instance(has_instance_id, l, v1));\n      }\n      \n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_binary_op_in = function (v1, v2) {\n  switch (v2) {\n    case Coq_value_object(l):\n      var%string x = to_string(v1);\n      return (object_has_prop(l, x));\n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_binary_op = function (op, v1, v2) {\n  switch (op) {\n    case Coq_binary_op_mult:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x * y));}, v1, v2));\n    case Coq_binary_op_div:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x / y));}, v1, v2));\n    case Coq_binary_op_mod:\n      return (\n        run_binary_op_arith(function (x, y) { return (JsNumber.fmod(x, y));},\n          v1, v2));\n    case Coq_binary_op_sub:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x - y));}, v1, v2));\n    case Coq_binary_op_lt:\n      return (run_binary_op_compare(false, false, v1, v2));\n    case Coq_binary_op_gt:\n      return (run_binary_op_compare(true, false, v1, v2));\n    case Coq_binary_op_le:\n      return (run_binary_op_compare(true, true, v1, v2));\n    case Coq_binary_op_ge:\n      return (run_binary_op_compare(false, true, v1, v2));\n    case Coq_binary_op_left_shift:\n      return (run_binary_op_shift(false, JsNumber.int32_left_shift, v1, v2));\n    case Coq_binary_op_right_shift:\n      return (\n        run_binary_op_shift(false, JsNumber.int32_right_shift, v1, v2));\n    case Coq_binary_op_unsigned_right_shift:\n      return (\n        run_binary_op_shift(true, JsNumber.uint32_right_shift, v1, v2));\n    case Coq_binary_op_bitwise_and:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_and, v1, v2));\n    case Coq_binary_op_bitwise_or:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_or, v1, v2));\n    case Coq_binary_op_bitwise_xor:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_xor, v1, v2));\n    case Coq_binary_op_add:\n      return (run_binary_op_add(v1, v2));\n    case Coq_binary_op_instanceof:\n      return (run_binary_op_instanceof(v1, v2));\n    case Coq_binary_op_in:\n      return (run_binary_op_in(v1, v2));\n    case Coq_binary_op_equal:\n      return (run_equal(v1, v2));\n    case Coq_binary_op_disequal:\n      var%bool b0 = run_equal(v1, v2);\n      return (Value_bool(!(b0)));\n    case Coq_binary_op_strict_equal:\n      return (Value_bool(strict_equality_test(v1, v2)));\n    case Coq_binary_op_strict_disequal:\n      return (Value_bool(!(strict_equality_test(v1, v2))));\n    case Coq_binary_op_coma:\n      return (v2);\n    case Coq_binary_op_and:\n      return (Result_impossible);\n    case Coq_binary_op_or:\n      return (Result_impossible);\n  }\n  \n};\n\nvar run_prepost_op = function (_foo_) {\n  switch (_foo_) {\n    case Coq_unary_op_delete:\n      return (None);\n    case Coq_unary_op_void:\n      return (None);\n    case Coq_unary_op_typeof:\n      return (None);\n    case Coq_unary_op_post_incr:\n      return (Some([add_one, false]));\n    case Coq_unary_op_post_decr:\n      return (Some([sub_one, false]));\n    case Coq_unary_op_pre_incr:\n      return (Some([add_one, true]));\n    case Coq_unary_op_pre_decr:\n      return (Some([sub_one, true]));\n    case Coq_unary_op_add:\n      return (None);\n    case Coq_unary_op_neg:\n      return (None);\n    case Coq_unary_op_bitwise_not:\n      return (None);\n    case Coq_unary_op_not:\n      return (None);\n  }\n  \n};\n\nvar run_typeof_value = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_object(l):\n      if (is_callable_dec(l)) {\n        return ("function");\n      } else {\n        return ("object");\n      }\n    default:\n      return (typeof_prim(_foo_));\n  }\n  \n};\n\nvar run_unary_op = function (op, e) {\n  if (prepost_unary_op_dec(op)) {\n    var%success rv1 = run_expr(e);\n    var%spec v2 = ref_get_value(rv1);\n    var%number n1 = to_number(v2);\n    var%some po = run_prepost_op(op);\n    var (number_op, is_pre) = po;\n    var n2 = number_op(n1);\n    var v = Value_number((function () {\n                if (is_pre) {\n                  return (n2);\n                } else {\n                  return (n1);\n                }}()));\n    var%void _ = ref_put_value(rv1, Value_number(n2));\n    return (v);\n  } else {\n    switch (op) {\n      case Coq_unary_op_delete:\n        var%success rv = run_expr(e);\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (Value_bool(true));\n          case Coq_resvalue_value(v):\n            return (Value_bool(true));\n          case Coq_resvalue_ref(r):\n            if (ref_kind_comparable(ref_kind_of(r), Ref_kind_undef)) {\n              if (r.ref_strict) {\n                return (run_error(Native_error_syntax));\n              } else {\n                return (Value_bool(true));\n              }\n            } else {\n              switch (r.ref_base) {\n                case Coq_ref_base_type_value(v):\n                  var%object l = to_object(v);\n                  return (object_delete(l, r.ref_name, r.ref_strict));\n                case Coq_ref_base_type_env_loc(l):\n                  if (r.ref_strict) {\n                    return (run_error(Native_error_syntax));\n                  } else {\n                    return (env_record_delete_binding(l, r.ref_name));\n                  }\n              }\n              \n            }\n        }\n        \n      case Coq_unary_op_typeof:\n        var%success rv = run_expr(e);\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Empty result for a `typeof\' in [run_unary_op]."));\n          case Coq_resvalue_value(v):\n            return (Value_string(run_typeof_value(v)));\n          case Coq_resvalue_ref(r):\n            if (ref_kind_comparable(ref_kind_of(r), Ref_kind_undef)) {\n              return (Value_string("undefined"));\n            } else {\n              var%spec v = ref_get_value(r);\n              return (Value_string(run_typeof_value(v)));\n            }\n        }\n        \n      default:\n        var%spec v = run_expr_get_value(e);\n        switch (op) {\n          case Coq_unary_op_void:\n            return (Value_undef);\n          case Coq_unary_op_add:\n            return (to_number(v));\n          case Coq_unary_op_neg:\n            var%number n = to_number(v);\n            return (Value_number(JsNumber.neg(n)));\n          case Coq_unary_op_bitwise_not:\n            var%spec k = to_int32(v);\n            return (Value_number(JsNumber.int32_bitwise_not(k)));\n          case Coq_unary_op_not:\n            return (Value_bool(!(to_boolean(v))));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Undealt regular operator in [run_unary_op]."));\n        }\n        \n    }\n    \n  }\n};\n\nvar create_new_function_in = function (args, bd) {\n  return (\n    creating_function_object(args, bd, c.execution_ctx_lexical_env,\n      c.execution_ctx_strict));\n};\n\nvar init_object = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (l);\n    case (p::pds_2):\n      var (pn, pb) = p;\n      var x = string_of_propname(pn);\n      var follows = function (desc) {\n        var%success rv = object_define_own_prop(l, x, desc, false);\n        return (init_object(l, pds_2));\n      };\n      switch (pb) {\n        case Coq_propbody_val(e0):\n          var%spec v0 = run_expr_get_value(e0);\n          var desc = {\n            descriptor_value: Some(v0),\n            descriptor_writable: Some(true),\n            descriptor_get: None,\n            descriptor_set: None,\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n        case Coq_propbody_get(bd):\n          var%value v0 = create_new_function_in(mk_nil, bd);\n          var desc = {\n            descriptor_value: None,\n            descriptor_writable: None,\n            descriptor_get: Some(v0),\n            descriptor_set: None,\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n        case Coq_propbody_set(args, bd):\n          var%value v0 = create_new_function_in(args, bd);\n          var desc = {\n            descriptor_value: None,\n            descriptor_writable: None,\n            descriptor_get: None,\n            descriptor_set: Some(v0),\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n      }\n      \n  }\n  \n};\n\nvar run_array_element_list = function (l, oes, n) {\n  switch (oes) {\n    case []:\n      return (l);\n    case (o::oes_2):\n      switch (o) {\n        case Some(e):\n          var loop_result = function () {\n            return (run_array_element_list(l, oes_2, 0.));\n          };\n          var%spec v = run_expr_get_value(e);\n          var%value vlen = run_object_get(l, "length");\n          var%spec ilen = to_uint32(vlen);\n          var%string slen = to_string(Value_number((ilen + n)));\n          var desc = {\n            attributes_data_value: v,\n            attributes_data_writable: true,\n            attributes_data_enumerable: true,\n            attributes_data_configurable: true\n          };\n          var%bool x = object_define_own_prop(l, slen,\n                         descriptor_of_attributes(desc), false);\n          var%object l0 = loop_result();\n          return (l0);\n        case None:\n          var firstIndex = elision_head_count(mk_cons(None, oes_2));\n          return (\n            run_array_element_list(l,\n              elision_head_remove(mk_cons(None, oes_2)), firstIndex));\n      }\n      \n  }\n  \n};\n\nvar init_array = function (l, oes) {\n  var elementList = elision_tail_remove(oes);\n  var elisionLength = elision_tail_count(oes);\n  var%object l0 = run_array_element_list(l, elementList, 0.);\n  var%value vlen = run_object_get(l0, "length");\n  var%spec ilen = to_uint32(vlen);\n  var%spec len = to_uint32(Value_number((ilen + elisionLength)));\n  var%not_throw x = object_put(l0, "length", Value_number(len), throw_false);\n  return (l0);\n};\n\nvar run_var_decl_item = function (x, _foo_) {\n  switch (_foo_) {\n    case Some(e):\n      var%spec ir = identifier_resolution(x);\n      var%spec v = run_expr_get_value(e);\n      var%void _ = ref_put_value(ir, v);\n      return (Value_string(x));\n    case None:\n      return (Value_string(x));\n  }\n  \n};\n\nvar run_var_decl = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (res_empty);\n    case (y::xeos_2):\n      var (x, eo) = y;\n      var%value vname = run_var_decl_item(x, eo);\n      return (run_var_decl(xeos_2));\n  }\n  \n};\n\nvar run_list_expr = function (vs, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rev(vs));\n    case (e::es_2):\n      var%spec v = run_expr_get_value(e);\n      return (run_list_expr(mk_cons(v, vs), es_2));\n  }\n  \n};\n\nvar run_block = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (Resvalue_empty);\n    case (t::ts_rev_2):\n      var%success rv0 = run_block(ts_rev_2);\n      return (\n        ifx_success_state(rv0, run_stat(t), function (x0) { return (x0);}));\n  }\n  \n};\n\nvar run_binary_op_and = function (e1, e2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b1 = to_boolean(v1);\n  if (!(b1)) {\n    return (v1);\n  } else {\n    var%spec v = run_expr_get_value(e2);return (v);\n  }\n};\n\nvar run_binary_op_or = function (e1, e2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b1 = to_boolean(v1);\n  if (b1) {\n    return (v1);\n  } else {\n    var%spec v = run_expr_get_value(e2);return (v);\n  }\n};\n\nvar run_expr_binary_op = function (op, e1, e2) {\n  switch (op) {\n    case Coq_binary_op_and:\n      return (run_binary_op_and(e1, e2));\n    case Coq_binary_op_or:\n      return (run_binary_op_or(e1, e2));\n    default:\n      var%spec v1 = run_expr_get_value(e1);\n      var%spec v2 = run_expr_get_value(e2);\n      return (run_binary_op(op, v1, v2));\n  }\n  \n};\n\nvar run_expr_access = function (e1, e2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var%spec v2 = run_expr_get_value(e2);\n  if ((value_compare(v1, Value_undef) || value_compare(v1, Value_null))) {\n    return (run_error(Native_error_type));\n  } else {\n    var%string x = to_string(v2);\n    return (ref_create_value(v1, x, c.execution_ctx_strict));\n  }\n};\n\nvar run_expr_assign = function (opo, e1, e2) {\n  var%success rv1 = run_expr(e1);\n  var follow = function (rv_2) {\n    switch (rv_2) {\n      case Coq_resvalue_value(v):\n        var%void _ = ref_put_value(rv1, v);\n        return (v);\n      case Coq_resvalue_empty:\n        Debug.impossible_with_heap_because(__LOC__,\n          "Non-value result in [run_expr_assign].");\n        return (Result_impossible);\n      case Coq_resvalue_ref(r):\n        Debug.impossible_with_heap_because(__LOC__,\n          "Non-value result in [run_expr_assign].");\n        return (Result_impossible);\n    }\n    \n  };\n  switch (opo) {\n    case Some(op):\n      var%spec v1 = ref_get_value(rv1);\n      var%spec v2 = run_expr_get_value(e2);\n      var%success v = run_binary_op(op, v1, v2);\n      return (follow(v));\n    case None:\n      var%spec x0 = run_expr_get_value(e2);\n      return (follow(x0));\n  }\n  \n};\n\nvar run_expr_function = function (fo, args, bd) {\n  switch (fo) {\n    case Some(fn):\n      var p = lexical_env_alloc_decl(c.execution_ctx_lexical_env);\n      var (lex_2, s_2) = p;\n      var follow = function (l) {\n        var%some e = env_record_binds_option(l);\n        var%void _ = env_record_create_immutable_binding(l, fn);\n        var%object l0 = creating_function_object(args, bd, lex_2,\n                          funcbody_is_strict(bd));\n        var%void _ = env_record_initialize_immutable_binding(l, fn, l0);\n        return (l0);\n      };\n      return (\n        destr_list(lex_2, function (x) {\n            Debug.impossible_with_heap_because(__LOC__,\n              "Empty lexical environnment allocated in [run_expr_function].");\n            return (Result_impossible);}, function (l, x) {\n            return (follow(l));}, {}));\n    case None:\n      var lex = c.execution_ctx_lexical_env;\n      return (\n        creating_function_object(args, bd, lex, funcbody_is_strict(bd)));\n  }\n  \n};\n\nvar entering_eval_code = function (direct, bd, k) {\n  var str = (funcbody_is_strict(bd) || (direct && c.execution_ctx_strict));\n  if (direct) {\n    var c_2 = c;\n  } else {\n    var c_2 = execution_ctx_initial(str);\n  }\n  if (str) {\n    var p = lexical_env_alloc_decl(c_2.execution_ctx_lexical_env);\n  } else {\n    var p = [c_2.execution_ctx_lexical_env, s];\n  }\n  var (lex, s_2) = p;\n  if (str) {\n    var c1 = execution_ctx_with_lex_same(lex);\n  } else {\n    var c1 = c_2;\n  }\n  var p0 = funcbody_prog(bd);\n  var%void _ = execution_ctx_binding_inst(Codetype_eval, None, p0, mk_nil);\n  return (k());\n};\n\nvar run_eval = function (is_direct_call, vs) {\n  switch (get_arg(0, vs)) {\n    case Coq_value_undef:\n      return (Value_undef);\n    case Coq_value_null:\n      return (Value_null);\n    case Coq_value_bool(b):\n      return (Value_bool(b));\n    case Coq_value_number(n):\n      return (Value_number(n));\n    case Coq_value_string(s0):\n      var str = (is_direct_call && c.execution_ctx_strict);\n      switch (parse_pickable(s0, str)) {\n        case Some(p0):\n          return (\n            entering_eval_code(is_direct_call, Funcbody_intro(p0, s0),\n              function () {\n                var%ter r = run_prog(p0);\n                switch (r.res_type) {\n                  case Coq_restype_normal:\n                    return (\n                      ifx_empty_label(r, function (x) {\n                          switch (r.res_value) {\n                            case Coq_resvalue_empty:\n                              return (Value_undef);\n                            case Coq_resvalue_value(v):\n                              return (v);\n                            case Coq_resvalue_ref(r0):\n                              Debug.impossible_with_heap_because(__LOC__,\n                                "Reference found in the result of an `eval\' in [run_eval].");\n                              return (Result_impossible);\n                          }\n                          }));\n                  case Coq_restype_throw:\n                    return (res_throw(r.res_value));\n                  default:\n                    Debug.impossible_with_heap_because(__LOC__,\n                      "Forbidden result type returned by an `eval\' in [run_eval].");\n                    return (Result_impossible);\n                }\n                }));\n        case None:\n          return (run_error(Native_error_syntax));\n      }\n      \n    case Coq_value_object(o):\n      return (o);\n  }\n  \n};\n\nvar run_expr_call = function (e1, e2s) {\n  var is_eval_direct = is_syntactic_eval(e1);\n  var%success rv = run_expr(e1);\n  var%spec f = ref_get_value(rv);\n  var%spec vs = run_list_expr(mk_nil, e2s);\n  switch (f) {\n    case Coq_value_object(l):\n      if (is_callable_dec(l)) {\n        var follow = function (vthis) {\n          if (object_loc_compare(l, Prealloc_global_eval)) {\n            return (run_eval(is_eval_direct, vs));\n          } else {\n            return (run_call(l, vthis, vs));\n          }\n        };\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "[run_expr_call] unable to call an  empty result."));\n          case Coq_resvalue_value(v):\n            return (follow(Value_undef));\n          case Coq_resvalue_ref(r):\n            switch (r.ref_base) {\n              case Coq_ref_base_type_value(v):\n                if ((ref_kind_comparable(ref_kind_of(r),\n                       Ref_kind_primitive_base)\n                    || (ref_kind_comparable(ref_kind_of(r), Ref_kind_null)\n                       || ref_kind_comparable(ref_kind_of(r),\n                            Ref_kind_object)))) {\n                  return (follow(v));\n                } else {\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "[run_expr_call] unable to call a non-property function."));\n                }\n              case Coq_ref_base_type_env_loc(l0):\n                var%some v = env_record_implicit_this_value(l0);\n                return (follow(v));\n            }\n            \n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_expr_conditionnal = function (e1, e2, e3) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b = to_boolean(v1);\n  if (b) {\n    var e = e2;\n  } else {\n    var e = e3;\n  }\n  var%spec r = run_expr_get_value(e);\n  return (r);\n};\n\nvar run_expr_new = function (e1, e2s) {\n  var%spec v = run_expr_get_value(e1);\n  var%spec args = run_list_expr(mk_nil, e2s);\n  switch (v) {\n    case Coq_value_object(l):\n      var%some coo = run_object_method(object_construct_, l);\n      switch (coo) {\n        case Some(co):\n          return (run_construct(co, l, args));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n    default:\n      return (run_error(Native_error_type));\n  }\n  \n};\n\nvar run_stat_label = function (lab, t) {\n  var%break r1 = run_stat(t);\n  return (\n    (function () {\n      if (label_compare(r1.res_label, lab)) {\n        return (r1.res_value);\n      } else {\n        return (r1);\n      }\n    }())\n    );\n};\n\nvar run_stat_with = function (e1, t2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var%object l = to_object(v1);\n  var lex = c.execution_ctx_lexical_env;\n  var p = lexical_env_alloc_object(lex, l, provide_this_true);\n  var (lex_2, s3) = p;\n  var c_2 = execution_ctx_with_lex(lex_2);\n  return (run_stat(t2));\n};\n\nvar run_stat_if = function (e1, t2, to0) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b = to_boolean(v1);\n  if (b) {\n    return (run_stat(t2));\n  } else {\n    switch (to0) {\n      case Some(t3):\n        return (run_stat(t3));\n      case None:\n        return (Resvalue_empty);\n    }\n    \n  }\n};\n\nvar run_stat_while = function (rv, labs, e1, t2) {\n  var%spec v1 = run_expr_get_value(e1);\n  var b = to_boolean(v1);\n  if (b) {\n    var%ter r = run_stat(t2);\n    if (!(resvalue_compare(r.res_value, Resvalue_empty))) {\n      var rv_2 = r.res_value;\n    } else {\n      var rv_2 = rv;\n    }\n    var loop = function (x) {\n      return (run_stat_while(rv_2, labs, e1, t2));\n    };\n    if ((!(restype_compare(r.res_type, Restype_continue))\n        || !(res_label_in(r, labs)))) {\n      if ((restype_compare(r.res_type, Restype_break)\n          && res_label_in(r, labs))) {\n        return (rv_2);\n      } else {\n        if (!(restype_compare(r.res_type, Restype_normal))) {\n          return (r);\n        } else {\n          return (loop({}));\n        }\n      }\n    } else {\n      return (loop({}));\n    }\n  } else {\n    return (rv);\n  }\n};\n\nvar run_stat_switch_end = function (rv, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rv);\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          return (\n            ifx_success_state(rv, run_block(rev(ts)), function (rv1) {\n                return (run_stat_switch_end(rv1, scs_2));}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_no_default = function (vi, rv, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rv);\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var%spec v1 = run_expr_get_value(e);\n          var b = strict_equality_test(v1, vi);\n          if (b) {\n            var%success rv2 = run_block(rev(ts));\n            return (run_stat_switch_end(rv2, scs_2));\n          } else {\n            return (run_stat_switch_no_default(vi, rv, scs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_default = function (ts, scs) {\n  var%success rv = run_block(rev(ts));\n  return (run_stat_switch_end(rv, scs));\n};\n\nvar run_stat_switch_with_default_B = function (vi, rv, ts0, scs) {\n  switch (scs) {\n    case []:\n      return (run_stat_switch_with_default_default(ts0, scs));\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var%spec v1 = run_expr_get_value(e);\n          var b = strict_equality_test(v1, vi);\n          if (b) {\n            var%success rv2 = run_block(rev(ts));\n            return (run_stat_switch_end(rv2, scs_2));\n          } else {\n            return (run_stat_switch_with_default_B(vi, rv, ts0, scs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_A = function (found, vi, rv, scs1, ts0, scs2) {\n  switch (scs1) {\n    case []:\n      if (found) {\n        return (run_stat_switch_with_default_default(ts0, scs2));\n      } else {\n        return (run_stat_switch_with_default_B(vi, rv, ts0, scs2));\n      }\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var follow = function () {\n            return (\n              ifx_success_state(rv, run_block(rev(ts)), function (rv0) {\n                  return (\n                    run_stat_switch_with_default_A(true, vi, rv0, scs_2, ts0,\n                      scs2));}));\n          };\n          if (found) {\n            return (follow());\n          } else {\n            var%spec v1 = run_expr_get_value(e);\n            var b = strict_equality_test(v1, vi);\n            if (b) {\n              return (follow());\n            } else {\n              return (\n                run_stat_switch_with_default_A(false, vi, rv, scs_2, ts0,\n                  scs2));\n            }\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch = function (labs, e, sb) {\n  var%spec vi = run_expr_get_value(e);\n  var follow = function (w) {\n    var%success r = var%break r = w;\n      if (res_label_in(r, labs)) {\n        return (r.res_value);\n      } else {\n        return (r);\n      };\n    return (r);\n  };\n  switch (sb) {\n    case Coq_switchbody_nodefault(scs):\n      return (follow(run_stat_switch_no_default(vi, Resvalue_empty, scs)));\n    case Coq_switchbody_withdefault(scs1, ts, scs2):\n      return (\n        follow(\n          run_stat_switch_with_default_A(false, vi, Resvalue_empty, scs1, ts,\n            scs2)));\n  }\n  \n};\n\nvar run_stat_do_while = function (rv, labs, e1, t2) {\n  var%ter r = run_stat(t2);\n  if (resvalue_compare(r.res_value, Resvalue_empty)) {\n    var rv_2 = rv;\n  } else {\n    var rv_2 = r.res_value;\n  }\n  var loop = function (x) {\n    var%spec v1 = run_expr_get_value(e1);\n    var b = to_boolean(v1);\n    if (b) {\n      return (run_stat_do_while(rv_2, labs, e1, t2));\n    } else {\n      return (rv_2);\n    }\n  };\n  if ((restype_compare(r.res_type, Restype_continue)\n      && res_label_in(r, labs))) {\n    return (loop({}));\n  } else {\n    if ((restype_compare(r.res_type, Restype_break) && res_label_in(r, labs))) {\n      return (rv_2);\n    } else {\n      if (!(restype_compare(r.res_type, Restype_normal))) {\n        return (r);\n      } else {\n        return (loop({}));\n      }\n    }\n  }\n};\n\nvar run_stat_try = function (t1, t2o, t3o) {\n  var finallycont = function (r) {\n    switch (t3o) {\n      case Some(t3):\n        var%success rv_2 = run_stat(t3);\n        return (r);\n      case None:\n        return (r);\n    }\n    \n  };\n  return (\n    ifx_any_or_throw(run_stat(t1), finallycont, function (v) {\n        switch (t2o) {\n          case Some(y):\n            var (x, t2) = y;\n            var lex = c.execution_ctx_lexical_env;\n            var p = lexical_env_alloc_decl(lex);\n            var (lex_2, s_2) = p;\n            switch (lex_2) {\n              case []:\n                return (\n                  function (m) {\n                      Debug.impossible_with_heap_because(__LOC__, m);\n                      return (Result_impossible);}(\n                    "Empty lexical environnment in [run_stat_try]."));\n              case (l::oldlex):\n                var%void _ = env_record_create_set_mutable_binding(l, x,\n                               None, v, throw_irrelevant);\n                var c_2 = execution_ctx_with_lex(lex_2);\n                var%ter r = run_stat(t2);\n                return (finallycont(r));\n            }\n            \n          case None:\n            return (finallycont(res_throw(v)));\n        }\n        }));\n};\n\nvar run_stat_throw = function (e) {\n  var%spec v1 = run_expr_get_value(e);\n  return (res_throw(v1));\n};\n\nvar run_stat_return = function (_foo_) {\n  switch (_foo_) {\n    case Some(e):\n      var%spec v1 = run_expr_get_value(e);\n      return (res_return(v1));\n    case None:\n      return (res_return(Value_undef));\n  }\n  \n};\n\nvar run_stat_for_loop = function (labs, rv, eo2, eo3, t) {\n  var follows = function () {\n    var%ter r = run_stat(t);\n    if (!(resvalue_compare(r.res_value, Resvalue_empty))) {\n      var rv_2 = r.res_value;\n    } else {\n      var rv_2 = rv;\n    }\n    var loop = function () {\n      return (run_stat_for_loop(labs, rv_2, eo2, eo3, t));\n    };\n    if ((restype_compare(r.res_type, Restype_break) && res_label_in(r, labs))) {\n      return (rv_2);\n    } else {\n      if ((restype_compare(r.res_type, Restype_normal)\n          || (restype_compare(r.res_type, Restype_continue)\n             && res_label_in(r, labs)))) {\n        switch (eo3) {\n          case Some(e3):\n            var%spec v3 = run_expr_get_value(e3);\n            return (loop());\n          case None:\n            return (loop());\n        }\n        \n      } else {\n        return (r);\n      }\n    }\n  };\n  switch (eo2) {\n    case Some(e2):\n      var%spec v2 = run_expr_get_value(e2);\n      var b = to_boolean(v2);\n      if (b) {\n        return (follows());\n      } else {\n        return (rv);\n      }\n    case None:\n      return (follows());\n  }\n  \n};\n\nvar run_stat_for = function (labs, eo1, eo2, eo3, t) {\n  var follows = function () {\n    return (run_stat_for_loop(labs, Resvalue_empty, eo2, eo3, t));\n  };\n  switch (eo1) {\n    case Some(e1):\n      var%spec v1 = run_expr_get_value(e1);\n      return (follows());\n    case None:\n      return (follows());\n  }\n  \n};\n\nvar run_stat_for_var = function (labs, ds, eo2, eo3, t) {\n  var%ter r = run_stat(Stat_var_decl(ds));\n  return (run_stat_for_loop(labs, Resvalue_empty, eo2, eo3, t));\n};\n\nvar run_expr = function (_term_) {\n  switch (_term_) {\n    case Coq_expr_this:\n      return (c.execution_ctx_this_binding);\n    case Coq_expr_identifier(x):\n      var%spec r = identifier_resolution(x);\n      return (r);\n    case Coq_expr_literal(i):\n      return (convert_literal_to_prim(i));\n    case Coq_expr_object(pds):\n      var%object l = run_construct_prealloc(Prealloc_object, mk_nil);\n      return (init_object(l, pds));\n    case Coq_expr_array(oes):\n      var%object l = run_construct_prealloc(Prealloc_array, mk_nil);\n      return (init_array(l, oes));\n    case Coq_expr_function(fo, args, bd):\n      return (run_expr_function(fo, args, bd));\n    case Coq_expr_access(e1, e2):\n      return (run_expr_access(e1, e2));\n    case Coq_expr_member(e1, f):\n      return (run_expr(Expr_access(e1, Expr_literal(Literal_string(f)))));\n    case Coq_expr_new(e1, e2s):\n      return (run_expr_new(e1, e2s));\n    case Coq_expr_call(e1, e2s):\n      return (run_expr_call(e1, e2s));\n    case Coq_expr_unary_op(op, e0):\n      return (run_unary_op(op, e0));\n    case Coq_expr_binary_op(e1, op, e2):\n      return (run_expr_binary_op(op, e1, e2));\n    case Coq_expr_conditional(e1, e2, e3):\n      return (run_expr_conditionnal(e1, e2, e3));\n    case Coq_expr_assign(e1, opo, e2):\n      return (run_expr_assign(opo, e1, e2));\n  }\n  \n};\n\nvar run_stat = function (_term_) {\n  switch (_term_) {\n    case Coq_stat_expr(e):\n      var%spec r = run_expr_get_value(e);\n      return (r);\n    case Coq_stat_label(lab, t0):\n      return (run_stat_label(Label_string(lab), t0));\n    case Coq_stat_block(ts):\n      return (run_block(rev(ts)));\n    case Coq_stat_var_decl(xeos):\n      return (run_var_decl(xeos));\n    case Coq_stat_if(e1, t2, to0):\n      return (run_stat_if(e1, t2, to0));\n    case Coq_stat_do_while(ls, t1, e2):\n      return (run_stat_do_while(Resvalue_empty, ls, e2, t1));\n    case Coq_stat_while(ls, e1, t2):\n      return (run_stat_while(Resvalue_empty, ls, e1, t2));\n    case Coq_stat_with(e1, t2):\n      return (run_stat_with(e1, t2));\n    case Coq_stat_throw(e):\n      return (run_stat_throw(e));\n    case Coq_stat_return(eo):\n      return (run_stat_return(eo));\n    case Coq_stat_break(so):\n      return (res_break(so));\n    case Coq_stat_continue(so):\n      return (res_continue(so));\n    case Coq_stat_try(t1, t2o, t3o):\n      return (run_stat_try(t1, t2o, t3o));\n    case Coq_stat_for(ls, eo1, eo2, eo3, s0):\n      return (run_stat_for(ls, eo1, eo2, eo3, s0));\n    case Coq_stat_for_var(ls, ds, eo2, eo3, s0):\n      return (run_stat_for_var(ls, ds, eo2, eo3, s0));\n    case Coq_stat_for_in(ls, e1, e2, s0):\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}("stat_for_in"));\n    case Coq_stat_for_in_var(ls, x, e1o, e2, s0):\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}("stat_for_in_var"));\n    case Coq_stat_debugger:\n      return (res_empty);\n    case Coq_stat_switch(labs, e, sb):\n      return (run_stat_switch(labs, e, sb));\n  }\n  \n};\n\nvar run_elements = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (Resvalue_empty);\n    case (el::els_rev_2):\n      var%success rv0 = run_elements(els_rev_2);\n      switch (el) {\n        case Coq_element_stat(t):\n          var%ter r1 = run_stat(t);\n          var r2 = res_overwrite_value_if_empty(rv0, r1);\n          return (r2);\n        case Coq_element_func_decl(name, args, bd):\n          return (rv0);\n      }\n      \n  }\n  \n};\n\nvar run_prog = function (_term_) {\n  switch (_term_) {\n    case Coq_prog_intro(str, els):\n      return (run_elements(rev(els)));\n  }\n  \n};\n\nvar push = function (l, args, ilen) {\n  var vlen = ilen;\n  switch (args) {\n    case []:\n      var%not_throw x = object_put(l, "length", Value_number(vlen),\n                          throw_true);\n      return (Value_number(vlen));\n    case (v::vs):\n      var%string slen = to_string(Value_number(vlen));\n      var%not_throw x = object_put(l, slen, v, throw_true);\n      return (push(l, vs, (ilen + 1.)));\n  }\n  \n};\n\nvar run_object_is_sealed = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some ext = run_object_method(object_extensible_, l);\n      return (Value_bool(!(ext)));\n    case (x::xs_2):\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if (attributes_configurable(a)) {\n            return (Value_bool(false));\n          } else {\n            return (run_object_is_sealed(l, xs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_object_seal = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some _ = run_object_heap_set_extensible(false, l);\n      return (l);\n    case (x::xs_2):\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_seal]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if (attributes_configurable(a)) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: None,\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: Some(false)\n            };\n            var a_2 = attributes_update(a, desc);\n          } else {\n            var a_2 = a;\n          }\n          var%bool x0 = object_define_own_prop(l, x,\n                          descriptor_of_attributes(a_2), true);\n          return (run_object_seal(l, xs_2));\n      }\n      \n  }\n  \n};\n\nvar run_object_freeze = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some _ = run_object_heap_set_extensible(false, l);\n      return (l);\n    case (x::xs_2):\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if ((attributes_is_data_dec(a) && attributes_writable(a))) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: Some(false),\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: None\n            };\n            var a_2 = attributes_update(a, desc);\n          } else {\n            var a_2 = a;\n          }\n          if (attributes_configurable(a_2)) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: None,\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: Some(false)\n            };\n            var a_3 = attributes_update(a_2, desc);\n          } else {\n            var a_3 = a_2;\n          }\n          var%bool x0 = object_define_own_prop(l, x,\n                          descriptor_of_attributes(a_3), true);\n          return (run_object_freeze(l, xs_2));\n      }\n      \n  }\n  \n};\n\nvar run_object_is_frozen = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some ext = run_object_method(object_extensible_, l);\n      return (Value_bool(!(ext)));\n    case (x::xs_2):\n      var%spec d = run_object_get_own_prop(l, x);\n      var check_configurable = function (a) {\n        if (attributes_configurable(a)) {\n          return (Value_bool(false));\n        } else {\n          return (run_object_is_frozen(l, xs_2));\n        }\n      };\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          switch (a) {\n            case Coq_attributes_data_of(ad):\n              if (attributes_writable(ad)) {\n                return (Value_bool(false));\n              } else {\n                return (check_configurable(ad));\n              }\n            case Coq_attributes_accessor_of(aa):\n              return (check_configurable(aa));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar run_get_args_for_apply = function (l, index, n) {\n  if ((index < n)) {\n    var%string sindex = to_string(Value_number(index));\n    var%value v = run_object_get(l, sindex);\n    var tail_args = run_get_args_for_apply(l, (index + 1.), n);\n    var%spec tail = tail_args;\n    return (mk_cons(v, tail));\n  } else {\n    return (mk_nil);\n  }\n};\n\nvar valueToStringForJoin = function (l, k) {\n  var%string prop = to_string(Value_number(k));\n  var%value v = run_object_get(l, prop);\n  switch (v) {\n    case Coq_value_undef:\n      return ("");\n    case Coq_value_null:\n      return ("");\n    case Coq_value_bool(b):\n      var%string s3 = to_string(v);\n      return (s3);\n    case Coq_value_number(n):\n      var%string s3 = to_string(v);\n      return (s3);\n    case Coq_value_string(s2):\n      var%string s4 = to_string(v);\n      return (s4);\n    case Coq_value_object(o):\n      var%string s3 = to_string(v);\n      return (s3);\n  }\n  \n};\n\nvar run_array_join_elements = function (l, k, length0, sep, sR) {\n  if ((k < length0)) {\n    var ss = strappend(sR, sep);\n    var sE = valueToStringForJoin(l, k);\n    var%spec element = sE;\n    var sR0 = strappend(ss, element);\n    return (run_array_join_elements(l, (k + 1.), length0, sep, sR0));\n  } else {\n    return (Value_string(sR));\n  }\n};\n\nvar run_call_prealloc = function (b, vthis, args) {\n  switch (b) {\n    case Coq_prealloc_global_is_finite:\n      var v = get_arg(0, args);\n      var%number n = to_number(v);\n      return (\n        Value_bool(\n          !(\n            (JsNumber.isnan(n)\n            || ((n === JsNumber.infinity) || (n === JsNumber.neg_infinity))))));\n    case Coq_prealloc_global_is_nan:\n      var v = get_arg(0, args);\n      var%number n = to_number(v);\n      return (Value_bool(JsNumber.isnan(n)));\n    case Coq_prealloc_object:\n      var value0 = get_arg(0, args);\n      switch (value0) {\n        case Coq_value_undef:\n          return (run_construct_prealloc(b, args));\n        case Coq_value_null:\n          return (run_construct_prealloc(b, args));\n        case Coq_value_bool(b0):\n          return (to_object(value0));\n        case Coq_value_number(n):\n          return (to_object(value0));\n        case Coq_value_string(s0):\n          return (to_object(value0));\n        case Coq_value_object(o):\n          return (to_object(value0));\n      }\n      \n    case Coq_prealloc_object_get_proto_of:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some proto = run_object_method(object_proto_, l);\n          return (proto);\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_get_own_prop_descriptor:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%string x = to_string(get_arg(1, args));\n          var%spec d = run_object_get_own_prop(l, x);\n          return (from_prop_descriptor(d));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_define_prop:\n      var o = get_arg(0, args);\n      var p = get_arg(1, args);\n      var attr = get_arg(2, args);\n      switch (o) {\n        case Coq_value_object(l):\n          var%string name = to_string(p);\n          var%spec desc = to_property_descriptor(attr);\n          var%bool x = object_define_own_prop(l, name, desc, true);\n          return (l);\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_seal:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_seal(l, _x_));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_freeze:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_freeze(l, _x_));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_prevent_extensions:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some o = object_binds_option(l);\n          var o1 = object_with_extension(o, false);\n          var s_2 = object_write(l, o1);\n          return (l);\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_is_sealed:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_is_sealed(l, _x_));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_is_frozen:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_is_frozen(l, _x_));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_is_extensible:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%some r = run_object_method(object_extensible_, l);\n          return (Value_bool(r));\n        default:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_prealloc_object_proto_to_string:\n      switch (vthis) {\n        case Coq_value_undef:\n          return (Value_string("[object Undefined]"));\n        case Coq_value_null:\n          return (Value_string("[object Null]"));\n        case Coq_value_bool(b0):\n          var%object l = to_object(vthis);\n          var%some s0 = run_object_method(object_class_, l);\n          return (Value_string(strappend("[object ", strappend(s0, "]"))));\n        case Coq_value_number(n):\n          var%object l = to_object(vthis);\n          var%some s0 = run_object_method(object_class_, l);\n          return (Value_string(strappend("[object ", strappend(s0, "]"))));\n        case Coq_value_string(s0):\n          var%object l = to_object(vthis);\n          var%some s2 = run_object_method(object_class_, l);\n          return (Value_string(strappend("[object ", strappend(s2, "]"))));\n        case Coq_value_object(o):\n          var%object l = to_object(vthis);\n          var%some s0 = run_object_method(object_class_, l);\n          return (Value_string(strappend("[object ", strappend(s0, "]"))));\n      }\n      \n    case Coq_prealloc_object_proto_value_of:\n      return (to_object(vthis));\n    case Coq_prealloc_object_proto_has_own_prop:\n      var v = get_arg(0, args);\n      var%string x = to_string(v);\n      var%object l = to_object(vthis);\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (Value_bool(false));\n        case Coq_full_descriptor_some(a):\n          return (Value_bool(true));\n      }\n      \n    case Coq_prealloc_object_proto_is_prototype_of:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_object(l):\n          var%object lo = to_object(vthis);\n          return (object_proto_is_prototype_of(lo, l));\n        default:\n          return (Value_bool(false));\n      }\n      \n    case Coq_prealloc_object_proto_prop_is_enumerable:\n      var v = get_arg(0, args);\n      var%string x = to_string(v);\n      var%object l = to_object(vthis);\n      var%spec d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (Value_bool(false));\n        case Coq_full_descriptor_some(a):\n          return (Value_bool(attributes_enumerable(a)));\n      }\n      \n    case Coq_prealloc_function_proto:\n      return (Value_undef);\n    case Coq_prealloc_function_proto_to_string:\n      if (is_callable_dec(vthis)) {\n        return (\n          function (s) {\n              Debug.not_yet_implemented_because(__LOC__, s);\n              return (Result_not_yet_implemented);}(\n            "Function.prototype.toString() is implementation dependent."));\n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_apply:\n      var thisArg = get_arg(0, args);\n      var argArray = get_arg(1, args);\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_object(thisobj):\n            switch (argArray) {\n              case Coq_value_undef:\n                return (run_call(thisobj, thisArg, mk_nil));\n              case Coq_value_null:\n                return (run_call(thisobj, thisArg, mk_nil));\n              case Coq_value_bool(b0):\n                return (run_error(Native_error_type));\n              case Coq_value_number(n):\n                return (run_error(Native_error_type));\n              case Coq_value_string(s0):\n                return (run_error(Native_error_type));\n              case Coq_value_object(array):\n                var%value v = run_object_get(array, "length");\n                var%spec ilen = to_uint32(v);\n                var%spec arguments_ = run_get_args_for_apply(array, 0., ilen);\n                return (run_call(thisobj, thisArg, arguments_));\n            }\n            \n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_call:\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_object(thisobj):\n            var (thisArg, a) = get_arg_first_and_rest(args);\n            return (run_call(thisobj, thisArg, a));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_bind:\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_object(thisobj):\n            var (vthisArg, a) = get_arg_first_and_rest(args);\n            var o1 = object_new(Prealloc_object_proto, "Object");\n            var o2 = object_with_get(o1, Builtin_get_function);\n            var o3 = object_with_details(o2, None, None, None, Some(thisobj),\n                       Some(vthisArg), Some(a), None);\n            var o4 = object_set_class(o3, "Function");\n            var o5 = object_set_proto(o4, Prealloc_function_proto);\n            var o6 = object_with_invokation(o5, Some(Construct_after_bind),\n                       Some(Call_after_bind),\n                       Some(Builtin_has_instance_after_bind));\n            var o7 = object_set_extensible(o6, true);\n            var (l, s_2) = object_alloc(o7);\n            var vlength = (function () {\n              var%some class0 = run_object_method(object_class_, thisobj);\n              if (string_eq(class0, "Function")) {\n                var%number n = run_object_get(thisobj, "length");\n                var%spec ilen = to_int32(Value_number(n));\n                if ((ilen < LibList.length(a))) {\n                  return (0.);\n                } else {\n                  return ((ilen - LibList.length(a)));\n                }\n              } else {\n                return (0.);\n              }\n            }())\n            ;\n            var%spec length0 = vlength;\n            var a0 = {\n              attributes_data_value: Value_number(length0),\n              attributes_data_writable: false,\n              attributes_data_enumerable: false,\n              attributes_data_configurable: false\n            };\n            var%some _ = run_object_heap_map_properties(l, function (p) {\n                             return (HeapStr.write(p, "length", a0));});\n            var vthrower = Prealloc_throw_type_error;\n            var a1 = {\n              attributes_accessor_get: vthrower,\n              attributes_accessor_set: vthrower,\n              attributes_accessor_enumerable: false,\n              attributes_accessor_configurable: false\n            };\n            var%bool x = object_define_own_prop(l, "caller",\n                           descriptor_of_attributes(a1), false);\n            var%bool x0 = object_define_own_prop(l, "arguments",\n                            descriptor_of_attributes(a1), false);\n            return (l);\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_bool:\n      var v = get_arg(0, args);\n      return (Value_bool(to_boolean(v)));\n    case Coq_prealloc_bool_proto_to_string:\n      switch (vthis) {\n        case Coq_value_undef:\n          return (run_error(Native_error_type));\n        case Coq_value_null:\n          return (run_error(Native_error_type));\n        case Coq_value_bool(b0):\n          return (Value_string(convert_bool_to_string(b0)));\n        case Coq_value_number(n):\n          return (run_error(Native_error_type));\n        case Coq_value_string(s0):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_undef:\n                                return (run_error(Native_error_type));\n                              case Coq_value_null:\n                                return (run_error(Native_error_type));\n                              case Coq_value_bool(b0):\n                                return (\n                                  Value_string(convert_bool_to_string(b0)));\n                              case Coq_value_number(n):\n                                return (run_error(Native_error_type));\n                              case Coq_value_string(s1):\n                                return (run_error(Native_error_type));\n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_bool_proto_value_of:\n      switch (vthis) {\n        case Coq_value_undef:\n          return (run_error(Native_error_type));\n        case Coq_value_null:\n          return (run_error(Native_error_type));\n        case Coq_value_bool(b0):\n          return (Value_bool(b0));\n        case Coq_value_number(n):\n          return (run_error(Native_error_type));\n        case Coq_value_string(s0):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_undef:\n                                return (run_error(Native_error_type));\n                              case Coq_value_null:\n                                return (run_error(Native_error_type));\n                              case Coq_value_bool(b0):\n                                return (Value_bool(b0));\n                              case Coq_value_number(n):\n                                return (run_error(Native_error_type));\n                              case Coq_value_string(s1):\n                                return (run_error(Native_error_type));\n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_number:\n      if (list_eq_nil_decidable(args)) {\n        return (Value_number(JsNumber.zero));\n      } else {\n        var v = get_arg(0, args);return (to_number(v));\n      }\n    case Coq_prealloc_number_proto_value_of:\n      switch (vthis) {\n        case Coq_value_undef:\n          return (run_error(Native_error_type));\n        case Coq_value_null:\n          return (run_error(Native_error_type));\n        case Coq_value_bool(b0):\n          return (run_error(Native_error_type));\n        case Coq_value_number(n):\n          return (Value_number(n));\n        case Coq_value_string(s0):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Number")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_undef:\n                                return (run_error(Native_error_type));\n                              case Coq_value_null:\n                                return (run_error(Native_error_type));\n                              case Coq_value_bool(b0):\n                                return (run_error(Native_error_type));\n                              case Coq_value_number(n):\n                                return (Value_number(n));\n                              case Coq_value_string(s1):\n                                return (run_error(Native_error_type));\n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_array:\n      return (run_construct_prealloc(Prealloc_array, args));\n    case Coq_prealloc_array_is_array:\n      var arg = get_arg(0, args);\n      switch (arg) {\n        case Coq_value_object(arg0):\n          var%some class0 = run_object_method(object_class_, arg0);\n          if (string_eq(class0, "Array")) {\n            return (Value_bool(true));\n          } else {\n            return (Value_bool(false));\n          }\n        default:\n          return (Value_bool(false));\n      }\n      \n    case Coq_prealloc_array_proto_to_string:\n      var%object array = to_object(vthis);\n      var%value vfunc = run_object_get(array, "join");\n      if (is_callable_dec(vfunc)) {\n        switch (vfunc) {\n          case Coq_value_object(func):\n            return (run_call(func, array, mk_nil));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n        }\n        \n      } else {\n        return (\n          run_call_prealloc(Prealloc_object_proto_to_string, array, mk_nil));\n      }\n    case Coq_prealloc_array_proto_join:\n      var vsep = get_arg(0, args);\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%spec ilen = to_uint32(vlen);\n      if (!(value_compare(vsep, Value_undef))) {\n        var rsep = vsep;\n      } else {\n        var rsep = Value_string(",");\n      }\n      var%string sep = to_string(rsep);\n      if ((ilen == 0.0)) {\n        return (Value_string(""));\n      } else {\n        var sR = valueToStringForJoin(l, 0.);\n        var%spec sR0 = sR;\n        return (run_array_join_elements(l, 1., ilen, sep, sR0));\n      }\n    case Coq_prealloc_array_proto_pop:\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%spec ilen = to_uint32(vlen);\n      if ((ilen == 0.0)) {\n        var%not_throw x = object_put(l, "length",\n                            Value_number(JsNumber.zero), throw_true);\n        return (Value_undef);\n      } else {\n        var%string sindx = to_string(Value_number((ilen - 1.)));\n        var%value velem = run_object_get(l, sindx);\n        var%not_throw x = object_delete_default(l, sindx, throw_true);\n        var%not_throw x0 = object_put(l, "length", Value_string(sindx),\n                             throw_true);\n        return (velem);\n      }\n    case Coq_prealloc_array_proto_push:\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%spec ilen = to_uint32(vlen);\n      return (push(l, args, ilen));\n    case Coq_prealloc_string:\n      if (list_eq_nil_decidable(args)) {\n        return (Value_string(""));\n      } else {\n        var value0 = get_arg(0, args);\n        var%string s1 = to_string(value0);\n        return (Value_string(s1));\n      }\n    case Coq_prealloc_string_proto_to_string:\n      switch (vthis) {\n        case Coq_value_object(l):\n          var%some s0 = run_object_method(object_class_, l);\n          if (string_eq(s0, "String")) {\n            return (run_object_prim_value(l));\n          } else {\n            return (run_error(Native_error_type));\n          }\n        default:\n          if (type_compare(type_of(vthis), Type_string)) {\n            return (vthis);\n          } else {\n            return (run_error(Native_error_type));\n          }\n      }\n      \n    case Coq_prealloc_string_proto_value_of:\n      switch (vthis) {\n        case Coq_value_object(l):\n          var%some s0 = run_object_method(object_class_, l);\n          if (string_eq(s0, "String")) {\n            return (run_object_prim_value(l));\n          } else {\n            return (run_error(Native_error_type));\n          }\n        default:\n          if (type_compare(type_of(vthis), Type_string)) {\n            return (vthis);\n          } else {\n            return (run_error(Native_error_type));\n          }\n      }\n      \n    case Coq_prealloc_error:\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_error_proto, v));\n    case Coq_prealloc_native_error(ne):\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_native_error_proto(ne), v));\n    case Coq_prealloc_throw_type_error:\n      return (run_error(Native_error_type));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}(\n          strappend("Call prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented"))));\n  }\n  \n};\n\nvar run_call = function (l, vthis, args) {\n  var%some co = run_object_method(object_call_, l);\n  var%some c0 = co;\n  switch (c0) {\n    case Coq_call_default:\n      return (entering_func_code(l, vthis, args));\n    case Coq_call_after_bind:\n      var%some oarg = run_object_method(object_bound_args_, l);\n      var%some boundArgs = oarg;\n      var%some obnd = run_object_method(object_bound_this_, l);\n      var%some boundThis = obnd;\n      var%some otrg = run_object_method(object_target_function_, l);\n      var%some target = otrg;\n      var arguments_ = LibList.append(boundArgs, args);\n      return (run_call(target, boundThis, arguments_));\n    case Coq_call_prealloc(b):\n      return (run_call_prealloc(b, vthis, args));\n    case Coq_call_proxy:\n      return (Result_not_yet_implemented);\n  }\n  \n};\n\nvar run_javascript_from_state = function (p) {\n  var c = execution_ctx_initial(prog_intro_strictness(p));\n  var%void _ = execution_ctx_binding_inst(Codetype_global, None, p, mk_nil);\n  return (run_prog(p));\n};\n\nvar run_javascript_from_result = function (w, p) {\n  var%success _pat_any_36 = w;\n  return (run_javascript_from_state(p));\n};\n\nvar run_javascript = function (p) {\n  return (run_javascript_from_state(p));\n};\n}// end of with Datatypes\n}// end of with JsCommon\n}// end of with JsCommonAux\n}// end of with JsInit\n}// end of with JsInterpreterMonads\n}// end of with JsSyntax\n}// end of with JsSyntaxAux\n}// end of with LibList\n}// end of with LibOption\n}// end of with LibProd\n}// end of with Shared\n\nreturn {\n  convert_prim_to_number: convert_prim_to_number, \n  convert_number_to_integer: convert_number_to_integer, \n  convert_bool_to_string: convert_bool_to_string, \n  convert_prim_to_string: convert_prim_to_string, \n  equality_test_for_same_type: equality_test_for_same_type, \n  strict_equality_test: strict_equality_test, \n  inequality_test_number: inequality_test_number, \n  inequality_test_string: inequality_test_string, \n  inequality_test_primitive: inequality_test_primitive, \n  typeof_prim: typeof_prim, \n  string_of_propname: string_of_propname, \n  run_object_method: run_object_method, \n  run_object_set_internal: run_object_set_internal, \n  run_object_heap_set_extensible: run_object_heap_set_extensible, \n  build_error: build_error, \n  run_error: run_error, \n  run_error_no_c: run_error_no_c, \n  object_has_internal_slot: object_has_internal_slot, \n  object_has_internal_method: object_has_internal_method, \n  object_internal_get_prototype_of: object_internal_get_prototype_of, \n  object_internal_set_prototype_of: object_internal_set_prototype_of, \n  object_internal_is_extensible: object_internal_is_extensible, \n  object_internal_prevent_extensions: object_internal_prevent_extensions, \n  object_internal_get_own_property: object_internal_get_own_property, \n  object_internal_define_own_property: object_internal_define_own_property, \n  object_internal_has_property: object_internal_has_property, \n  object_internal_get: object_internal_get, \n  object_internal_set: object_internal_set, \n  object_put: object_put, \n  object_internal_call: object_internal_call, \n  get_base: get_base, \n  get_referenced_name: get_referenced_name, \n  is_strict_reference: is_strict_reference, \n  has_primitive_base: has_primitive_base, \n  is_property_reference: is_property_reference, \n  is_unresolvable_reference: is_unresolvable_reference, \n  is_super_reference: is_super_reference, \n  get_value: get_value, \n  put_value: put_value, \n  get_this_value: get_this_value, \n  is_accessor_descriptor: is_accessor_descriptor, \n  is_data_descriptor: is_data_descriptor, \n  is_generic_descriptor: is_generic_descriptor, \n  to_property_descriptor: to_property_descriptor, \n  complete_property_descriptor: complete_property_descriptor, \n  to_boolean: to_boolean, \n  is_callable: is_callable, \n  is_extensible: is_extensible, \n  is_property_key: is_property_key, \n  same_value: same_value, \n  same_value_non_number: same_value_non_number, \n  get: get, \n  get_v: get_v, \n  set: set, \n  create_data_property: create_data_property, \n  get_method: get_method, \n  has_property: has_property, \n  call: call, \n  set_mutable_binding: set_mutable_binding, \n  get_binding_value: get_binding_value, \n  binding_is_uninitialized: binding_is_uninitialized, \n  binding_is_mutable: binding_is_mutable, \n  decl_env_record_create_mutable_binding: decl_env_record_create_mutable_binding, \n  decl_env_record_initialize_binding: decl_env_record_initialize_binding, \n  decl_env_record_set_mutable_binding: decl_env_record_set_mutable_binding, \n  decl_env_record_get_binding_value: decl_env_record_get_binding_value, \n  object_env_record_set_mutable_binding: object_env_record_set_mutable_binding, \n  object_env_record_get_binding_value: object_env_record_get_binding_value, \n  get_global_object: get_global_object, \n  ordinary_object_internal_get_prototype_of: ordinary_object_internal_get_prototype_of, \n  ordinary_get_prototype_of: ordinary_get_prototype_of, \n  ordinary_object_internal_set_prototype_of: ordinary_object_internal_set_prototype_of, \n  ordinary_set_prototype_of: ordinary_set_prototype_of, \n  ordinary_object_internal_is_extensible: ordinary_object_internal_is_extensible, \n  ordinary_is_extensible: ordinary_is_extensible, \n  ordinary_object_internal_prevent_extensions: ordinary_object_internal_prevent_extensions, \n  ordinary_prevent_extensions: ordinary_prevent_extensions, \n  ordinary_object_internal_get_own_property: ordinary_object_internal_get_own_property, \n  ordinary_get_own_property: ordinary_get_own_property, \n  ordinary_object_internal_define_own_property: ordinary_object_internal_define_own_property, \n  ordinary_define_own_property: ordinary_define_own_property, \n  is_compatible_property_descriptor: is_compatible_property_descriptor, \n  validate_and_apply_property_descriptor: validate_and_apply_property_descriptor, \n  ordinary_object_internal_has_property: ordinary_object_internal_has_property, \n  ordinary_has_property: ordinary_has_property, \n  ordinary_object_internal_set: ordinary_object_internal_set, \n  ordinary_set: ordinary_set, \n  ordinary_own_property_keys: ordinary_own_property_keys, \n  object_has_prop: object_has_prop, \n  out_error_or_void: out_error_or_void, \n  out_error_or_cst: out_error_or_cst, \n  object_get_builtin: object_get_builtin, \n  run_object_get: run_object_get, \n  run_object_get_prop: run_object_get_prop, \n  object_proto_is_prototype_of: object_proto_is_prototype_of, \n  object_default_value: object_default_value, \n  to_primitive: to_primitive, \n  to_number: to_number, \n  to_integer: to_integer, \n  to_int32: to_int32, \n  to_uint32: to_uint32, \n  to_string: to_string, \n  run_object_define_own_prop_array_loop: run_object_define_own_prop_array_loop, \n  object_define_own_prop: object_define_own_prop, \n  prim_new_object: prim_new_object, \n  to_object: to_object, \n  run_object_prim_value: run_object_prim_value, \n  prim_value_get: prim_value_get, \n  env_record_has_binding: env_record_has_binding, \n  lexical_env_get_identifier_ref: lexical_env_get_identifier_ref, \n  object_delete_default: object_delete_default, \n  object_delete: object_delete, \n  env_record_delete_binding: env_record_delete_binding, \n  env_record_implicit_this_value: env_record_implicit_this_value, \n  identifier_resolution: identifier_resolution, \n  env_record_get_binding_value: env_record_get_binding_value, \n  ref_get_value: ref_get_value, \n  run_expr_get_value: run_expr_get_value, \n  env_record_set_mutable_binding: env_record_set_mutable_binding, \n  prim_value_put: prim_value_put, \n  ref_put_value: ref_put_value, \n  env_record_create_mutable_binding: env_record_create_mutable_binding, \n  env_record_create_set_mutable_binding: env_record_create_set_mutable_binding, \n  env_record_create_immutable_binding: env_record_create_immutable_binding, \n  env_record_initialize_immutable_binding: env_record_initialize_immutable_binding, \n  call_object_new: call_object_new, \n  array_args_map_loop: array_args_map_loop, \n  run_construct_prealloc: run_construct_prealloc, \n  run_construct_default: run_construct_default, \n  run_construct: run_construct, \n  run_call_default: run_call_default, \n  creating_function_object_proto: creating_function_object_proto, \n  creating_function_object: creating_function_object, \n  binding_inst_formal_params: binding_inst_formal_params, \n  binding_inst_function_decls: binding_inst_function_decls, \n  make_arg_getter: make_arg_getter, \n  make_arg_setter: make_arg_setter, \n  arguments_object_map_loop: arguments_object_map_loop, \n  arguments_object_map: arguments_object_map, \n  create_arguments_object: create_arguments_object, \n  binding_inst_arg_obj: binding_inst_arg_obj, \n  binding_inst_var_decls: binding_inst_var_decls, \n  execution_ctx_binding_inst: execution_ctx_binding_inst, \n  entering_func_code: entering_func_code, \n  run_object_get_own_prop: run_object_get_own_prop, \n  run_function_has_instance: run_function_has_instance, \n  run_object_has_instance: run_object_has_instance, \n  from_prop_descriptor: from_prop_descriptor, \n  run_equal: run_equal, \n  convert_twice: convert_twice, \n  convert_twice_primitive: convert_twice_primitive, \n  convert_twice_number: convert_twice_number, \n  convert_twice_string: convert_twice_string, \n  issome: issome, \n  run_binary_op_add: run_binary_op_add, \n  run_binary_op_arith: run_binary_op_arith, \n  run_binary_op_shift: run_binary_op_shift, \n  run_binary_op_bitwise: run_binary_op_bitwise, \n  run_binary_op_compare: run_binary_op_compare, \n  run_binary_op_instanceof: run_binary_op_instanceof, \n  run_binary_op_in: run_binary_op_in, \n  run_binary_op: run_binary_op, \n  run_prepost_op: run_prepost_op, \n  run_typeof_value: run_typeof_value, \n  run_unary_op: run_unary_op, \n  create_new_function_in: create_new_function_in, \n  init_object: init_object, \n  run_array_element_list: run_array_element_list, \n  init_array: init_array, \n  run_var_decl_item: run_var_decl_item, \n  run_var_decl: run_var_decl, \n  run_list_expr: run_list_expr, \n  run_block: run_block, \n  run_binary_op_and: run_binary_op_and, \n  run_binary_op_or: run_binary_op_or, \n  run_expr_binary_op: run_expr_binary_op, \n  run_expr_access: run_expr_access, \n  run_expr_assign: run_expr_assign, \n  run_expr_function: run_expr_function, \n  entering_eval_code: entering_eval_code, \n  run_eval: run_eval, \n  run_expr_call: run_expr_call, \n  run_expr_conditionnal: run_expr_conditionnal, \n  run_expr_new: run_expr_new, \n  run_stat_label: run_stat_label, \n  run_stat_with: run_stat_with, \n  run_stat_if: run_stat_if, \n  run_stat_while: run_stat_while, \n  run_stat_switch_end: run_stat_switch_end, \n  run_stat_switch_no_default: run_stat_switch_no_default, \n  run_stat_switch_with_default_default: run_stat_switch_with_default_default, \n  run_stat_switch_with_default_B: run_stat_switch_with_default_B, \n  run_stat_switch_with_default_A: run_stat_switch_with_default_A, \n  run_stat_switch: run_stat_switch, \n  run_stat_do_while: run_stat_do_while, \n  run_stat_try: run_stat_try, \n  run_stat_throw: run_stat_throw, \n  run_stat_return: run_stat_return, \n  run_stat_for_loop: run_stat_for_loop, \n  run_stat_for: run_stat_for, \n  run_stat_for_var: run_stat_for_var, \n  run_expr: run_expr, \n  run_stat: run_stat, \n  run_elements: run_elements, \n  run_prog: run_prog, \n  push: push, \n  run_object_is_sealed: run_object_is_sealed, \n  run_object_seal: run_object_seal, \n  run_object_freeze: run_object_freeze, \n  run_object_is_frozen: run_object_is_frozen, \n  run_get_args_for_apply: run_get_args_for_apply, \n  valueToStringForJoin: valueToStringForJoin, \n  run_array_join_elements: run_array_join_elements, \n  run_call_prealloc: run_call_prealloc, \n  run_call: run_call, \n  run_javascript_from_state: run_javascript_from_state, \n  run_javascript_from_result: run_javascript_from_result, \n  run_javascript: run_javascript};\n})();\n'},

/* --------------------- JsInterpreter.ml --------------------- */
  { file: 'JsInterpreter.ml', contents: 'open Datatypes\nopen JsCommon\nopen JsCommonAux\nopen JsInit\nopen JsInterpreterMonads\nopen JsSyntax\nopen JsSyntaxAux\nopen LibList\nopen LibOption\nopen LibProd\nopen Shared\n\n(** ECMAScript Reference Interpreter Implementation\n\n    @esurl     https://tc39.github.io/ecma262/\n    @esversion 2017\n*)\n\n(* Basically, the ordering of the functions in this file are random. They need to be sorted. *)\n\n(*------------JS preliminary -----------*)\n\n(** val convert_prim_to_number : prim -> number **)\n\nlet convert_prim_to_number _foo_ = match _foo_ with\n| Coq_value_undef -> JsNumber.nan\n| Coq_value_null -> JsNumber.zero\n| Coq_value_bool b -> if b then JsNumber.one else JsNumber.zero\n| Coq_value_number n -> n\n| Coq_value_string s -> JsNumber.from_string s\n| _ -> assert false\n\n(** val convert_number_to_integer : number -> number **)\n\nlet convert_number_to_integer n =\n  if JsNumber.isnan n\n  then JsNumber.zero\n  else if   (JsNumber.isposzero n)\n         || (JsNumber.isnegzero n)\n         || (n === JsNumber.infinity)\n         || (n === JsNumber.neg_infinity)\n       then n\n       else  (JsNumber.sign n) *. (JsNumber.floor (JsNumber.absolute n))\n\n(** val convert_bool_to_string : bool -> string **)\n\nlet convert_bool_to_string _foo_ = match _foo_ with\n| true -> "true"\n| false -> "false"\n\n(** val convert_prim_to_string : prim -> string **)\n\nlet convert_prim_to_string _foo_ = match _foo_ with\n| Coq_value_undef -> "undefined"\n| Coq_value_null -> "null"\n| Coq_value_bool b -> convert_bool_to_string b\n| Coq_value_number n -> JsNumber.to_string n\n| Coq_value_string s -> s\n| _ -> assert false\n\n(** val equality_test_for_same_type : coq_type -> value -> value -> bool **)\n\nlet equality_test_for_same_type ty v1 v2 =\n  match ty with\n  | Coq_type_undef -> true\n  | Coq_type_null -> true\n  | Coq_type_bool -> value_compare v1 v2\n  | Coq_type_number ->\n    (match v1 with\n     | Coq_value_undef -> false\n     | Coq_value_null -> false\n     | Coq_value_bool b -> false\n     | Coq_value_string s -> false\n     | Coq_value_number n1 ->\n       (match v2 with\n        | Coq_value_undef -> false\n        | Coq_value_null -> false\n        | Coq_value_bool b -> false\n        | Coq_value_string s -> false\n        | Coq_value_number n2 ->\n          if JsNumber.isnan n1\n          then false\n          else if JsNumber.isnan n2\n               then false\n               else if   (JsNumber.isposzero n1)\n                      && (JsNumber.isnegzero n2)\n                    then true\n                    else if   (JsNumber.isnegzero n1)\n                          &&  (JsNumber.isposzero n2)\n                         then true\n                         else n1 === n2\n        | Coq_value_object o -> false)\n     | Coq_value_object o -> false)\n  | Coq_type_string -> value_compare v1 v2\n  | Coq_type_object -> value_compare v1 v2\n\n(** val strict_equality_test : value -> value -> bool **)\n\nlet strict_equality_test v1 v2 =\n  let ty1 = type_of v1 in\n  let ty2 = type_of v2 in\n  if type_compare ty1 ty2\n  then equality_test_for_same_type ty1 v1 v2\n  else false\n\n(** val inequality_test_number : number -> number -> prim **)\n\nlet inequality_test_number n1 n2 =\n  if (JsNumber.isnan n1) || (JsNumber.isnan n2)\n  then Coq_value_undef else if n1 === n2\n       then Coq_value_bool false\n       else if   (JsNumber.isposzero n1)\n              && (JsNumber.isnegzero n2)\n            then Coq_value_bool false\n            else if (JsNumber.isnegzero n1)\n                 && (JsNumber.isposzero n2)\n                 then Coq_value_bool false\n                 else if n1 === JsNumber.infinity\n                      then Coq_value_bool false\n                      else if n2 === JsNumber.infinity\n                           then Coq_value_bool true\n                           else if n2 === JsNumber.neg_infinity\n                                then Coq_value_bool false\n                                else if n1 === JsNumber.neg_infinity\n                                     then Coq_value_bool true\n                                     else Coq_value_bool (n1 < n2)\n\n(** val inequality_test_string : string -> string -> bool **)\n\n(* ARTHUR hack \nlet rec inequality_test_string s1 s2 =\n  match s1 with\n  | [] ->\n    (match s2 with\n     | [] -> false\n     | a::s -> true)\n  | c1::s1_2 ->\n    (match s2 with\n     | [] -> false\n     | c2::s2_2 ->\n       if ascii_comparable c1 c2\n       then inequality_test_string s1_2 s2_2\n       else lt_int_decidable (int_of_char c1) (int_of_char c2))\n*)\nlet inequality_test_string s1 s2 = string_lt s1 s2\n\n\n(** val inequality_test_primitive : prim -> prim -> prim **)\n\nlet inequality_test_primitive w1 w2 =\n  match w1 with\n  | Coq_value_undef ->\n    inequality_test_number (convert_prim_to_number w1)\n      (convert_prim_to_number w2)\n  | Coq_value_null ->\n    inequality_test_number (convert_prim_to_number w1)\n      (convert_prim_to_number w2)\n  | Coq_value_bool b ->\n    inequality_test_number (convert_prim_to_number w1)\n      (convert_prim_to_number w2)\n  | Coq_value_number n ->\n    inequality_test_number (convert_prim_to_number w1)\n      (convert_prim_to_number w2)\n  | Coq_value_string s1 ->\n    (match w2 with\n     | Coq_value_undef ->\n       inequality_test_number (convert_prim_to_number w1)\n         (convert_prim_to_number w2)\n     | Coq_value_null ->\n       inequality_test_number (convert_prim_to_number w1)\n         (convert_prim_to_number w2)\n     | Coq_value_bool b ->\n       inequality_test_number (convert_prim_to_number w1)\n         (convert_prim_to_number w2)\n     | Coq_value_number n ->\n       inequality_test_number (convert_prim_to_number w1)\n         (convert_prim_to_number w2)\n     | Coq_value_string s2 -> Coq_value_bool (inequality_test_string s1 s2)\n     | _ -> assert false)\n  | _ -> assert false\n\n(** val typeof_prim : prim -> string **)\n\nlet typeof_prim _foo_ = match _foo_ with\n| Coq_value_undef -> "undefined"\n| Coq_value_null -> "object"\n| Coq_value_bool b -> "boolean"\n| Coq_value_number n -> "number"\n| Coq_value_string s -> "string"\n| _ -> assert false\n\n(** val string_of_propname : propname -> prop_name **)\n\nlet string_of_propname _foo_ = match _foo_ with\n| Coq_propname_identifier s -> s\n| Coq_propname_string s -> s\n| Coq_propname_number n -> JsNumber.to_string n\n\n(*---------------------------------*)\n\n\n(** Fetches a given object slot value (using proj) from the object l in state s\n    FIXME: The name is very confusing. *)\nlet run_object_method proj s l =\n  LibOption.map proj (object_binds_option s l)\n\n(*---DEBUG\n  let run_object_method proj s l =\n   let opt = object_binds_option s l in\n     begin match opt with\n       | None -> Debug.run_object_method l\n       | _ -> ()\n     end;\n     LibOption.map proj opt\n*)\n\n(** val run_object_heap_set :\n    (coq_object -> a\' -> coq_object) -> state -> object_loc -> a\' -> state option **)\n(** Updates an object\'s internal field with the given update function [prj].\n    (Update functions are defined in JsSyntaxAux) *)\n\nlet run_object_set_internal prj s l v =\n  LibOption.map (fun o -> object_write s l (prj o v)) (object_binds_option s l)\n\n(** val run_object_heap_set_extensible :\n    bool -> state -> object_loc -> state option **)\n\nlet run_object_heap_set_extensible b s l =\n  run_object_set_internal object_set_extensible s l b\n\n(* DEBUG\n   let run_object_heap_set_extensible b s l =\n   let opt = object_binds_option s l in\n     begin match opt with\n       | None -> Debug.run_object_heap_set_extensible l\n       | _ -> ()\n     end;\n     LibOption.map (fun o -> object_write s l (object_set_extensible o b)) opt\n*)\n\nlet rec build_error s c vproto vmsg : \'a specret resultof =\n  let o = object_new vproto ("Error") in\n  let (l, s_2) = object_alloc s o in\n  if value_compare vmsg Coq_value_undef\n  then res_out s_2 (res_val (Coq_value_object l))\n  else (\n    let%value (s_3, vstr) = to_string s_2 c vmsg in\n    let a = { attributes_data_value = vstr; attributes_data_writable = true;\n      attributes_data_enumerable = false; attributes_data_configurable = true } in\n    let%success (s_4, rv) = object_define_own_prop s_3 c l "message" (descriptor_of_attributes (Coq_attributes_data_of a)) throw_true in\n    res_out s_4 (res_val (Coq_value_object l))\n  )\n\nand run_error s c ne : \'a specret resultof =\n  let%object (s_2, l) = (build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                                            (Coq_prealloc_native_error_proto ne))) Coq_value_undef) in\n  res_out s_2 (res_throw (Coq_resvalue_value (Coq_value_object l)))\n\nand run_error_no_c s ne =\n  (* FIXME: Try and run c *)\n  run_error s (execution_ctx_initial true) ne\n\n(*****************************************************************************)\n(*****************************************************************************)\n(************* START OF THE BIG RECURSIVE INTERPRETER FUNCTION ***************)\n(*****************************************************************************)\n(*****************************************************************************)\n\n(** New ES6 Spec functions here, writting in the specification in CamelCase()\n    will all be prefixed with spec_ *)\n\n(** {4 Object Internal Methods and Internal Slots }\n    @esid sec-object-internal-methods-and-internal-slots\n    @essec 6.1.7.2 *)\n(** Function to implement the specification text "O has a [[X]] internal slot"\n    @param l    The location of O\n    @param prj  The object projection function corresponding to [[X]] *)\nand object_has_internal_slot s l prj =\n  let slot_value = run_object_method prj s l in\n  match slot_value with\n  | None -> assert false\n  | Some v -> match v with\n    | Some _ -> true\n    | None -> false\n\n(** Function to implement the specification text of "O has a [[X]] internal method" *)\nand object_has_internal_method s l prj =\n  object_has_internal_slot s l prj\n\n(** {5 Object Internal Method Dispatch Functions }\n    Functions in this section are used to dispatch Internal Methods to the\n    correct implementation based upon the value of the internal slot\n\n    All these functions accept a parameter o, which is the {i location} of the object.\n *)\n\n(** Function to dispatch calls to O.[[GetPrototypeOf]]() *)\nand object_internal_get_prototype_of s o =\n  let%some internal_method = (run_object_method object_get_prototype_of_ s o) in\n  match internal_method with\n  | Coq_builtin_get_prototype_of_default -> ordinary_object_internal_get_prototype_of s o\n  | Coq_builtin_get_prototype_of_proxy   -> Coq_result_not_yet_implemented (* TODO *)\n\n(** Function to dispatch calls to O.[[GetPrototypeOf]](V) *)\nand object_internal_set_prototype_of s o v =\n  let%some internal_method = (run_object_method object_set_prototype_of_ s o) in\n  match internal_method with\n  | Coq_builtin_set_prototype_of_default -> ordinary_object_internal_set_prototype_of s o v\n  | Coq_builtin_set_prototype_of_proxy   -> Coq_result_not_yet_implemented (* TODO *)\n\n(** Function to dispatch calls to O.[[IsExtensible]]() *)\nand object_internal_is_extensible s o =\n  let%some internal_method = run_object_method object_is_extensible_ s o in\n  match internal_method with\n  | Coq_builtin_is_extensible_default -> ordinary_object_internal_is_extensible s o\n  | Coq_builtin_is_extensible_proxy   -> Coq_result_not_yet_implemented (* TODO *)\n\n(** Function to dispatch calls to O.[[PreventExtensions]]() *)\nand object_internal_prevent_extensions s o =\n  let%some internal_method = run_object_method object_prevent_extensions_ s o in\n  match internal_method with\n  | Coq_builtin_prevent_extensions_default -> ordinary_object_internal_prevent_extensions s o\n  | Coq_builtin_prevent_extensions_proxy   -> Coq_result_not_yet_implemented (* TODO *)\n\n(** Function to dispatch calls to O.[[GetOwnProperty]](P) *)\nand object_internal_get_own_property s o p =\n  let%some internal_method = (run_object_method object_get_own_prop_ s o) in\n  match internal_method with\n  | Coq_builtin_get_own_prop_default  -> ordinary_object_internal_get_own_property s o p\n  | Coq_builtin_get_own_prop_args_obj -> Coq_result_not_yet_implemented (* TODO *)\n  | Coq_builtin_get_own_prop_string   -> Coq_result_not_yet_implemented (* TODO *)\n  | Coq_builtin_get_own_prop_proxy    -> Coq_result_not_yet_implemented (* TODO *)\n\n(** Function to dispatch calls to O.[[DefineOwnProperty]](P, desc) *)\nand object_internal_define_own_property s o p desc =\n  let%some internal_method = (run_object_method object_define_own_prop_ s o) in\n  match internal_method with\n  | Coq_builtin_define_own_prop_default  -> ordinary_object_internal_define_own_property s o p desc\n  | Coq_builtin_define_own_prop_array    -> Coq_result_not_yet_implemented (* TODO *)\n  | Coq_builtin_define_own_prop_args_obj -> Coq_result_not_yet_implemented (* TODO *)\n  | Coq_builtin_define_own_prop_proxy    -> Coq_result_not_yet_implemented (* TODO *)\n\n(** Function to dispatch calls to O.[[HasProperty]](P) *)\nand object_internal_has_property s o p =\n  let%some b = (run_object_method object_has_prop_ s o) in\n  match b with\n  | Coq_builtin_has_prop_default -> ordinary_has_property s o p\n  | Coq_builtin_has_prop_proxy   -> Coq_result_not_yet_implemented (* TODO *)\n\n(** Function to dispatch calls to O.[[Get]](P, receiver) *)\nand object_internal_get s o p receiver =\n  let%some internal_method = (run_object_method object_get_ s o) in\n  let dispatch_es5 _ =\n    match p with\n    (* FIXME: ES5 HACK CONTEXT *)\n    | Coq_value_string x -> object_get_builtin s (execution_ctx_initial true) internal_method (Coq_value_object o) o x\n    | _ -> assert false\n  in match internal_method with\n  (* FIXME: Dispatch to new versions of functions *)\n  | Coq_builtin_get_default  -> dispatch_es5 ()\n  | Coq_builtin_get_function -> dispatch_es5 ()\n  | Coq_builtin_get_args_obj -> dispatch_es5 ()\n  | Coq_builtin_get_proxy    -> Coq_result_not_yet_implemented\n\n(** Function to dispatch calls to O.[[Set]](P, V, Receiver) *)\nand object_internal_set s o p v receiver =\n  let%some internal_method = (run_object_method object_set_ s o) in\n  match internal_method with\n  | Coq_builtin_set_default -> ordinary_object_internal_set s o p v receiver\n  | Coq_builtin_set_proxy   -> Coq_result_not_yet_implemented\n\n(** @deprecated In favour of potentially the same [object_internal_set] ES6 method *)\nand object_put s c l p v str = object_internal_set s l (Coq_value_string p) v (Coq_value_object l)\n\n(** Function to dispatch calls to O.[[Call]](thisArgument, argumentsList) *)\nand object_internal_call s o thisArgument argumentsList =\n  (* FIXME: ES5 HACK CONTEXT *)\n  run_call s (execution_ctx_initial true) o thisArgument argumentsList\n\n(** {3 The Reference Specification Type}\n    @essec 6.2.4\n    @esid sec-reference-specification-type *)\n\nand get_base = ref_base\n\n(* Note: may prefer this to return a raw string? *)\nand get_referenced_name r =\n  Coq_value_string (ref_name r)\n\nand is_strict_reference = ref_strict\n\n(* TODO: Copied ES5 code, tidy up *)\nand has_primitive_base r =\n  ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base\n\nand is_property_reference r =\n  (ref_kind_of r === Coq_ref_kind_object) || has_primitive_base r\n\nand is_unresolvable_reference r =\n  ref_kind_of r === Coq_ref_kind_undef\n\nand is_super_reference r =\n  is_some r.ref_this_value\n\n(** GetValue(V)\n\n    Note: Although the type of [v] is a resultof, its state is disregarded\n    and must be explicitly passed to prevent issues with the value being\n    computed prior to other state mutations.\n\n    @esid sec-getvalue\n    @essec 6.2.4.1\n*)\nand get_value s v =\n  let%success (_, v\') = v in\n  if not (type_of_resvalue v\' === Type_resvalue_ref) then v\n  else\n    let v = ref_of_resvalue v\' in\n    let base = get_base v in\n    if is_unresolvable_reference v then\n      run_error_no_c s Coq_native_error_ref\n    else if is_property_reference v then\n      let base = value_of_ref_base_type base in\n      let%ret (s, base) =\n        if has_primitive_base v then\n          let%assert_ret _ = not (base === Coq_value_undef) || (base === Coq_value_null) in\n          let%OBJECT_ret (s, base) = to_object s base in\n          Continue (s, base)\n        else\n          Continue (s, loc_of_value base)\n      in object_internal_get s base (get_referenced_name v) (get_this_value v)\n    else\n      let base = env_loc_of_ref_base_type base in\n      get_binding_value s base (get_referenced_name v) (is_strict_reference v)\n\n(** PutValue(V,W)\n\n    Note: Although the types of [v] and [w] are resultof, their states are\n    disregarded and must be explicitly passed, as it is not clear in which\n    order they were calculated.\n\n    @esid sec-putvalue\n    @essec 6.2.4.2\n*)\nand put_value s c v w =\n  let%success (_, v) = v in\n  let%value (_, w) = w in\n  if not (type_of_resvalue v === Type_resvalue_ref) then\n    run_error_no_c s Coq_native_error_ref\n  else\n  let v = ref_of_resvalue v in\n  let base = get_base v in\n  if is_unresolvable_reference v then\n    if is_strict_reference v then\n      run_error_no_c s Coq_native_error_ref\n    else\n      let globalObj = get_global_object s c in\n      set s globalObj (get_referenced_name v) w (Coq_value_bool false)\n  else if is_property_reference v then\n    let base = value_of_ref_base_type base in\n    let%ret s, base =\n      if has_primitive_base v then\n        let%assert_ret _ = not (base === Coq_value_null || base === Coq_value_undef) in\n        let%OBJECT_ret s, base = to_object s base in\n        Continue (s, base)\n      else\n        Continue (s, loc_of_value base)\n    in\n    let%bool s, succeeded = object_internal_set s base (get_referenced_name v) w (get_this_value v) in\n    if (not succeeded) && (is_strict_reference v) then\n      run_error_no_c s Coq_native_error_type\n    else\n      res_void s\n  else\n    let base = env_loc_of_ref_base_type base in\n    set_mutable_binding s base (get_referenced_name v) w (Coq_value_bool (is_strict_reference v))\n\n(** @esid sec-getthisvalue\n    @essec 6.2.4.3 *)\nand get_this_value v =\n  let asrt = assert (is_property_reference v) in\n  if is_super_reference v then\n    ref_this_value v\n  else\n    value_of_ref_base_type (get_base v)\n\n\n(** {3 The Property Descriptor Specification Type}\n    @esid sec-property-descriptor-specification-type\n    @essec 6.2.5 *)\n\n(** @essec 6.2.5.1\n    @esid sec-isaccessordescriptor *)\nand is_accessor_descriptor desc =\n  match desc with\n  | Descriptor_undef -> false\n  | Descriptor desc -> not\n    (  (option_compare value_compare desc.descriptor_get None)\n    && (option_compare value_compare desc.descriptor_set None))\n\n(** @essec 6.2.5.2\n    @esid sec-isdatadescriptor *)\nand is_data_descriptor desc =\n  match desc with\n  | Descriptor_undef -> false\n  | Descriptor desc -> not\n    (  (option_compare value_compare desc.descriptor_value None)\n    && (option_compare bool_eq desc.descriptor_writable None))\n\n(** @essec 6.2.5.3\n    @esid sec-isgenericdescriptor *)\nand is_generic_descriptor desc =\n  match desc with\n  | Descriptor_undef -> false\n  | Descriptor _ -> (not (is_accessor_descriptor desc)) && (not (is_data_descriptor desc))\n\n(** @esid sec-topropertydescriptor\n    @essec 6.2.5.5 *)\nand to_property_descriptor s _foo_ =\n  match _foo_ with\n  | Coq_value_object l ->\n    let desc = descriptor_intro_empty in\n    let%bool (s, hasEnumerable) = has_property s _foo_ (Coq_value_string "enumerable") in\n    let%spec (s, desc) =\n      if hasEnumerable\n      then\n        let%value (s, v) = get s _foo_ (Coq_value_string "enumerable") in\n        let enum = to_boolean v in\n        res_spec s (descriptor_with_enumerable desc (Some enum))\n      else res_spec s desc\n    in\n    let%bool (s, hasConfigurable) = has_property s _foo_ (Coq_value_string "configurable") in\n    let%spec (s, desc) =\n      if hasConfigurable\n      then\n        let%value (s, v) = get s _foo_ (Coq_value_string "configurable") in\n        let conf = to_boolean v in\n        res_spec s (descriptor_with_configurable desc (Some conf))\n      else res_spec s desc\n    in\n    let%bool (s, hasValue) = has_property s _foo_ (Coq_value_string "value") in\n    let%spec (s, desc) =\n      if hasValue\n      then\n        let%value (s, value) = get s _foo_ (Coq_value_string "value") in\n        res_spec s (descriptor_with_value desc (Some value))\n      else res_spec s desc\n    in\n    let%bool (s, hasWritable) = has_property s _foo_ (Coq_value_string "writable") in\n    let%spec (s, desc) =\n      if hasValue\n      then\n        let%value (s, v) = get s _foo_ (Coq_value_string "writable") in\n        let writable = to_boolean v in\n        res_spec s (descriptor_with_writable desc (Some writable))\n      else res_spec s desc\n    in\n    let%bool (s, hasGet) = has_property s _foo_ (Coq_value_string "get") in\n    let%spec (s, desc) =\n      if hasGet\n      then\n        let%value (s, getter) = get s _foo_ (Coq_value_string "get") in\n        if (not (is_callable s getter)) && (not (type_of getter === Coq_type_undef))\n        then run_error_no_c s Coq_native_error_type\n        else res_spec s (descriptor_with_get desc (Some getter))\n      else res_spec s desc\n    in\n    let%bool (s, hasSet) = has_property s _foo_ (Coq_value_string "set") in\n    let%spec (s, desc) =\n      if hasSet\n      then\n        let%value (s, setter) = get s _foo_ (Coq_value_string "set") in\n        if (not (is_callable s setter)) && (not (type_of setter === Coq_type_undef))\n        then run_error_no_c s Coq_native_error_type\n        else res_spec s (descriptor_with_set desc (Some setter))\n      else res_spec s desc\n    in\n    if ((not (desc.descriptor_get === None)) || (not (desc.descriptor_set === None)))\n      && ((not (desc.descriptor_value === None)) || (not (desc.descriptor_writable === None)))\n    then run_error_no_c s Coq_native_error_type\n    else res_spec s desc\n  | _ -> throw_result (run_error_no_c s Coq_native_error_type)\n\n(** @essec 6.2.5.6\n    @esid sec-completepropertydescriptor *)\nand complete_property_descriptor s desc =\n  let desc = descriptor_get_defined desc in\n  let like = { descriptor_value        = Some Coq_value_undef;\n               descriptor_writable     = Some false;\n               descriptor_get          = Some Coq_value_undef;\n               descriptor_set          = Some Coq_value_undef;\n               descriptor_enumerable   = Some false;\n               descriptor_configurable = Some false }\n  in let desc =\n    if is_generic_descriptor (Descriptor desc) || is_data_descriptor (Descriptor desc)\n    then\n      let desc = descriptor_with_value desc like.descriptor_value in\n      descriptor_with_writable desc like.descriptor_writable\n    else\n      let desc = descriptor_with_get desc like.descriptor_get in\n      descriptor_with_set desc like.descriptor_set\n  in let desc =\n    if option_compare bool_eq desc.descriptor_enumerable None\n    then descriptor_with_enumerable desc like.descriptor_enumerable\n    else desc\n  in let desc =\n    if option_compare bool_eq desc.descriptor_configurable None\n    then descriptor_with_configurable desc like.descriptor_configurable\n    else desc\n  in desc\n\n(** {1 Abstract Operations }\n    @essec 7\n    @esid sec-abstract-operations *)\n\n(** {2 Type Conversion }\n    @essec 7.1\n    @esid sec-type-conversion *)\n\n(** @essec 7.1.2\n    @esid sec-toboolean *)\n(* FIXME: _foo_ = argument *)\nand to_boolean _foo_ = match _foo_ with\n| Coq_value_undef -> false\n| Coq_value_null -> false\n| Coq_value_bool b -> b\n| Coq_value_number n ->\n  if (JsNumber.isposzero n) || (JsNumber.isnegzero n) || (JsNumber.isnan n) then false\n  else true\n| Coq_value_string s -> if string_eq s "" then false else true\n(* | Coq_value_symbol s -> true *)\n| Coq_value_object o -> true\n\n(** {2 Testing and Comparison Operations }\n    @essec 7.2\n    @esid sec-testing-and-comparison-operations *)\n\n(** @essec 7.2.3\n    @esid sec-iscallable *)\nand is_callable s argument =\n  match argument with\n  | Coq_value_object l -> object_has_internal_method s l object_call_\n  | _ -> false\n\n(** @essec 7.2.5\n    @esid sec-isextensible-o *)\nand is_extensible s o =\n  let%assert _ = match type_of o with Coq_type_object -> true | _ -> false in\n  match o with\n  | Coq_value_object l -> object_internal_is_extensible s l\n  | _ -> assert false\n\n(** @essec 7.2.7\n    @esid sec-ispropertykey *)\nand is_property_key argument =\n  (type_of argument) === Coq_type_string (* FIXME: || (type_of argument) === Coq_type_symbol *)\n\n(** @essec 7.2.9\n    @esid sec-samevalue *)\nand same_value x y =\n  if not (type_compare (type_of x) (type_of y))\n  then false\n  else match type_of x with\n  | Coq_type_number ->\n    (match x with\n    | Coq_value_number n_x ->\n      (match y with\n      | Coq_value_number n_y ->\n        if (JsNumber.isnan n_x) && (JsNumber.isnan n_y) then true\n        else if (JsNumber.isposzero n_x) && (JsNumber.isnegzero n_y) then true\n        else if (JsNumber.isnegzero n_x) && (JsNumber.isposzero n_y) then true\n        else n_x === n_y\n      | _ -> assert false)\n    | _ -> assert false)\n  | _ -> same_value_non_number x y\n\n(** @essec 7.2.11\n    @esid sec-samevaluenonnumber *)\nand same_value_non_number x y =\n  let (*%assert*) asrt = assert (not (type_compare (type_of x) Coq_type_number)) in\n  let (*%assert*) asrt = assert (type_compare (type_of x) (type_of y)) in\n  match x with\n  | Coq_value_undef      -> true\n  | Coq_value_null       -> true\n  | Coq_value_string s_x ->\n    (match y with\n    | Coq_value_string s_y -> string_eq s_x s_y\n    | _ -> assert false)\n  | Coq_value_bool b_x   ->\n    (match y with\n     | Coq_value_bool b_y -> bool_eq b_x b_y\n     | _ -> assert false)\n  (* FIXME: Symbol\n  | Coq_value_symbol s_x ->\n     (match y with\n     | Coq_value_symbol s_y -> symbol_compare s_x s_y\n     | _ -> assert false)\n  *)\n  | Coq_value_object l_x ->\n    (match y with\n    | Coq_value_object l_y -> object_loc_compare l_x l_y\n    | _ -> assert false)\n  | _ -> assert false\n\n(** {2 Operations on Objects }\n    @essec 7.3\n    @esid sec-operations-on-objects *)\n\n(** @essec 7.3.1\n    @esid sec-get-o-p *)\nand get s o p =\n  let%assert _ = (type_of o) === Coq_type_object in\n  let%assert _ = is_property_key p in\n  match o with\n  | Coq_value_object l -> object_internal_get s l p o\n  | _ -> assert false\n\n(** @essec 7.3.2\n    @esid sec-getv *)\nand get_v s v p =\n  let%assert _ = is_property_key p in\n  let%object (s1, l) = to_object s v in\n  object_internal_get s1 l p v\n\n(** @essec 7.3.3\n    @esid sec-set-o-p-v-throw *)\nand set s o p v throw =\n  let%assert _ = (type_of o) === Coq_type_object in\n  let l = loc_of_value o in\n  let%assert _ = is_property_key p in\n  let%assert _ = (type_of throw) === Coq_type_bool in\n  let throw = bool_of_value throw in\n  let%bool s, success = object_internal_set s l p v o in\n  if (not success) && throw then\n    run_error_no_c s Coq_native_error_type\n  else\n    res_ter s (res_val (Coq_value_bool success))\n\n(** @essec 7.3.4\n    @esid sec-createdataproperty *)\nand create_data_property s o p v =\n  let%assert _ = type_of o === Coq_type_object in\n  let o = loc_of_value o in\n  let%assert _ = is_property_key p in\n  let newDesc = descriptor_intro_data v true true true in\n  object_internal_define_own_property s o p newDesc\n\n(** @essec 7.3.9\n    @esid sec-getmethod *)\nand get_method s v p =\n  let%assert _ = is_property_key p in\n  let%value (s1, func) = get_v s v p in\n  match type_of func with\n  | Coq_type_undef -> res_out s1 (res_val Coq_value_undef)\n  | Coq_type_null  -> res_out s1 (res_val Coq_value_undef)\n  | _ ->\n    let callable = is_callable s1 func in\n    if not callable\n    then run_error_no_c s1 Coq_native_error_type\n    else res_out s1 (res_val func)\n\n(** @essec 7.3.10\n    @esid sec-hasproperty *)\nand has_property s o p =\n  let%assert _ = (type_of o) === Coq_type_object in\n  let%assert _ = is_property_key p in\n  match o with\n  | Coq_value_object l -> object_internal_has_property s l p\n  | _ -> assert false\n\n(** @essec 7.3.12\n    @esid sec-call *)\nand call s f v argumentList =\n  if_some_or_apply_default argumentList [] (fun argumentList ->\n    let callable = is_callable s f in\n    if not callable then run_error_no_c s Coq_native_error_type\n    else match f with\n    | Coq_value_object l -> object_internal_call s l v argumentList\n    | _ -> assert false\n  )\n\n(** {1 Executable Code and Execution Contexts}\n    @essec 8\n    @esid sec-executable-code-and-execution-contexts *)\n(** {2 Lexical Environments}\n    @essec 8.1\n    @esid sec-lexical-environments *)\n(** {3 Environment Records}\n    @essec 8.1.1\n    @esid sec-environment-records *)\n(** {4 Abstract Methods}\n    Dynamic dispatch functions for environment record abstract methods.\n\n    @esid table-15\n*)\n(*\nand has_binding s e n =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_has_binding s e n\n  | Coq_env_record_object (l, this) -> object_env_record_has_binding s l this n\n\nand create_mutable_binding s e n d =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_create_mutable_binding s e n d\n  | Coq_env_record_object (l, this) -> object_env_record_create_mutable_binding s l this n d\n\nand create_immutable_binding s e n str =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_create_immutable_binding s e n str\n  | Coq_env_record_object (l, this) -> object_env_record_create_immutable_binding s l this n str\n\nand initialize_binding s e n v =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_initialize_binding s e n v\n  | Coq_env_record_object (l, this) -> object_env_record_initialize_binding s l this n v\n*)\n\nand set_mutable_binding s l n v str =\n  let%some e = env_record_binds_option s l in\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_set_mutable_binding s l e n v str\n  | Coq_env_record_object (l, this) -> object_env_record_set_mutable_binding s (Coq_value_object l) this n v str\n\nand get_binding_value s l n str =\n  let%some e = env_record_binds_option s l in\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_get_binding_value s e n str\n  | Coq_env_record_object (l, this) -> object_env_record_get_binding_value s (Coq_value_object l) this n str\n\n(*\nand delete_binding s e n =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_delete_binding s e n\n  | Coq_env_record_object (l, this) -> object_env_record_delete_binding s l this n\n\nand has_this_binding s e =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_has_this_binding s e\n  | Coq_env_record_object (l, this) -> object_env_record_has_this_binding s l this\n\nand has_super_binding s e =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_has_super_binding s e\n  | Coq_env_record_object (l, this) -> object_env_record_has_super_binding s l this\n\nand with_base_object s e =\n  match e with\n  | Coq_env_record_decl e           -> decl_env_record_with_base_object s e\n  | Coq_env_record_object (l, this) -> object_env_record_with_base_object s l this\n*)\n\n(**\n    {4 Declarative Environment Records}\n    @essec 8.1.1.1\n    @esid sec-declarative-environment-records\n*)\n\n(* FIXME: Move to a bindings data structure section. Apply to mutable bindings also. *)\nand binding_is_uninitialized binding =\n  let (mutability, unused) = binding in\n  mutability_compare mutability Coq_mutability_uninitialized_immutable\n\nand binding_is_mutable binding =\n  let (mutability, unused) = binding in\n  (mutability === Coq_mutability_nondeletable) || (mutability === Coq_mutability_deletable)\n\n(** @essec 8.1.1.1.2\n    @esid sec-declarative-environment-records-createmutablebinding-n-d *)\nand decl_env_record_create_mutable_binding s l envRec n\' d =\n  let n = string_of_value n\' in\n  let d = bool_of_value d in\n  let%assert _ = not (HeapStr.indom_dec envRec n) in\n  let s = env_record_write_decl_env s l n (mutability_of_bool d) Coq_value_undef in (* FIXME: Uninitialized field *)\n  res_void s\n\n(** @essec 8.1.1.1.4\n    @esid sec-declarative-environment-records-initializebinding-n-v *)\nand decl_env_record_initialize_binding s l envRec n\' v =\n  let n = string_of_value n\' in\n  let%some binding = HeapStr.read_option envRec n in\n  let (mutability, unused) = binding in (* TODO: Tidy up *)\n  let%assert _ = binding_is_uninitialized binding in\n  (* Update mutability / initialization flag *)\n  let s = env_record_write_decl_env s l n mutability v in\n  res_void s\n\n(** @essec 8.1.1.1.5\n    @esid sec-declarative-environment-records-setmutablebinding-n-v-s *)\nand decl_env_record_set_mutable_binding s l envRec n\' v str =\n  let n = string_of_value n\' in\n  let str = bool_of_value str in\n  if not (HeapStr.indom_dec envRec n) then\n    if str then\n      run_error_no_c s Coq_native_error_ref\n    else\n      let%success s, _ = decl_env_record_create_mutable_binding s l envRec n\' (Coq_value_bool true) in\n      let%success s, _ = decl_env_record_initialize_binding s l envRec n\' v in\n      res_void s\n  else\n  let%some binding = HeapStr.read_option envRec n in\n  let (mutability, unused) = binding in\n  (* FIXME: Implement strictness for bindings: let str = if binding.ref_strict then true else str in *)\n  if binding_is_uninitialized binding then\n    run_error_no_c s Coq_native_error_ref\n  else let%ret s =\n    if binding_is_mutable binding then\n      Continue (env_record_write_decl_env s l n mutability v)\n    else\n      if str then\n        Return (run_error_no_c s Coq_native_error_type)\n      else\n        Continue s\n    in\n    res_void s\n\n(** @essec 8.1.1.1.6\n    @esid sec sec-declarative-environment-records-getbindingvalue-n-s *)\nand decl_env_record_get_binding_value s envRec n str =\n  let n = string_of_value n in\n  let%assert _ = HeapStr.indom_dec envRec n in\n  let%some binding = HeapStr.read_option envRec n in\n  let (mutability, v) = binding in\n  if mutability_compare mutability Coq_mutability_uninitialized_immutable (* FIXME: Need to handle mutable uninitialized also *)\n  then run_error_no_c s Coq_native_error_ref\n  else res_ter s (res_val v)\n\n(**\n    {4 Object Environment Records}\n    @essec 8.1.1.2\n    @esid sec-object-environment-records\n*)\n\n(** @essec 8.1.1.1.2.5\n    @edid sec-object-environment-records-setmutablebinding-n-v-s *)\nand object_env_record_set_mutable_binding s bindings this n v str =\n  set s bindings n v str\n\n(** @essec 8.1.1.1.2.6\n    @esid sec-object-environment-records-getbindingvalue-n-s *)\nand object_env_record_get_binding_value s bindings this n str =\n  let%bool s, value = has_property s bindings n in\n  if not value then\n    if not str\n    then res_ter s (res_val Coq_value_undef)\n    else run_error_no_c s Coq_native_error_ref\n  else\n    get s bindings n\n\n(** {2 Execution Contexts}\n    @essec 8.3\n    @esid sec-execution-contexts *)\n\n(** @esid sec-getglobalobject\n    @essec 8.3.6 *)\nand get_global_object s ctx =\n  (* FIXME: ES5 hack (realms required) *)\n  let e = unsome_error (env_record_binds_option s env_loc_global_env_record) in\n  match e with\n  | Coq_env_record_object (l, this) -> Coq_value_object l\n  |  _ -> assert false\n\n(** {1 Ordinary and Exotic Objects Behaviours }\n    @essec 9\n    @esid sec-ordinary-and-exotic-objects-behaviours *)\n\n(**\n    {2 Ordinary Object Internal Methods and Internal Slots }\n    @essec 9.1\n    @esid sec-ordinary-object-internal-methods-and-internal-slots *)\n\n(** [[GetPrototypeOf]]()\n    @essec 9.1.1\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof *)\nand ordinary_object_internal_get_prototype_of s o =\n  let%value (s1, v) = ordinary_get_prototype_of s o in\n  res_out s (res_val v)\n\n(** @essec 9.1.1.1\n    @esid sec-ordinarygetprototypeof *)\nand ordinary_get_prototype_of s o =\n  let%some v = run_object_method object_proto_ s o in\n  res_spec s (res_val v)\n\n(** [[SetPrototypeOf]](V)\n    @essec 9.1.2\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v *)\nand ordinary_object_internal_set_prototype_of s o v =\n  let%value (s1, v) = ordinary_set_prototype_of s o v in\n  res_out s (res_val v)\n\n(** @essec 9.1.2.1\n    @esid sec-ordinarysetprototypeof *)\nand ordinary_set_prototype_of s o v =\n  let%assert _ = (match type_of v with Coq_type_object -> true | Coq_type_null -> true | _ -> false) in\n  let%some extensible = run_object_method object_extensible_ s o in\n  let%some current = run_object_method object_prototype_ s o in\n  let sv = same_value v current in\n  if sv then res_spec s (res_val (Coq_value_bool true))\n  else if not extensible then res_spec s (res_val (Coq_value_bool false))\n  else\n    let rec repeat p done_ = begin\n      if not done_ then\n        (match p with\n        | Coq_value_null -> repeat p true\n        | Coq_value_object p_l ->\n          if same_value p (Coq_value_object o)\n          then res_spec s (res_val (Coq_value_bool false))\n          else\n            let%some gpo = run_object_method object_get_prototype_of_ s p_l in\n            (match gpo with\n            | Coq_builtin_get_prototype_of_default -> (\n              let%some prototype = run_object_method object_prototype_ s p_l in\n              repeat prototype false)\n            | _ -> repeat p true)\n        | _ -> assert false)\n      else\n        (* Set the value of the [[Prototype]] internal slot of O to V *)\n        let%some s\' = run_object_set_internal object_set_proto s o v in\n        res_spec s\' (res_val (Coq_value_bool true))\n    end\n    in repeat v false\n\n(** @essec 9.1.3\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-isextensible *)\nand ordinary_object_internal_is_extensible s o =\n  let%value (s1, v) = ordinary_is_extensible s o in\n  res_out s (res_val v)\n\n(** @essec 9.1.3.1\n    @esid sec-ordinaryisextensible *)\nand ordinary_is_extensible s o =\n  let%some b = run_object_method object_extensible_ s o in\n  res_out s (res_val (Coq_value_bool b))\n\n(** @essec 9.1.4\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-preventextensions *)\nand ordinary_object_internal_prevent_extensions s o =\n  let%value (s1, v) = ordinary_prevent_extensions s o in\n  res_out s (res_val v)\n\n(** @essec 9.1.4.1\n    @esid sec-ordinarypreventextensions *)\nand ordinary_prevent_extensions s o =\n  let%some s\' = run_object_set_internal object_set_extensible s o false in\n  res_spec s (res_val (Coq_value_bool true))\n\n(** @essec 9.1.5\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p *)\nand ordinary_object_internal_get_own_property s o p =\n  ordinary_get_own_property s o p\n\n(** @essec 9.1.5.1\n    @esid sec-ordinarygetownproperty *)\nand ordinary_get_own_property s o p =\n  let%assert _ = is_property_key p in\n  let p = string_of_value p in\n  if not (object_property_exists s o p) then res_spec s Descriptor_undef\n  else let d = descriptor_intro_empty in\n  let%some x = object_retrieve_property s o p in\n  let d = match x with\n  | Coq_attributes_data_of x ->\n      { d with descriptor_value    = (Some x.attributes_data_value);\n               descriptor_writable = (Some x.attributes_data_writable) }\n  | Coq_attributes_accessor_of x ->\n      { d with descriptor_get = (Some x.attributes_accessor_get);\n               descriptor_set = (Some x.attributes_accessor_set) } in\n  let d = { d with descriptor_enumerable   = (Some (attributes_enumerable x)) } in\n  let d = { d with descriptor_configurable = (Some (attributes_configurable x)) } in\n  res_spec s (Descriptor d)\n\n(** @essec 9.1.6\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc *)\nand ordinary_object_internal_define_own_property s o p desc =\n  ordinary_define_own_property s o p desc\n\n(** @essec 9.1.6.1\n    @esid sec-ordinarydefineownproperty *)\nand ordinary_define_own_property s o p desc =\n  let%spec (s, current) = object_internal_get_own_property s o p in\n  let%some extensible = run_object_method object_extensible_ s o in\n  validate_and_apply_property_descriptor s (Coq_value_object o) p extensible desc current\n\n(** @essec 9.1.6.2\n    @esid sec-iscompatiblepropertydescriptor *)\nand is_compatible_property_descriptor s extensible desc current =\n  validate_and_apply_property_descriptor s Coq_value_undef Coq_value_undef extensible desc current\n\n(** @essec 9.1.6.3\n    @esid sec-validateandapplypropertydescriptor *)\nand validate_and_apply_property_descriptor s o p extensible desc current =\n  (* FIXME: o, p type mismatch, specified as object, property key but undefined passed *)\n  (* A -> B === !A || B *)\n  let%assert _ = (value_compare o Coq_value_undef) || (is_property_key p) in\n  let p = string_of_value p in (* FIXME: Will break with Symbols *)\n  match current with\n  (* Three types of descriptors: full, attributes: accessor and data...\n     Spec assumes one with variable field definitions, move to this? (equiv. our full)\n   *)\n  | Descriptor_undef ->\n    if not extensible then res_out s (res_val (Coq_value_bool false))\n    else\n      let%assert _ = extensible in (* SPEC: This assert assumes extensible is any value, but is strictly typed for us *)\n      let%some s =\n        match o with\n        | Coq_value_object l ->\n          if (is_generic_descriptor (Descriptor desc)) || (is_data_descriptor (Descriptor desc))\n          then object_set_property s l p (Coq_attributes_data_of (attributes_data_of_descriptor desc))\n          else object_set_property s l p (Coq_attributes_accessor_of (attributes_accessor_of_descriptor desc))\n        | Coq_value_undef -> Some s\n        | _ -> None\n      in res_ter s (res_val (Coq_value_bool true))\n\n  | Descriptor current ->\n    (* The following two steps 3 & 4 of the spec are implied by the rest of the function, except in the\n       case of NaN values for [[Value]] which may change internal representation.\n       Otherwise, they are only an optimisation as far as I can tell. *)\n    (* Step 3 (also implied by step 4) *)\n    let%ret s = if descriptor_is_empty desc\n      then Return (res_ter s (res_val (Coq_value_bool true)))\n      else Continue s\n\n    (* Step 4 *)\n    in let%ret s =\n    if descriptor_contained_by desc current same_value\n      then Return (res_ter s (res_val (Coq_value_bool true)))\n      else Continue s\n\n    (* Steps 5 *)\n    in let%ret s =\n    if (option_compare bool_eq current.descriptor_configurable (Some false))\n    then\n      if (option_compare bool_eq desc.descriptor_configurable (Some true))\n      then Return (res_ter s (res_val (Coq_value_bool false)))\n      else if ((is_some desc.descriptor_enumerable) &&\n        not (some_compare bool_eq current.descriptor_enumerable desc.descriptor_enumerable))\n      then Return (res_ter s (res_val (Coq_value_bool false)))\n      else Continue s\n    else Continue s\n\n    (* Step 6 if IsGenericDescriptor(Desc) is true, implied by following conditions *)\n    in let%ret s =\n    if is_generic_descriptor (Descriptor desc)\n    then Continue s\n\n    (* Step 7 *)\n    else if not (bool_eq (is_data_descriptor (Descriptor current)) (is_data_descriptor (Descriptor desc)))\n    then\n      (* 7a *)\n      if (option_compare bool_eq current.descriptor_configurable (Some false))\n        then Return (res_ter s (res_val (Coq_value_bool false)))\n      (* 7b *)\n      else if is_data_descriptor (Descriptor current)\n        then\n          let s = unsome_default s (match o with\n          | Coq_value_object l -> object_map_property s l p attributes_accessor_of_attributes_data\n          | _ -> Some s)\n          in Continue s\n        else\n          let s = unsome_default s (match o with\n          | Coq_value_object l -> object_map_property s l p attributes_data_of_attributes_accessor\n          | _ -> Some s)\n          in Continue s\n\n    (* Step 8 *)\n    else if (is_data_descriptor (Descriptor current)) && (is_data_descriptor (Descriptor desc))\n    then\n      (* Step 8a *)\n      if option_compare bool_eq current.descriptor_configurable (Some false)\n      then\n        (* Step 8ai *)\n        if (option_compare bool_eq current.descriptor_writable (Some false))\n           && (option_compare bool_eq desc.descriptor_writable (Some true))\n        then Return (res_ter s (res_val (Coq_value_bool false)))\n\n        (* Step 8aii *)\n        else if option_compare bool_eq current.descriptor_writable (Some false)\n        then\n          (* Step 8aii1 *)\n          if (is_some desc.descriptor_value)\n             && not (option_compare same_value desc.descriptor_value current.descriptor_value)\n          then Return (res_ter s (res_val (Coq_value_bool false)))\n          else Continue s\n        else Continue s\n\n      (* Step 8b *)\n      else if not (option_compare bool_eq current.descriptor_configurable (Some true))\n        then Return (spec_assertion_failure ())\n        else Continue s\n\n    (* Step 9 *)\n    else if not ((is_accessor_descriptor (Descriptor current)) && (is_accessor_descriptor (Descriptor desc)))\n      then Return (spec_assertion_failure ())\n      else if option_compare bool_eq current.descriptor_configurable (Some false)\n      then\n        if (is_some desc.descriptor_set) &&\n            not (option_compare same_value desc.descriptor_set current.descriptor_set)\n        then Return (res_ter s (res_val (Coq_value_bool false)))\n        else if (is_some desc.descriptor_get) &&\n                not (option_compare same_value desc.descriptor_get current.descriptor_get)\n        then Return (res_ter s (res_val (Coq_value_bool false)))\n        else Continue s\n      else Continue s\n\n    (* Step 10 *)\n    in let%some s = match o with\n    | Coq_value_object l ->\n       object_map_property s l p (fun a -> attributes_update a desc)\n    | _ -> Some s\n\n    (* Step 11 *)\n    in res_ter s (res_val (Coq_value_bool true))\n\n(** @essesc 9.1.7\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p *)\nand ordinary_object_internal_has_property s o p =\n  ordinary_has_property s o p\n\n(** @essec 9.1.7.1\n    @esid sec-ordinaryhasproperty *)\nand ordinary_has_property s o p =\n  let%assert _ = is_property_key p in\n  let%spec s, hasOwn = object_internal_get_own_property s o p in\n  if not (hasOwn === Descriptor_undef) then res_ter s (res_val (Coq_value_bool true))\n  else let%value s, parent = object_internal_get_prototype_of s o in\n  if not (parent === Coq_value_null) then object_internal_has_property s (loc_of_value parent) p\n  else res_ter s (res_val (Coq_value_bool false))\n\n(** @essec 9.1.9\n    @esid sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver *)\nand ordinary_object_internal_set s o p v receiver =\n  ordinary_set s o p v receiver\n\n(** @essec 9.1.9.1\n    @esid sec-ordinaryset *)\nand ordinary_set s o p v receiver =\n  let%assert _ = is_property_key p in\n  let%spec s, ownDesc = object_internal_get_own_property s o p in\n  let%ret ownDesc =\n    if ownDesc === Descriptor_undef then begin\n      let%value_ret s, parent = object_internal_get_prototype_of s o in\n      if not (parent === Coq_value_null) then\n        let parent = loc_of_value parent in\n        Return (object_internal_set s parent p v receiver)\n      else Continue (Descriptor {\n        descriptor_value = Some Coq_value_undef;\n        descriptor_writable = Some false;\n        descriptor_get = None;\n        descriptor_set = None;\n        descriptor_enumerable = Some true;\n        descriptor_configurable = Some true\n      })\n    end else Continue ownDesc\n  in\n  if is_data_descriptor ownDesc then begin\n    let ownDesc = descriptor_get_defined ownDesc in\n    let%some writable = ownDesc.descriptor_writable in\n    if writable then res_ter s (res_val (Coq_value_bool false))\n    else if not (type_of receiver === Coq_type_object) then res_ter s (res_val (Coq_value_bool false))\n    else\n      let receiver = loc_of_value receiver in\n      let%spec s, existingDescriptor = object_internal_get_own_property s receiver p in\n      if not (existingDescriptor === Descriptor_undef) then begin\n        if is_accessor_descriptor existingDescriptor then res_ter s (res_val (Coq_value_bool false))\n        else\n          let existingDescriptor = descriptor_get_defined existingDescriptor in\n          let%some w = existingDescriptor.descriptor_writable in\n          if not w then res_ter s (res_val (Coq_value_bool false))\n          else\n            let valueDesc = (descriptor_with_value descriptor_intro_empty (Some v)) in\n            object_internal_define_own_property s receiver p valueDesc\n      end else\n        create_data_property s (Coq_value_object receiver) p v\n  end else\n    let%assert _ = is_accessor_descriptor ownDesc in\n    let ownDesc = descriptor_get_defined ownDesc in\n    let%some setter = ownDesc.descriptor_set in\n    if setter === Coq_value_undef then res_ter s (res_val (Coq_value_bool false))\n    else\n      let%spec s, _ = call s setter receiver (Some [v]) in\n      res_ter s (res_val (Coq_value_bool true))\n\n(** @essec 9.1.11.1\n    @esid sec-ordinaryownpropertykeys *)\nand ordinary_own_property_keys s c l =\n  let%some keys = object_properties_keys_as_list_option s l in\n  (* FIXME: Precise key ordering is to be implemented here! *)\n  res_spec s keys\n\n(******** UNCHECKED ES5 IMPLEMENTATION CONTINUES BELOW ***********)\n\n(** @deprecated Compatibility wrapper for ES5 code to ES6\n                implementation use [has_property] instead *)\nand object_has_prop s c l x =\n  object_internal_has_property s l (Coq_value_string x)\n\n\n(** val out_error_or_void :\n    state -> strictness_flag -> native_error -> result **)\n\nand out_error_or_void s c str ne =\n  if str then run_error s c ne else res_void s\n\n(** val out_error_or_cst :\n    state -> strictness_flag -> native_error -> value -> result **)\n\nand out_error_or_cst s c str ne v =\n  if str then run_error s c ne else res_out s (res_val v)\n\n(** val object_get_builtin :\n    state -> execution_ctx -> builtin_get -> value -> object_loc\n    -> prop_name -> result\n\n    @deprecated ES5 version of function. New versions need to be written and\n                dispatched to in {!object_internal_get}.\n**)\nand object_get_builtin s c b vthis l x =\n  let def s0 l0 =\n    let%spec (s1, d) = (run_object_get_prop s0 c l0 x) in\n    match d with\n    | Coq_full_descriptor_undef ->\n      res_ter s1 (res_val Coq_value_undef)\n    | Coq_full_descriptor_some a ->\n      (match a with\n       | Coq_attributes_data_of ad ->\n         res_ter s1 (res_val ad.attributes_data_value)\n       | Coq_attributes_accessor_of aa ->\n         (match aa.attributes_accessor_get with\n          | Coq_value_undef ->\n            res_ter s1 (res_val Coq_value_undef)\n          | Coq_value_null -> Coq_result_impossible\n          | Coq_value_bool b0 -> Coq_result_impossible\n          | Coq_value_number n -> Coq_result_impossible\n          | Coq_value_string s2 -> Coq_result_impossible\n          | Coq_value_object lf -> run_call s1 c lf vthis [])) in\n  let function0 s0 =\n    let%value (s_2, v) = (def s0 l) in\n    if spec_function_get_error_case_dec s_2 x v\n    then run_error s_2 c Coq_native_error_type\n    else res_ter s_2 (res_val v) in\n  match b with\n  | Coq_builtin_get_default -> def s l\n  | Coq_builtin_get_function -> function0 s\n  | Coq_builtin_get_args_obj -> (\n    let%some lmapo = (run_object_method object_parameter_map_ s l) in\n    let%some lmap = (lmapo) in\n    let%spec (s0, d) = (run_object_get_own_prop s c lmap x) in\n    match d with\n    | Coq_full_descriptor_undef -> function0 s0\n    | Coq_full_descriptor_some a -> run_object_get s0 c lmap x)\n  | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val run_object_get :\n    state -> execution_ctx -> object_loc -> prop_name -> result\n\n    @deprecated This is the ES5 version, replaced by {!object_internal_get}\n    **)\nand run_object_get s c l x =\n  let%some b = (run_object_method object_get_ s l) in\n  object_get_builtin s c b (Coq_value_object l) l x\n\n(** val run_object_get_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    full_descriptor specres **)\n\nand run_object_get_prop s c l x =\n  let%some b = (run_object_method object_get_prop_ s l) in\n  match b with Coq_builtin_get_prop_default ->\n    let%spec (s1, d) = (run_object_get_own_prop s c l x) in\n    if full_descriptor_compare d Coq_full_descriptor_undef\n    then let%some proto = (run_object_method object_proto_ s1 l) in\n      match proto with\n      | Coq_value_null -> res_spec s1 Coq_full_descriptor_undef\n      | Coq_value_object lproto ->\n        run_object_get_prop s1 c lproto x\n      | _ ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s1\n          ("Found a non-object or null value as a prototype in [run_object_get_prop].")\n    else res_spec s1 d\n\n(** val object_proto_is_prototype_of :\n    state -> object_loc -> object_loc -> result **)\n\nand object_proto_is_prototype_of s l0 l =\n  let%some b = (run_object_method object_proto_ s l) in\n  match b with\n  | Coq_value_null ->\n    res_out s (res_val (Coq_value_bool false))\n  | Coq_value_object l_2 ->\n    if object_loc_compare l_2 l0\n    then res_out s (res_val (Coq_value_bool true))\n    else object_proto_is_prototype_of s l0 l_2\n  | _ ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("[run_object_method] returned a non-object in [object_proto_is_prototype_of_body].")\n\n(** val object_default_value :\n    state -> execution_ctx -> object_loc -> preftype option ->\n    result **)\n\nand object_default_value s c l prefo =\n  let%some b = (run_object_method object_default_value_ s l) in\n  match b with Coq_builtin_default_value_default ->\n    let gpref = unsome_default Coq_preftype_number prefo in\n    let lpref = other_preftypes gpref in\n    let sub0 s_2 x k =\n      let%value (s1, vfo) = (run_object_get s_2 c l x) in\n      let%some co = (run_callable s1 vfo) in\n      match co with\n      | Some b0 ->\n        let%object (s2, lfunc) = (res_out s1 (res_val vfo)) in\n        let%value (s3, v) = (run_call s2 c lfunc (Coq_value_object l) []) in begin\n          match v with\n          | Coq_value_object l0 -> k s3\n          | _ -> res_out s3 (res_val v)\n        end\n      | None -> k s1 in\n    let gmeth = (method_of_preftype gpref) in\n    sub0 s gmeth (fun s_2 ->\n        let lmeth = method_of_preftype lpref in\n        sub0 s_2 lmeth (fun s_3 -> run_error s_3 c Coq_native_error_type))\n\n(** val to_primitive :\n    state -> execution_ctx -> value -> preftype option -> result **)\n\nand to_primitive s c v prefo =\n  match v with\n  | Coq_value_object l ->\n    let%prim (s0, r) = (object_default_value s c l prefo) in\n    res_ter s0 (res_val r)\n  | _ -> res_out s (res_val v)\n\n(** val to_number :\n    state -> execution_ctx -> value -> result **)\n\nand to_number s c _foo_ = match _foo_ with\n  | Coq_value_object l ->\n    let%prim (s1, w) = (to_primitive s c (Coq_value_object l) (Some Coq_preftype_number)) in\n    res_ter s1 (res_val (Coq_value_number (convert_prim_to_number w)))\n  | _ ->\n    res_out s (res_val (Coq_value_number (convert_prim_to_number _foo_)))\n\n(** val to_integer :\n    state -> execution_ctx -> value -> result **)\n\nand to_integer s c v =\n  let%number (s1, n) = to_number s c v in\n  res_ter s1\n    (res_val (Coq_value_number (convert_number_to_integer n)))\n\n(** val to_int32 :\n    state -> execution_ctx -> value -> float specres **)\n\nand to_int32 s c v =\n  let%number (s_2, n) = to_number s c v in res_spec s_2 (JsNumber.to_int32 n)\n\n(** val to_uint32 :\n    state -> execution_ctx -> value -> float specres **)\n\nand to_uint32 s c v =\n  let%number (s_2, n) = to_number s c v in res_spec s_2 (JsNumber.to_uint32 n)\n\n(** val to_string :\n    state -> execution_ctx -> value -> result **)\n\nand to_string s c _foo_ = match _foo_ with\n  | Coq_value_object l ->\n    let%prim (s1, w) = (to_primitive s c (Coq_value_object l) (Some Coq_preftype_string)) in\n    res_ter s1\n      (res_val (Coq_value_string (convert_prim_to_string w)))\n  | _ ->\n    res_out s (res_val (Coq_value_string (convert_prim_to_string _foo_)))\n\n(** val run_object_define_own_prop_array_loop :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    descriptor -> bool -> bool -> (state -> prop_name -> descriptor ->\n    strictness_flag -> __ specres) -> result **)\n\nand run_object_define_own_prop_array_loop s c l newLen oldLen newLenDesc newWritable throwcont def =\n  if newLen < oldLen\n  then let oldLen_2 = (oldLen -. 1.) in\n    let%string (s0, slen) = (to_string s c (Coq_value_number oldLen_2)) in\n    let%bool (s1, deleteSucceeded) = (object_delete s0 c l slen false) in\n    if not deleteSucceeded\n    then let newLenDesc0 =\n           (descriptor_with_value\n              newLenDesc\n              (Some (Coq_value_number (oldLen_2 +. 1.)))) in\n      let newLenDesc1 = (if not newWritable\n                         then descriptor_with_writable newLenDesc0 (Some false)\n                         else newLenDesc0) in\n      let%bool (s2, x) = (def s1 ("length")\n                            newLenDesc1 false) in\n      out_error_or_cst s2 c throwcont Coq_native_error_type\n        (Coq_value_bool false)\n    else run_object_define_own_prop_array_loop s1 c l\n        newLen oldLen_2 newLenDesc newWritable throwcont def\n  else if not newWritable\n  then def s ("length")\n      { descriptor_value = None; descriptor_writable = (Some false);\n        descriptor_get = None; descriptor_set = None;\n        descriptor_enumerable = None; descriptor_configurable = None }\n      false\n  else res_ter s (res_val (Coq_value_bool true))\n\n(** val object_define_own_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    descriptor -> strictness_flag -> result **)\n\nand object_define_own_prop s c l x desc throwcont =\n  let reject s0 throwcont0 =\n    out_error_or_cst\n      s0 c throwcont0 Coq_native_error_type (Coq_value_bool false) in\n  let def s p d _ = ordinary_define_own_property s l (Coq_value_string p) d in\n  let%some b = (run_object_method object_define_own_prop_ s l) in\n  match b with\n  | Coq_builtin_define_own_prop_default ->\n      object_internal_define_own_property s l (Coq_value_string x) desc (* ES6 hack *)\n  | Coq_builtin_define_own_prop_array ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l ("length")) in\n    begin\n      match d with\n      | Coq_full_descriptor_undef ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s0\n          ("Array length property descriptor cannot be undefined.")\n      | Coq_full_descriptor_some attr ->\n        (match attr with\n         | Coq_attributes_data_of a ->\n           let  oldLen = (a.attributes_data_value) in begin\n             match oldLen with\n             | Coq_value_object l0 ->\n               (Debug.impossible_with_heap_because __LOC__ s0\n                  "Spec asserts length of array is number.";\n                Coq_result_impossible)\n             | _ ->\n               let oldLen0 = (JsNumber.to_uint32 (convert_prim_to_number oldLen)) in\n               let descValueOpt = (desc.descriptor_value) in\n               if string_eq x ("length")\n               then (match descValueOpt with\n                   | Some descValue ->\n                     let%spec (s1, newLen) = (to_uint32 s0 c descValue) in\n                     let%number (s2, newLenN) = to_number s1 c descValue in\n                     if not (newLen === newLenN)\n                     then run_error s2 c Coq_native_error_range\n                     else let newLenDesc =\n                            (descriptor_with_value desc (Some (Coq_value_number newLen))) in\n                       if le_int_decidable oldLen0 newLen\n                       then def s2 ("length") newLenDesc throwcont\n                       else if not a.attributes_data_writable\n                       then reject s2 throwcont\n                       else let newWritable = (match newLenDesc.descriptor_writable with\n                           | Some b0 -> if b0 then true else false\n                           | None -> true) in\n                         let newLenDesc0 = (if not newWritable\n                                            then descriptor_with_writable newLenDesc (Some true)\n                                            else newLenDesc) in\n                         let%bool (s3, succ) = (def s2 ("length") newLenDesc0 throwcont) in\n                         if not succ\n                         then res_ter s3 (res_val (Coq_value_bool false))\n                         else run_object_define_own_prop_array_loop s3 c l newLen oldLen0 newLenDesc0 newWritable throwcont def\n                   | None -> def s0 ("length") desc throwcont)\n               else let%spec (s1, ilen) = (to_uint32 s0 c (Coq_value_string x)) in\n                 let%string (s2, slen) = (to_string s1 c (Coq_value_number ilen)) in\n                 if (string_eq x slen) && (not ( ilen = 4294967295.))\n                 then let%spec (s3, index) = (to_uint32 s2 c (Coq_value_string x)) in\n                   if  (le_int_decidable oldLen0 index) && (not a.attributes_data_writable)\n                   then reject s3 throwcont\n                   else let%bool (s4, b0) = (def s3 x desc false) in\n                     if not b0\n                     then reject s4 throwcont\n                     else if le_int_decidable oldLen0 index\n                     then let a0 =\n                            descriptor_with_value (descriptor_of_attributes (Coq_attributes_data_of a))\n                              (Some (Coq_value_number (index +. 1.))) in\n                       def s4 ("length") a0 false\n                     else res_ter s4 (res_val (Coq_value_bool true))\n                 else def s2 x desc throwcont\n           end\n         | Coq_attributes_accessor_of a ->\n           (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n             s0\n             ("Array length property descriptor cannot be accessor."))\n    end\n  | Coq_builtin_define_own_prop_args_obj ->\n    let%some lmapo = (run_object_method object_parameter_map_ s l) in\n    let%some lmap = (lmapo) in\n    let%spec (s0, d) = (run_object_get_own_prop s c lmap x) in\n    let%bool (s1, b0) = (def s0 x desc false) in\n    if b0\n    then let follow s2 = res_ter s2 (res_val (Coq_value_bool true)) in\n      match d with\n      | Coq_full_descriptor_undef -> follow s1\n      | Coq_full_descriptor_some a ->\n        if is_accessor_descriptor (Descriptor desc)\n        then let%bool (s2, x0) = (object_delete s1 c lmap x false) in follow s2\n        else let follow0 s2 =\n               if option_compare bool_eq desc.descriptor_writable (Some false)\n               then let%bool (s3, x0) = (object_delete s2 c lmap x false) in\n                 follow s3\n               else follow s2 in\n          match desc.descriptor_value with\n          | Some v ->\n            let%void s2 = (object_put s1 c lmap x v throwcont) in follow0 s2\n          | None -> follow0 s1\n    else reject s1 throwcont\n  | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val prim_new_object : state -> prim -> result **)\n\nand prim_new_object s _foo_ = match _foo_ with\n  | Coq_value_bool b ->\n    let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_bool_proto)) ("Boolean")) in\n    let o = (object_with_primitive_value o1 (Coq_value_bool b)) in\n    let (l, s1) = object_alloc s o in\n    res_out s1 (res_val (Coq_value_object l))\n  | Coq_value_number n ->\n    let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_number_proto)) ("Number")) in\n     let o = (object_with_primitive_value o1 (Coq_value_number n)) in\n     let (l, s1) = object_alloc s o in\n     res_out s1 (res_val (Coq_value_object l))\n  | Coq_value_string s0 ->\n    let o2 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_string_proto)) ("String")) in\n    let o1 = (object_with_get_own_property o2 Coq_builtin_get_own_prop_string) in\n    let o = (object_with_primitive_value o1 (Coq_value_string s0)) in\n    let (l, s1) = object_alloc s o in\n    let%some s_2 = (run_object_heap_map_properties s1 l\n      (fun p -> HeapStr.write p ("length")\n         (Coq_attributes_data_of (attributes_data_intro_constant\n         (Coq_value_number (number_of_int (strlength s0))))))) in\n    res_ter s_2 (res_val (Coq_value_object l))\n  | _ ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("[prim_new_object] received an null or undef.")\n\n(** val to_object : state -> value -> result **)\n\nand to_object s _foo_ = match _foo_ with\n  | Coq_value_undef -> run_error_no_c s Coq_native_error_type\n  | Coq_value_null -> run_error_no_c s Coq_native_error_type\n  | Coq_value_bool b -> prim_new_object s _foo_\n  | Coq_value_number n -> prim_new_object s _foo_\n  | Coq_value_string s0 -> prim_new_object s _foo_\n  | Coq_value_object l ->\n    res_out s (res_val (Coq_value_object l))\n\n(** val run_object_prim_value : state -> object_loc -> result **)\n\nand run_object_prim_value s l =\n  let%some ov = (run_object_method object_prim_value_ s l) in\n      let%some v = (ov) in  res_ter s (res_val v)\n\n(** val prim_value_get :\n    state -> execution_ctx -> value -> prop_name -> result **)\n\nand prim_value_get s c v x =\n  let%object (s_2, l) = (to_object s v) in\n      object_get_builtin s_2 c Coq_builtin_get_default v l x\n\n(** val env_record_has_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> result **)\n\nand env_record_has_binding s c l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        res_out s (res_val (Coq_value_bool (HeapStr.indom_dec ed x)))\n      | Coq_env_record_object (l0, pt) -> object_has_prop s c l0 x\n\n(** val lexical_env_get_identifier_ref :\n    state -> execution_ctx -> lexical_env -> prop_name ->\n    strictness_flag -> ref specres **)\n\nand lexical_env_get_identifier_ref s c x x0 str =\n  match x with\n  | [] ->\n    res_spec s (ref_create_value Coq_value_undef x0 str)\n  | l :: x_2 ->\n    let%bool (s1, has) = (env_record_has_binding s c l x0) in\n        if has\n        then res_spec s1 (ref_create_env_loc l x0 str)\n        else lexical_env_get_identifier_ref s1 c x_2 x0 str\n\n(** val object_delete_default :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    strictness_flag -> result **)\n\nand object_delete_default s c l x str =\n  let%spec (s1, d) = (run_object_get_own_prop s c l x) in\n      match d with\n      | Coq_full_descriptor_undef ->\n        res_ter s1 (res_val (Coq_value_bool true))\n      | Coq_full_descriptor_some a ->\n        if attributes_configurable a\n        then let%some\n             s_2 = (run_object_heap_map_properties s1 l (fun p ->\n                 HeapStr.rem p x)) in\n                res_ter s_2 (res_val (Coq_value_bool true))\n        else out_error_or_cst s1 c str Coq_native_error_type (Coq_value_bool false)\n\n(** val object_delete :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    strictness_flag -> result **)\n\nand object_delete s c l x str =\n  let%some b = (run_object_method object_delete_ s l) in\n      match b with\n      | Coq_builtin_delete_default -> object_delete_default s c l x str\n      | Coq_builtin_delete_args_obj ->\n        begin\n          let%some mo = (run_object_method object_parameter_map_ s l) in\n          let%some m = (mo) in\n          let%spec (s1, d) = (run_object_get_own_prop s c m x) in\n          let%bool (s2, b0) = (object_delete_default s1 c l x str) in\n          if b0 then (match d with\n            | Coq_full_descriptor_undef ->\n              res_ter s2 (res_val (Coq_value_bool b0))\n            | Coq_full_descriptor_some a ->\n              let%bool (s3, b_2) = (object_delete s2 c m x false) in\n              res_ter s3 (res_val (Coq_value_bool b0)))\n          else res_ter s2 (res_val (Coq_value_bool b0))\n        end\n      | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val env_record_delete_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> result **)\n\nand env_record_delete_binding s c l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        (match HeapStr.read_option ed x with\n         | Some p ->\n           let (mu, v) = p in\n           (match mu with\n            | Coq_mutability_uninitialized_immutable ->\n              res_out s (res_val (Coq_value_bool false))\n            | Coq_mutability_immutable ->\n              res_out s (res_val (Coq_value_bool false))\n            | Coq_mutability_nondeletable ->\n              res_out s (res_val (Coq_value_bool false))\n            | Coq_mutability_deletable ->\n              let s_2 =\n                env_record_write s l (Coq_env_record_decl (decl_env_record_rem ed x))\n              in\n              res_out s_2 (res_val (Coq_value_bool true)))\n         | None ->\n           res_out s (res_val (Coq_value_bool true)))\n      | Coq_env_record_object (l0, pt) ->\n        object_delete s c l0 x throw_false\n\n(** val env_record_implicit_this_value : state -> env_loc -> value option **)\n\nand env_record_implicit_this_value s l =\n  ifx_some_or_default (env_record_binds_option s l) None (fun e ->\n      Some\n        (match e with\n         | Coq_env_record_decl ed -> Coq_value_undef\n         | Coq_env_record_object (l0, provide_this) ->\n           if provide_this\n           then Coq_value_object l0\n           else Coq_value_undef))\n\n(** val identifier_resolution :\n    state -> execution_ctx -> prop_name -> ref specres **)\n\nand identifier_resolution s c x =\n  let x0 = c.execution_ctx_lexical_env in\n  let str = c.execution_ctx_strict in\n  lexical_env_get_identifier_ref s c x0 x str\n\n(** @deprecated ES5 *)\nand env_record_get_binding_value s c l x str =\n  get_binding_value s l (Coq_value_string x) str\n\n(** @deprecated ES5 *)\nand ref_get_value s c _foo_ =\n  let%value s, v = get_value s (res_ter s (res_normal _foo_)) in\n  res_spec s v\n\n(** @deprecated ES5 *)\nand run_expr_get_value s c e =\n  let%value s, v = get_value s (run_expr s c e) in\n  res_spec s v\n\n(** val env_record_set_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> value ->\n    strictness_flag -> result_void **)\n\nand env_record_set_mutable_binding s c l x v str =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        let%some rm = (HeapStr.read_option ed x) in\n            let (mu, v_old) = rm in\n            if not (mutability_compare mu Coq_mutability_immutable)\n            then res_void (env_record_write_decl_env s l x mu v)\n            else out_error_or_void s c str Coq_native_error_type\n      | Coq_env_record_object (l0, pt) -> object_put s c l0 x v str\n\n(** val prim_value_put :\n    state -> execution_ctx -> prim -> prop_name -> value ->\n    strictness_flag -> result_void **)\n\nand prim_value_put s c w x v str =\n  assert false (* FIXME *)\n  (* let%object (s1, l) = (to_object s w) in\n      object_put_complete Coq_builtin_put_default s1 c w l x v str *)\n\n(** val ref_put_value :\n    state -> execution_ctx -> resvalue -> value -> result_void **)\n\nand ref_put_value s c rv v =\n  match rv with\n  | Coq_resvalue_empty ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("[ref_put_value] received an empty result.")\n  | Coq_resvalue_value v0 -> run_error s c Coq_native_error_ref\n  | Coq_resvalue_ref r ->\n    if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_undef\n    then if r.ref_strict\n      then run_error s c Coq_native_error_ref\n      else object_put s c (Coq_object_loc_prealloc\n                             Coq_prealloc_global) r.ref_name v throw_false\n    else if\n          (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base)\n       || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_null)\n       || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_object)\n    then (match r.ref_base with\n        | Coq_ref_base_type_value v_2 ->\n          if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base\n          then (match v_2 with\n              | Coq_value_object o ->\n                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                  s\n                  ("[ref_put_value] impossible case")\n              | _ ->\n                prim_value_put s c v_2 r.ref_name v r.ref_strict\n            )\n          else (match v_2 with\n              | Coq_value_object l ->\n                object_put s c l r.ref_name v r.ref_strict\n              | _ ->\n                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                  s\n                  ("[ref_put_value] impossible case")\n            )\n        | Coq_ref_base_type_env_loc l ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("[ref_put_value] contradicts ref_is_property"))\n    else (match r.ref_base with\n        | Coq_ref_base_type_value v0 ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("[ref_put_value] impossible spec")\n        | Coq_ref_base_type_env_loc l ->\n          env_record_set_mutable_binding s c l r.ref_name v\n            r.ref_strict)\n\n(** val env_record_create_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> bool\n    option -> result_void **)\n\nand env_record_create_mutable_binding s c l x deletable_opt =\n  let  deletable = (unsome_default false deletable_opt) in\n      let%some e = (env_record_binds_option s l) in\n          match e with\n          | Coq_env_record_decl ed ->\n            if HeapStr.indom_dec ed x\n            then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s\n                ("Already declared environnment record in [env_record_create_mutable_binding].")\n            else let s_2 = (env_record_write_decl_env s l x\n                              (mutability_of_bool deletable) Coq_value_undef) in\n              res_void s_2\n          | Coq_env_record_object (l0, pt) ->\n            let%bool (s1, has) = (object_has_prop s c l0 x) in\n              if has\n              then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                    s1\n                    ("Already declared binding in [env_record_create_mutable_binding].")\n              else let  a = ({ attributes_data_value = Coq_value_undef; attributes_data_writable = true;\n                                   attributes_data_enumerable = true;\n                                   attributes_data_configurable = deletable }) in\n                    let%success\n                       (s2, rv) = (object_define_own_prop s1 c l0 x\n                         (descriptor_of_attributes (Coq_attributes_data_of a))\n                         throw_true) in  res_void s2\n\n(** val env_record_create_set_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> bool\n    option -> value -> strictness_flag -> result_void **)\n\nand env_record_create_set_mutable_binding s c l x deletable_opt v str =\n  let%void \n    s0 = (env_record_create_mutable_binding s c l x deletable_opt) in  env_record_set_mutable_binding s0 c l x v str\n\n(** val env_record_create_immutable_binding :\n    state -> env_loc -> prop_name -> result_void **)\n\nand env_record_create_immutable_binding s l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        if HeapStr.indom_dec ed x\n        then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("Already declared environnment record in [env_record_create_immutable_binding].")\n        else res_void\n            (env_record_write_decl_env s l x\n               Coq_mutability_uninitialized_immutable Coq_value_undef)\n      | Coq_env_record_object (o, p) ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("[env_record_create_immutable_binding] received an environnment record object.")\n\n(** val env_record_initialize_immutable_binding :\n    state -> env_loc -> prop_name -> value -> result_void **)\n\nand env_record_initialize_immutable_binding s l x v =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        let%some evs = (decl_env_record_option ed x) in\n            if prod_compare mutability_compare value_compare evs\n                (Coq_mutability_uninitialized_immutable, Coq_value_undef)\n            then let s_2 = (env_record_write_decl_env s l x Coq_mutability_immutable v) in res_void s_2\n            else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s\n                ("Non suitable binding in [env_record_initialize_immutable_binding].")\n      | Coq_env_record_object (o, p) ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("[env_record_initialize_immutable_binding] received an environnment record object.")\n\n(** val call_object_new : state -> value -> result **)\n\nand call_object_new s c v =\n  match type_of v with\n  | Coq_type_undef ->\n    let o = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_object_proto))\n      ("Object")) in\n    let  p = object_alloc s o in\n    let (l, s_2) = p in\n    res_out s_2 (res_val (Coq_value_object l))\n  | Coq_type_null ->\n    let o = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_object_proto))\n      ("Object")) in\n    let  p = object_alloc s o in\n    let (l, s_2) = p in\n    res_out s_2 (res_val (Coq_value_object l))\n  | Coq_type_bool -> to_object s v\n  | Coq_type_number -> to_object s v\n  | Coq_type_string -> to_object s v\n  | Coq_type_object -> res_out s (res_val v)\n\n(** val array_args_map_loop :\n    state -> execution_ctx -> object_loc -> value list -> float\n    -> result_void **)\n\nand array_args_map_loop s c l args ind =\n  match args with\n  | [] -> res_void s\n  | h :: rest ->\n    let%some s_2 = (run_object_heap_map_properties s l (fun p ->\n           HeapStr.write p (JsNumber.to_string ind)\n             (Coq_attributes_data_of (attributes_data_intro_all_true h)))) in\n             array_args_map_loop s_2 c l rest (ind +. 1.)\n\n(** val run_construct_prealloc :\n    state -> execution_ctx -> prealloc -> value list -> result **)\n\nand run_construct_prealloc s c b args =\n  match b with\n  | Coq_prealloc_object ->\n    let v = (get_arg 0 args) in call_object_new s c v\n  | Coq_prealloc_bool ->\n    let v = get_arg 0 args in\n    let b0 = to_boolean v in\n    let o1 = object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_bool_proto))\n      ("Boolean") in\n    let o = object_with_primitive_value o1 (Coq_value_bool b0) in\n    let  p = object_alloc s o in\n    let (l, s_2) = p in\n    res_out s_2 (res_val (Coq_value_object l))\n  | Coq_prealloc_number ->\n    let follow = (fun s_2 v ->\n      let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_number_proto))\n        ("Number")) in\n      let o = object_with_primitive_value o1 v in\n      let (l, s1) = object_alloc s_2 o in\n      res_out s1 (res_val (Coq_value_object l))) in\n    if list_eq_nil_decidable args\n    then follow s (Coq_value_number JsNumber.zero)\n    else\n      let v = get_arg 0 args in\n      let%number (x, x0) = (to_number s c v) in\n      follow x (Coq_value_number x0)\n  | Coq_prealloc_array ->\n    let o_2 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_array_proto))\n      ("Array")) in\n    let o = (object_for_array o_2 Coq_builtin_define_own_prop_array) in\n    let p = (object_alloc s o) in\n    let (l, s_2) = p in\n    let follow = (fun s_3 length0 ->\n      let%some s0 = (run_object_heap_map_properties s_3 l (fun p0 ->\n        HeapStr.write p0 ("length") (Coq_attributes_data_of\n          { attributes_data_value = (Coq_value_number length0);\n            attributes_data_writable = true;\n            attributes_data_enumerable = false;\n            attributes_data_configurable = false }))) in\n      res_ter s0 (res_val (Coq_value_object l))) in\n    let arg_len = (LibList.length args) in\n    if nat_eq arg_len 1\n    then let v = get_arg 0 args in\n    match v with\n    | Coq_value_undef ->\n      let%some s0 = (run_object_heap_map_properties s_2 l\n        (fun p1 -> HeapStr.write p1 ("0") (Coq_attributes_data_of (attributes_data_intro_all_true v)))) in\n      follow s0 1.0\n    | Coq_value_null ->\n      let%some s0 = (run_object_heap_map_properties s_2 l\n        (fun p1 -> HeapStr.write p1 ("0") (Coq_attributes_data_of (attributes_data_intro_all_true v)))) in\n      follow s0 1.0\n    | Coq_value_bool b0 ->\n      let%some s0 = (run_object_heap_map_properties s_2 l\n        (fun p1 -> HeapStr.write p1 ("0") (Coq_attributes_data_of (attributes_data_intro_all_true v)))) in\n      follow s0 1.0\n    | Coq_value_number vlen ->\n      let%spec (s0, ilen) = (to_uint32 s_2 c (Coq_value_number vlen)) in\n      if ilen === vlen\n      then follow s0 ilen\n      else run_error s0 c Coq_native_error_range\n    | Coq_value_string s0 ->\n      let%some s1 = (run_object_heap_map_properties s_2 l\n        (fun p1 -> HeapStr.write p1 ("0") (Coq_attributes_data_of (attributes_data_intro_all_true v)))) in\n      follow s1 1.0\n    | Coq_value_object o0 ->\n      let%some\n         s0 = (run_object_heap_map_properties s_2 l\n           (fun p0 ->\n              HeapStr.write p0 ("0") (Coq_attributes_data_of\n                                     (attributes_data_intro_all_true v)))) in\n            follow s0 1.0\n                          else let%some\n                               s0 = (run_object_heap_map_properties s_2 l\n                                 (fun p0 ->\n                                    HeapStr.write p0\n                                      ("length")\n                                      (Coq_attributes_data_of { attributes_data_value =\n                                                                  (Coq_value_number (number_of_int arg_len));\n                                                                attributes_data_writable = true;\n                                                                attributes_data_enumerable = false;\n                                                                attributes_data_configurable = false }))) in\n                                  let%void \n                                    s1 = (array_args_map_loop s0 c l args 0.) in  res_ter s1 (res_val (Coq_value_object l))\n  | Coq_prealloc_string ->\n    let\n       o2 = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                       Coq_prealloc_string_proto))\n         ("String")) in\n          let\n            \n            o1 = (object_with_get_own_property o2 Coq_builtin_get_own_prop_string) in\n               let  follow = (fun s0 s1 ->\n                   let\n                      o = (object_with_primitive_value o1 (Coq_value_string s1)) in\n                         let (l, s2) = object_alloc s0 o in\n                         let lenDesc = (attributes_data_intro_constant (Coq_value_number (number_of_int (strlength s1)))) in\n                              let%some\n                                 s_2 = (run_object_heap_map_properties s2 l (fun p ->\n                                     HeapStr.write p ("length")\n                                       (Coq_attributes_data_of lenDesc))) in\n                                    res_ter s_2 (res_val (Coq_value_object l))) in\n                   let  arg_len = (LibList.length args) in\n                       if nat_eq arg_len 0\n                       then follow s ""\n                       else let  arg = (get_arg 0 args) in\n                           let%string (s0, s1) = (to_string s c arg) in\n                               follow s0 s1\n  | Coq_prealloc_error ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           Coq_prealloc_error_proto)) v\n  | Coq_prealloc_native_error ne ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           (Coq_prealloc_native_error_proto ne))) v\n  | _ ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      (strappend\n         ("Construct prealloc_")\n         (strappend (string_of_prealloc b)\n            (" not yet implemented.")))\n\n(** val run_construct_default :\n    state -> execution_ctx -> object_loc -> value list -> __\n    specres **)\n\nand run_construct_default s c l args =\n  let%value\n    \n    (s1, v1) = (run_object_get s c l\n       ("prototype")) in\n       let\n          vproto = (if type_compare (type_of v1) Coq_type_object\n          then v1\n          else Coq_value_object (Coq_object_loc_prealloc\n                                   Coq_prealloc_object_proto)) in\n             let\n               \n               o = (object_new vproto ("Object")) in\n                  let  p = (object_alloc s1 o) in\n                      let (l_2, s2) = p in\n                      let%value \n                        (s3, v2) = (run_call s2 c l (Coq_value_object l_2) args) in\n                           let\n                              vr = (if type_compare (type_of v2) Coq_type_object\n                              then v2\n                              else Coq_value_object l_2) in res_ter s3 (res_val vr)\n\n(** val run_construct :\n    state -> execution_ctx -> construct -> object_loc -> value\n    list -> result **)\n\nand run_construct s c co l args =\n  match co with\n  | Coq_construct_default -> run_construct_default s c l args\n  | Coq_construct_after_bind ->\n    let%some otrg = run_object_method object_target_function_ s l in\n    let%some target = (otrg) in\n    let%some oco = run_object_method object_construct_ s target in begin\n      match oco with\n      | Some co0 ->\n        let%some oarg = run_object_method object_bound_args_ s l in\n        let%some boundArgs = oarg in\n        let  arguments_ = (LibList.append boundArgs args) in\n            run_construct s c co0 target arguments_\n      | None -> run_error s c Coq_native_error_type\n    end\n  | Coq_construct_prealloc b -> run_construct_prealloc s c b args\n  | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val run_call_default :\n    state -> execution_ctx -> object_loc -> result **)\n\nand run_call_default s c lf =\n  let def = res_out s (res_val Coq_value_undef) in\n  let%some oC = (run_object_method object_code_ s lf) in\n  match oC with\n  | Some bd ->\n    if list_eq_nil_decidable (prog_elements (funcbody_prog bd))\n    then def\n    else ifx_success_or_return (run_prog s c (funcbody_prog bd))\n      (fun s_2 -> res_out s_2 (res_val Coq_value_undef))\n      (fun s_2 rv -> res_out s_2 (res_normal rv))\n  | None -> def\n\n(** val creating_function_object_proto :\n    state -> execution_ctx -> object_loc -> result **)\n\nand creating_function_object_proto s c l =\n  let%object \n    (s1, lproto) = (run_construct_prealloc s c Coq_prealloc_object []) in\n       let  a1 = ({ attributes_data_value = (Coq_value_object l);\n                     attributes_data_writable = true; attributes_data_enumerable = false;\n                     attributes_data_configurable = true }) in\n           let%bool\n             \n             (s2, b) = (object_define_own_prop s1 c lproto\n                ("constructor")\n                (descriptor_of_attributes (Coq_attributes_data_of a1)) false) in\n                let  a2 = ({ attributes_data_value = (Coq_value_object lproto);\n                              attributes_data_writable = true; attributes_data_enumerable =\n                                                                 false; attributes_data_configurable = false }) in\n                    object_define_own_prop s2 c l\n                      ("prototype")\n                      (descriptor_of_attributes (Coq_attributes_data_of a2)) false\n\n(** val creating_function_object :\n    state -> execution_ctx -> string list -> funcbody ->\n    lexical_env -> strictness_flag -> result **)\n\nand creating_function_object s c names bd x str =\n  let\n     o = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                     Coq_prealloc_function_proto))\n       ("Function")) in\n        let  o1 = (object_with_get o Coq_builtin_get_function) in\n            let o2 = (object_with_invokation o1 (Some Coq_construct_default) (Some\n                                                                         Coq_call_default) (Some Coq_builtin_has_instance_function)) in\n             let o3 = (object_with_details o2 (Some x) (Some names) (Some bd) None None None None) in\n             let p = (object_alloc s o3) in\n             let (l, s1) = p in\n             let a1 = ({\n               attributes_data_value = (Coq_value_number (number_of_int (LibList.length names)));\n               attributes_data_writable = false; attributes_data_enumerable = false;\n               attributes_data_configurable = false\n             }) in\n             let%bool (s2, b2) = (object_define_own_prop s1 c l ("length")\n               (descriptor_of_attributes (Coq_attributes_data_of a1)) false) in\n             let%bool (s3, b3) = (creating_function_object_proto s2 c l) in\n             if not str\n             then res_ter s3 (res_val (Coq_value_object l))\n             else\n               let vthrower = (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_throw_type_error)) in\n               let a2 = ({ attributes_accessor_get = vthrower;\n                           attributes_accessor_set = vthrower;\n                           attributes_accessor_enumerable = false;\n                           attributes_accessor_configurable = false }) in\n               let%bool (s4, b4) = (object_define_own_prop s3 c l ("caller")\n                 (descriptor_of_attributes (Coq_attributes_accessor_of a2)) false) in\n               let%bool (s5, b5) = (object_define_own_prop s4 c l ("arguments")\n                 (descriptor_of_attributes (Coq_attributes_accessor_of a2)) false) in\n               res_ter s5 (res_val (Coq_value_object l))\n\n(** val binding_inst_formal_params :\n    state -> execution_ctx -> env_loc -> value list -> string\n    list -> strictness_flag -> result_void **)\n\nand binding_inst_formal_params s c l args names str =\n  match names with\n  | [] -> res_void s\n  | argname :: names_2 ->\n    let  v = (hd Coq_value_undef args) in\n        let  args_2 = (tl args) in\n            let%bool (s1, hb) = (env_record_has_binding s c l argname) in\n                let \n                  follow = (fun s_2 ->\n                    let%void\n                      \n                      s_3= (env_record_set_mutable_binding s_2 c l argname v str) in\n                         binding_inst_formal_params s_3 c l args_2 names_2 str) in\n                     if hb\n                     then follow s1\n                     else let%void\n                          s2 = (env_record_create_mutable_binding s1 c l argname\n                            None) in  follow s2\n\n(** val binding_inst_function_decls :\n    state -> execution_ctx -> env_loc -> funcdecl list ->\n    strictness_flag -> bool -> result_void **)\n\nand binding_inst_function_decls s c l fds str bconfig =\n\n  match fds with\n  | [] -> res_void s\n  | fd :: fds_2 ->\n    let  fbd = (fd.funcdecl_body) in\n        let  str_fd = (funcbody_is_strict fbd) in\n            let  fparams = (fd.funcdecl_parameters) in\n                let  fname = (fd.funcdecl_name) in\n                    let%object\n                       (s1, fo) = (creating_function_object s c fparams fbd\n                         c.execution_ctx_variable_env str_fd) in\n                          let \n                            follow = (fun s2 ->\n                              let%void\n                                 s3= (env_record_set_mutable_binding s2 c l fname\n                                   (Coq_value_object fo) str) in\n                                    binding_inst_function_decls s3 c l fds_2 str bconfig) in\n                               let%bool \n                                 (s2, has) = (env_record_has_binding s1 c l fname) in\n                                    if has\n                                    then if nat_eq l env_loc_global_env_record\n                                      then let%spec\n                                           (s3, d) = (run_object_get_prop s2 c\n                                             (Coq_object_loc_prealloc Coq_prealloc_global)\n                                             fname) in\n                                              match d with\n                                              | Coq_full_descriptor_undef ->\n                                                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                                  s3\n                                                  ("Undefined full descriptor in [binding_inst_function_decls].")\n                                              | Coq_full_descriptor_some a ->\n                                                if attributes_configurable a\n                                                then let  a_2 = ({ attributes_data_value =\n                                                                     Coq_value_undef;\n                                                                   attributes_data_writable = true;\n                                                                   attributes_data_enumerable = true;\n                                                                   attributes_data_configurable =\n                                                                     bconfig }) in\n                                                    let%bool\n                                                       (s0, x) = (object_define_own_prop s3 c\n                                                         (Coq_object_loc_prealloc\n                                                            Coq_prealloc_global) fname\n                                                         (descriptor_of_attributes\n                                                            (Coq_attributes_data_of a_2))\n                                                         true) in follow s0\n                                                else if \n                                                       (is_accessor_descriptor (Descriptor (descriptor_of_attributes a)))\n                                                    || (not (attributes_writable a))\n                                                    || (not (attributes_enumerable a))\n                                                then run_error s3 c Coq_native_error_type\n                                                else follow s3\n                                      else follow s2\n                                    else let%void\n                                         s3 = (env_record_create_mutable_binding s2 c l\n                                           fname (Some bconfig)) in  follow s3\n\n(** val make_arg_getter :\n    state -> execution_ctx -> prop_name -> lexical_env -> result **)\n\nand make_arg_getter s c x x0 =\n  let xbd =\n    strappend ("return ")\n      (strappend x (";"))\n  in\n  let bd = Coq_funcbody_intro ((Coq_prog_intro (true, ((Coq_element_stat\n                                                          (Coq_stat_return (Some (Coq_expr_identifier x)))) :: []))), xbd)\n  in\n  creating_function_object s c [] bd x0 true\n\n(** val make_arg_setter :\n    state -> execution_ctx -> prop_name -> lexical_env -> result **)\n\nand make_arg_setter s c x x0 =\n  let xparam = strappend x ("_arg") in\n  let xbd =\n    strappend x (strappend (" = ") (strappend xparam ";"))\n  in\n  let bd = Coq_funcbody_intro ((Coq_prog_intro (true, ((Coq_element_stat\n                                                          (Coq_stat_expr (Coq_expr_assign ((Coq_expr_identifier x), None,\n                                                                                           (Coq_expr_identifier xparam))))) :: []))), xbd)\n  in\n  creating_function_object s c (xparam :: []) bd x0 true\n\n(** val arguments_object_map_loop :\n    state -> execution_ctx -> object_loc -> string list ->\n    int -> value list -> lexical_env -> strictness_flag -> object_loc ->\n    string list -> result_void **)\n\nand arguments_object_map_loop s c l xs len args x str lmap xsmap =\n  (fun fO fS n -> if int_eq n 0 then fO () else fS (n-1))\n    (fun _ ->\n       if list_eq_nil_decidable xsmap\n       then res_void s\n       else let%some o = (object_binds_option s l) in\n           let\n              o_2 = (object_for_args_object o lmap Coq_builtin_get_args_obj\n                Coq_builtin_get_own_prop_args_obj\n                Coq_builtin_define_own_prop_args_obj\n                Coq_builtin_delete_args_obj) in\n                 res_void (object_write s l o_2))\n    (fun len_2 ->\n       let  tdl = (take_drop_last args) in\n           let (rmlargs, largs) = tdl in\n           let  arguments_object_map_loop_2 = (fun s0 xsmap0 ->\n               arguments_object_map_loop s0 c l xs len_2 rmlargs x str lmap\n                 xsmap0) in\n               let  a = (attributes_data_intro_all_true largs) in\n                   let%bool\n                     \n                     (s1, b) = (object_define_own_prop s c l\n                        (convert_prim_to_string (Coq_value_number (number_of_int len_2)))\n                        (descriptor_of_attributes (Coq_attributes_data_of a)) false) in\n                        if ge_nat_decidable len_2 (LibList.length xs)\n                        then arguments_object_map_loop_2 s1 xsmap\n                        else let dummy = "" in\n                          let  x0 = (nth_def dummy len_2 xs) in\n                              if    (str)\n                                 || (mem_decide string_eq x0 xsmap)\n                              then arguments_object_map_loop_2 s1 xsmap\n                              else let%object \n                                  (s2, lgetter) = (make_arg_getter s1 c x0 x) in\n                                     let%object \n                                       (s3, lsetter) = (make_arg_setter s2 c x0 x) in\n                                          let  a_2 = ({ attributes_accessor_get =\n                                                          (Coq_value_object lgetter);\n                                                        attributes_accessor_set = (Coq_value_object\n                                                                                     lsetter); attributes_accessor_enumerable =\n                                                                                                 false; attributes_accessor_configurable =\n                                                                                                          true }) in\n                                              let%bool\n                                                \n                                                (s4, b_2) = (object_define_own_prop s3 c lmap\n                                                   (convert_prim_to_string (Coq_value_number (number_of_int len_2)))\n                                                   (descriptor_of_attributes\n                                                      (Coq_attributes_accessor_of a_2)) false) in\n                                                   arguments_object_map_loop_2 s4 (x0 :: xsmap))\n    len\n\n(** val arguments_object_map :\n    state -> execution_ctx -> object_loc -> string list ->\n    value list -> lexical_env -> strictness_flag -> result_void **)\n\nand arguments_object_map s c l xs args x str =\n  let%object \n    (s_2, lmap) = (run_construct_prealloc s c Coq_prealloc_object []) in\n       arguments_object_map_loop s_2 c l xs (LibList.length args) args x\n         str lmap []\n\n(** val create_arguments_object :\n    state -> execution_ctx -> object_loc -> string list ->\n    value list -> lexical_env -> strictness_flag -> result **)\n\nand create_arguments_object s c lf xs args x str =\n  let\n     o = (object_create_builtin (Coq_value_object (Coq_object_loc_prealloc\n                                                Coq_prealloc_object_proto))\n       ("Arguments")\n       Heap.empty) in\n        let  p = (object_alloc s o) in\n            let (l, s_2) = p in\n            let  a = ({ attributes_data_value = (Coq_value_number (number_of_int (LibList.length args)));\n                          attributes_data_writable = true; attributes_data_enumerable = false;\n                          attributes_data_configurable = true }) in\n                let%bool\n                  \n                  (s1, b) = (object_define_own_prop s_2 c l\n                     ("length")\n                     (descriptor_of_attributes (Coq_attributes_data_of a)) false) in\n                     let%void \n                       s2= (arguments_object_map s1 c l xs args x str) in\n                          if str\n                          then let  vthrower = (Coq_value_object (Coq_object_loc_prealloc\n                                                                Coq_prealloc_throw_type_error)) in\n                              let  a0 = ({ attributes_accessor_get = vthrower;\n                                            attributes_accessor_set = vthrower;\n                                            attributes_accessor_enumerable = false;\n                                            attributes_accessor_configurable = false }) in\n                                  let%bool\n                                    \n                                    (s3, b_2) = (object_define_own_prop s2 c l\n                                       ("caller")\n                                       (descriptor_of_attributes\n                                          (Coq_attributes_accessor_of a0)) false) in\n                                       let%bool\n                                         \n                                         (s4, b_3) = (object_define_own_prop s3 c l\n                                            ("callee")\n                                            (descriptor_of_attributes\n                                               (Coq_attributes_accessor_of a0)) false) in\n                                            res_ter s4 (res_val (Coq_value_object l))\n                          else let  a0 = ({ attributes_data_value = (Coq_value_object lf);\n                                             attributes_data_writable = true;\n                                             attributes_data_enumerable = false;\n                                             attributes_data_configurable = true }) in\n                              let%bool\n                                 (s3, b_2) = (object_define_own_prop s2 c l\n                                   ("callee")\n                                   (descriptor_of_attributes (Coq_attributes_data_of a0))\n                                   false) in\n                                    res_ter s3 (res_val (Coq_value_object l))\n\n(** val binding_inst_arg_obj :\n    state -> execution_ctx -> object_loc -> prog -> string\n    list -> value list -> env_loc -> result_void **)\n\nand binding_inst_arg_obj s c lf p xs args l =\n  let arguments_ =\n    "arguments"\n  in\n  let  str = (prog_intro_strictness p) in\n      let%object\n         (s1, largs) = (create_arguments_object s c lf xs args\n           c.execution_ctx_variable_env str) in\n            if str\n            then let%void \n                s2= (env_record_create_immutable_binding s1 l arguments_) in\n                   env_record_initialize_immutable_binding s2 l arguments_\n                     (Coq_value_object largs)\n            else env_record_create_set_mutable_binding s1 c l arguments_ None\n                (Coq_value_object largs) false\n\n(** val binding_inst_var_decls :\n    state -> execution_ctx -> env_loc -> string list -> bool\n    -> strictness_flag -> result_void **)\n\nand binding_inst_var_decls s c l vds bconfig str =\n  match vds with\n  | [] -> res_void s\n  | vd :: vds_2 ->\n    let  bivd = (fun s0 ->\n        binding_inst_var_decls s0 c l vds_2 bconfig str) in\n        let%bool (s1, has) = (env_record_has_binding s c l vd) in\n            if has\n            then bivd s1\n            else let%void\n                 s2 = (env_record_create_set_mutable_binding s1 c l vd (Some\n                                                                    bconfig) Coq_value_undef str) in  bivd s2\n\n(** val execution_ctx_binding_inst :\n    state -> execution_ctx -> codetype -> object_loc option ->\n    prog -> value list -> result_void **)\n\nand execution_ctx_binding_inst s c ct funco p args =\n  match c.execution_ctx_variable_env with\n  | [] ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst].")\n  | l :: l0 ->\n    let  str = (prog_intro_strictness p) in\n        let  follow = (fun s_2 names ->\n            let \n              bconfig = (codetype_compare ct Coq_codetype_eval) in\n                 let  fds = (prog_funcdecl p) in\n                     let%void\n                       \n                       s1= (binding_inst_function_decls s_2 c l fds str bconfig) in\n                          let%bool\n                            \n                            (s2, bdefined) = (env_record_has_binding s1 c l\n                               ("arguments")) in\n                               let \n                                 follow2 = (fun s10 ->\n                                   let vds = prog_vardecl p in\n                                   binding_inst_var_decls s10 c l vds bconfig str) in\n                                    match ct with\n                                    | Coq_codetype_func ->\n                                      (match funco with\n                                       | Some func ->\n                                         if bdefined\n                                         then follow2 s2\n                                         else let%void\n                                              s3 = (binding_inst_arg_obj s2 c func p names\n                                                args l) in  follow2 s3\n                                       | None ->\n                                         if bdefined\n                                         then follow2 s2\n                                         else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                             s2\n                                             ("Weird `arguments\\\' object in [execution_ctx_binding_inst]."))\n                                    | Coq_codetype_global -> follow2 s2\n                                    | Coq_codetype_eval -> follow2 s2) in\n            match ct with\n            | Coq_codetype_func ->\n              (match funco with\n               | Some func ->\n                 let%some \n                   nameso = (run_object_method object_formal_parameters_ s func) in\n                      let%some names = (nameso) in\n                          let%void\n                            \n                            s_2 = (binding_inst_formal_params s c l args names str) in  follow s_2 names\n               | None ->\n                 (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                   s\n                   ("Non coherent functionnal code type in [execution_ctx_binding_inst]."))\n            | Coq_codetype_global ->\n              (match funco with\n               | Some o ->\n                 (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                   s\n                   ("Non coherent non-functionnal code type in [execution_ctx_binding_inst].")\n               | None -> follow s [])\n            | Coq_codetype_eval ->\n              (match funco with\n               | Some o ->\n                 (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                   s\n                   ("Non coherent non-functionnal code type in [execution_ctx_binding_inst].")\n               | None -> follow s [])\n\n(** val entering_func_code :\n    state -> execution_ctx -> object_loc -> value -> value list\n    -> result **)\n\nand entering_func_code s c lf vthis args =\n  let%some bdo = (run_object_method object_code_ s lf) in\n  let%some bd = (bdo) in\n  let str = (funcbody_is_strict bd) in\n  let follow = (fun s_2 vthis_2 ->\n    let%some lexo = (run_object_method object_scope_ s_2 lf) in\n    let%some lex = (lexo) in\n    let p = (lexical_env_alloc_decl s_2 lex) in\n    let (lex_2, s1) = p in\n    let c_2 = (execution_ctx_intro_same lex_2 vthis_2 str) in\n    let%void s2 = (execution_ctx_binding_inst s1 c_2 Coq_codetype_func\n      (Some lf) (funcbody_prog bd) args) in\n    run_call_default s2 c_2 lf)\n  in\n  if str\n  then follow s vthis\n  else (match vthis with\n      | Coq_value_undef ->\n        follow s (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_global))\n      | Coq_value_null ->\n        follow s (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_global))\n      | Coq_value_bool b -> let%value (s2, v) = (to_object s vthis) in follow s2 v\n      | Coq_value_number n -> let%value (s2, v) = (to_object s vthis) in follow s2 v\n      | Coq_value_string s0 -> let%value (s2, v) = (to_object s vthis) in follow s2 v\n      | Coq_value_object lthis -> follow s vthis)\n\n(** val run_object_get_own_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    full_descriptor specres **)\n\nand run_object_get_own_prop s c l x =\n  let%some b = (run_object_method object_get_own_prop_ s l) in\n  let def = (fun s_2 ->\n    let%some p = (run_object_method object_properties_ s_2 l) in\n    res_spec s_2 (ifx_some_or_default (convert_option_attributes (HeapStr.read_option p x))\n      Coq_full_descriptor_undef (fun x -> x))\n  ) in\n  match b with\n  | Coq_builtin_get_own_prop_default -> def s\n  | Coq_builtin_get_own_prop_args_obj ->\n    let%spec (s1, d) = (def s) in\n    begin\n      match d with\n      | Coq_full_descriptor_undef -> res_spec s1 Coq_full_descriptor_undef\n      | Coq_full_descriptor_some a ->\n        let%some lmapo = (run_object_method object_parameter_map_ s1 l) in\n        let%some lmap = (lmapo) in\n        let%spec (s2, d0) = (run_object_get_own_prop s1 c lmap x) in\n        let follow = (fun s_2 a0 -> res_spec s_2 (Coq_full_descriptor_some a0)) in\n        match d0 with\n        | Coq_full_descriptor_undef -> follow s2 a\n        | Coq_full_descriptor_some amap ->\n          let%value (s3, v) = (run_object_get s2 c lmap x) in\n          match a with\n          | Coq_attributes_data_of ad ->\n            follow s3 (Coq_attributes_data_of (attributes_data_with_value ad v))\n          | Coq_attributes_accessor_of aa ->\n            (Debug.impossible_with_heap_because __LOC__ s3\n              "[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens.";\n              Coq_result_impossible)\n    end\n  | Coq_builtin_get_own_prop_string ->\n    let%spec (s0, d) = def s in\n    (match d with\n    | Coq_full_descriptor_undef ->\n      let%spec (s1, k) = (to_int32 s0 c (Coq_value_string x)) in\n      let%string (s2, s3) = (to_string s1 c (Coq_value_number (JsNumber.absolute k))) in\n      if not (string_eq x s3)\n      then res_spec s2 Coq_full_descriptor_undef\n      else\n        let%string (s4, str) = (run_object_prim_value s2 l) in\n        let%spec (s5, k0) = (to_int32 s4 c (Coq_value_string x)) in\n        let len = (number_of_int (strlength str)) in\n        if le_int_decidable len k0\n        then res_spec s5 Coq_full_descriptor_undef\n        else\n          let resultStr = string_sub str (int_of_number k0) 1 (* TODO: check k0 is not negative *) in\n          let a = { attributes_data_value = (Coq_value_string resultStr);\n                    attributes_data_writable = false; attributes_data_enumerable = true;\n                    attributes_data_configurable = false } in\n          res_spec s5 (Coq_full_descriptor_some (Coq_attributes_data_of a))\n    | Coq_full_descriptor_some a -> res_spec s0 d)\n  | _ -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val run_function_has_instance :\n    state -> object_loc -> value -> result **)\n\nand run_function_has_instance s c lv _foo_ =\n  (match _foo_ with\n  | Coq_value_object lo ->\n    let%some vproto = (run_object_method object_proto_ s lv) in\n      (match vproto with\n        | Coq_value_null -> res_ter s (res_val (Coq_value_bool false))\n        | Coq_value_object proto ->\n          if object_loc_compare proto lo\n          then res_ter s (res_val (Coq_value_bool true))\n          else run_function_has_instance s c proto (Coq_value_object lo)\n        | _ -> (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("Primitive found in the prototype chain in [run_object_has_instance_loop]."))\n  | _ -> run_error s c Coq_native_error_type)\n\n(** val run_object_has_instance :\n    state -> execution_ctx -> builtin_has_instance -> object_loc\n    -> value -> result **)\n\nand run_object_has_instance s c b l v =\n  match b with\n  | Coq_builtin_has_instance_function ->\n    (match v with\n     | Coq_value_object lv ->\n       let%value (s1, vproto) = (run_object_get s c l ("prototype")) in\n       (match vproto with\n       | Coq_value_object lproto -> run_function_has_instance s1 c lv (Coq_value_object lproto)\n       | _ -> run_error s1 c Coq_native_error_type)\n     | _ -> res_out s (res_val (Coq_value_bool false)))\n  | Coq_builtin_has_instance_after_bind ->\n    let%some ol = run_object_method object_target_function_ s l in\n    let%some l0 = ol in\n    let%some ob = run_object_method object_has_instance_ s l0 in\n    match ob with\n    | Some b0 -> run_object_has_instance s c b0 l0 v\n    | None -> run_error s c Coq_native_error_type\n\n(** val from_prop_descriptor :\n    state -> execution_ctx -> full_descriptor -> result **)\n\nand from_prop_descriptor s c _foo_ = match _foo_ with\n  | Coq_full_descriptor_undef ->\n    res_out s (res_val Coq_value_undef)\n  | Coq_full_descriptor_some a ->\n    let%object (s1, l) = run_construct_prealloc s c Coq_prealloc_object [] in\n    let follow = (fun s0 x ->\n      let a1 = (attributes_data_intro_all_true (Coq_value_bool (attributes_enumerable a))) in\n      let%bool (s0_2, x0) = (object_define_own_prop s0 c l ("enumerable")\n        (descriptor_of_attributes (Coq_attributes_data_of a1)) throw_false) in\n      let a2 = (attributes_data_intro_all_true (Coq_value_bool (attributes_configurable a))) in\n      let%bool (s_2, x1) = (object_define_own_prop s0_2 c l ("configurable") (descriptor_of_attributes (Coq_attributes_data_of a2)) throw_false) in\n      res_ter s_2 (res_val (Coq_value_object l))) in\n    match a with\n    | Coq_attributes_data_of ad ->\n      let a1 = (attributes_data_intro_all_true ad.attributes_data_value) in\n      let%bool (s2, x) = (object_define_own_prop s1 c l ("value")\n        (descriptor_of_attributes (Coq_attributes_data_of a1)) throw_false) in\n      let a2 = (attributes_data_intro_all_true (Coq_value_bool ad.attributes_data_writable)) in\n      let%bool (s3, v) = (object_define_own_prop s2 c l ("writable")\n        (descriptor_of_attributes (Coq_attributes_data_of a2)) throw_false) in\n      follow s3 v\n    | Coq_attributes_accessor_of aa ->\n      let a1 = (attributes_data_intro_all_true aa.attributes_accessor_get) in\n      let%bool (s2, x) = (object_define_own_prop s1 c l ("get")\n        (descriptor_of_attributes (Coq_attributes_data_of a1)) throw_false) in\n      let a2 = (attributes_data_intro_all_true aa.attributes_accessor_set) in\n      let%bool (s3, v) = (object_define_own_prop s2 c l ("set")\n        (descriptor_of_attributes (Coq_attributes_data_of a2)) throw_false) in\n      follow s3 v\n\n(** val run_equal :\n    state -> execution_ctx -> value -> value -> result **)\n\nand run_equal s c v1 v2 =\n  let conv_number = fun s0 v -> to_number s0 c v in\n  let conv_primitive = fun s0 v -> to_primitive s0 c v None in\n  let checkTypesThen = (fun s0 v3 v4 k ->\n    let ty1 = type_of v3 in\n    let ty2 = type_of v4 in\n    if type_compare ty1 ty2\n    then res_out s0 (res_val (Coq_value_bool (equality_test_for_same_type ty1 v3 v4)))\n    else k ty1 ty2) in\n  checkTypesThen s v1 v2 (fun ty1 ty2 ->\n    let dc_conv = (fun v3 f v4 -> let%value (s0, v2_2) = (f s v4) in run_equal s0 c v3 v2_2) in\n    let so = fun b -> res_out s (res_val (Coq_value_bool b)) in\n    if (type_compare ty1 Coq_type_null) && (type_compare ty2 Coq_type_undef)\n    then so true\n    else if (type_compare ty1 Coq_type_undef) && (type_compare ty2 Coq_type_null)\n    then so true\n    else if (type_compare ty1 Coq_type_number) && (type_compare ty2 Coq_type_string)\n    then dc_conv v1 conv_number v2\n    else if (type_compare ty1 Coq_type_string) && (type_compare ty2 Coq_type_number)\n    then dc_conv v2 conv_number v1\n    else if type_compare ty1 Coq_type_bool\n    then dc_conv v2 conv_number v1\n    else if type_compare ty2 Coq_type_bool\n    then dc_conv v1 conv_number v2\n    else if ((type_compare ty1 Coq_type_string) || (type_compare ty1 Coq_type_number)) && (type_compare ty2 Coq_type_object)\n    then dc_conv v1 conv_primitive v2\n    else if (type_compare ty1 Coq_type_object) && ((type_compare ty2 Coq_type_string) || (type_compare ty2 Coq_type_number))\n    then dc_conv v2 conv_primitive v1\n    else so false)\n\n(** val convert_twice :\n    (\'a2 resultof -> (state -> \'a1 -> (\'a1 * \'a1) specres) -> (\'a1 * \'a1)\n    specres) -> (state -> value -> \'a2 resultof) -> state -> value -> value\n    -> (\'a1 * \'a1) specres **)\n\nand convert_twice :\n  \'a1 \'a2 . (\'a2 resultof -> (state -> \'a1 -> (\'a1 * \'a1) specres) -> (\'a1 * \'a1) specres) ->\n  (state -> value -> \'a2 resultof) -> state -> value -> value -> (\'a1 * \'a1) specres\n = fun ifv kC s v1 v2 ->\n    ifv (kC s v1) (fun s1 vc1 ->\n        ifv (kC s1 v2) (fun s2 vc2 -> res_spec s2 (vc1, vc2)))\n\n(** val convert_twice_primitive :\n    state -> execution_ctx -> value -> value -> (prim * prim)\n    specres **)\n\nand convert_twice_primitive s c v1 v2 =\n  convert_twice ifx_prim (fun s0 v -> to_primitive s0 c v None) s v1 v2\n\n(** val convert_twice_number :\n    state -> execution_ctx -> value -> value ->\n    (number * number) specres **)\n\nand convert_twice_number s c v1 v2 =\n  convert_twice ifx_number (fun s0 v -> to_number s0 c v) s v1 v2\n\n(** val convert_twice_string :\n    state -> execution_ctx -> value -> value ->\n    (string * string) specres **)\n\nand convert_twice_string s c v1 v2 =\n  convert_twice ifx_string (fun s0 v -> to_string s0 c v) s v1 v2\n\n(** val issome : \'a1 option -> bool **)\n\nand issome : \'a1 . \'a1 option -> bool = fun _foo_ ->\n  match _foo_ with\n  | Some t -> true\n  | None -> false\n\nand run_binary_op_add s c v1 v2 =\n  let%spec (s1, (w1, w2)) = (convert_twice_primitive s c v1 v2) in\n  if  (type_compare (type_of w1) Coq_type_string)\n   || (type_compare (type_of w2) Coq_type_string)\n  then let%spec (s2, (str1, str2)) = (convert_twice_string s1 c w1 w2) in\n    res_out s2 (res_val (Coq_value_string (strappend str1 str2)))\n  else let%spec (s2, (n1, n2)) = (convert_twice_number s1 c w1 w2) in\n    res_out s2 (res_val (Coq_value_number (n1 +. n2)))\n\nand run_binary_op_arith mathop s c v1 v2 =\n  let%spec (s1, nn) = (convert_twice_number s c v1 v2) in\n  let (n1, n2) = nn in\n  res_out s1 (res_val (Coq_value_number (mathop n1 n2)))\n\nand run_binary_op_shift b_unsigned mathop s c v1 v2 =\n  let conv = (if b_unsigned then to_uint32 else to_int32) in\n  let%spec (s1, k1) = (conv s c v1) in\n  let%spec (s2, k2) = (to_uint32 s1 c v2) in\n  let k2_2 = JsNumber.modulo_32 k2 in\n  res_ter s2 (res_val (Coq_value_number (mathop k1 k2_2)))\n\nand run_binary_op_bitwise mathop s c v1 v2 =\n  let%spec (s1, k1) = (to_int32 s c v1) in\n  let%spec (s2, k2) = (to_int32 s1 c v2) in\n  res_ter s2 (res_val (Coq_value_number (mathop k1 k2)))\n\nand run_binary_op_compare b_swap b_neg s c v1 v2 =\n  let%spec (s1, ww) = convert_twice_primitive s c v1 v2 in\n  let (w1, w2) = ww in\n  let p = if b_swap then (w2, w1) else (w1, w2) in\n  let (wa, wb) = p in\n  let wr = inequality_test_primitive wa wb in\n  if value_compare wr Coq_value_undef then res_out s1 (res_val (Coq_value_bool false))\n  else if (b_neg) && (value_compare wr (Coq_value_bool true))\n  then res_out s1 (res_val (Coq_value_bool false))\n  else if (b_neg) && (value_compare wr (Coq_value_bool false))\n  then res_out s1 (res_val (Coq_value_bool true))\n  else res_out s1 (res_val wr)\n\nand run_binary_op_instanceof s c v1 v2 =\n  match v2 with\n  | Coq_value_object l ->\n    let%some b = (run_object_method object_has_instance_ s l) in\n    (match b with\n    | None -> run_error s c Coq_native_error_type\n    | Some has_instance_id -> run_object_has_instance s c has_instance_id l v1)\n  | _ -> run_error s c Coq_native_error_type\n\nand run_binary_op_in s c v1 v2 =\n  match v2 with\n  | Coq_value_object l ->\n    let%string (s2, x) = (to_string s c v1) in\n    object_has_prop s2 c l x\n  | _ -> run_error s c Coq_native_error_type\n\n(** val run_binary_op :\n    state -> execution_ctx -> binary_op -> value -> value ->\n    result **)\n\nand run_binary_op s c op v1 v2 =\n  match op with\n  | Coq_binary_op_mult -> run_binary_op_arith (fun x y -> x *. y) s c v1 v2\n  | Coq_binary_op_div -> run_binary_op_arith (fun x y -> x /. y) s c v1 v2\n  | Coq_binary_op_mod -> run_binary_op_arith (fun x y -> JsNumber.fmod x y) s c v1 v2\n  | Coq_binary_op_sub -> run_binary_op_arith (fun x y -> x -. y) s c v1 v2\n  | Coq_binary_op_lt -> run_binary_op_compare false false s c v1 v2\n  | Coq_binary_op_gt -> run_binary_op_compare true false s c v1 v2\n  | Coq_binary_op_le -> run_binary_op_compare true true s c v1 v2\n  | Coq_binary_op_ge -> run_binary_op_compare false true s c v1 v2\n  | Coq_binary_op_left_shift -> run_binary_op_shift false JsNumber.int32_left_shift s c v1 v2\n  | Coq_binary_op_right_shift -> run_binary_op_shift false JsNumber.int32_right_shift s c v1 v2\n  | Coq_binary_op_unsigned_right_shift -> run_binary_op_shift true JsNumber.uint32_right_shift s c v1 v2\n  | Coq_binary_op_bitwise_and -> run_binary_op_bitwise JsNumber.int32_bitwise_and s c v1 v2\n  | Coq_binary_op_bitwise_or  -> run_binary_op_bitwise JsNumber.int32_bitwise_or s c v1 v2\n  | Coq_binary_op_bitwise_xor -> run_binary_op_bitwise JsNumber.int32_bitwise_xor s c v1 v2\n  | Coq_binary_op_add -> run_binary_op_add s c v1 v2\n  | Coq_binary_op_instanceof -> run_binary_op_instanceof s c v1 v2\n  | Coq_binary_op_in -> run_binary_op_in s c v1 v2\n  | Coq_binary_op_equal -> run_equal s c v1 v2\n  | Coq_binary_op_disequal ->\n    let%bool (s0, b0) = (run_equal s c v1 v2) in\n    res_ter s0 (res_val (Coq_value_bool (not b0)))\n  | Coq_binary_op_strict_equal ->\n    res_out s (res_val (Coq_value_bool (strict_equality_test v1 v2)))\n  | Coq_binary_op_strict_disequal ->\n    res_out s (res_val (Coq_value_bool (not (strict_equality_test v1 v2))))\n  | Coq_binary_op_coma -> res_out s (res_val v2)\n  | Coq_binary_op_and -> Coq_result_impossible\n  | Coq_binary_op_or  -> Coq_result_impossible\n\n(** val run_prepost_op : unary_op -> ((number -> number) * bool) option **)\n\nand run_prepost_op _foo_ = match _foo_ with\n  | Coq_unary_op_delete -> None\n  | Coq_unary_op_void -> None\n  | Coq_unary_op_typeof -> None\n  | Coq_unary_op_post_incr -> Some (add_one, false)\n  | Coq_unary_op_post_decr -> Some (sub_one, false)\n  | Coq_unary_op_pre_incr -> Some (add_one, true)\n  | Coq_unary_op_pre_decr -> Some (sub_one, true)\n  | Coq_unary_op_add -> None\n  | Coq_unary_op_neg -> None\n  | Coq_unary_op_bitwise_not -> None\n  | Coq_unary_op_not -> None\n\n(** val run_typeof_value : state -> value -> string **)\n\nand run_typeof_value s _foo_ =\n  match _foo_ with\n  | Coq_value_object l ->\n    if is_callable_dec s (Coq_value_object l)\n    then "function"\n    else "object"\n  | _ -> typeof_prim _foo_\n\n(** val run_unary_op :\n    state -> execution_ctx -> unary_op -> expr -> result **)\n\nand run_unary_op s c op e =\n  if prepost_unary_op_dec op\n  then\n    let%success (s1, rv1)= run_expr s c e in\n    let%spec (s2, v2) = ref_get_value s1 c rv1 in\n    let%number (s3, n1) = to_number s2 c v2 in\n    let%some po = run_prepost_op op in\n    let (number_op, is_pre) = po in\n    let n2 = number_op n1 in\n    let v = Coq_value_number (if is_pre then n2 else n1) in\n    let%void s4 = ref_put_value s3 c rv1 (Coq_value_number n2) in\n    res_out s4 (res_val v)\n  else (match op with\n      | Coq_unary_op_delete ->\n        let%success (s0, rv)= (run_expr s c e) in begin\n            match rv with\n            | Coq_resvalue_empty ->\n              res_ter s0 (res_val (Coq_value_bool true))\n            | Coq_resvalue_value v ->\n              res_ter s0 (res_val (Coq_value_bool true))\n            | Coq_resvalue_ref r ->\n              if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_undef\n              then if r.ref_strict\n                then run_error s0 c Coq_native_error_syntax\n                else res_ter s0\n                    (res_val (Coq_value_bool true))\n              else (match r.ref_base with\n                  | Coq_ref_base_type_value v ->\n                    let%object (s1, l) = (to_object s0 v) in\n                        object_delete s1 c l r.ref_name\n                          r.ref_strict\n                  | Coq_ref_base_type_env_loc l ->\n                    if r.ref_strict\n                    then run_error s0 c Coq_native_error_syntax\n                    else env_record_delete_binding s0 c l r.ref_name)\n        end\n      | Coq_unary_op_typeof ->\n        let%success (s1, rv)= (run_expr s c e) in begin\n            match rv with\n            | Coq_resvalue_empty ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s1\n                ("Empty result for a `typeof\\\' in [run_unary_op].")\n            | Coq_resvalue_value v ->\n              res_ter s1\n                (res_val (Coq_value_string (run_typeof_value s1 v)))\n            | Coq_resvalue_ref r ->\n              if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_undef\n              then res_ter s1\n                  (res_val (Coq_value_string ("undefined")))\n              else let%spec \n                  (s2, v) = (ref_get_value s1 c (Coq_resvalue_ref r)) in\n                     res_ter s2\n                       (res_val (Coq_value_string (run_typeof_value s2 v)))\n        end\n      | _ ->\n        let%spec (s1, v) = (run_expr_get_value s c e) in\n            match op with\n            | Coq_unary_op_void ->\n              res_ter s1 (res_val Coq_value_undef)\n            | Coq_unary_op_add -> to_number s1 c v\n            | Coq_unary_op_neg ->\n              let%number (s2, n) = (to_number s1 c v) in\n                  res_ter s2\n                    (res_val (Coq_value_number (JsNumber.neg n)))\n            | Coq_unary_op_bitwise_not ->\n              let%spec (s2, k) = (to_int32 s1 c v) in\n                  res_ter s2\n                    (res_val (Coq_value_number (JsNumber.int32_bitwise_not k)))\n            | Coq_unary_op_not ->\n              res_ter s1\n                (res_val (Coq_value_bool (not (to_boolean v))))\n            | _ ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s1\n                ("Undealt regular operator in [run_unary_op]."))\n\n(** val create_new_function_in :\n    state -> execution_ctx -> string list -> funcbody ->\n    result **)\n\nand create_new_function_in s c args bd =\n  creating_function_object s c args bd c.execution_ctx_lexical_env\n    c.execution_ctx_strict\n\n(** val init_object :\n    state -> execution_ctx -> object_loc -> propdefs -> result **)\n\nand init_object s c l _foo_ = match _foo_ with\n  | [] -> res_out s (res_val (Coq_value_object l))\n  | p :: pds_2 ->\n    let (pn, pb) = p in\n    let  x = (string_of_propname pn) in\n        let  follows = (fun s1 desc ->\n            let%success \n              (s2, rv) = (object_define_own_prop s1 c l x desc false) in  init_object s2 c l pds_2) in\n            match pb with\n            | Coq_propbody_val e0 ->\n              let%spec (s1, v0) = (run_expr_get_value s c e0) in\n                  let desc = { descriptor_value = (Some v0); descriptor_writable =\n                                                               (Some true); descriptor_get = None; descriptor_set = None;\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n            | Coq_propbody_get bd ->\n              let%value (s1, v0) = (create_new_function_in s c [] bd) in\n                  let desc = { descriptor_value = None; descriptor_writable = None;\n                               descriptor_get = (Some v0); descriptor_set = None;\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n            | Coq_propbody_set (args, bd) ->\n              let%value (s1, v0) = (create_new_function_in s c args bd) in\n                  let desc = { descriptor_value = None; descriptor_writable = None;\n                               descriptor_get = None; descriptor_set = (Some v0);\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n\n(** val run_array_element_list :\n    state -> execution_ctx -> object_loc -> expr option list ->\n    float -> result **)\n\nand run_array_element_list s c l oes n =\n  match oes with\n  | [] -> res_out s (res_val (Coq_value_object l))\n  | o :: oes_2 ->\n    (match o with\n     | Some e ->\n       let \n         loop_result = (fun s0 ->\n           run_array_element_list s0 c l oes_2 0.) in\n            let%spec (s0, v) = (run_expr_get_value s c e) in\n                let%value\n                   (s1, vlen) = (run_object_get s0 c l\n                     ("length")) in\n                      let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n                          let%string\n                             (s3, slen) = (to_string s2 c (Coq_value_number (ilen +. n))) in\n                                let  desc = ({ attributes_data_value = v;\n                                              attributes_data_writable = true;\n                                              attributes_data_enumerable = true;\n                                              attributes_data_configurable = true }) in\n                                    let%bool\n                                       (s4, x) = (object_define_own_prop s3 c l slen\n                                         (descriptor_of_attributes (Coq_attributes_data_of\n                                                                      desc)) false) in\n                                          let%object (s5, l0) = (loop_result s4) in\n                                              res_ter s5 (res_val (Coq_value_object l0))\n     | None ->\n       let  firstIndex = (elision_head_count (None :: oes_2)) in\n           run_array_element_list s c l\n             (elision_head_remove (None :: oes_2)) (number_of_int firstIndex))\n\n(** val init_array :\n    state -> execution_ctx -> object_loc -> expr option list ->\n    result **)\n\nand init_array s c l oes =\n  let elementList = (elision_tail_remove oes) in\n  let elisionLength = (elision_tail_count oes) in\n  let%object (s0, l0) = (run_array_element_list s c l elementList 0.) in\n  let%value (s1, vlen) = (run_object_get s0 c l0 ("length")) in\n  let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n  let%spec (s3, len) = (to_uint32 s2 c (Coq_value_number (ilen +. number_of_int elisionLength))) in\n  let%not_throw (s4, x) = (object_put s3 c l0 ("length") (Coq_value_number len) throw_false) in\n  res_out s4 (res_val (Coq_value_object l0))\n\n(** val run_var_decl_item :\n    state -> execution_ctx -> prop_name -> expr option -> result **)\n\nand run_var_decl_item s c x _foo_ = match _foo_ with\n  | Some e ->\n    let%spec (s1, ir) = (identifier_resolution s c x) in\n    let%spec (s2, v) = (run_expr_get_value s1 c e) in\n    let%void s3 = (ref_put_value s2 c (Coq_resvalue_ref ir) v) in\n    res_out s3 (res_val (Coq_value_string x))\n  | None ->\n    res_out s (res_val (Coq_value_string x))\n\n(** val run_var_decl :\n    state -> execution_ctx -> (prop_name * expr option) list ->\n    result **)\n\nand run_var_decl s c _foo_ = match _foo_ with\n  | [] -> res_out s res_empty\n  | y :: xeos_2 ->\n    let (x, eo) = y in\n    let%value (s1, vname) = (run_var_decl_item s c x eo) in\n        run_var_decl s1 c xeos_2\n\n(** val run_list_expr :\n    state -> execution_ctx -> value list -> expr list -> value\n    list specres **)\n\nand run_list_expr s1 c vs _foo_ = match _foo_ with\n  | [] -> res_spec s1 (rev vs)\n  | e :: es_2 ->\n    let%spec (s2, v) = (run_expr_get_value s1 c e) in\n        run_list_expr s2 c (v :: vs) es_2\n\n(** val run_block :\n    state -> execution_ctx -> stat list -> result **)\n\nand run_block s c _foo_ = match _foo_ with\n  | [] -> res_ter s (res_normal Coq_resvalue_empty)\n  | t :: ts_rev_2 ->\n    let%success (s0, rv0)= (run_block s c ts_rev_2) in\n      ifx_success_state rv0 (run_stat s0 c t) (fun x x0 -> res_out x (res_normal x0))\n\nand run_binary_op_and s c e1 e2 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n  let b1 = (to_boolean v1) in\n  if not b1\n    then res_ter s1 (res_val v1)\n    else let%spec (s2, v) = (run_expr_get_value s1 c e2) in\n    res_ter s2 (res_val v)\n\nand run_binary_op_or s c e1 e2 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n  let b1 = (to_boolean v1) in\n  if b1 \n    then res_ter s1 (res_val v1)\n    else let%spec (s2, v) = (run_expr_get_value s1 c e2) in\n    res_ter s2 (res_val v)\n\n(** val run_expr_binary_op :\n    state -> execution_ctx -> binary_op -> expr -> expr ->\n    result **)\n\nand run_expr_binary_op s c op e1 e2 =\n  match op with\n  | Coq_binary_op_and -> run_binary_op_and s c e1 e2\n  | Coq_binary_op_or -> run_binary_op_or s c e1 e2\n  | _ ->\n    let%spec (s1,v1) = run_expr_get_value s c e1 in\n    let%spec (s2,v2) = run_expr_get_value s1 c e2 in\n    run_binary_op s2 c op v1 v2\n\n(** val run_expr_access :\n    state -> execution_ctx -> expr -> expr -> result **)\n\n(* TODO DEPRECATEd\n   and run_expr_access s c e1 e2 =\n   let%spec (s1, v1) = (run_expr_get_value s c e1) in\n    let%spec (s2, v2) = (run_expr_get_value s1 c e2) in\n      if or_decidable (value_compare v1 Coq_value_undef)\n           (value_compare v1 Coq_value_null)\n      then run_error s2 Coq_native_error_type\n      else let%string (s3, x) = (to_string s2 c v2) in\n             res_ter s3\n               (res_ref (ref_create_value v1 x c.execution_ctx_strict))\n*)\n\nand run_expr_access s c e1 e2 =\n  let%spec (s1,v1) = run_expr_get_value s c e1 in\n  let%spec (s2,v2) = run_expr_get_value s1 c e2 in\n  if    (value_compare v1 Coq_value_undef)\n     || (value_compare v1 Coq_value_null)\n  then run_error s2 c Coq_native_error_type\n  else let%string (s3,x) = to_string s2 c v2 in\n    res_ter s3 (res_ref (ref_create_value v1 x c.execution_ctx_strict))\n\n(** val run_expr_assign :\n    state -> execution_ctx -> binary_op option -> expr -> expr\n    -> result **)\n\nand run_expr_assign s c opo e1 e2 =\n  let%success (s1, rv1)= (run_expr s c e1) in\n  let follow = (fun s0 rv_2 ->\n    match rv_2 with\n    | Coq_resvalue_value v ->\n      let%void s_2= (ref_put_value s0 c rv1 v) in\n      res_out s_2 (res_val v)\n    | Coq_resvalue_empty ->\n      Debug.impossible_with_heap_because __LOC__ s0 "Non-value result in [run_expr_assign]."; Coq_result_impossible\n    | Coq_resvalue_ref r ->\n      Debug.impossible_with_heap_because __LOC__ s "Non-value result in [run_expr_assign]."; Coq_result_impossible\n    ) in\n  match opo with\n  | Some op ->\n    let%spec (s2, v1) = (ref_get_value s1 c rv1) in\n    let%spec (s3, v2) = (run_expr_get_value s2 c e2) in\n    let%success (s4, v) = (run_binary_op s3 c op v1 v2) in\n    follow s4 v\n  | None ->\n    let%spec (x, x0 )= (run_expr_get_value s1 c e2) in\n    follow x (Coq_resvalue_value x0)\n\n(** val run_expr_function :\n    state -> execution_ctx -> prop_name option -> string list\n    -> funcbody -> result **)\n\nand run_expr_function s c fo args bd =\n  match fo with\n  | Some fn ->\n    let p = (lexical_env_alloc_decl s c.execution_ctx_lexical_env) in\n    let (lex_2, s_2) = p in\n    let follow = fun l ->\n      let%some e = (env_record_binds_option s_2 l) in\n      let%void s1 = (env_record_create_immutable_binding s_2 l fn) in\n      let%object (s2, l0) = (creating_function_object s1 c args bd lex_2 (funcbody_is_strict bd)) in\n      let%void s3 = (env_record_initialize_immutable_binding s2 l fn (Coq_value_object l0)) in\n      res_out s3 (res_val (Coq_value_object l0))\n    in destr_list lex_2\n      (fun x -> Debug.impossible_with_heap_because __LOC__ s "Empty lexical environnment allocated in [run_expr_function]."; Coq_result_impossible)\n      (fun l x -> follow l) ()\n  | None ->\n    let lex = c.execution_ctx_lexical_env in\n    creating_function_object s c args bd lex (funcbody_is_strict bd)\n\n(** val entering_eval_code :\n    state -> execution_ctx -> bool -> funcbody -> (state ->\n    execution_ctx -> result) -> result **)\n\nand entering_eval_code s c direct bd k =\n  let str = ((funcbody_is_strict bd) || (direct && c.execution_ctx_strict)) in\n       let c_2 = (if direct then c else execution_ctx_initial str) in\n           let p = (if str\n              then lexical_env_alloc_decl s c_2.execution_ctx_lexical_env\n              else (c_2.execution_ctx_lexical_env, s)) in\n                 let (lex, s_2) = p in\n                 let c1 = (if str then execution_ctx_with_lex_same c_2 lex else c_2) in\n                      let p0 = (funcbody_prog bd) in\n                          let%void\n                             s1 = (execution_ctx_binding_inst s_2 c1 Coq_codetype_eval None\n                               p0 []) in  k s1 c1\n\n(** val run_eval :\n    state -> execution_ctx -> bool -> value list -> result **)\n\nand run_eval s c is_direct_call vs =\n  match get_arg 0 vs with\n  | Coq_value_undef ->\n    res_out s (res_val Coq_value_undef)\n  | Coq_value_null ->\n    res_out s (res_val Coq_value_null)\n  | Coq_value_bool b ->\n    res_out s (res_val (Coq_value_bool b))\n  | Coq_value_number n ->\n    res_out s (res_val (Coq_value_number n))\n  | Coq_value_string s0 ->\n    let str = (is_direct_call && c.execution_ctx_strict) in\n    (match parse_pickable s0 str with\n    | Some p0 ->\n       entering_eval_code s c is_direct_call (Coq_funcbody_intro (p0, s0))\n         (fun s1 c_2 ->\n           let%ter (s2, r) = (run_prog s1 c_2 p0) in\n           match r.res_type with\n           | Coq_restype_normal ->\n             ifx_empty_label s2 r (fun x ->\n               match r.res_value with\n               | Coq_resvalue_empty -> res_ter s2 (res_val Coq_value_undef)\n               | Coq_resvalue_value v -> res_ter s2 (res_val v)\n               | Coq_resvalue_ref r0 -> (Debug.impossible_with_heap_because __LOC__ s2\n                   "Reference found in the result of an `eval\\\' in [run_eval]."; Coq_result_impossible))\n           | Coq_restype_throw -> res_ter s2 (res_throw r.res_value)\n           | _ -> (Debug.impossible_with_heap_because __LOC__ s2\n               "Forbidden result type returned by an `eval\\\' in [run_eval]."; Coq_result_impossible))\n    | None -> run_error s c Coq_native_error_syntax)\n  | Coq_value_object o ->\n    res_out s (res_val (Coq_value_object o))\n\n(** val run_expr_call :\n    state -> execution_ctx -> expr -> expr list -> result **)\n\nand run_expr_call s c e1 e2s =\n  let is_eval_direct = (is_syntactic_eval e1) in\n  let%success (s1, rv)= (run_expr s c e1) in\n  let%spec (s2, f) = (ref_get_value s1 c rv) in\n  let%spec (s3, vs) = (run_list_expr s2 c [] e2s) in\n  match f with\n  | Coq_value_object l ->\n    if is_callable_dec s3 (Coq_value_object l)\n    then let  follow = (fun vthis ->\n        if object_loc_compare l (Coq_object_loc_prealloc\n                                      Coq_prealloc_global_eval)\n        then run_eval s3 c is_eval_direct vs\n        else run_call s3 c l vthis vs) in\n        match rv with\n        | Coq_resvalue_empty ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s3\n            ("[run_expr_call] unable to call an  empty result.")\n        | Coq_resvalue_value v ->\n          follow Coq_value_undef\n        | Coq_resvalue_ref r ->\n          (match r.ref_base with\n           | Coq_ref_base_type_value v ->\n             if   (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base)\n               || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_null)\n               || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_object)\n             then follow v\n             else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                 s3\n                 ("[run_expr_call] unable to call a non-property function.")\n           | Coq_ref_base_type_env_loc l0 ->\n             let%some v = (env_record_implicit_this_value s3 l0) in  follow v)\n    else run_error s3 c Coq_native_error_type\n  | _ -> run_error s3 c Coq_native_error_type\n\n(** val run_expr_conditionnal :\n    state -> execution_ctx -> expr -> expr -> expr -> result **)\n\nand run_expr_conditionnal s c e1 e2 e3 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n      let  b = (to_boolean v1) in\n          let  e = (if b then e2 else e3) in\n              let%spec (s0, r) = (run_expr_get_value s1 c e) in\n                  res_ter s0 (res_val r)\n\n(** val run_expr_new :\n    state -> execution_ctx -> expr -> expr list -> result **)\n\nand run_expr_new s c e1 e2s =\n  let%spec (s1, v) = (run_expr_get_value s c e1) in\n  let%spec (s2, args) = (run_list_expr s1 c [] e2s) in\n  match v with\n  | Coq_value_object l ->\n    let%some coo = (run_object_method object_construct_ s2 l) in\n    (match coo with\n    | Some co -> run_construct s2 c co l args\n    | None -> run_error s2 c Coq_native_error_type)\n  | _ -> run_error s2 c Coq_native_error_type\n\n(** val run_stat_label :\n    state -> execution_ctx -> label -> stat -> result **)\n\nand run_stat_label s c lab t =\n  let%break (s1, r1) = run_stat s c t in\n  res_out s1 (if label_compare r1.res_label lab then res_normal r1.res_value else r1)\n\n(** val run_stat_with :\n    state -> execution_ctx -> expr -> stat -> result **)\n\nand run_stat_with s c e1 t2 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n      let%object (s2, l) = (to_object s1 v1) in\n          let  lex = (c.execution_ctx_lexical_env) in\n              let \n                p = (lexical_env_alloc_object s2 lex l provide_this_true) in\n                   let (lex_2, s3) = p in\n                   let  c_2 = (execution_ctx_with_lex c lex_2) in\n                       run_stat s3 c_2 t2\n\n(** val run_stat_if :\n    state -> execution_ctx -> expr -> stat -> stat option ->\n    result **)\n\nand run_stat_if s c e1 t2 to0 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n  let b = (to_boolean v1) in\n  if b\n  then run_stat s1 c t2\n  else (match to0 with\n    | Some t3 -> run_stat s1 c t3\n    | None -> res_out s1 (res_normal Coq_resvalue_empty))\n\n(** val run_stat_while :\n    state -> execution_ctx -> resvalue -> label_set -> expr ->\n    stat -> result **)\n\nand run_stat_while s c rv labs e1 t2 =\n  let%spec (s1, v1) = (run_expr_get_value s c e1) in\n      let  b = (to_boolean v1) in\n          if b\n          then let%ter (s2, r) = (run_stat s1 c t2) in\n              let\n                 rv_2 = (if not\n                    (resvalue_compare r.res_value Coq_resvalue_empty)\n                 then r.res_value\n                 else rv) in\n                    let  loop = (fun x ->\n                        run_stat_while s2 c rv_2 labs e1 t2) in\n                        if  (not (restype_compare r.res_type Coq_restype_continue))\n                         || (not (res_label_in r labs))\n                        then if \n                             (restype_compare r.res_type Coq_restype_break)\n                           && (res_label_in r labs)\n                          then res_ter s2 (res_normal rv_2)\n                          else if not\n                              (restype_compare r.res_type\n                                 Coq_restype_normal)\n                          then res_ter s2 r\n                          else loop ()\n                        else loop ()\n          else res_ter s1 (res_normal rv)\n\n(** val run_stat_switch_end :\n    state -> execution_ctx -> resvalue -> switchclause list ->\n    result **)\n\nand run_stat_switch_end s c rv _foo_ = match _foo_ with\n  | [] -> res_out s (res_normal rv)\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      ifx_success_state rv (run_block s c (rev ts)) (fun s1 rv1 ->\n          run_stat_switch_end s1 c rv1 scs_2)\n\n(** val run_stat_switch_no_default :\n    state -> execution_ctx -> value -> resvalue -> switchclause\n    list -> result **)\n\nand run_stat_switch_no_default s c vi rv _foo_ = match _foo_ with\n  | [] -> res_out s (res_normal rv)\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let%spec (s1, v1) = (run_expr_get_value s c e) in\n          let  b = (strict_equality_test v1 vi) in\n              if b\n              then let%success (s2, rv2)= (run_block s1 c (rev ts)) in\n                  run_stat_switch_end s2 c rv2 scs_2\n              else run_stat_switch_no_default s1 c vi rv scs_2\n\n(** val run_stat_switch_with_default_default :\n    state -> execution_ctx -> stat list -> switchclause list ->\n    result **)\n\nand run_stat_switch_with_default_default s c ts scs =\n  let%success (s1, rv)= (run_block s c (rev ts)) in\n      run_stat_switch_end s1 c rv scs\n\n(** val run_stat_switch_with_default_B :\n    state -> execution_ctx -> value -> resvalue -> stat list ->\n    switchclause list -> result **)\n\nand run_stat_switch_with_default_B s c vi rv ts0 scs = match scs with\n  | [] -> run_stat_switch_with_default_default s c ts0 scs\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let%spec (s1, v1) = (run_expr_get_value s c e) in\n          let  b = (strict_equality_test v1 vi) in\n              if b\n              then let%success (s2, rv2)= (run_block s1 c (rev ts)) in\n                  run_stat_switch_end s2 c rv2 scs_2\n              else run_stat_switch_with_default_B s1 c vi rv ts0 scs_2\n\n(** val run_stat_switch_with_default_A :\n    state -> execution_ctx -> bool -> value -> resvalue ->\n    switchclause list -> stat list -> switchclause list -> result **)\n\nand run_stat_switch_with_default_A s c found vi rv scs1 ts0 scs2 =\n  match scs1 with\n  | [] ->\n    if found\n    then run_stat_switch_with_default_default s c ts0 scs2\n    else run_stat_switch_with_default_B s c vi rv ts0 scs2\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let \n        follow = (fun s0 ->\n          ifx_success_state rv (run_block s0 c (rev ts)) (fun s1 rv0 ->\n              run_stat_switch_with_default_A s1 c true vi rv0 scs_2 ts0 scs2)) in\n           if found\n           then follow s\n           else let%spec (s1, v1) = (run_expr_get_value s c e) in\n               let  b = (strict_equality_test v1 vi) in\n                   if b\n                   then follow s1\n                   else run_stat_switch_with_default_A s1 c false vi rv\n                       scs_2 ts0 scs2\n\n(** val run_stat_switch :\n    state -> execution_ctx -> label_set -> expr -> switchbody ->\n    result **)\n\n(* ALTERNATIVE VERSION, WITH LESS FACTORIZATION\nand run_stat_switch s c labs e sb =\n  let%spec (s1, vi) = run_expr_get_value s c e in\n  match sb with\n  | Coq_switchbody_nodefault scs ->\n    let%success (s0, r) = begin\n      let%break (s2, r) =\n        run_stat_switch_no_default s1 c vi \n        Coq_resvalue_empty scs in\n      if res_label_in r labs\n      then res_out s2 (res_normal r.res_value)\n      else res_out s2 r\n      end in\n    res_ter s0 (res_normal r)\n  | Coq_switchbody_withdefault (scs1, ts, scs2) ->\n    let%success (s0, r) = begin\n      let%break (s2, r) = \n        run_stat_switch_with_default_A s1 c false vi\n         Coq_resvalue_empty scs1 ts scs2 in\n      if res_label_in r labs\n      then res_out s2 (res_normal r.res_value)\n      else res_out s2 r end in\n    res_ter s0 (res_normal r)\n*)\n\nand run_stat_switch s c labs e sb =\n  let%spec (s1, vi) = run_expr_get_value s c e in\n  let  follow = (fun w ->\n    let%success (s0, r) =\n      let%break (s2, r) = w in\n      if res_label_in r labs\n      then res_out s2 (res_normal r.res_value)\n      else res_out s2 r in\n    res_ter s0 (res_normal r)) in\n  match sb with\n  | Coq_switchbody_nodefault scs ->\n    follow (run_stat_switch_no_default s1 c vi \n              Coq_resvalue_empty scs)\n  | Coq_switchbody_withdefault (scs1, ts, scs2) ->\n    follow (run_stat_switch_with_default_A s1 c false vi\n              Coq_resvalue_empty scs1 ts scs2)\n\n(** val run_stat_do_while :\n    state -> execution_ctx -> resvalue -> label_set -> expr ->\n    stat -> result **)\n\nand run_stat_do_while s c rv labs e1 t2 =\n  let%ter (s1, r) = (run_stat s c t2) in\n      let\n         rv_2 = (if resvalue_compare r.res_value Coq_resvalue_empty\n         then rv\n         else r.res_value) in\n            let  loop = (fun x ->\n                let%spec (s2, v1) = (run_expr_get_value s1 c e1) in\n                    let  b = (to_boolean v1) in\n                        if b\n                        then run_stat_do_while s2 c rv_2 labs e1 t2\n                        else res_ter s2 (res_normal rv_2)) in\n                if  (restype_compare r.res_type Coq_restype_continue)\n                   && (res_label_in r labs)\n                then loop ()\n                else if \n                    (restype_compare r.res_type Coq_restype_break)\n                 && (res_label_in r labs)\n                then res_ter s1 (res_normal rv_2)\n                else if not\n                    (restype_compare r.res_type Coq_restype_normal)\n                then res_ter s1 r\n                else loop ()\n\n(** val run_stat_try :\n    state -> execution_ctx -> stat -> (prop_name * stat) option\n    -> stat option -> result **)\n\nand run_stat_try s c t1 t2o t3o =\n  let  finallycont = (fun s1 r ->\n      match t3o with\n      | Some t3 ->\n        let%success (s2, rv_2) = (run_stat s1 c t3) in  res_ter s2 r\n      | None -> res_ter s1 r) in\n      ifx_any_or_throw (run_stat s c t1) finallycont (fun s1 v ->\n          match t2o with\n          | Some y ->\n            let (x, t2) = y in\n            let  lex = (c.execution_ctx_lexical_env) in\n                let  p = (lexical_env_alloc_decl s1 lex) in\n                    let (lex_2, s_2) = p in\n                    (match lex_2 with\n                     | [] ->\n                       (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                         s_2\n                         ("Empty lexical environnment in [run_stat_try].")\n                     | l :: oldlex ->\n                       let%void\n                          s2= (env_record_create_set_mutable_binding s_2 c l x None v\n                            throw_irrelevant) in\n                             let c_2 = execution_ctx_with_lex c lex_2 in\n                             let%ter (s3, r) = (run_stat s2 c_2 t2) in finallycont s3 r)\n          | None -> finallycont s1 (res_throw (Coq_resvalue_value v)))\n\n(** val run_stat_throw :\n    state -> execution_ctx -> expr -> result **)\n\nand run_stat_throw s c e =\n  let%spec (s1, v1) = (run_expr_get_value s c e) in\n      res_ter s1 (res_throw (Coq_resvalue_value v1))\n\n(** val run_stat_return :\n    state -> execution_ctx -> expr option -> result **)\n\nand run_stat_return s c _foo_ = match _foo_ with\n  | Some e ->\n      let%spec (s1, v1) = (run_expr_get_value s c e) in\n      res_ter s1 (res_return (Coq_resvalue_value v1))\n  | None ->\n      res_out s (res_return (Coq_resvalue_value Coq_value_undef))\n\n(** val run_stat_for_loop :\n    state -> execution_ctx -> label_set -> resvalue -> expr\n    option -> expr option -> stat -> result **)\n\nand run_stat_for_loop s c labs rv eo2 eo3 t =\n  let  follows = (fun s0 ->\n      let%ter (s1, r) = (run_stat s0 c t) in\n          let\n             rv_2 = (if not\n                (resvalue_compare r.res_value Coq_resvalue_empty)\n             then r.res_value\n             else rv) in\n                let  loop = (fun s2 ->\n                    run_stat_for_loop s2 c labs rv_2 eo2 eo3 t) in\n                    if   (restype_compare r.res_type Coq_restype_break)\n                      && (res_label_in r labs)\n                    then res_ter s1 (res_normal rv_2)\n                    else if \n                         (restype_compare r.res_type Coq_restype_normal)\n                      || (    (restype_compare r.res_type Coq_restype_continue)\n                           && (res_label_in r labs))\n                    then (match eo3 with\n                        | Some e3 ->\n                          let%spec \n                            (s2, v3) = (run_expr_get_value s1 c e3) in loop s2\n                        | None -> loop s1)\n                    else res_ter s1 r) in\n      match eo2 with\n      | Some e2 ->\n        let%spec (s0, v2) = (run_expr_get_value s c e2) in\n            let  b = (to_boolean v2) in\n                if b then follows s0 else res_ter s0 (res_normal rv)\n      | None -> follows s\n\n(** val run_stat_for :\n    state -> execution_ctx -> label_set -> expr option -> expr\n    option -> expr option -> stat -> result **)\n\nand run_stat_for s c labs eo1 eo2 eo3 t =\n  let follows = fun s0 ->\n    run_stat_for_loop s0 c labs Coq_resvalue_empty eo2 eo3 t\n  in\n  (match eo1 with\n   | Some e1 ->\n     let%spec (s0, v1) = (run_expr_get_value s c e1) in follows s0\n   | None -> follows s)\n\n(** val run_stat_for_var :\n    state -> execution_ctx -> label_set -> (string * expr\n    option) list -> expr option -> expr option -> stat -> result **)\n\nand run_stat_for_var s c labs ds eo2 eo3 t =\n  let%ter (s0, r) = (run_stat s c (Coq_stat_var_decl ds)) in\n      run_stat_for_loop s0 c labs Coq_resvalue_empty eo2 eo3 t\n\n(** val run_expr : state -> execution_ctx -> expr -> result **)\n\nand run_expr s c _term_ = match _term_ with\n  | Coq_expr_this ->\n    res_out s (res_val c.execution_ctx_this_binding)\n  | Coq_expr_identifier x ->\n    let%spec (s0, r) = (identifier_resolution s c x) in\n    res_ter s0 (res_ref r)\n  | Coq_expr_literal i ->\n    res_out s (res_val (convert_literal_to_prim i))\n  | Coq_expr_object pds ->\n    let%object (s1, l) = run_construct_prealloc s c Coq_prealloc_object [] in\n    init_object s1 c l pds\n  | Coq_expr_array oes ->\n    let%object (s1, l) = run_construct_prealloc s c Coq_prealloc_array [] in\n    init_array s1 c l oes\n  | Coq_expr_function (fo, args, bd) -> run_expr_function s c fo args bd\n  | Coq_expr_access (e1, e2) -> run_expr_access s c e1 e2\n  | Coq_expr_member (e1, f) ->\n    run_expr s c (Coq_expr_access (e1, (Coq_expr_literal\n                                          (Coq_literal_string f))))\n  | Coq_expr_new (e1, e2s) -> run_expr_new s c e1 e2s\n  | Coq_expr_call (e1, e2s) -> run_expr_call s c e1 e2s\n  | Coq_expr_unary_op (op, e0) -> run_unary_op s c op e0\n  | Coq_expr_binary_op (e1, op, e2) -> run_expr_binary_op s c op e1 e2\n  | Coq_expr_conditional (e1, e2, e3) ->\n    run_expr_conditionnal s c e1 e2 e3\n  | Coq_expr_assign (e1, opo, e2) -> run_expr_assign s c opo e1 e2\n\n(** val run_stat : state -> execution_ctx -> stat -> result **)\n\nand run_stat s c _term_ = match _term_ with\n  | Coq_stat_expr e ->\n    let%spec (s0, r) = (run_expr_get_value s c e) in\n        res_ter s0 (res_val r)\n  | Coq_stat_label (lab, t0) ->\n    run_stat_label s c (Coq_label_string lab) t0\n  | Coq_stat_block ts -> run_block s c (rev ts)\n  | Coq_stat_var_decl xeos -> run_var_decl s c xeos\n  | Coq_stat_if (e1, t2, to0) -> run_stat_if s c e1 t2 to0\n  | Coq_stat_do_while (ls, t1, e2) ->\n    run_stat_do_while s c Coq_resvalue_empty ls e2 t1\n  | Coq_stat_while (ls, e1, t2) ->\n    run_stat_while s c Coq_resvalue_empty ls e1 t2\n  | Coq_stat_with (e1, t2) -> run_stat_with s c e1 t2\n  | Coq_stat_throw e -> run_stat_throw s c e\n  | Coq_stat_return eo -> run_stat_return s c eo\n  | Coq_stat_break so -> res_out s (res_break so)\n  | Coq_stat_continue so -> res_out s (res_continue so)\n  | Coq_stat_try (t1, t2o, t3o) -> run_stat_try s c t1 t2o t3o\n  | Coq_stat_for (ls, eo1, eo2, eo3, s0) ->\n    run_stat_for s c ls eo1 eo2 eo3 s0\n  | Coq_stat_for_var (ls, ds, eo2, eo3, s0) ->\n    run_stat_for_var s c ls ds eo2 eo3 s0\n  | Coq_stat_for_in (ls, e1, e2, s0) ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      ("stat_for_in")\n  | Coq_stat_for_in_var (ls, x, e1o, e2, s0) ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      ("stat_for_in_var")\n  | Coq_stat_debugger -> res_out s res_empty\n  | Coq_stat_switch (labs, e, sb) -> run_stat_switch s c labs e sb\n\n(** val run_elements :\n    state -> execution_ctx -> elements -> result **)\n\nand run_elements s c _foo_ = match _foo_ with\n  | [] -> res_out s (res_normal Coq_resvalue_empty)\n  | el :: els_rev_2 ->\n    let%success (s0, rv0)= (run_elements s c els_rev_2) in\n        match el with\n        | Coq_element_stat t ->\n          let%ter (s1, r1) = (run_stat s0 c t) in\n              let r2 = res_overwrite_value_if_empty rv0 r1 in\n              res_out s1 r2\n        | Coq_element_func_decl (name, args, bd) -> res_ter s0 (res_normal rv0)\n\n(** val run_prog : state -> execution_ctx -> prog -> result **)\n\nand run_prog s c _term_ = match _term_ with\n  | Coq_prog_intro (str, els) -> run_elements s c (rev els)\n\n(** val push :\n    state -> execution_ctx -> object_loc -> value list -> float\n    -> result **)\n\nand push s c l args ilen =\n  let vlen = ilen in\n      match args with\n      | [] ->\n        let%not_throw\n           (s0, x) = (object_put s c l ("length")\n             (Coq_value_number vlen) throw_true) in\n              res_out s0 (res_val (Coq_value_number vlen))\n      | v :: vs ->\n        let%string \n          (s0, slen) = (to_string s c (Coq_value_number vlen)) in\n             let%not_throw  (s1, x) = (object_put s0 c l slen v throw_true) in\n                 push s1 c l vs (ilen +. 1.)\n\n(** val run_object_is_sealed :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_is_sealed s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some ext = (run_object_method object_extensible_ s l) in\n        res_ter s (res_val (Coq_value_bool (not ext)))\n  | x :: xs_2 ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          if attributes_configurable a\n          then res_ter s0 (res_val (Coq_value_bool false))\n          else run_object_is_sealed s0 c l xs_2\n\n(** val run_object_seal :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_seal s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some s0= (run_object_heap_set_extensible false s l) in\n        res_ter s0 (res_val (Coq_value_object l))\n  | x :: xs_2 ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_seal]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          let a_2 =\n            if attributes_configurable a\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         None; descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = (Some\n                                                                                         false) }\n              in\n              attributes_update a desc\n            else a\n          in\n          let%bool\n             (s1, x0) = (object_define_own_prop s0 c l x (descriptor_of_attributes a_2)\n               true) in run_object_seal s1 c l xs_2\n\n(** val run_object_freeze :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_freeze s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some s0= (run_object_heap_set_extensible false s l) in\n        res_ter s0 (res_val (Coq_value_object l))\n  | x :: xs_2 ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          let a_2 =\n            if (attributes_is_data_dec a) && (attributes_writable a)\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         (Some false); descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = None }\n              in\n              attributes_update a desc\n            else a\n          in\n          let a_3 =\n            if attributes_configurable a_2\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         None; descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = (Some\n                                                                                         false) }\n              in\n              attributes_update a_2 desc\n            else a_2\n          in\n          let%bool\n             (s1, x0) = (object_define_own_prop s0 c l x (descriptor_of_attributes a_3)\n               true) in run_object_freeze s1 c l xs_2\n\n(** val run_object_is_frozen :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_is_frozen s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some ext = (run_object_method object_extensible_ s l) in\n        res_ter s (res_val (Coq_value_bool (not ext)))\n  | x :: xs_2 ->\n    let%spec (s0, d) = (run_object_get_own_prop s c l x) in\n        let  check_configurable = (fun a ->\n            if attributes_configurable a\n            then res_ter s0 (res_val (Coq_value_bool false))\n            else run_object_is_frozen s0 c l xs_2) in\n            match d with\n            | Coq_full_descriptor_undef ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s0\n                ("[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n            | Coq_full_descriptor_some a ->\n              (match a with\n               | Coq_attributes_data_of ad ->\n                 if attributes_writable (Coq_attributes_data_of ad)\n                 then res_ter s0 (res_val (Coq_value_bool false))\n                 else check_configurable (Coq_attributes_data_of ad)\n               | Coq_attributes_accessor_of aa ->\n                 check_configurable (Coq_attributes_accessor_of aa))\n\n(** val run_get_args_for_apply :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    value list specres **)\n\nand run_get_args_for_apply s c l index n =\n  if  index < n\n  then let%string\n       (s0, sindex) = (to_string s c (Coq_value_number index)) in\n          let%value (s1, v) = (run_object_get s0 c l sindex) in\n              let\n                \n                tail_args = (run_get_args_for_apply s1 c l (index +. 1.) n) in\n                   let%spec (s2, tail) = (tail_args) in res_spec s2 (v :: tail)\n  else res_spec s []\n\n(** val valueToStringForJoin :\n    state -> execution_ctx -> object_loc -> float -> string\n    specres **)\n\nand valueToStringForJoin s c l k =\n  let%string (s0, prop) = (to_string s c (Coq_value_number k)) in\n  let%value (s1, v) = (run_object_get s0 c l prop) in\n  match v with\n  | Coq_value_undef -> res_spec s1 ""\n  | Coq_value_null -> res_spec s1 ""\n  | Coq_value_bool b ->\n    let%string (s2, s3) = (to_string s1 c v) in res_spec s2 s3\n  | Coq_value_number n ->\n    let%string (s2, s3) = (to_string s1 c v) in res_spec s2 s3\n  | Coq_value_string s2 ->\n    let%string (s3, s4) = (to_string s1 c v) in res_spec s3 s4\n  | Coq_value_object o ->\n    let%string (s2, s3) = (to_string s1 c v) in res_spec s2 s3\n\n(** val run_array_join_elements :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    string -> string -> result **)\n\nand run_array_join_elements s c l k length0 sep sR =\n  if  k < length0\n  then let  ss = (strappend sR sep) in\n      let  sE = (valueToStringForJoin s c l k) in\n          let%spec (s0, element) = (sE) in\n              let  sR0 = (strappend ss element) in\n                  run_array_join_elements s0 c l (k +. 1.)\n                    length0 sep sR0\n  else res_ter s (res_val (Coq_value_string sR))\n\n(** Definitions of prealloc (built-in) functions *)\n(** val run_call_prealloc :\n    state -> execution_ctx -> prealloc -> value -> value list ->\n    result **)\n\nand run_call_prealloc s c b vthis args =\n  match b with\n  | Coq_prealloc_global_is_finite ->\n    let  v = (get_arg 0 args) in\n    let%number (s0, n) = (to_number s c v) in\n    res_ter s0 (res_val (Coq_value_bool (not ((JsNumber.isnan n) || (n === JsNumber.infinity) || (n === JsNumber.neg_infinity)))))\n  | Coq_prealloc_global_is_nan ->\n    let  v = (get_arg 0 args) in\n        let%number (s0, n) = (to_number s c v) in\n            res_ter s0\n              (res_val (Coq_value_bool (JsNumber.isnan n)))\n  | Coq_prealloc_object ->\n    let  value0 = (get_arg 0 args) in begin\n        match value0 with\n        | Coq_value_undef -> run_construct_prealloc s c b args\n        | Coq_value_null -> run_construct_prealloc s c b args\n        | Coq_value_bool b0 -> to_object s value0\n        | Coq_value_number n -> to_object s value0\n        | Coq_value_string s0 -> to_object s value0\n        | Coq_value_object o -> to_object s value0\n    end\n  | Coq_prealloc_object_get_proto_of ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_object l ->\n          let%some proto = (run_object_method object_proto_ s l) in\n          res_ter s (res_val proto)\n        | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_get_own_prop_descriptor ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%string (s1, x) = (to_string s c (get_arg 1 args)) in\n        let%spec (s2, d) = (run_object_get_own_prop s1 c l x) in\n        from_prop_descriptor s2 c d\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_define_prop ->\n    let o = (get_arg 0 args) in\n    let p = (get_arg 1 args) in\n    let attr = (get_arg 2 args) in begin\n      match o with\n      | Coq_value_object l ->\n        let%string (s1, name) = (to_string s c p) in\n        let%spec (s2, desc) = (to_property_descriptor s1 attr) in\n        let%bool (s3, x) = (object_define_own_prop s2 c l name desc true) in\n        res_ter s3 (res_val (Coq_value_object l))\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_seal ->\n    let v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some _x_ = (object_properties_keys_as_list_option s l) in\n        run_object_seal s c l _x_\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_freeze ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some _x_ = (object_properties_keys_as_list_option s l) in\n        run_object_freeze s c l _x_\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_prevent_extensions ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some o = (object_binds_option s l) in\n        let o1 = object_with_extension o false in\n        let s_2 = object_write s l o1 in\n        res_ter s_2 (res_val (Coq_value_object l))\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_is_sealed ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some _x_ = (object_properties_keys_as_list_option s l) in  run_object_is_sealed s c l _x_\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_is_frozen ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some _x_ = (object_properties_keys_as_list_option s l) in  run_object_is_frozen s c l _x_\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_is_extensible ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%some r = (run_object_method object_extensible_ s l) in\n        res_ter s (res_val (Coq_value_bool r))\n      | _ -> run_error s c Coq_native_error_type\n    end\n  | Coq_prealloc_object_proto_to_string ->\n    (match vthis with\n     | Coq_value_undef ->\n       res_out s (res_val (Coq_value_string ("[object Undefined]")))\n     | Coq_value_null ->\n       res_out s (res_val (Coq_value_string ("[object Null]")))\n     | Coq_value_bool b0 ->\n       let%object (s1, l) = (to_object s vthis) in\n       let%some s0= (run_object_method object_class_ s1 l) in\n       res_ter s1 (res_val (Coq_value_string (strappend "[object " (strappend s0 "]"))))\n     | Coq_value_number n ->\n       let%object (s1, l) = (to_object s vthis) in\n       let%some s0= (run_object_method object_class_ s1 l) in\n       res_ter s1 (res_val (Coq_value_string (strappend "[object " (strappend s0 "]"))))\n     | Coq_value_string s0 ->\n       let%object (s1, l) = (to_object s vthis) in\n       let%some s2= (run_object_method object_class_ s1 l) in\n       res_ter s1 (res_val (Coq_value_string (strappend "[object " (strappend s2 "]"))))\n     | Coq_value_object o ->\n       let%object (s1, l) = (to_object s vthis) in\n       let%some s0= (run_object_method object_class_ s1 l) in\n       res_ter s1 (res_val (Coq_value_string (strappend "[object " (strappend s0 "]")))))\n  | Coq_prealloc_object_proto_value_of -> to_object s vthis\n  | Coq_prealloc_object_proto_has_own_prop ->\n    let  v = (get_arg 0 args) in\n        let%string (s1, x) = (to_string s c v) in\n            let%object (s2, l) = (to_object s1 vthis) in\n                let%spec (s3, d) = (run_object_get_own_prop s2 c l x) in begin\n                    match d with\n                    | Coq_full_descriptor_undef ->\n                      res_ter s3 (res_val (Coq_value_bool false))\n                    | Coq_full_descriptor_some a ->\n                      res_ter s3 (res_val (Coq_value_bool true))\n    end\n  | Coq_prealloc_object_proto_is_prototype_of ->\n    let  v = (get_arg 0 args) in begin\n      match v with\n      | Coq_value_object l ->\n        let%object (s1, lo) = (to_object s vthis) in\n        object_proto_is_prototype_of s1 lo l\n      | _ ->\n        res_out s (res_val (Coq_value_bool false))\n    end\n  | Coq_prealloc_object_proto_prop_is_enumerable ->\n    let  v = (get_arg 0 args) in\n    let%string (s1, x) = (to_string s c v) in\n    let%object (s2, l) = (to_object s1 vthis) in\n    let%spec (s3, d) = (run_object_get_own_prop s2 c l x) in begin\n      match d with\n      | Coq_full_descriptor_undef ->\n        res_ter s3 (res_val (Coq_value_bool false))\n      | Coq_full_descriptor_some a ->\n        res_ter s3 (res_val (Coq_value_bool (attributes_enumerable a)))\n    end\n  | Coq_prealloc_function_proto ->\n    res_out s (res_val Coq_value_undef)\n  | Coq_prealloc_function_proto_to_string ->\n    if is_callable_dec s vthis\n    then (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n        ("Function.prototype.toString() is implementation dependent.")\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_apply ->\n    let  thisArg = (get_arg 0 args) in\n    let  argArray = (get_arg 1 args) in\n    if is_callable_dec s vthis\n    then\n      (match vthis with\n      | Coq_value_object thisobj ->\n        (match argArray with\n        | Coq_value_undef -> run_call s c thisobj thisArg []\n        | Coq_value_null -> run_call s c thisobj thisArg []\n        | Coq_value_bool b0 -> run_error s c Coq_native_error_type\n        | Coq_value_number n -> run_error s c Coq_native_error_type\n        | Coq_value_string s0 -> run_error s c Coq_native_error_type\n        | Coq_value_object array ->\n          let%value (s0, v) = (run_object_get s c array ("length")) in\n          let%spec (s1, ilen) = (to_uint32 s0 c v) in\n          let%spec (s2, arguments_) = (run_get_args_for_apply s1 c array 0. ilen) in\n          run_call s2 c thisobj thisArg arguments_)\n      | _ ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("Value is callable, but isn\\\'t an object."))\n            else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_call ->\n    if is_callable_dec s vthis\n    then\n      (match vthis with\n      | Coq_value_object thisobj ->\n        let (thisArg, a) = get_arg_first_and_rest args in\n        run_call s c thisobj thisArg a\n      | _ ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("Value is callable, but isn\\\'t an object.")\n      )\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_bind ->\n    if is_callable_dec s vthis\n    then\n      (match vthis with\n      | Coq_value_object thisobj ->\n        let (vthisArg, a) = get_arg_first_and_rest args in\n        let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_object_proto)) ("Object")) in\n        let o2 = (object_with_get o1 Coq_builtin_get_function) in\n        let o3 = (object_with_details o2 None None None (Some thisobj) (Some vthisArg) (Some a) None) in\n        let o4 = (object_set_class o3 ("Function")) in\n        let o5 = (object_set_proto o4 (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_function_proto))) in\n        let o6 = (object_with_invokation o5 (Some Coq_construct_after_bind) (Some Coq_call_after_bind) (Some Coq_builtin_has_instance_after_bind)) in\n        let o7 = (object_set_extensible o6 true) in\n        let (l, s_2) = object_alloc s o7 in\n        let vlength = (\n          let%some class0 = (run_object_method object_class_ s_2 thisobj) in\n          if string_eq class0 ("Function")\n          then\n            let%number (s10, n) = (run_object_get s_2 c thisobj ("length")) in\n            let%spec (s11, ilen) = (to_int32 s10 c (Coq_value_number n)) in\n            if  ilen < (number_of_int (LibList.length a))\n            then res_spec s11 0.\n            else res_spec s11 (ilen -.  (number_of_int (LibList.length a)))\n          else res_spec s_2 0.) in\n        let%spec (s10, length0) = (vlength) in\n        let a0 = ({ attributes_data_value = (Coq_value_number  length0);\n                    attributes_data_writable = false;\n                    attributes_data_enumerable = false;\n                    attributes_data_configurable = false }) in\n        let%some s11 = (run_object_heap_map_properties s10 l\n          (fun p -> HeapStr.write p ("length") (Coq_attributes_data_of a0))) in\n        let vthrower = (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_throw_type_error)) in\n        let a1 = ({ attributes_accessor_get = vthrower;\n                    attributes_accessor_set = vthrower;\n                    attributes_accessor_enumerable = false;\n                    attributes_accessor_configurable = false }) in\n        let%bool (s12, x) = (object_define_own_prop s11 c l ("caller") (descriptor_of_attributes (Coq_attributes_accessor_of a1)) false) in\n        let%bool (s13, x0) = (object_define_own_prop s12 c l ("arguments") (descriptor_of_attributes (Coq_attributes_accessor_of a1)) false) in\n        res_ter s13 (res_val (Coq_value_object l))\n      | _ ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("Value is callable, but isn\\\'t an object.")\n      )\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_bool ->\n      let v = get_arg 0 args in\n      res_out s (res_val (Coq_value_bool (to_boolean v)))\n  | Coq_prealloc_bool_proto_to_string ->\n    (match vthis with\n     | Coq_value_undef -> run_error s c Coq_native_error_type\n     | Coq_value_null -> run_error s c Coq_native_error_type\n     | Coq_value_bool b0 -> res_ter s (res_val (Coq_value_string (convert_bool_to_string b0)))\n     | Coq_value_number n -> run_error s c Coq_native_error_type\n     | Coq_value_string s0 -> run_error s c Coq_native_error_type\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n           if string_eq s0 ("Boolean")\n           then ifx_some_or_default (run_object_method object_prim_value_ s l)\n             (run_error s c Coq_native_error_type) (fun wo ->\n               match wo with\n               | Some v ->\n                 (match v with\n                 | Coq_value_undef -> run_error s c Coq_native_error_type\n                 | Coq_value_null -> run_error s c Coq_native_error_type\n                 | Coq_value_bool b0 ->\n                   res_ter s\n                     (res_val (Coq_value_string (convert_bool_to_string b0)))\n                 | Coq_value_number n ->\n                   run_error s c Coq_native_error_type\n                 | Coq_value_string s1 ->\n                   run_error s c Coq_native_error_type\n                 | Coq_value_object o -> run_error s c Coq_native_error_type)\n               | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_bool_proto_value_of ->\n    (match vthis with\n     | Coq_value_undef -> run_error s c Coq_native_error_type\n     | Coq_value_null -> run_error s c Coq_native_error_type\n     | Coq_value_bool b0 ->\n       res_ter s (res_val (Coq_value_bool b0))\n     | Coq_value_number n -> run_error s c Coq_native_error_type\n     | Coq_value_string s0 -> run_error s c Coq_native_error_type\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n             if string_eq s0 ("Boolean")\n             then ifx_some_or_default (run_object_method object_prim_value_ s l)\n               (run_error s c Coq_native_error_type) (fun wo ->\n                 match wo with\n                 | Some v ->\n                   (match v with\n                    | Coq_value_undef -> run_error s c Coq_native_error_type\n                    | Coq_value_null -> run_error s c Coq_native_error_type\n                    | Coq_value_bool b0 -> res_ter s (res_val (Coq_value_bool b0))\n                    | Coq_value_number n -> run_error s c Coq_native_error_type\n                    | Coq_value_string s1 -> run_error s c Coq_native_error_type\n                    | Coq_value_object o -> run_error s c Coq_native_error_type)\n                 | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_number ->\n    if list_eq_nil_decidable args\n    then res_out s (res_val (Coq_value_number JsNumber.zero))\n    else let v = get_arg 0 args in to_number s c v\n  | Coq_prealloc_number_proto_value_of ->\n    (match vthis with\n     | Coq_value_undef -> run_error s c Coq_native_error_type\n     | Coq_value_null -> run_error s c Coq_native_error_type\n     | Coq_value_bool b0 -> run_error s c Coq_native_error_type\n     | Coq_value_number n ->\n       res_ter s (res_val (Coq_value_number n))\n     | Coq_value_string s0 -> run_error s c Coq_native_error_type\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n             if string_eq s0 ("Number")\n             then ifx_some_or_default (run_object_method object_prim_value_ s l)\n                 (run_error s c Coq_native_error_type) (fun wo ->\n                     match wo with\n                     | Some v ->\n                       (match v with\n                        | Coq_value_undef -> run_error s c Coq_native_error_type\n                        | Coq_value_null -> run_error s c Coq_native_error_type\n                        | Coq_value_bool b0 -> run_error s c Coq_native_error_type\n                        | Coq_value_number n -> res_ter s (res_val (Coq_value_number n))\n                        | Coq_value_string s1 -> run_error s c Coq_native_error_type\n                        | Coq_value_object o -> run_error s c Coq_native_error_type)\n                     | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_array ->\n    run_construct_prealloc s c Coq_prealloc_array args\n  | Coq_prealloc_array_is_array ->\n    let  arg = (get_arg 0 args) in begin\n        match arg with\n        | Coq_value_object arg0 ->\n          let%some class0= (run_object_method object_class_ s arg0) in\n          if string_eq class0 ("Array")\n          then res_ter s (res_val (Coq_value_bool true))\n          else res_ter s (res_val (Coq_value_bool false))\n        | _ -> res_ter s (res_val (Coq_value_bool false))\n    end\n  | Coq_prealloc_array_proto_to_string ->\n    let%object (s0, array) = (to_object s vthis) in\n    let%value (s1, vfunc) = (run_object_get s0 c array ("join")) in\n    if is_callable_dec s1 vfunc\n    then (match vfunc with\n        | Coq_value_object func -> run_call s1 c func (Coq_value_object array) []\n        | _ ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s1\n            ("Value is callable, but isn\\\'t an object."))\n    else run_call_prealloc s1 c Coq_prealloc_object_proto_to_string (Coq_value_object array) []\n  | Coq_prealloc_array_proto_join ->\n    let  vsep = (get_arg 0 args) in\n    let%object (s0, l) = (to_object s vthis) in\n    let%value (s1, vlen) = (run_object_get s0 c l ("length")) in\n    let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n    let rsep = (if not (value_compare vsep Coq_value_undef) then vsep else Coq_value_string (",")) in\n    let%string (s3, sep) = (to_string s2 c rsep) in\n    if ilen = 0.0\n    then res_ter s3 (res_val (Coq_value_string ""))\n    else\n      let sR = (valueToStringForJoin s3 c l 0.) in\n      let%spec (s4, sR0) = (sR) in\n      run_array_join_elements s4 c l 1. ilen sep sR0\n  | Coq_prealloc_array_proto_pop ->\n    let%object (s0, l) = (to_object s vthis) in\n    let%value (s1, vlen) = (run_object_get s0 c l ("length")) in\n    let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n    if ilen = 0.0\n    then\n      let%not_throw (s3, x) = (object_put s2 c l ("length") (Coq_value_number JsNumber.zero) throw_true) in\n      res_out s3 (res_val Coq_value_undef)\n    else\n      let%string (s3, sindx) = (to_string s2 c (Coq_value_number (ilen -. 1.))) in\n      let%value (s4, velem) = (run_object_get s3 c l sindx) in\n      let%not_throw (s5, x) = (object_delete_default s4 c l sindx throw_true) in\n      let%not_throw (s6, x0) = (object_put s5 c l ("length") (Coq_value_string sindx) throw_true) in\n      res_out s6 (res_val velem)\n  | Coq_prealloc_array_proto_push ->\n    let%object (s0, l) = (to_object s vthis) in\n    let%value (s1, vlen) = (run_object_get s0 c l ("length")) in\n    let%spec (s2, ilen) = (to_uint32 s1 c vlen) in\n    push s2 c l args ilen\n  | Coq_prealloc_string ->\n    if list_eq_nil_decidable args\n    then res_ter s (res_val (Coq_value_string ""))\n    else\n      let value0 = (get_arg 0 args) in\n      let%string (s0, s1) = (to_string s c value0) in\n      res_ter s0 (res_val (Coq_value_string s1))\n  | Coq_prealloc_string_proto_to_string ->\n    (match vthis with\n     | Coq_value_object l ->\n       let%some s0= (run_object_method object_class_ s l) in\n           if string_eq s0 ("String")\n           then run_object_prim_value s l\n           else run_error s c Coq_native_error_type\n     | _ ->\n       if type_compare (type_of vthis) Coq_type_string\n       then res_ter s (res_val vthis)\n       else run_error s c Coq_native_error_type\n    )\n  | Coq_prealloc_string_proto_value_of ->\n    (match vthis with\n     | Coq_value_object l ->\n       let%some s0= (run_object_method object_class_ s l) in\n           if string_eq s0 ("String")\n           then run_object_prim_value s l\n           else run_error s c Coq_native_error_type\n     | _ ->\n       if type_compare (type_of vthis) Coq_type_string\n       then res_ter s (res_val vthis)\n       else run_error s c Coq_native_error_type\n    )\n  | Coq_prealloc_error ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           Coq_prealloc_error_proto)) v\n  | Coq_prealloc_native_error ne ->\n    let  v = (get_arg 0 args) in\n    build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                       (Coq_prealloc_native_error_proto ne))) v\n  | Coq_prealloc_throw_type_error -> run_error s c Coq_native_error_type\n  | _ ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      (strappend ("Call prealloc_") (strappend (string_of_prealloc b) (" not yet implemented")))\n\n(** val run_call :\n    state -> execution_ctx -> object_loc -> value -> value list\n    -> result **)\n\nand run_call s c l vthis args =\n  let%some co = run_object_method object_call_ s l in\n  let%some c0 = co in\n  match c0 with\n  | Coq_call_default -> entering_func_code s c l vthis args\n  | Coq_call_after_bind ->\n    let%some oarg = run_object_method object_bound_args_ s l in\n    let%some boundArgs = oarg in\n    let%some obnd = run_object_method object_bound_this_ s l in\n    let%some boundThis = obnd in\n    let%some otrg = run_object_method object_target_function_ s l in\n    let%some target = otrg in\n    let arguments_ = (LibList.append boundArgs args) in run_call s c target boundThis arguments_\n  | Coq_call_prealloc b -> run_call_prealloc s c b vthis args\n  | Coq_call_proxy -> Coq_result_not_yet_implemented (* FIXME: Proxy *)\n\n(** val run_javascript_from_state : state -> prog -> result **)\n\nand run_javascript_from_state s p =\n  let c = execution_ctx_initial (prog_intro_strictness p) in\n  let%void s_2 = execution_ctx_binding_inst s c Coq_codetype_global None p [] in\n  run_prog s_2 c p\n\n(** val run_javascript_from_result : result -> prog -> result **)\n\nand run_javascript_from_result w p =\n  if_success w (fun s _ -> run_javascript_from_state s p)\n\n(** val run_javascript : prog -> result **)\n\nand run_javascript p =\n  run_javascript_from_state state_initial p\n'},
];
