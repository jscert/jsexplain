var tracer_files = [

/* --------------------- JsInterpreter.js --------------------- */
  { file: 'JsInterpreter.js', contents: 'var JsInterpreter = (function() {\nwith (Datatypes) {\nwith (JsCommon) {\nwith (JsCommonAux) {\nwith (JsInit) {\nwith (JsInterpreterMonads) {\nwith (JsPreliminary) {\nwith (JsSyntax) {\nwith (JsSyntaxAux) {\nwith (LibList) {\nwith (LibOption) {\nwith (LibProd) {\nwith (Shared) {\n\nvar convert_number_to_bool = function (n) {\n  if ((JsNumber.isposzero(n) || (JsNumber.isnegzero(n) || JsNumber.isnan(n)))) {\n    return (false);\n  } else {\n    return (true);\n  }\n};\n\n\n\nvar convert_string_to_bool = function (s) {\n  if (string_eq(s, "")) {\n    return (false);\n  } else {\n    return (true);\n  }\n};\n\n\n\nvar convert_prim_to_boolean = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_prim_undef":\n      return (false);\n    case "Coq_prim_null":\n      return (false);\n    case "Coq_prim_bool":\n      var b = _foo_.value;\n      return (b);\n    case "Coq_prim_number":\n      var n = _foo_.value;\n      return (convert_number_to_bool(n));\n    case "Coq_prim_string":\n      var s = _foo_.value;\n      return (convert_string_to_bool(s));\n  }\n  \n};\n\n\n\nvar convert_value_to_boolean = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_prim":\n      var p = _foo_.value;\n      return (convert_prim_to_boolean(p));\n    case "Coq_value_object":\n      var o = _foo_.value;\n      return (true);\n  }\n  \n};\n\n\n\nvar convert_prim_to_number = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_prim_undef":\n      return (JsNumber.nan);\n    case "Coq_prim_null":\n      return (JsNumber.zero);\n    case "Coq_prim_bool":\n      var b = _foo_.value;\n      if (b) {\n        return (JsNumber.one);\n      } else {\n        return (JsNumber.zero);\n      }\n    case "Coq_prim_number":\n      var n = _foo_.value;\n      return (n);\n    case "Coq_prim_string":\n      var s = _foo_.value;\n      return (JsNumber.from_string(s));\n  }\n  \n};\n\n\n\nvar convert_number_to_integer = function (n) {\n  if (JsNumber.isnan(n)) {\n    return (JsNumber.zero);\n  } else {\n    if ((JsNumber.isposzero(n)\n        || (JsNumber.isnegzero(n)\n           || ((n === JsNumber.infinity) || (n === JsNumber.neg_infinity))))) {\n      return (n);\n    } else {\n      return ((JsNumber.sign(n) * JsNumber.floor(JsNumber.absolute(n))));\n    }\n  }\n};\n\n\n\nvar convert_bool_to_string = function (_foo_) {\n  switch (_foo_) {\n    case true:\n      return ("true");\n    case false:\n      return ("false");\n  }\n  \n};\n\n\n\nvar convert_prim_to_string = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_prim_undef":\n      return ("undefined");\n    case "Coq_prim_null":\n      return ("null");\n    case "Coq_prim_bool":\n      var b = _foo_.value;\n      return (convert_bool_to_string(b));\n    case "Coq_prim_number":\n      var n = _foo_.value;\n      return (JsNumber.to_string(n));\n    case "Coq_prim_string":\n      var s = _foo_.value;\n      return (s);\n  }\n  \n};\n\n\n\nvar equality_test_for_same_type = function (ty, v1, v2) {\n  switch (ty.tag) {\n    case "Coq_type_undef":\n      return (true);\n    case "Coq_type_null":\n      return (true);\n    case "Coq_type_bool":\n      return (value_compare(v1, v2));\n    case "Coq_type_number":\n      switch (v1.tag) {\n        case "Coq_value_prim":\n          var p = v1.value;\n          switch (p.tag) {\n            case "Coq_prim_undef":\n              return (false);\n            case "Coq_prim_null":\n              return (false);\n            case "Coq_prim_bool":\n              var b = p.value;\n              return (false);\n            case "Coq_prim_number":\n              var n1 = p.value;\n              switch (v2.tag) {\n                case "Coq_value_prim":\n                  var p0 = v2.value;\n                  switch (p0.tag) {\n                    case "Coq_prim_undef":\n                      return (false);\n                    case "Coq_prim_null":\n                      return (false);\n                    case "Coq_prim_bool":\n                      var b = p0.value;\n                      return (false);\n                    case "Coq_prim_number":\n                      var n2 = p0.value;\n                      if (JsNumber.isnan(n1)) {\n                        return (false);\n                      } else {\n                        if (JsNumber.isnan(n2)) {\n                          return (false);\n                        } else {\n                          if ((JsNumber.isposzero(n1)\n                              && JsNumber.isnegzero(n2))) {\n                            return (true);\n                          } else {\n                            if ((JsNumber.isnegzero(n1)\n                                && JsNumber.isposzero(n2))) {\n                              return (true);\n                            } else {\n                              return ((n1 === n2));\n                            }\n                          }\n                        }\n                      }\n                    case "Coq_prim_string":\n                      var s = p0.value;\n                      return (false);\n                  }\n                  \n                case "Coq_value_object":\n                  var o = v2.value;\n                  return (false);\n              }\n              \n            case "Coq_prim_string":\n              var s = p.value;\n              return (false);\n          }\n          \n        case "Coq_value_object":\n          var o = v1.value;\n          return (false);\n      }\n      \n    case "Coq_type_string":\n      return (value_compare(v1, v2));\n    case "Coq_type_object":\n      return (value_compare(v1, v2));\n  }\n  \n};\n\n\n\nvar strict_equality_test = function (v1, v2) {\n  var ty1 = type_of(v1);\n  var ty2 = type_of(v2);\n  if (type_compare(ty1, ty2)) {\n    return (equality_test_for_same_type(ty1, v1, v2));\n  } else {\n    return (false);\n  }\n};\n\n\n\nvar inequality_test_number = function (n1, n2) {\n  if ((JsNumber.isnan(n1) || JsNumber.isnan(n2))) {\n    return (Coq_prim_undef());\n  } else {\n    if ((n1 === n2)) {\n      return (Coq_prim_bool(false));\n    } else {\n      if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n        return (Coq_prim_bool(false));\n      } else {\n        if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n          return (Coq_prim_bool(false));\n        } else {\n          if ((n1 === JsNumber.infinity)) {\n            return (Coq_prim_bool(false));\n          } else {\n            if ((n2 === JsNumber.infinity)) {\n              return (Coq_prim_bool(true));\n            } else {\n              if ((n2 === JsNumber.neg_infinity)) {\n                return (Coq_prim_bool(false));\n              } else {\n                if ((n1 === JsNumber.neg_infinity)) {\n                  return (Coq_prim_bool(true));\n                } else {\n                  return (Coq_prim_bool((n1 < n2)));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n\n\nvar inequality_test_string = function (s1, s2) {\n  return (string_lt(s1, s2));\n};\n\n\n\nvar inequality_test_primitive = function (w1, w2) {\n  switch (w1.tag) {\n    case "Coq_prim_undef":\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case "Coq_prim_null":\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case "Coq_prim_bool":\n      var b = w1.value;\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case "Coq_prim_number":\n      var n = w1.value;\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case "Coq_prim_string":\n      var s1 = w1.value;\n      switch (w2.tag) {\n        case "Coq_prim_undef":\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case "Coq_prim_null":\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case "Coq_prim_bool":\n          var b = w2.value;\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case "Coq_prim_number":\n          var n = w2.value;\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case "Coq_prim_string":\n          var s2 = w2.value;\n          return (Coq_prim_bool(inequality_test_string(s1, s2)));\n      }\n      \n  }\n  \n};\n\n\n\nvar typeof_prim = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_prim_undef":\n      return ("undefined");\n    case "Coq_prim_null":\n      return ("object");\n    case "Coq_prim_bool":\n      var b = _foo_.value;\n      return ("boolean");\n    case "Coq_prim_number":\n      var n = _foo_.value;\n      return ("number");\n    case "Coq_prim_string":\n      var s = _foo_.value;\n      return ("string");\n  }\n  \n};\n\n\n\nvar string_of_propname = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_propname_identifier":\n      var s = _foo_.value;\n      return (s);\n    case "Coq_propname_string":\n      var s = _foo_.value;\n      return (s);\n    case "Coq_propname_number":\n      var n = _foo_.value;\n      return (JsNumber.to_string(n));\n  }\n  \n};\n\n\n\nvar run_object_method = function (proj, s, l) {\n  return (LibOption.map(proj, object_binds_option(s, l)));\n};\n\n\n\nvar run_object_heap_set_extensible = function (b, s, l) {\n  return (\n    LibOption.map(function (o) {\n        return (object_write(s, l, object_set_extensible(o, b)));},\n      object_binds_option(s, l)));\n};\n\n\n\nvar object_has_prop = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_has_prop_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_has_prop_default":\n            return (\n              if_run(run_object_get_prop(s, c, l, x), function(s1, d) {\n                  \n                  return (\n                    res_ter(s1,\n                      res_val(\n                        Coq_value_prim(\n                          Coq_prim_bool(\n                            !(\n                              full_descriptor_compare(d,\n                                Coq_full_descriptor_undef())))))));}));\n        }\n        }));\n};\n\nvar build_error = function (s, c, vproto, vmsg) {\n  var o = object_new(vproto, "Error");\n  var _tuple_arg_1 = object_alloc(s, o);\n  var l = _tuple_arg_1[0], s_2 = _tuple_arg_1[1];\n  if (value_compare(vmsg, Coq_value_prim(Coq_prim_undef()))) {\n    return (result_out(Coq_out_ter(s_2, res_val(Coq_value_object(l)))));\n  } else {\n    return (\n      if_value(to_string(s_2, c, vmsg), function(s_3, vstr) {\n          \n          var a = {\n            attributes_data_value: vstr,\n            attributes_data_writable: true,\n            attributes_data_enumerable: false,\n            attributes_data_configurable: true\n          };\n          return (\n            if_success(\n              object_define_own_prop(s_3, c, l, "message",\n                descriptor_of_attributes(Coq_attributes_data_of(a)),\n                throw_true), function(s_4, rv) {\n                \n                return (\n                  result_out(Coq_out_ter(s_4, res_val(Coq_value_object(l)))));\n              }));}));\n  }\n};\n\nvar run_error = function (s, c, ne) {\n  return (\n    if_object(\n      build_error(s, c,\n        Coq_value_object(\n          Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))),\n        Coq_value_prim(Coq_prim_undef())), function(s_2, l) {\n        \n        return (\n          Coq_result_some(\n            Coq_specret_out(\n              Coq_out_ter(s_2,\n                res_throw(Coq_resvalue_value(Coq_value_object(l)))))));}));\n};\n\nvar out_error_or_void = function (s, c, str, ne) {\n  if (str) {\n    return (run_error(s, c, ne));\n  } else {\n    return (result_out(out_void(s)));\n  }\n};\n\nvar out_error_or_cst = function (s, c, str, ne, v) {\n  if (str) {\n    return (run_error(s, c, ne));\n  } else {\n    return (result_out(Coq_out_ter(s, res_val(v))));\n  }\n};\n\nvar object_get_builtin = function (s, c, b, vthis, l, x) {\n  var def = function (s0, l0) {\n    return (\n      if_run(run_object_get_prop(s0, c, l0, x), function(s1, d) {\n          \n          switch (d.tag) {\n            case "Coq_full_descriptor_undef":\n              return (\n                res_ter(s1, res_val(Coq_value_prim(Coq_prim_undef()))));\n            case "Coq_full_descriptor_some":\n              var a = d.value;\n              switch (a.tag) {\n                case "Coq_attributes_data_of":\n                  var ad = a.value;\n                  return (res_ter(s1, res_val(ad.attributes_data_value)));\n                case "Coq_attributes_accessor_of":\n                  var aa = a.value;\n                  var _switch_arg_2 = aa.attributes_accessor_get;\n                  switch (_switch_arg_2.tag) {\n                    case "Coq_value_prim":\n                      var p = _switch_arg_2.value;\n                      switch (p.tag) {\n                        case "Coq_prim_undef":\n                          return (\n                            res_ter(s1,\n                              res_val(Coq_value_prim(Coq_prim_undef()))));\n                        case "Coq_prim_null":\n                          return (Coq_result_impossible());\n                        case "Coq_prim_bool":\n                          var b0 = p.value;\n                          return (Coq_result_impossible());\n                        case "Coq_prim_number":\n                          var n = p.value;\n                          return (Coq_result_impossible());\n                        case "Coq_prim_string":\n                          var s2 = p.value;\n                          return (Coq_result_impossible());\n                      }\n                      \n                    case "Coq_value_object":\n                      var lf = _switch_arg_2.value;\n                      return (run_call(s1, c, lf, vthis, mk_nil()));\n                  }\n                  \n              }\n              \n          }\n          }));\n  };\n  var function0 = function (s0) {\n    return (\n      if_value(def(s0, l), function(s_2, v) {\n          \n          if (spec_function_get_error_case_dec(s_2, x, v)) {\n            return (run_error(s_2, c, Coq_native_error_type()));\n          } else {\n            return (res_ter(s_2, res_val(v)));\n          }}));\n  };\n  switch (b.tag) {\n    case "Coq_builtin_get_default":\n      return (def(s, l));\n    case "Coq_builtin_get_function":\n      return (function0(s));\n    case "Coq_builtin_get_args_obj":\n      return (\n        if_some(run_object_method(object_parameter_map_, s, l),\n          function(lmapo) {\n            \n            return (\n              if_some(lmapo, function(lmap) {\n                  \n                  return (\n                    if_run(run_object_get_own_prop(s, c, lmap, x),\n                      function(s0, d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (function0(s0));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (run_object_get(s0, c, lmap, x));\n                        }\n                        }));}));}));\n  }\n  \n};\n\nvar run_object_get = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_, s, l), function(b) {\n        \n        return (object_get_builtin(s, c, b, Coq_value_object(l), l, x));}));\n};\n\nvar run_object_get_prop = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_prop_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_get_prop_default":\n            return (\n              if_run(run_object_get_own_prop(s, c, l, x), function(s1, d) {\n                  \n                  if (full_descriptor_compare(d, Coq_full_descriptor_undef())) {\n                    return (\n                      if_some(run_object_method(object_proto_, s1, l),\n                        function(proto) {\n                          \n                          switch (proto.tag) {\n                            case "Coq_value_prim":\n                              var p = proto.value;\n                              switch (p.tag) {\n                                case "Coq_prim_null":\n                                  return (\n                                    res_spec(s1, Coq_full_descriptor_undef()));\n                                default:\n                                  return (\n                                    function (s, m) {\n                                        Debug.impossible_with_heap_because(\n                                          __LOC__, s, m);\n                                        return (Coq_result_impossible());}(\n                                      s1,\n                                      "Found a non-null primitive value as a prototype in [run_object_get_prop]."));\n                              }\n                              \n                            case "Coq_value_object":\n                              var lproto = proto.value;\n                              return (run_object_get_prop(s1, c, lproto, x));\n                          }\n                          }));\n                  } else {\n                    return (res_spec(s1, d));\n                  }}));\n        }\n        }));\n};\n\nvar object_proto_is_prototype_of = function (s, l0, l) {\n  return (\n    if_some(run_object_method(object_proto_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_value_prim":\n            var p = b.value;\n            switch (p.tag) {\n              case "Coq_prim_null":\n                return (\n                  result_out(\n                    Coq_out_ter(s,\n                      res_val(Coq_value_prim(Coq_prim_bool(false))))));\n              default:\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s,\n                    "[run_object_method] returned a primitive in [object_proto_is_prototype_of_body]."));\n            }\n            \n          case "Coq_value_object":\n            var l_2 = b.value;\n            if (object_loc_compare(l_2, l0)) {\n              return (\n                result_out(\n                  Coq_out_ter(s,\n                    res_val(Coq_value_prim(Coq_prim_bool(true))))));\n            } else {\n              return (object_proto_is_prototype_of(s, l0, l_2));\n            }\n        }\n        }));\n};\n\nvar object_default_value = function (s, c, l, prefo) {\n  return (\n    if_some(run_object_method(object_default_value_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_default_value_default":\n            var gpref = unsome_default(Coq_preftype_number(), prefo);\n            var lpref = other_preftypes(gpref);\n            var sub0 = function (s_2, x, k) {\n              return (\n                if_value(run_object_get(s_2, c, l, x), function(s1, vfo) {\n                    \n                    return (\n                      if_some(run_callable(s1, vfo), function(co) {\n                          \n                          switch (co.tag) {\n                            case "Some":\n                              var b0 = co.value;\n                              return (\n                                if_object(\n                                  result_out(Coq_out_ter(s1, res_val(vfo))),\n                                  function(s2, lfunc) {\n                                    \n                                    return (\n                                      if_value(\n                                        run_call(s2, c, lfunc,\n                                          Coq_value_object(l), mk_nil()),\n                                        function(s3, v) {\n                                          \n                                          switch (v.tag) {\n                                            case "Coq_value_prim":\n                                              var w = v.value;\n                                              return (\n                                                result_out(\n                                                  Coq_out_ter(s3,\n                                                    res_val(\n                                                      Coq_value_prim(w)))));\n                                            case "Coq_value_object":\n                                              var l0 = v.value;\n                                              return (k(s3));\n                                          }\n                                          }));}));\n                            case "None":\n                              return (k(s1));\n                          }\n                          }));}));\n            };\n            var gmeth = method_of_preftype(gpref);\n            return (\n              sub0(s, gmeth, function (s_2) {\n                  var lmeth = method_of_preftype(lpref);\n                  return (\n                    sub0(s_2, lmeth, function (s_3) {\n                        return (run_error(s_3, c, Coq_native_error_type()));\n                      }));}));\n        }\n        }));\n};\n\nvar to_primitive = function (s, c, v, prefo) {\n  switch (v.tag) {\n    case "Coq_value_prim":\n      var w = v.value;\n      return (result_out(Coq_out_ter(s, res_val(Coq_value_prim(w)))));\n    case "Coq_value_object":\n      var l = v.value;\n      return (\n        if_prim(object_default_value(s, c, l, prefo), function(s0, r) {\n            \n            return (res_ter(s0, res_val(Coq_value_prim(r))));}));\n  }\n  \n};\n\nvar to_number = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_prim":\n      var w = _foo_.value;\n      return (\n        result_out(\n          Coq_out_ter(s,\n            res_val(\n              Coq_value_prim(Coq_prim_number(convert_prim_to_number(w)))))));\n    case "Coq_value_object":\n      var l = _foo_.value;\n      return (\n        if_prim(\n          to_primitive(s, c, Coq_value_object(l),\n            Some(Coq_preftype_number())), function(s1, w) {\n            \n            return (\n              res_ter(s1,\n                res_val(\n                  Coq_value_prim(Coq_prim_number(convert_prim_to_number(w))))));\n          }));\n  }\n  \n};\n\nvar to_integer = function (s, c, v) {\n  return (\n    if_number(to_number(s, c, v), function(s1, n) {\n        \n        return (\n          res_ter(s1,\n            res_val(\n              Coq_value_prim(Coq_prim_number(convert_number_to_integer(n))))));\n      }));\n};\n\nvar to_int32 = function (s, c, v) {\n  return (\n    if_number(to_number(s, c, v), function(s_2, n) {\n        \n        return (res_spec(s_2, JsNumber.to_int32(n)));}));\n};\n\nvar to_uint32 = function (s, c, v) {\n  return (\n    if_number(to_number(s, c, v), function(s_2, n) {\n        \n        return (res_spec(s_2, JsNumber.to_uint32(n)));}));\n};\n\nvar to_string = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_prim":\n      var w = _foo_.value;\n      return (\n        result_out(\n          Coq_out_ter(s,\n            res_val(\n              Coq_value_prim(Coq_prim_string(convert_prim_to_string(w)))))));\n    case "Coq_value_object":\n      var l = _foo_.value;\n      return (\n        if_prim(\n          to_primitive(s, c, Coq_value_object(l),\n            Some(Coq_preftype_string())), function(s1, w) {\n            \n            return (\n              res_ter(s1,\n                res_val(\n                  Coq_value_prim(Coq_prim_string(convert_prim_to_string(w))))));\n          }));\n  }\n  \n};\n\nvar object_can_put = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_can_put_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_can_put_default":\n            return (\n              if_run(run_object_get_own_prop(s, c, l, x), function(s1, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (\n                        if_some(run_object_method(object_proto_, s1, l),\n                          function(vproto) {\n                            \n                            switch (vproto.tag) {\n                              case "Coq_value_prim":\n                                var p = vproto.value;\n                                switch (p.tag) {\n                                  case "Coq_prim_null":\n                                    return (\n                                      if_some(\n                                        run_object_method(object_extensible_,\n                                          s1, l), function(b0) {\n                                          \n                                          return (\n                                            res_ter(s1,\n                                              res_val(\n                                                Coq_value_prim(\n                                                  Coq_prim_bool(b0)))));}));\n                                  default:\n                                    return (\n                                      function (s, m) {\n                                          Debug.impossible_with_heap_because(\n                                            __LOC__, s, m);\n                                          return (Coq_result_impossible());}(\n                                        s1,\n                                        "Non-null primitive get as a prototype value in [object_can_put]."));\n                                }\n                                \n                              case "Coq_value_object":\n                                var lproto = vproto.value;\n                                return (\n                                  if_run(\n                                    run_object_get_prop(s1, c, lproto, x),\n                                    function(s2, d_2) {\n                                      \n                                      switch (d_2.tag) {\n                                        case "Coq_full_descriptor_undef":\n                                          return (\n                                            if_some(\n                                              run_object_method(\n                                                object_extensible_, s2, l),\n                                              function(b0) {\n                                                \n                                                return (\n                                                  res_ter(s2,\n                                                    res_val(\n                                                      Coq_value_prim(\n                                                        Coq_prim_bool(b0)))));\n                                              }));\n                                        case "Coq_full_descriptor_some":\n                                          var a = d_2.value;\n                                          switch (a.tag) {\n                                            case "Coq_attributes_data_of":\n                                              var ad = a.value;\n                                              return (\n                                                if_some(\n                                                  run_object_method(\n                                                    object_extensible_, s2,\n                                                    l), function(ext) {\n                                                    \n                                                    return (\n                                                      res_ter(s2,\n                                                        (function () {\n                                                          if (ext) {\n                                                            return (\n                                                              res_val(\n                                                                Coq_value_prim(\n                                                                  Coq_prim_bool(\n                                                                    ad.attributes_data_writable))));\n                                                          } else {\n                                                            return (\n                                                              res_val(\n                                                                Coq_value_prim(\n                                                                  Coq_prim_bool(\n                                                                    false))));\n                                                          }}())));}));\n                                            case "Coq_attributes_accessor_of":\n                                              var aa = a.value;\n                                              return (\n                                                res_ter(s2,\n                                                  res_val(\n                                                    Coq_value_prim(\n                                                      Coq_prim_bool(\n                                                        !(\n                                                          value_compare(\n                                                            aa.attributes_accessor_set,\n                                                            Coq_value_prim(\n                                                              Coq_prim_undef(\n                                                                )))))))));\n                                          }\n                                          \n                                      }\n                                      }));\n                            }\n                            }));\n                    case "Coq_full_descriptor_some":\n                      var a = d.value;\n                      switch (a.tag) {\n                        case "Coq_attributes_data_of":\n                          var ad = a.value;\n                          return (\n                            res_ter(s1,\n                              res_val(\n                                Coq_value_prim(\n                                  Coq_prim_bool(ad.attributes_data_writable)))));\n                        case "Coq_attributes_accessor_of":\n                          var aa = a.value;\n                          return (\n                            res_ter(s1,\n                              res_val(\n                                Coq_value_prim(\n                                  Coq_prim_bool(\n                                    !(\n                                      value_compare(\n                                        aa.attributes_accessor_set,\n                                        Coq_value_prim(Coq_prim_undef()))))))));\n                      }\n                      \n                  }\n                  }));\n        }\n        }));\n};\n\nvar run_object_define_own_prop_array_loop = function (s, c, l, newLen, oldLen, newLenDesc, newWritable, throwcont, def) {\n  if ((newLen < oldLen)) {\n    var oldLen_2 = (oldLen - 1.);\n    return (\n      if_string(to_string(s, c, Coq_value_prim(Coq_prim_number(oldLen_2))),\n        function(s0, slen) {\n          \n          return (\n            if_bool(object_delete(s0, c, l, slen, false), function(s1,\n              deleteSucceeded) {\n                \n                if (!(deleteSucceeded)) {\n                  var newLenDesc0 = descriptor_with_value(newLenDesc,\n                                      Some(\n                                        Coq_value_prim(\n                                          Coq_prim_number((oldLen_2 + 1.)))));\n                  if (!(newWritable)) {\n                    var newLenDesc1 = descriptor_with_writable(newLenDesc0,\n                                        Some(false));\n                  } else {\n                    var newLenDesc1 = newLenDesc0;\n                  }\n                  return (\n                    if_bool(def(s1, "length", newLenDesc1, false),\n                      function(s2, x) {\n                        \n                        return (\n                          out_error_or_cst(s2, c, throwcont,\n                            Coq_native_error_type(),\n                            Coq_value_prim(Coq_prim_bool(false))));}));\n                } else {\n                  return (\n                    run_object_define_own_prop_array_loop(s1, c, l, newLen,\n                      oldLen_2, newLenDesc, newWritable, throwcont, def));\n                }}));}));\n  } else {\n    if (!(newWritable)) {\n      return (\n        def(s, "length", {\n            descriptor_value: None(),\n            descriptor_writable: Some(false),\n            descriptor_get: None(),\n            descriptor_set: None(),\n            descriptor_enumerable: None(),\n            descriptor_configurable: None()}, false));\n    } else {\n      return (res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(true)))));\n    }\n  }\n};\n\nvar object_define_own_prop = function (s, c, l, x, desc, throwcont) {\n  var reject = function (s0, throwcont0) {\n    return (\n      out_error_or_cst(s0, c, throwcont0, Coq_native_error_type(),\n        Coq_value_prim(Coq_prim_bool(false))));\n  };\n  var def = function (s0, x0, desc0, throwcont0) {\n    return (\n      if_run(run_object_get_own_prop(s0, c, l, x0), function(s1, d) {\n          \n          return (\n            if_some(run_object_method(object_extensible_, s1, l),\n              function(ext) {\n                \n                switch (d.tag) {\n                  case "Coq_full_descriptor_undef":\n                    if (ext) {\n                      if ((descriptor_is_generic_dec(desc0)\n                          || descriptor_is_data_dec(desc0))) {\n                        var a = Coq_attributes_data_of(\n                                  attributes_data_of_descriptor(desc0));\n                      } else {\n                        var a = Coq_attributes_accessor_of(\n                                  attributes_accessor_of_descriptor(desc0));\n                      }\n                      return (\n                        if_some(\n                          object_heap_map_properties_option(s1, l,\n                            function (p) { return (HeapStr.write(p, x0, a));\n                            }), function(s2) {\n                            \n                            return (\n                              res_ter(s2,\n                                res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                          }));\n                    } else {\n                      return (reject(s1, throwcont0));\n                    }\n                  case "Coq_full_descriptor_some":\n                    var a = d.value;\n                    var object_define_own_prop_write = function (s2, a0) {\n                      var a_2 = attributes_update(a0, desc0);\n                      return (\n                        if_some(\n                          object_heap_map_properties_option(s2, l,\n                            function (p) {\n                              return (HeapStr.write(p, x0, a_2));}),\n                          function(s3) {\n                            \n                            return (\n                              res_ter(s3,\n                                res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                          }));\n                    };\n                    if (descriptor_contains_dec(descriptor_of_attributes(a),\n                          desc0)) {\n                      return (\n                        res_ter(s1,\n                          res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                    } else {\n                      if (attributes_change_enumerable_on_non_configurable_dec(\n                            a, desc0)) {\n                        return (reject(s1, throwcont0));\n                      } else {\n                        if (descriptor_is_generic_dec(desc0)) {\n                          return (object_define_own_prop_write(s1, a));\n                        } else {\n                          if (!(\n                                bool_eq(attributes_is_data_dec(a),\n                                  descriptor_is_data_dec(desc0)))) {\n                            if (attributes_configurable(a)) {\n                              switch (a.tag) {\n                                case "Coq_attributes_data_of":\n                                  var ad = a.value;\n                                  var a_2 = Coq_attributes_accessor_of(\n                                              attributes_accessor_of_attributes_data(\n                                                ad));\n                                  break;\n                                case "Coq_attributes_accessor_of":\n                                  var aa = a.value;\n                                  var a_2 = Coq_attributes_data_of(\n                                              attributes_data_of_attributes_accessor(\n                                                aa));\n                                  break;\n                              }\n                              \n                              return (\n                                if_some(\n                                  object_heap_map_properties_option(s1, l,\n                                    function (p) {\n                                      return (HeapStr.write(p, x0, a_2));}),\n                                  function(s2) {\n                                    \n                                    return (\n                                      object_define_own_prop_write(s2, a_2));\n                                  }));\n                            } else {\n                              return (reject(s1, throwcont0));\n                            }\n                          } else {\n                            if ((attributes_is_data_dec(a)\n                                && descriptor_is_data_dec(desc0))) {\n                              switch (a.tag) {\n                                case "Coq_attributes_data_of":\n                                  var ad = a.value;\n                                  if (attributes_change_data_on_non_configurable_dec(\n                                        ad, desc0)) {\n                                    return (reject(s1, throwcont0));\n                                  } else {\n                                    return (\n                                      object_define_own_prop_write(s1, a));\n                                  }\n                                case "Coq_attributes_accessor_of":\n                                  var a0 = a.value;\n                                  return (\n                                    function (s, m) {\n                                        Debug.impossible_with_heap_because(\n                                          __LOC__, s, m);\n                                        return (Coq_result_impossible());}(\n                                      s0,\n                                      "data is not accessor in [defineOwnProperty]"));\n                              }\n                              \n                            } else {\n                              if ((!(attributes_is_data_dec(a))\n                                  && descriptor_is_accessor_dec(desc0))) {\n                                switch (a.tag) {\n                                  case "Coq_attributes_data_of":\n                                    var a0 = a.value;\n                                    return (\n                                      function (s, m) {\n                                          Debug.impossible_with_heap_because(\n                                            __LOC__, s, m);\n                                          return (Coq_result_impossible());}(\n                                        s0,\n                                        "accessor is not data in [defineOwnProperty]"));\n                                  case "Coq_attributes_accessor_of":\n                                    var aa = a.value;\n                                    if (attributes_change_accessor_on_non_configurable_dec(\n                                          aa, desc0)) {\n                                      return (reject(s1, throwcont0));\n                                    } else {\n                                      return (\n                                        object_define_own_prop_write(s1, a));\n                                    }\n                                }\n                                \n                              } else {\n                                return (\n                                  function (s, m) {\n                                      Debug.impossible_with_heap_because(\n                                        __LOC__, s, m);\n                                      return (Coq_result_impossible());}(s0,\n                                    "cases are mutually exclusives in [defineOwnProperty]"));\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                }\n                }));}));\n  };\n  return (\n    if_some(run_object_method(object_define_own_prop_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_define_own_prop_default":\n            return (def(s, x, desc, throwcont));\n          case "Coq_builtin_define_own_prop_array":\n            return (\n              if_run(run_object_get_own_prop(s, c, l, "length"), function(s0,\n                d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (\n                        function (s, m) {\n                            Debug.impossible_with_heap_because(__LOC__, s, m);\n                            return (Coq_result_impossible());}(s0,\n                          "Array length property descriptor cannot be undefined."));\n                    case "Coq_full_descriptor_some":\n                      var attr = d.value;\n                      switch (attr.tag) {\n                        case "Coq_attributes_data_of":\n                          var a = attr.value;\n                          var oldLen = a.attributes_data_value;\n                          switch (oldLen.tag) {\n                            case "Coq_value_prim":\n                              var w = oldLen.value;\n                              var oldLen0 = JsNumber.to_uint32(\n                                              convert_prim_to_number(w));\n                              var descValueOpt = desc.descriptor_value;\n                              if (string_eq(x, "length")) {\n                                switch (descValueOpt.tag) {\n                                  case "Some":\n                                    var descValue = descValueOpt.value;\n                                    return (\n                                      if_run(to_uint32(s0, c, descValue),\n                                        function(s1, newLen) {\n                                          \n                                          return (\n                                            if_number(\n                                              to_number(s1, c, descValue),\n                                              function(s2, newLenN) {\n                                                \n                                                if (!((newLen === newLenN))) {\n                                                  return (\n                                                    run_error(s2, c,\n                                                      Coq_native_error_range(\n                                                        )));\n                                                } else {\n                                                  var newLenDesc = descriptor_with_value(\n                                                                    desc,\n                                                                    Some(\n                                                                    Coq_value_prim(\n                                                                    Coq_prim_number(\n                                                                    newLen))));\n                                                  if (le_int_decidable(\n                                                        oldLen0, newLen)) {\n                                                    return (\n                                                      def(s2, "length",\n                                                        newLenDesc,\n                                                        throwcont));\n                                                  } else {\n                                                    if (!(\n                                                          a.attributes_data_writable)) {\n                                                      return (\n                                                        reject(s2, throwcont));\n                                                    } else {\n                                                      var _switch_arg_3 = newLenDesc.descriptor_writable;\n                                                      switch (_switch_arg_3.tag) {\n                                                        case "Some":\n                                                          var b0 = _switch_arg_3.value;\n                                                          if (b0) {\n                                                            var newWritable = true;\n                                                          } else {\n                                                            var newWritable = false;\n                                                          }\n                                                          break;\n                                                        case "None":\n                                                          var newWritable = true;\n                                                          break;\n                                                      }\n                                                      \n                                                      if (!(newWritable)) {\n                                                        var newLenDesc0 = \n                                                        descriptor_with_writable(\n                                                          newLenDesc,\n                                                          Some(true));\n                                                      } else {\n                                                        var newLenDesc0 = newLenDesc;\n                                                      }\n                                                      return (\n                                                        if_bool(\n                                                          def(s2, "length",\n                                                            newLenDesc0,\n                                                            throwcont),\n                                                          function(s3,\n                                                          succ) {\n                                                            \n                                                            if (!(succ)) {\n                                                              return (\n                                                                res_ter(s3,\n                                                                  res_val(\n                                                                    Coq_value_prim(\n                                                                    Coq_prim_bool(\n                                                                    false)))));\n                                                            } else {\n                                                              return (\n                                                                run_object_define_own_prop_array_loop(\n                                                                  s3, c, l,\n                                                                  newLen,\n                                                                  oldLen0,\n                                                                  newLenDesc0,\n                                                                  newWritable,\n                                                                  throwcont,\n                                                                  def));\n                                                            }}));\n                                                    }\n                                                  }\n                                                }}));}));\n                                  case "None":\n                                    return (\n                                      def(s0, "length", desc, throwcont));\n                                }\n                                \n                              } else {\n                                return (\n                                  if_run(\n                                    to_uint32(s0, c,\n                                      Coq_value_prim(Coq_prim_string(x))),\n                                    function(s1, ilen) {\n                                      \n                                      return (\n                                        if_string(\n                                          to_string(s1, c,\n                                            Coq_value_prim(\n                                              Coq_prim_number(ilen))),\n                                          function(s2, slen) {\n                                            \n                                            if ((string_eq(x, slen)\n                                                && !((ilen == 4294967295.)))) {\n                                              return (\n                                                if_run(\n                                                  to_uint32(s2, c,\n                                                    Coq_value_prim(\n                                                      Coq_prim_string(x))),\n                                                  function(s3, index) {\n                                                    \n                                                    if ((le_int_decidable(\n                                                           oldLen0, index)\n                                                        && !(\n                                                             a.attributes_data_writable))) {\n                                                      return (\n                                                        reject(s3, throwcont));\n                                                    } else {\n                                                      return (\n                                                        if_bool(\n                                                          def(s3, x, desc,\n                                                            false),\n                                                          function(s4, b0) {\n                                                            \n                                                            if (!(b0)) {\n                                                              return (\n                                                                reject(s4,\n                                                                  throwcont));\n                                                            } else {\n                                                              if (le_int_decidable(\n                                                                    oldLen0,\n                                                                    index)) {\n                                                                var a0 = \n                                                                descriptor_with_value(\n                                                                  descriptor_of_attributes(\n                                                                    Coq_attributes_data_of(\n                                                                    a)),\n                                                                  Some(\n                                                                    Coq_value_prim(\n                                                                    Coq_prim_number(\n                                                                    (index\n                                                                    + 1.)))));\n                                                                return (\n                                                                  def(s4,\n                                                                    "length",\n                                                                    a0,\n                                                                    false));\n                                                              } else {\n                                                                return (\n                                                                  res_ter(s4,\n                                                                    res_val(\n                                                                    Coq_value_prim(\n                                                                    Coq_prim_bool(\n                                                                    true)))));\n                                                              }\n                                                            }}));\n                                                    }}));\n                                            } else {\n                                              return (\n                                                def(s2, x, desc, throwcont));\n                                            }}));}));\n                              }\n                            case "Coq_value_object":\n                              var l0 = oldLen.value;\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s0,\n                                  "Spec asserts length of array is number."));\n                          }\n                          \n                        case "Coq_attributes_accessor_of":\n                          var a = attr.value;\n                          return (\n                            function (s, m) {\n                                Debug.impossible_with_heap_because(__LOC__,\n                                  s, m);\n                                return (Coq_result_impossible());}(s0,\n                              "Array length property descriptor cannot be accessor."));\n                      }\n                      \n                  }\n                  }));\n          case "Coq_builtin_define_own_prop_args_obj":\n            return (\n              if_some(run_object_method(object_parameter_map_, s, l),\n                function(lmapo) {\n                  \n                  return (\n                    if_some(lmapo, function(lmap) {\n                        \n                        return (\n                          if_run(run_object_get_own_prop(s, c, lmap, x),\n                            function(s0, d) {\n                              \n                              return (\n                                if_bool(def(s0, x, desc, false), function(s1,\n                                  b0) {\n                                    \n                                    if (b0) {\n                                      var follow = function (s2) {\n                                        return (\n                                          res_ter(s2,\n                                            res_val(\n                                              Coq_value_prim(\n                                                Coq_prim_bool(true)))));\n                                      };\n                                      switch (d.tag) {\n                                        case "Coq_full_descriptor_undef":\n                                          return (follow(s1));\n                                        case "Coq_full_descriptor_some":\n                                          var a = d.value;\n                                          if (descriptor_is_accessor_dec(\n                                                desc)) {\n                                            return (\n                                              if_bool(\n                                                object_delete(s1, c, lmap, x,\n                                                  false), function(s2, x0) {\n                                                  \n                                                  return (follow(s2));}));\n                                          } else {\n                                            var follow0 = function (s2) {\n                                              if (option_compare(bool_eq,\n                                                    desc.descriptor_writable,\n                                                    Some(false))) {\n                                                return (\n                                                  if_bool(\n                                                    object_delete(s2, c,\n                                                      lmap, x, false),\n                                                    function(s3, x0) {\n                                                      \n                                                      return (follow(s3));}));\n                                              } else {\n                                                return (follow(s2));\n                                              }\n                                            };\n                                            var _switch_arg_4 = desc.descriptor_value;\n                                            switch (_switch_arg_4.tag) {\n                                              case "Some":\n                                                var v = _switch_arg_4.value;\n                                                return (\n                                                  if_void(\n                                                    object_put(s1, c, lmap,\n                                                      x, v, throwcont),\n                                                    function(s2) {\n                                                      \n                                                      return (follow0(s2));}));\n                                              case "None":\n                                                return (follow0(s1));\n                                            }\n                                            \n                                          }\n                                      }\n                                      \n                                    } else {\n                                      return (reject(s1, throwcont));\n                                    }}));}));}));}));\n        }\n        }));\n};\n\nvar run_to_descriptor = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_prim":\n      var p = _foo_.value;\n      return (throw_result(run_error(s, c, Coq_native_error_type())));\n    case "Coq_value_object":\n      var l = _foo_.value;\n      var sub0 = function (s0, desc, name, conv, k) {\n        return (\n          if_bool(object_has_prop(s0, c, l, name), function(s1, has) {\n              \n              if (!(has)) {\n                return (k(s1, desc));\n              } else {\n                return (\n                  if_value(run_object_get(s1, c, l, name), function(s2, v0) {\n                      \n                      return (\n                        if_run(conv(s2, v0, desc), function(s3, r) {\n                            \n                            return (k(s3, r));}));}));\n              }}));\n      };\n      return (\n        sub0(s, descriptor_intro_empty, "enumerable",\n          function (s1, v1, desc) {\n            var b = convert_value_to_boolean(v1);\n            return (res_spec(s1, descriptor_with_enumerable(desc, Some(b))));\n          }, function (s1_2, desc) {\n            return (\n              sub0(s1_2, desc, "configurable", function (s2, v2, desc0) {\n                  var b = convert_value_to_boolean(v2);\n                  return (\n                    res_spec(s2,\n                      descriptor_with_configurable(desc0, Some(b))));},\n                function (s2_2, desc0) {\n                  return (\n                    sub0(s2_2, desc0, "value", function (s3, v3, desc1) {\n                        return (\n                          res_spec(s3,\n                            descriptor_with_value(desc1, Some(v3))));},\n                      function (s3_2, desc1) {\n                        return (\n                          sub0(s3_2, desc1, "writable",\n                            function (s4, v4, desc2) {\n                              var b = convert_value_to_boolean(v4);\n                              return (\n                                res_spec(s4,\n                                  descriptor_with_writable(desc2, Some(b))));\n                            }, function (s4_2, desc2) {\n                              return (\n                                sub0(s4_2, desc2, "get",\n                                  function (s5, v5, desc3) {\n                                    if ((!(is_callable_dec(s5, v5))\n                                        && !(\n                                             value_compare(v5,\n                                               Coq_value_prim(\n                                                 Coq_prim_undef()))))) {\n                                      return (\n                                        throw_result(\n                                          run_error(s5, c,\n                                            Coq_native_error_type())));\n                                    } else {\n                                      return (\n                                        res_spec(s5,\n                                          descriptor_with_get(desc3,\n                                            Some(v5))));\n                                    }}, function (s5_2, desc3) {\n                                    return (\n                                      sub0(s5_2, desc3, "set",\n                                        function (s6, v6, desc4) {\n                                          if ((!(is_callable_dec(s6, v6))\n                                              && !(\n                                                   value_compare(v6,\n                                                     Coq_value_prim(\n                                                       Coq_prim_undef()))))) {\n                                            return (\n                                              throw_result(\n                                                run_error(s6, c,\n                                                  Coq_native_error_type())));\n                                          } else {\n                                            return (\n                                              res_spec(s6,\n                                                descriptor_with_set(desc4,\n                                                  Some(v6))));\n                                          }}, function (s7, desc4) {\n                                          if (((!(\n                                                  option_compare(\n                                                    value_compare,\n                                                    desc4.descriptor_get,\n                                                    None()))\n                                               || !(\n                                                    option_compare(\n                                                      value_compare,\n                                                      desc4.descriptor_set,\n                                                      None())))\n                                              && (!(\n                                                    option_compare(\n                                                      value_compare,\n                                                      desc4.descriptor_value,\n                                                      None()))\n                                                 || !(\n                                                      option_compare(bool_eq,\n                                                        desc4.descriptor_writable,\n                                                        None()))))) {\n                                            return (\n                                              throw_result(\n                                                run_error(s7, c,\n                                                  Coq_native_error_type())));\n                                          } else {\n                                            return (res_spec(s7, desc4));\n                                          }}));}));}));}));}));}));\n  }\n  \n};\n\nvar prim_new_object = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_prim_bool":\n      var b = _foo_.value;\n      return (\n        result_out((function () {\n            var o1 = object_new(\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_bool_proto())),\n                       "Boolean");\n            var o = object_with_primitive_value(o1,\n                      Coq_value_prim(Coq_prim_bool(b)));\n            var _tuple_arg_5 = object_alloc(s, o);\n            var l = _tuple_arg_5[0], s1 = _tuple_arg_5[1];\n            return (Coq_out_ter(s1, res_val(Coq_value_object(l))));}())));\n    case "Coq_prim_number":\n      var n = _foo_.value;\n      return (\n        result_out((function () {\n            var o1 = object_new(\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_number_proto())),\n                       "Number");\n            var o = object_with_primitive_value(o1,\n                      Coq_value_prim(Coq_prim_number(n)));\n            var _tuple_arg_6 = object_alloc(s, o);\n            var l = _tuple_arg_6[0], s1 = _tuple_arg_6[1];\n            return (Coq_out_ter(s1, res_val(Coq_value_object(l))));}())));\n    case "Coq_prim_string":\n      var s0 = _foo_.value;\n      var o2 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_string_proto())),\n                 "String");\n      var o1 = object_with_get_own_property(o2,\n                 Coq_builtin_get_own_prop_string());\n      var o = object_with_primitive_value(o1,\n                Coq_value_prim(Coq_prim_string(s0)));\n      var _tuple_arg_7 = object_alloc(s, o);\n      var l = _tuple_arg_7[0], s1 = _tuple_arg_7[1];\n      return (\n        if_some(\n          object_heap_map_properties_option(s1, l, function (p) {\n              return (\n                HeapStr.write(p, "length",\n                  Coq_attributes_data_of(\n                    attributes_data_intro_constant(\n                      Coq_value_prim(\n                        Coq_prim_number(number_of_int(strlength(s0))))))));}),\n          function(s_2) {\n            \n            return (res_ter(s_2, res_val(Coq_value_object(l))));}));\n    default:\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "[prim_new_object] received an null or undef."));\n  }\n  \n};\n\nvar to_object = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_prim":\n      var w = _foo_.value;\n      switch (w.tag) {\n        case "Coq_prim_undef":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_prim_null":\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_prim_bool":\n          var b = w.value;\n          return (prim_new_object(s, w));\n        case "Coq_prim_number":\n          var n = w.value;\n          return (prim_new_object(s, w));\n        case "Coq_prim_string":\n          var s0 = w.value;\n          return (prim_new_object(s, w));\n      }\n      \n    case "Coq_value_object":\n      var l = _foo_.value;\n      return (result_out(Coq_out_ter(s, res_val(Coq_value_object(l)))));\n  }\n  \n};\n\nvar run_object_prim_value = function (s, l) {\n  return (\n    if_some(run_object_method(object_prim_value_, s, l), function(ov) {\n        \n        return (\n          if_some(ov, function(v) { \n                                    return (res_ter(s, res_val(v)));}));}));\n};\n\nvar prim_value_get = function (s, c, v, x) {\n  return (\n    if_object(to_object(s, c, v), function(s_2, l) {\n        \n        return (\n          object_get_builtin(s_2, c, Coq_builtin_get_default(), v, l, x));}));\n};\n\nvar env_record_has_binding = function (s, c, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              result_out(\n                Coq_out_ter(s,\n                  res_val(\n                    Coq_value_prim(Coq_prim_bool(HeapStr.indom_dec(ed, x)))))));\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (object_has_prop(s, c, l0, x));\n        }\n        }));\n};\n\nvar lexical_env_get_identifier_ref = function (s, c, x, x0, str) {\n  switch (x.tag) {\n    case "[]":\n      return (\n        res_spec(s,\n          ref_create_value(Coq_value_prim(Coq_prim_undef()), x0, str)));\n    case "::":\n      var l = x.head, x_2 = x.tail;\n      return (\n        if_bool(env_record_has_binding(s, c, l, x0), function(s1, has) {\n            \n            if (has) {\n              return (res_spec(s1, ref_create_env_loc(l, x0, str)));\n            } else {\n              return (lexical_env_get_identifier_ref(s1, c, x_2, x0, str));\n            }}));\n  }\n  \n};\n\nvar object_delete_default = function (s, c, l, x, str) {\n  return (\n    if_run(run_object_get_own_prop(s, c, l, x), function(s1, d) {\n        \n        switch (d.tag) {\n          case "Coq_full_descriptor_undef":\n            return (\n              res_ter(s1, res_val(Coq_value_prim(Coq_prim_bool(true)))));\n          case "Coq_full_descriptor_some":\n            var a = d.value;\n            if (attributes_configurable(a)) {\n              return (\n                if_some(\n                  object_heap_map_properties_option(s1, l, function (p) {\n                      return (HeapStr.rem(p, x));}), function(s_2) {\n                    \n                    return (\n                      res_ter(s_2,\n                        res_val(Coq_value_prim(Coq_prim_bool(true)))));}));\n            } else {\n              return (\n                out_error_or_cst(s1, c, str, Coq_native_error_type(),\n                  Coq_value_prim(Coq_prim_bool(false))));\n            }\n        }\n        }));\n};\n\nvar object_delete = function (s, c, l, x, str) {\n  return (\n    if_some(run_object_method(object_delete_, s, l), function(b) {\n        \n        switch (b.tag) {\n          case "Coq_builtin_delete_default":\n            return (object_delete_default(s, c, l, x, str));\n          case "Coq_builtin_delete_args_obj":\n            return (\n              if_some(run_object_method(object_parameter_map_, s, l),\n                function(mo) {\n                  \n                  return (\n                    if_some(mo, function(m) {\n                        \n                        return (\n                          if_run(run_object_get_own_prop(s, c, m, x),\n                            function(s1, d) {\n                              \n                              return (\n                                if_bool(\n                                  object_delete_default(s1, c, l, x, str),\n                                  function(s2, b0) {\n                                    \n                                    if (b0) {\n                                      switch (d.tag) {\n                                        case "Coq_full_descriptor_undef":\n                                          return (\n                                            res_ter(s2,\n                                              res_val(\n                                                Coq_value_prim(\n                                                  Coq_prim_bool(b0)))));\n                                        case "Coq_full_descriptor_some":\n                                          var a = d.value;\n                                          return (\n                                            if_bool(\n                                              object_delete(s2, c, m, x,\n                                                false), function(s3, b_2) {\n                                                \n                                                return (\n                                                  res_ter(s3,\n                                                    res_val(\n                                                      Coq_value_prim(\n                                                        Coq_prim_bool(b0)))));\n                                              }));\n                                      }\n                                      \n                                    } else {\n                                      return (\n                                        res_ter(s2,\n                                          res_val(\n                                            Coq_value_prim(Coq_prim_bool(b0)))));\n                                    }}));}));}));}));\n        }\n        }));\n};\n\nvar env_record_delete_binding = function (s, c, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            var _switch_arg_8 = HeapStr.read_option(ed, x);\n            switch (_switch_arg_8.tag) {\n              case "Some":\n                var p = _switch_arg_8.value;\n                var mu = p[0], v = p[1];\n                switch (mu.tag) {\n                  case "Coq_mutability_uninitialized_immutable":\n                    return (\n                      result_out(\n                        Coq_out_ter(s,\n                          res_val(Coq_value_prim(Coq_prim_bool(false))))));\n                  case "Coq_mutability_immutable":\n                    return (\n                      result_out(\n                        Coq_out_ter(s,\n                          res_val(Coq_value_prim(Coq_prim_bool(false))))));\n                  case "Coq_mutability_nondeletable":\n                    return (\n                      result_out(\n                        Coq_out_ter(s,\n                          res_val(Coq_value_prim(Coq_prim_bool(false))))));\n                  case "Coq_mutability_deletable":\n                    var s_2 = env_record_write(s, l,\n                                Coq_env_record_decl(\n                                  decl_env_record_rem(ed, x)));\n                    return (\n                      result_out(\n                        Coq_out_ter(s_2,\n                          res_val(Coq_value_prim(Coq_prim_bool(true))))));\n                }\n                \n              case "None":\n                return (\n                  result_out(\n                    Coq_out_ter(s,\n                      res_val(Coq_value_prim(Coq_prim_bool(true))))));\n            }\n            \n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (object_delete(s, c, l0, x, throw_false));\n        }\n        }));\n};\n\nvar env_record_implicit_this_value = function (s, l) {\n  return (\n    ifx_some_or_default(env_record_binds_option(s, l), None(), function (e) {\n        return (\n          Some((function () {\n              switch (e.tag) {\n                case "Coq_env_record_decl":\n                  var ed = e.value;\n                  return (Coq_value_prim(Coq_prim_undef()));\n                case "Coq_env_record_object":\n                  var l0 = e.value, provide_this = e.provide_this;\n                  if (provide_this) {\n                    return (Coq_value_object(l0));\n                  } else {\n                    return (Coq_value_prim(Coq_prim_undef()));\n                  }\n              }\n              }())));}));\n};\n\nvar identifier_resolution = function (s, c, x) {\n  var x0 = c.execution_ctx_lexical_env;\n  var str = c.execution_ctx_strict;\n  return (lexical_env_get_identifier_ref(s, c, x0, x, str));\n};\n\nvar env_record_get_binding_value = function (s, c, l, x, str) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              if_some(HeapStr.read_option(ed, x), function(rm) {\n                  \n                  var mu = rm[0], v = rm[1];\n                  if (mutability_compare(mu,\n                        Coq_mutability_uninitialized_immutable())) {\n                    return (\n                      out_error_or_cst(s, c, str, Coq_native_error_ref(),\n                        Coq_value_prim(Coq_prim_undef())));\n                  } else {\n                    return (res_ter(s, res_val(v)));\n                  }}));\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (\n              if_bool(object_has_prop(s, c, l0, x), function(s1, has) {\n                  \n                  if (has) {\n                    return (run_object_get(s1, c, l0, x));\n                  } else {\n                    return (\n                      out_error_or_cst(s1, c, str, Coq_native_error_ref(),\n                        Coq_value_prim(Coq_prim_undef())));\n                  }}));\n        }\n        }));\n};\n\nvar ref_get_value = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_resvalue_empty":\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "[ref_get_value] received an empty result."));\n    case "Coq_resvalue_value":\n      var v = _foo_.value;\n      return (res_spec(s, v));\n    case "Coq_resvalue_ref":\n      var r = _foo_.ref;\n      var for_base_or_object = function (tt) {\n        var _switch_arg_9 = r.ref_base;\n        switch (_switch_arg_9.tag) {\n          case "Coq_ref_base_type_value":\n            var v = _switch_arg_9.value;\n            if (ref_kind_comparable(ref_kind_of(r),\n                  Coq_ref_kind_primitive_base())) {\n              return (\n                if_value(prim_value_get(s, c, v, r.ref_name), function(s2,\n                  v) { \n                       return (res_spec(s2, v));}));\n            } else {\n              switch (v.tag) {\n                case "Coq_value_prim":\n                  var p = v.value;\n                  return (\n                    function (s, m) {\n                        Debug.impossible_with_heap_because(__LOC__, s, m);\n                        return (Coq_result_impossible());}(s,\n                      "[ref_get_value] received a primitive value whose kind is not primitive."));\n                case "Coq_value_object":\n                  var l = v.value;\n                  return (\n                    if_value(run_object_get(s, c, l, r.ref_name),\n                      function(s2, v) { \n                                        return (res_spec(s2, v));}));\n              }\n              \n            }\n          case "Coq_ref_base_type_env_loc":\n            var l = _switch_arg_9.value;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[ref_get_value] received a reference to a value whose base type is an environnment record."));\n        }\n        \n      };\n      var _switch_arg_10 = ref_kind_of(r);\n      switch (_switch_arg_10.tag) {\n        case "Coq_ref_kind_null":\n          return (\n            function (s, m) {\n                Debug.impossible_with_heap_because(__LOC__, s, m);\n                return (Coq_result_impossible());}(s,\n              "[ref_get_value] received a reference whose base is [null]."));\n        case "Coq_ref_kind_undef":\n          return (throw_result(run_error(s, c, Coq_native_error_ref())));\n        case "Coq_ref_kind_primitive_base":\n          return (for_base_or_object({}));\n        case "Coq_ref_kind_object":\n          return (for_base_or_object({}));\n        case "Coq_ref_kind_env_record":\n          var _switch_arg_11 = r.ref_base;\n          switch (_switch_arg_11.tag) {\n            case "Coq_ref_base_type_value":\n              var v = _switch_arg_11.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "[ref_get_value] received a reference to an environnment record whose base type is a value."));\n            case "Coq_ref_base_type_env_loc":\n              var l = _switch_arg_11.value;\n              return (\n                if_value(\n                  env_record_get_binding_value(s, c, l, r.ref_name,\n                    r.ref_strict), function(s2, v) {\n                    \n                    return (res_spec(s2, v));}));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar run_expr_get_value = function (s, c, e) {\n  return (\n    if_success(run_expr(s, c, e), function(s0, rv) {\n        \n        return (ref_get_value(s0, c, rv));}));\n};\n\nvar object_put_complete = function (b, s, c, vthis, l, x, v, str) {\n  switch (b.tag) {\n    case "Coq_builtin_put_default":\n      return (\n        if_bool(object_can_put(s, c, l, x), function(s1, b0) {\n            \n            if (b0) {\n              return (\n                if_run(run_object_get_own_prop(s1, c, l, x), function(s2,\n                  d) {\n                    \n                    var follow = function (x0) {\n                      return (\n                        if_run(run_object_get_prop(s2, c, l, x), function(s3,\n                          d_2) {\n                            \n                            var follow_2 = function (x1) {\n                              switch (vthis.tag) {\n                                case "Coq_value_prim":\n                                  var wthis = vthis.value;\n                                  return (\n                                    out_error_or_void(s3, c, str,\n                                      Coq_native_error_type()));\n                                case "Coq_value_object":\n                                  var lthis = vthis.value;\n                                  var desc = descriptor_intro_data(v, true,\n                                               true, true);\n                                  return (\n                                    if_success(\n                                      object_define_own_prop(s3, c, l, x,\n                                        desc, str), function(s4, rv) {\n                                        \n                                        return (res_void(s4));}));\n                              }\n                              \n                            };\n                            switch (d_2.tag) {\n                              case "Coq_full_descriptor_undef":\n                                return (follow_2({}));\n                              case "Coq_full_descriptor_some":\n                                var a = d_2.value;\n                                switch (a.tag) {\n                                  case "Coq_attributes_data_of":\n                                    var a0 = a.value;\n                                    return (follow_2({}));\n                                  case "Coq_attributes_accessor_of":\n                                    var aa_2 = a.value;\n                                    var _switch_arg_12 = aa_2.attributes_accessor_set;\n                                    switch (_switch_arg_12.tag) {\n                                      case "Coq_value_prim":\n                                        var p = _switch_arg_12.value;\n                                        return (\n                                          function (s, m) {\n                                              Debug.impossible_with_heap_because(\n                                                __LOC__, s, m);\n                                              return (\n                                                Coq_result_impossible());}(\n                                            s3,\n                                            "[object_put_complete] found a primitive in an `set\' accessor."));\n                                      case "Coq_value_object":\n                                        var lfsetter = _switch_arg_12.value;\n                                        return (\n                                          if_success(\n                                            run_call(s3, c, lfsetter, vthis,\n                                              mk_cons(v, mk_nil())),\n                                            function(s4, rv) {\n                                              \n                                              return (res_void(s4));}));\n                                    }\n                                    \n                                }\n                                \n                            }\n                            }));\n                    };\n                    switch (d.tag) {\n                      case "Coq_full_descriptor_undef":\n                        return (follow({}));\n                      case "Coq_full_descriptor_some":\n                        var a = d.value;\n                        switch (a.tag) {\n                          case "Coq_attributes_data_of":\n                            var ad = a.value;\n                            switch (vthis.tag) {\n                              case "Coq_value_prim":\n                                var wthis = vthis.value;\n                                return (\n                                  out_error_or_void(s2, c, str,\n                                    Coq_native_error_type()));\n                              case "Coq_value_object":\n                                var lthis = vthis.value;\n                                var desc = {\n                                  descriptor_value: Some(v),\n                                  descriptor_writable: None(),\n                                  descriptor_get: None(),\n                                  descriptor_set: None(),\n                                  descriptor_enumerable: None(),\n                                  descriptor_configurable: None()\n                                };\n                                return (\n                                  if_success(\n                                    object_define_own_prop(s2, c, l, x, desc,\n                                      str), function(s3, rv) {\n                                      \n                                      return (res_void(s3));}));\n                            }\n                            \n                          case "Coq_attributes_accessor_of":\n                            var a0 = a.value;\n                            return (follow({}));\n                        }\n                        \n                    }\n                    }));\n            } else {\n              return (\n                out_error_or_void(s1, c, str, Coq_native_error_type()));\n            }}));\n  }\n  \n};\n\nvar object_put = function (s, c, l, x, v, str) {\n  return (\n    if_some(run_object_method(object_put_, s, l), function(b) {\n        \n        return (\n          object_put_complete(b, s, c, Coq_value_object(l), l, x, v, str));}));\n};\n\nvar env_record_set_mutable_binding = function (s, c, l, x, v, str) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              if_some(HeapStr.read_option(ed, x), function(rm) {\n                  \n                  var mu = rm[0], v_old = rm[1];\n                  if (!(mutability_compare(mu, Coq_mutability_immutable()))) {\n                    return (\n                      res_void(env_record_write_decl_env(s, l, x, mu, v)));\n                  } else {\n                    return (\n                      out_error_or_void(s, c, str, Coq_native_error_type()));\n                  }}));\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (object_put(s, c, l0, x, v, str));\n        }\n        }));\n};\n\nvar prim_value_put = function (s, c, w, x, v, str) {\n  return (\n    if_object(to_object(s, c, Coq_value_prim(w)), function(s1, l) {\n        \n        return (\n          object_put_complete(Coq_builtin_put_default(), s1, c,\n            Coq_value_prim(w), l, x, v, str));}));\n};\n\nvar ref_put_value = function (s, c, rv, v) {\n  switch (rv.tag) {\n    case "Coq_resvalue_empty":\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "[ref_put_value] received an empty result."));\n    case "Coq_resvalue_value":\n      var v0 = rv.value;\n      return (run_error(s, c, Coq_native_error_ref()));\n    case "Coq_resvalue_ref":\n      var r = rv.ref;\n      if (ref_kind_comparable(ref_kind_of(r), Coq_ref_kind_undef())) {\n        if (r.ref_strict) {\n          return (run_error(s, c, Coq_native_error_ref()));\n        } else {\n          return (\n            object_put(s, c, Coq_object_loc_prealloc(Coq_prealloc_global()),\n              r.ref_name, v, throw_false));\n        }\n      } else {\n        if ((ref_kind_comparable(ref_kind_of(r),\n               Coq_ref_kind_primitive_base())\n            || (ref_kind_comparable(ref_kind_of(r), Coq_ref_kind_null())\n               || ref_kind_comparable(ref_kind_of(r), Coq_ref_kind_object())))) {\n          var _switch_arg_14 = r.ref_base;\n          switch (_switch_arg_14.tag) {\n            case "Coq_ref_base_type_value":\n              var v_2 = _switch_arg_14.value;\n              if (ref_kind_comparable(ref_kind_of(r),\n                    Coq_ref_kind_primitive_base())) {\n                switch (v_2.tag) {\n                  case "Coq_value_prim":\n                    var w = v_2.value;\n                    return (\n                      prim_value_put(s, c, w, r.ref_name, v, r.ref_strict));\n                  case "Coq_value_object":\n                    var o = v_2.value;\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s,\n                        "[ref_put_value] impossible case"));\n                }\n                \n              } else {\n                switch (v_2.tag) {\n                  case "Coq_value_prim":\n                    var p = v_2.value;\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s,\n                        "[ref_put_value] impossible case"));\n                  case "Coq_value_object":\n                    var l = v_2.value;\n                    return (\n                      object_put(s, c, l, r.ref_name, v, r.ref_strict));\n                }\n                \n              }\n            case "Coq_ref_base_type_env_loc":\n              var l = _switch_arg_14.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "[ref_put_value] contradicts ref_is_property"));\n          }\n          \n        } else {\n          var _switch_arg_13 = r.ref_base;\n          switch (_switch_arg_13.tag) {\n            case "Coq_ref_base_type_value":\n              var v0 = _switch_arg_13.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "[ref_put_value] impossible spec"));\n            case "Coq_ref_base_type_env_loc":\n              var l = _switch_arg_13.value;\n              return (\n                env_record_set_mutable_binding(s, c, l, r.ref_name, v,\n                  r.ref_strict));\n          }\n          \n        }\n      }\n  }\n  \n};\n\nvar env_record_create_mutable_binding = function (s, c, l, x, deletable_opt) {\n  var deletable = unsome_default(false, deletable_opt);\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            if (HeapStr.indom_dec(ed, x)) {\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Already declared environnment record in [env_record_create_mutable_binding]."));\n            } else {\n              var s_2 = env_record_write_decl_env(s, l, x,\n                          mutability_of_bool(deletable),\n                          Coq_value_prim(Coq_prim_undef()));\n              return (res_void(s_2));\n            }\n          case "Coq_env_record_object":\n            var l0 = e.value, pt = e.provide_this;\n            return (\n              if_bool(object_has_prop(s, c, l0, x), function(s1, has) {\n                  \n                  if (has) {\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s1,\n                        "Already declared binding in [env_record_create_mutable_binding]."));\n                  } else {\n                    var a = {\n                      attributes_data_value: Coq_value_prim(Coq_prim_undef()),\n                      attributes_data_writable: true,\n                      attributes_data_enumerable: true,\n                      attributes_data_configurable: deletable\n                    };\n                    return (\n                      if_success(\n                        object_define_own_prop(s1, c, l0, x,\n                          descriptor_of_attributes(Coq_attributes_data_of(a)),\n                          throw_true), function(s2, rv) {\n                          \n                          return (res_void(s2));}));\n                  }}));\n        }\n        }));\n};\n\nvar env_record_create_set_mutable_binding = function (s, c, l, x, deletable_opt, v, str) {\n  return (\n    if_void(env_record_create_mutable_binding(s, c, l, x, deletable_opt),\n      function(s0) {\n        \n        return (env_record_set_mutable_binding(s0, c, l, x, v, str));}));\n};\n\nvar env_record_create_immutable_binding = function (s, l, x) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            if (HeapStr.indom_dec(ed, x)) {\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Already declared environnment record in [env_record_create_immutable_binding]."));\n            } else {\n              return (\n                res_void(\n                  env_record_write_decl_env(s, l, x,\n                    Coq_mutability_uninitialized_immutable(),\n                    Coq_value_prim(Coq_prim_undef()))));\n            }\n          case "Coq_env_record_object":\n            var o = e.value, p = e.provide_this;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[env_record_create_immutable_binding] received an environnment record object."));\n        }\n        }));\n};\n\nvar env_record_initialize_immutable_binding = function (s, l, x, v) {\n  return (\n    if_some(env_record_binds_option(s, l), function(e) {\n        \n        switch (e.tag) {\n          case "Coq_env_record_decl":\n            var ed = e.value;\n            return (\n              if_some(decl_env_record_option(ed, x), function(evs) {\n                  \n                  if (prod_compare(mutability_compare, value_compare, evs,\n                        [Coq_mutability_uninitialized_immutable(), Coq_value_prim(\n                                                                    Coq_prim_undef(\n                                                                    ))])) {\n                    var s_2 = env_record_write_decl_env(s, l, x,\n                                Coq_mutability_immutable(), v);\n                    return (res_void(s_2));\n                  } else {\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s,\n                        "Non suitable binding in [env_record_initialize_immutable_binding]."));\n                  }}));\n          case "Coq_env_record_object":\n            var o = e.value, p = e.provide_this;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "[env_record_initialize_immutable_binding] received an environnment record object."));\n        }\n        }));\n};\n\nvar call_object_new = function (s, c, v) {\n  var _switch_arg_15 = type_of(v);\n  switch (_switch_arg_15.tag) {\n    case "Coq_type_undef":\n      return (\n        result_out((function () {\n            var o = object_new(\n                      Coq_value_object(\n                        Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                      "Object");\n            var p = object_alloc(s, o);\n            var l = p[0], s_2 = p[1];\n            return (Coq_out_ter(s_2, res_val(Coq_value_object(l))));}())));\n    case "Coq_type_null":\n      return (\n        result_out((function () {\n            var o = object_new(\n                      Coq_value_object(\n                        Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                      "Object");\n            var p = object_alloc(s, o);\n            var l = p[0], s_2 = p[1];\n            return (Coq_out_ter(s_2, res_val(Coq_value_object(l))));}())));\n    case "Coq_type_bool":\n      return (to_object(s, c, v));\n    case "Coq_type_number":\n      return (to_object(s, c, v));\n    case "Coq_type_string":\n      return (to_object(s, c, v));\n    case "Coq_type_object":\n      return (result_out(Coq_out_ter(s, res_val(v))));\n  }\n  \n};\n\nvar array_args_map_loop = function (s, c, l, args, ind) {\n  switch (args.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var h = args.head, rest = args.tail;\n      return (\n        if_some(\n          object_heap_map_properties_option(s, l, function (p) {\n              return (\n                HeapStr.write(p, JsNumber.to_string(ind),\n                  Coq_attributes_data_of(attributes_data_intro_all_true(h))));\n            }), function(s_2) {\n            \n            return (array_args_map_loop(s_2, c, l, rest, (ind + 1.)));}));\n  }\n  \n};\n\nvar string_of_prealloc = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_prealloc_global":\n      return ("global");\n    case "Coq_prealloc_global_eval":\n      return ("global_eval");\n    case "Coq_prealloc_global_parse_int":\n      return ("global_parse_int");\n    case "Coq_prealloc_global_parse_float":\n      return ("global_parse_float");\n    case "Coq_prealloc_global_is_finite":\n      return ("global_is_finite");\n    case "Coq_prealloc_global_is_nan":\n      return ("global_is_nan");\n    case "Coq_prealloc_global_decode_uri":\n      return ("global_decode_uri");\n    case "Coq_prealloc_global_decode_uri_component":\n      return ("global_decode_uri_component");\n    case "Coq_prealloc_global_encode_uri":\n      return ("global_encode_uri");\n    case "Coq_prealloc_global_encode_uri_component":\n      return ("global_encode_uri_component");\n    case "Coq_prealloc_object":\n      return ("object");\n    case "Coq_prealloc_object_get_proto_of":\n      return ("object_get_proto_of");\n    case "Coq_prealloc_object_get_own_prop_descriptor":\n      return ("object_get_own_prop_descriptor");\n    case "Coq_prealloc_object_get_own_prop_name":\n      return ("object_get_own_prop_name");\n    case "Coq_prealloc_object_create":\n      return ("object_create");\n    case "Coq_prealloc_object_define_prop":\n      return ("object_define_prop");\n    case "Coq_prealloc_object_define_props":\n      return ("object_define_props");\n    case "Coq_prealloc_object_seal":\n      return ("object_seal");\n    case "Coq_prealloc_object_freeze":\n      return ("object_freeze");\n    case "Coq_prealloc_object_prevent_extensions":\n      return ("object_prevent_extensions");\n    case "Coq_prealloc_object_is_sealed":\n      return ("object_is_sealed");\n    case "Coq_prealloc_object_is_frozen":\n      return ("object_is_frozen");\n    case "Coq_prealloc_object_is_extensible":\n      return ("object_is_extensible");\n    case "Coq_prealloc_object_keys":\n      return ("object_keys");\n    case "Coq_prealloc_object_keys_call":\n      return ("object_keys_call");\n    case "Coq_prealloc_object_proto":\n      return ("object_proto_");\n    case "Coq_prealloc_object_proto_to_string":\n      return ("object_proto_to_string");\n    case "Coq_prealloc_object_proto_value_of":\n      return ("object_proto_value_of");\n    case "Coq_prealloc_object_proto_has_own_prop":\n      return ("object_proto_has_own_prop");\n    case "Coq_prealloc_object_proto_is_prototype_of":\n      return ("object_proto_is_prototype_of");\n    case "Coq_prealloc_object_proto_prop_is_enumerable":\n      return ("object_proto_prop_is_enumerable");\n    case "Coq_prealloc_function":\n      return ("function");\n    case "Coq_prealloc_function_proto":\n      return ("function_proto");\n    case "Coq_prealloc_function_proto_to_string":\n      return ("function_proto_to_string");\n    case "Coq_prealloc_function_proto_apply":\n      return ("function_proto_apply");\n    case "Coq_prealloc_function_proto_call":\n      return ("function_proto_call");\n    case "Coq_prealloc_function_proto_bind":\n      return ("function_proto_bind");\n    case "Coq_prealloc_bool":\n      return ("bool");\n    case "Coq_prealloc_bool_proto":\n      return ("bool_proto");\n    case "Coq_prealloc_bool_proto_to_string":\n      return ("bool_proto_to_string");\n    case "Coq_prealloc_bool_proto_value_of":\n      return ("bool_proto_value_of");\n    case "Coq_prealloc_number":\n      return ("number");\n    case "Coq_prealloc_number_proto":\n      return ("number_proto");\n    case "Coq_prealloc_number_proto_to_string":\n      return ("number_proto_to_string");\n    case "Coq_prealloc_number_proto_value_of":\n      return ("number_proto_value_of");\n    case "Coq_prealloc_number_proto_to_fixed":\n      return ("number_proto_to_fixed");\n    case "Coq_prealloc_number_proto_to_exponential":\n      return ("number_proto_to_exponential");\n    case "Coq_prealloc_number_proto_to_precision":\n      return ("number_proto_to_precision");\n    case "Coq_prealloc_array":\n      return ("array");\n    case "Coq_prealloc_array_is_array":\n      return ("array_is_array");\n    case "Coq_prealloc_array_proto":\n      return ("array_proto");\n    case "Coq_prealloc_array_proto_to_string":\n      return ("array_proto_to_string");\n    case "Coq_prealloc_array_proto_join":\n      return ("array_proto_join");\n    case "Coq_prealloc_array_proto_pop":\n      return ("array_proto_pop");\n    case "Coq_prealloc_array_proto_push":\n      return ("array_proto_push");\n    case "Coq_prealloc_string":\n      return ("string");\n    case "Coq_prealloc_string_proto":\n      return ("string_proto");\n    case "Coq_prealloc_string_proto_to_string":\n      return ("string_proto_to_string");\n    case "Coq_prealloc_string_proto_value_of":\n      return ("string_proto_value_of");\n    case "Coq_prealloc_string_proto_char_at":\n      return ("string_proto_char_at");\n    case "Coq_prealloc_string_proto_char_code_at":\n      return ("string_proto_char_code_at");\n    case "Coq_prealloc_math":\n      return ("math");\n    case "Coq_prealloc_mathop":\n      var m = _foo_.mathop;\n      return ("mathop");\n    case "Coq_prealloc_date":\n      return ("date");\n    case "Coq_prealloc_regexp":\n      return ("regexp");\n    case "Coq_prealloc_error":\n      return ("error");\n    case "Coq_prealloc_error_proto":\n      return ("error_proto");\n    case "Coq_prealloc_native_error":\n      var n = _foo_.error;\n      return ("native_error");\n    case "Coq_prealloc_native_error_proto":\n      var n = _foo_.error;\n      return ("native_error_proto");\n    case "Coq_prealloc_error_proto_to_string":\n      return ("error_proto_to_string");\n    case "Coq_prealloc_throw_type_error":\n      return ("throw_type_error");\n    case "Coq_prealloc_json":\n      return ("json");\n  }\n  \n};\n\nvar run_construct_prealloc = function (s, c, b, args) {\n  switch (b.tag) {\n    case "Coq_prealloc_object":\n      var v = get_arg(0, args);\n      return (call_object_new(s, c, v));\n    case "Coq_prealloc_bool":\n      return (\n        result_out((function () {\n            var v = get_arg(0, args);\n            var b0 = convert_value_to_boolean(v);\n            var o1 = object_new(\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_bool_proto())),\n                       "Boolean");\n            var o = object_with_primitive_value(o1,\n                      Coq_value_prim(Coq_prim_bool(b0)));\n            var p = object_alloc(s, o);\n            var l = p[0], s_2 = p[1];\n            return (Coq_out_ter(s_2, res_val(Coq_value_object(l))));}())));\n    case "Coq_prealloc_number":\n      var follow = function (s_2, v) {\n        var o1 = object_new(\n                   Coq_value_object(\n                     Coq_object_loc_prealloc(Coq_prealloc_number_proto())),\n                   "Number");\n        var o = object_with_primitive_value(o1, v);\n        var _tuple_arg_16 = object_alloc(s_2, o);\n        var l = _tuple_arg_16[0], s1 = _tuple_arg_16[1];\n        return (result_out(Coq_out_ter(s1, res_val(Coq_value_object(l)))));\n      };\n      if (list_eq_nil_decidable(args)) {\n        return (follow(s, Coq_value_prim(Coq_prim_number(JsNumber.zero))));\n      } else {\n        var v = get_arg(0, args);\n        return (\n          if_number(to_number(s, c, v), function(x, x0) {\n              \n              return (follow(x, Coq_value_prim(Coq_prim_number(x0))));}));\n      }\n    case "Coq_prealloc_array":\n      var o_2 = object_new(\n                  Coq_value_object(\n                    Coq_object_loc_prealloc(Coq_prealloc_array_proto())),\n                  "Array");\n      var o = object_for_array(o_2, Coq_builtin_define_own_prop_array());\n      var p = object_alloc(s, o);\n      var l = p[0], s_2 = p[1];\n      var follow = function (s_3, length0) {\n        return (\n          if_some(\n            object_heap_map_properties_option(s_3, l, function (p0) {\n                return (\n                  HeapStr.write(p0, "length",\n                    Coq_attributes_data_of({\n                        attributes_data_value: Coq_value_prim(\n                                                 Coq_prim_number(length0)),\n                        attributes_data_writable: true,\n                        attributes_data_enumerable: false,\n                        attributes_data_configurable: false})));}),\n            function(s0) {\n              \n              return (res_ter(s0, res_val(Coq_value_object(l))));}));\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 1)) {\n        var v = get_arg(0, args);\n        switch (v.tag) {\n          case "Coq_value_prim":\n            var p0 = v.value;\n            switch (p0.tag) {\n              case "Coq_prim_undef":\n                return (\n                  if_some(\n                    object_heap_map_properties_option(s_2, l, function (p1) {\n                        return (\n                          HeapStr.write(p1, "0",\n                            Coq_attributes_data_of(\n                              attributes_data_intro_all_true(v))));}),\n                    function(s0) { \n                                   return (follow(s0, 1.0));}));\n              case "Coq_prim_null":\n                return (\n                  if_some(\n                    object_heap_map_properties_option(s_2, l, function (p1) {\n                        return (\n                          HeapStr.write(p1, "0",\n                            Coq_attributes_data_of(\n                              attributes_data_intro_all_true(v))));}),\n                    function(s0) { \n                                   return (follow(s0, 1.0));}));\n              case "Coq_prim_bool":\n                var b0 = p0.value;\n                return (\n                  if_some(\n                    object_heap_map_properties_option(s_2, l, function (p1) {\n                        return (\n                          HeapStr.write(p1, "0",\n                            Coq_attributes_data_of(\n                              attributes_data_intro_all_true(v))));}),\n                    function(s0) { \n                                   return (follow(s0, 1.0));}));\n              case "Coq_prim_number":\n                var vlen = p0.value;\n                return (\n                  if_run(\n                    to_uint32(s_2, c, Coq_value_prim(Coq_prim_number(vlen))),\n                    function(s0, ilen) {\n                      \n                      if ((ilen === vlen)) {\n                        return (follow(s0, ilen));\n                      } else {\n                        return (run_error(s0, c, Coq_native_error_range()));\n                      }}));\n              case "Coq_prim_string":\n                var s0 = p0.value;\n                return (\n                  if_some(\n                    object_heap_map_properties_option(s_2, l, function (p1) {\n                        return (\n                          HeapStr.write(p1, "0",\n                            Coq_attributes_data_of(\n                              attributes_data_intro_all_true(v))));}),\n                    function(s1) { \n                                   return (follow(s1, 1.0));}));\n            }\n            \n          case "Coq_value_object":\n            var o0 = v.value;\n            return (\n              if_some(\n                object_heap_map_properties_option(s_2, l, function (p0) {\n                    return (\n                      HeapStr.write(p0, "0",\n                        Coq_attributes_data_of(\n                          attributes_data_intro_all_true(v))));}),\n                function(s0) { \n                               return (follow(s0, 1.0));}));\n        }\n        \n      } else {\n        return (\n          if_some(\n            object_heap_map_properties_option(s_2, l, function (p0) {\n                return (\n                  HeapStr.write(p0, "length",\n                    Coq_attributes_data_of({\n                        attributes_data_value: Coq_value_prim(\n                                                 Coq_prim_number(\n                                                   number_of_int(arg_len))),\n                        attributes_data_writable: true,\n                        attributes_data_enumerable: false,\n                        attributes_data_configurable: false})));}),\n            function(s0) {\n              \n              return (\n                if_void(array_args_map_loop(s0, c, l, args, 0.),\n                  function(s1) {\n                    \n                    return (res_ter(s1, res_val(Coq_value_object(l))));}));}));\n      }\n    case "Coq_prealloc_string":\n      var o2 = object_new(\n                 Coq_value_object(\n                   Coq_object_loc_prealloc(Coq_prealloc_string_proto())),\n                 "String");\n      var o1 = object_with_get_own_property(o2,\n                 Coq_builtin_get_own_prop_string());\n      var follow = function (s0, s1) {\n        var o = object_with_primitive_value(o1,\n                  Coq_value_prim(Coq_prim_string(s1)));\n        var _tuple_arg_17 = object_alloc(s0, o);\n        var l = _tuple_arg_17[0], s2 = _tuple_arg_17[1];\n        var lenDesc = attributes_data_intro_constant(\n                        Coq_value_prim(\n                          Coq_prim_number(number_of_int(strlength(s1)))));\n        return (\n          if_some(\n            object_heap_map_properties_option(s2, l, function (p) {\n                return (\n                  HeapStr.write(p, "length", Coq_attributes_data_of(lenDesc)));\n              }), function(s_2) {\n              \n              return (res_ter(s_2, res_val(Coq_value_object(l))));}));\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 0)) {\n        return (follow(s, ""));\n      } else {\n        var arg = get_arg(0, args);\n        return (\n          if_string(to_string(s, c, arg), function(s0, s1) {\n              \n              return (follow(s0, s1));}));\n      }\n    case "Coq_prealloc_error":\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_error_proto())), v));\n    case "Coq_prealloc_native_error":\n      var ne = b.error;\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))), v));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}(\n          strappend("Construct prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented."))));\n  }\n  \n};\n\nvar run_construct_default = function (s, c, l, args) {\n  return (\n    if_value(run_object_get(s, c, l, "prototype"), function(s1, v1) {\n        \n        if (type_compare(type_of(v1), Coq_type_object())) {\n          var vproto = v1;\n        } else {\n          var vproto = Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_object_proto()));\n        }\n        var o = object_new(vproto, "Object");\n        var p = object_alloc(s1, o);\n        var l_2 = p[0], s2 = p[1];\n        return (\n          if_value(run_call(s2, c, l, Coq_value_object(l_2), args),\n            function(s3, v2) {\n              \n              if (type_compare(type_of(v2), Coq_type_object())) {\n                var vr = v2;\n              } else {\n                var vr = Coq_value_object(l_2);\n              }\n              return (res_ter(s3, res_val(vr)));}));}));\n};\n\nvar run_construct = function (s, c, co, l, args) {\n  switch (co.tag) {\n    case "Coq_construct_default":\n      return (run_construct_default(s, c, l, args));\n    case "Coq_construct_after_bind":\n      return (\n        if_some(run_object_method(object_target_function_, s, l),\n          function(otrg) {\n            \n            return (\n              if_some(otrg, function(target) {\n                  \n                  return (\n                    if_some(run_object_method(object_construct_, s, target),\n                      function(oco) {\n                        \n                        switch (oco.tag) {\n                          case "Some":\n                            var co0 = oco.value;\n                            return (\n                              if_some(\n                                run_object_method(object_bound_args_, s, l),\n                                function(oarg) {\n                                  \n                                  return (\n                                    if_some(oarg, function(boundArgs) {\n                                        \n                                        var arguments_ = LibList.append(\n                                                           boundArgs, args);\n                                        return (\n                                          run_construct(s, c, co0, target,\n                                            arguments_));}));}));\n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));}));}));\n    case "Coq_construct_prealloc":\n      var b = co.prealloc;\n      return (run_construct_prealloc(s, c, b, args));\n  }\n  \n};\n\nvar run_call_default = function (s, c, lf) {\n  var def = result_out(\n              Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_undef()))));\n  return (\n    if_some(run_object_method(object_code_, s, lf), function(oC) {\n        \n        switch (oC.tag) {\n          case "Some":\n            var bd = oC.value;\n            if (list_eq_nil_decidable(prog_elements(funcbody_prog(bd)))) {\n              return (def);\n            } else {\n              return (\n                ifx_success_or_return(run_prog(s, c, funcbody_prog(bd)),\n                  function (s_2) {\n                    return (\n                      result_out(\n                        Coq_out_ter(s_2,\n                          res_val(Coq_value_prim(Coq_prim_undef())))));},\n                  function (s_2, rv) {\n                    return (result_out(Coq_out_ter(s_2, res_normal(rv))));}));\n            }\n          case "None":\n            return (def);\n        }\n        }));\n};\n\nvar creating_function_object_proto = function (s, c, l) {\n  return (\n    if_object(run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n      function(s1, lproto) {\n        \n        var a1 = {\n          attributes_data_value: Coq_value_object(l),\n          attributes_data_writable: true,\n          attributes_data_enumerable: false,\n          attributes_data_configurable: true\n        };\n        return (\n          if_bool(\n            object_define_own_prop(s1, c, lproto, "constructor",\n              descriptor_of_attributes(Coq_attributes_data_of(a1)), false),\n            function(s2, b) {\n              \n              var a2 = {\n                attributes_data_value: Coq_value_object(lproto),\n                attributes_data_writable: true,\n                attributes_data_enumerable: false,\n                attributes_data_configurable: false\n              };\n              return (\n                object_define_own_prop(s2, c, l, "prototype",\n                  descriptor_of_attributes(Coq_attributes_data_of(a2)),\n                  false));}));}));\n};\n\nvar creating_function_object = function (s, c, names, bd, x, str) {\n  var o = object_new(\n            Coq_value_object(\n              Coq_object_loc_prealloc(Coq_prealloc_function_proto())),\n            "Function");\n  var o1 = object_with_get(o, Coq_builtin_get_function());\n  var o2 = object_with_invokation(o1, Some(Coq_construct_default()),\n             Some(Coq_call_default()),\n             Some(Coq_builtin_has_instance_function()));\n  var o3 = object_with_details(o2, Some(x), Some(names), Some(bd), None(),\n             None(), None(), None());\n  var p = object_alloc(s, o3);\n  var l = p[0], s1 = p[1];\n  var a1 = {\n    attributes_data_value: Coq_value_prim(\n                             Coq_prim_number(\n                               number_of_int(LibList.length(names)))),\n    attributes_data_writable: false,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  return (\n    if_bool(\n      object_define_own_prop(s1, c, l, "length",\n        descriptor_of_attributes(Coq_attributes_data_of(a1)), false),\n      function(s2, b2) {\n        \n        return (\n          if_bool(creating_function_object_proto(s2, c, l), function(s3,\n            b3) {\n              \n              if (!(str)) {\n                return (res_ter(s3, res_val(Coq_value_object(l))));\n              } else {\n                var vthrower = Coq_value_object(\n                                 Coq_object_loc_prealloc(\n                                   Coq_prealloc_throw_type_error()));\n                var a2 = {\n                  attributes_accessor_get: vthrower,\n                  attributes_accessor_set: vthrower,\n                  attributes_accessor_enumerable: false,\n                  attributes_accessor_configurable: false\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s3, c, l, "caller",\n                      descriptor_of_attributes(\n                        Coq_attributes_accessor_of(a2)), false), function(s4,\n                    b4) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s4, c, l, "arguments",\n                            descriptor_of_attributes(\n                              Coq_attributes_accessor_of(a2)), false),\n                          function(s5, b5) {\n                            \n                            return (\n                              res_ter(s5, res_val(Coq_value_object(l))));}));\n                    }));\n              }}));}));\n};\n\nvar binding_inst_formal_params = function (s, c, l, args, names, str) {\n  switch (names.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var argname = names.head, names_2 = names.tail;\n      var v = hd(Coq_value_prim(Coq_prim_undef()), args);\n      var args_2 = tl(args);\n      return (\n        if_bool(env_record_has_binding(s, c, l, argname), function(s1, hb) {\n            \n            var follow = function (s_2) {\n              return (\n                if_void(\n                  env_record_set_mutable_binding(s_2, c, l, argname, v, str),\n                  function(s_3) {\n                    \n                    return (\n                      binding_inst_formal_params(s_3, c, l, args_2, names_2,\n                        str));}));\n            };\n            if (hb) {\n              return (follow(s1));\n            } else {\n              return (\n                if_void(\n                  env_record_create_mutable_binding(s1, c, l, argname,\n                    None()), function(s2) { \n                                            return (follow(s2));}));\n            }}));\n  }\n  \n};\n\nvar binding_inst_function_decls = function (s, c, l, fds, str, bconfig) {\n  switch (fds.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var fd = fds.head, fds_2 = fds.tail;\n      var fbd = fd.funcdecl_body;\n      var str_fd = funcbody_is_strict(fbd);\n      var fparams = fd.funcdecl_parameters;\n      var fname = fd.funcdecl_name;\n      return (\n        if_object(\n          creating_function_object(s, c, fparams, fbd,\n            c.execution_ctx_variable_env, str_fd), function(s1, fo) {\n            \n            var follow = function (s2) {\n              return (\n                if_void(\n                  env_record_set_mutable_binding(s2, c, l, fname,\n                    Coq_value_object(fo), str), function(s3) {\n                    \n                    return (\n                      binding_inst_function_decls(s3, c, l, fds_2, str,\n                        bconfig));}));\n            };\n            return (\n              if_bool(env_record_has_binding(s1, c, l, fname), function(s2,\n                has) {\n                  \n                  if (has) {\n                    if (nat_eq(l, env_loc_global_env_record)) {\n                      return (\n                        if_run(\n                          run_object_get_prop(s2, c,\n                            Coq_object_loc_prealloc(Coq_prealloc_global()),\n                            fname), function(s3, d) {\n                            \n                            switch (d.tag) {\n                              case "Coq_full_descriptor_undef":\n                                return (\n                                  function (s, m) {\n                                      Debug.impossible_with_heap_because(\n                                        __LOC__, s, m);\n                                      return (Coq_result_impossible());}(s3,\n                                    "Undefined full descriptor in [binding_inst_function_decls]."));\n                              case "Coq_full_descriptor_some":\n                                var a = d.value;\n                                if (attributes_configurable(a)) {\n                                  var a_2 = {\n                                    attributes_data_value: Coq_value_prim(\n                                                             Coq_prim_undef()),\n                                    attributes_data_writable: true,\n                                    attributes_data_enumerable: true,\n                                    attributes_data_configurable: bconfig\n                                  };\n                                  return (\n                                    if_bool(\n                                      object_define_own_prop(s3, c,\n                                        Coq_object_loc_prealloc(\n                                          Coq_prealloc_global()), fname,\n                                        descriptor_of_attributes(\n                                          Coq_attributes_data_of(a_2)), true),\n                                      function(s0, x) { \n                                                        return (follow(s0));\n                                      }));\n                                } else {\n                                  if ((descriptor_is_accessor_dec(\n                                         descriptor_of_attributes(a))\n                                      || (!(attributes_writable(a))\n                                         || !(attributes_enumerable(a))))) {\n                                    return (\n                                      run_error(s3, c,\n                                        Coq_native_error_type()));\n                                  } else {\n                                    return (follow(s3));\n                                  }\n                                }\n                            }\n                            }));\n                    } else {\n                      return (follow(s2));\n                    }\n                  } else {\n                    return (\n                      if_void(\n                        env_record_create_mutable_binding(s2, c, l, fname,\n                          Some(bconfig)), function(s3) { \n                                                         return (follow(s3));\n                        }));\n                  }}));}));\n  }\n  \n};\n\nvar make_arg_getter = function (s, c, x, x0) {\n  var xbd = strappend("return ", strappend(x, ";"));\n  var bd = Coq_funcbody_intro(\n             Coq_prog_intro(true,\n               mk_cons(\n                 Coq_element_stat(\n                   Coq_stat_return(Some(Coq_expr_identifier(x)))), mk_nil())),\n             xbd);\n  return (creating_function_object(s, c, mk_nil(), bd, x0, true));\n};\n\nvar make_arg_setter = function (s, c, x, x0) {\n  var xparam = strappend(x, "_arg");\n  var xbd = strappend(x, strappend(" = ", strappend(xparam, ";")));\n  var bd = Coq_funcbody_intro(\n             Coq_prog_intro(true,\n               mk_cons(\n                 Coq_element_stat(\n                   Coq_stat_expr(\n                     Coq_expr_assign(Coq_expr_identifier(x), None(),\n                       Coq_expr_identifier(xparam)))), mk_nil())), xbd);\n  return (\n    creating_function_object(s, c, mk_cons(xparam, mk_nil()), bd, x0, true));\n};\n\nvar arguments_object_map_loop = function (s, c, l, xs, len, args, x, str, lmap, xsmap) {\n  return (\n    function (fO, fS, n) {\n        if (int_eq(n, 0)) {\n          return (fO({}));\n        } else {\n          return (fS((n - 1)));\n        }}(function (_pat_any_18) {\n        if (list_eq_nil_decidable(xsmap)) {\n          return (res_void(s));\n        } else {\n          return (\n            if_some(object_binds_option(s, l), function(o) {\n                \n                var o_2 = object_for_args_object(o, lmap,\n                            Coq_builtin_get_args_obj(),\n                            Coq_builtin_get_own_prop_args_obj(),\n                            Coq_builtin_define_own_prop_args_obj(),\n                            Coq_builtin_delete_args_obj());\n                return (res_void(object_write(s, l, o_2)));}));\n        }}, function (len_2) {\n        var tdl = take_drop_last(args);\n        var rmlargs = tdl[0], largs = tdl[1];\n        var arguments_object_map_loop_2 = function (s0, xsmap0) {\n          return (\n            arguments_object_map_loop(s0, c, l, xs, len_2, rmlargs, x, str,\n              lmap, xsmap0));\n        };\n        var a = attributes_data_intro_all_true(largs);\n        return (\n          if_bool(\n            object_define_own_prop(s, c, l,\n              convert_prim_to_string(Coq_prim_number(number_of_int(len_2))),\n              descriptor_of_attributes(Coq_attributes_data_of(a)), false),\n            function(s1, b) {\n              \n              if (ge_nat_decidable(len_2, LibList.length(xs))) {\n                return (arguments_object_map_loop_2(s1, xsmap));\n              } else {\n                var dummy = "";\n                var x0 = nth_def(dummy, len_2, xs);\n                if ((str || mem_decide(string_eq, x0, xsmap))) {\n                  return (arguments_object_map_loop_2(s1, xsmap));\n                } else {\n                  return (\n                    if_object(make_arg_getter(s1, c, x0, x), function(s2,\n                      lgetter) {\n                        \n                        return (\n                          if_object(make_arg_setter(s2, c, x0, x),\n                            function(s3, lsetter) {\n                              \n                              var a_2 = {\n                                attributes_accessor_get: Coq_value_object(\n                                                           lgetter),\n                                attributes_accessor_set: Coq_value_object(\n                                                           lsetter),\n                                attributes_accessor_enumerable: false,\n                                attributes_accessor_configurable: true\n                              };\n                              return (\n                                if_bool(\n                                  object_define_own_prop(s3, c, lmap,\n                                    convert_prim_to_string(\n                                      Coq_prim_number(number_of_int(len_2))),\n                                    descriptor_of_attributes(\n                                      Coq_attributes_accessor_of(a_2)),\n                                    false), function(s4, b_2) {\n                                    \n                                    return (\n                                      arguments_object_map_loop_2(s4,\n                                        mk_cons(x0, xsmap)));}));}));}));\n                }\n              }}));}, len));\n};\n\nvar arguments_object_map = function (s, c, l, xs, args, x, str) {\n  return (\n    if_object(run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n      function(s_2, lmap) {\n        \n        return (\n          arguments_object_map_loop(s_2, c, l, xs, LibList.length(args),\n            args, x, str, lmap, mk_nil()));}));\n};\n\nvar create_arguments_object = function (s, c, lf, xs, args, x, str) {\n  var o = object_create_builtin(\n            Coq_value_object(\n              Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n            "Arguments", Heap.empty);\n  var p = object_alloc(s, o);\n  var l = p[0], s_2 = p[1];\n  var a = {\n    attributes_data_value: Coq_value_prim(\n                             Coq_prim_number(\n                               number_of_int(LibList.length(args)))),\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  return (\n    if_bool(\n      object_define_own_prop(s_2, c, l, "length",\n        descriptor_of_attributes(Coq_attributes_data_of(a)), false),\n      function(s1, b) {\n        \n        return (\n          if_void(arguments_object_map(s1, c, l, xs, args, x, str),\n            function(s2) {\n              \n              if (str) {\n                var vthrower = Coq_value_object(\n                                 Coq_object_loc_prealloc(\n                                   Coq_prealloc_throw_type_error()));\n                var a0 = {\n                  attributes_accessor_get: vthrower,\n                  attributes_accessor_set: vthrower,\n                  attributes_accessor_enumerable: false,\n                  attributes_accessor_configurable: false\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s2, c, l, "caller",\n                      descriptor_of_attributes(\n                        Coq_attributes_accessor_of(a0)), false), function(s3,\n                    b_2) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s3, c, l, "callee",\n                            descriptor_of_attributes(\n                              Coq_attributes_accessor_of(a0)), false),\n                          function(s4, b_3) {\n                            \n                            return (\n                              res_ter(s4, res_val(Coq_value_object(l))));}));\n                    }));\n              } else {\n                var a0 = {\n                  attributes_data_value: Coq_value_object(lf),\n                  attributes_data_writable: true,\n                  attributes_data_enumerable: false,\n                  attributes_data_configurable: true\n                };\n                return (\n                  if_bool(\n                    object_define_own_prop(s2, c, l, "callee",\n                      descriptor_of_attributes(Coq_attributes_data_of(a0)),\n                      false), function(s3, b_2) {\n                      \n                      return (res_ter(s3, res_val(Coq_value_object(l))));}));\n              }}));}));\n};\n\nvar binding_inst_arg_obj = function (s, c, lf, p, xs, args, l) {\n  var arguments_ = "arguments";\n  var str = prog_intro_strictness(p);\n  return (\n    if_object(\n      create_arguments_object(s, c, lf, xs, args,\n        c.execution_ctx_variable_env, str), function(s1, largs) {\n        \n        if (str) {\n          return (\n            if_void(env_record_create_immutable_binding(s1, l, arguments_),\n              function(s2) {\n                \n                return (\n                  env_record_initialize_immutable_binding(s2, l, arguments_,\n                    Coq_value_object(largs)));}));\n        } else {\n          return (\n            env_record_create_set_mutable_binding(s1, c, l, arguments_,\n              None(), Coq_value_object(largs), false));\n        }}));\n};\n\nvar binding_inst_var_decls = function (s, c, l, vds, bconfig, str) {\n  switch (vds.tag) {\n    case "[]":\n      return (res_void(s));\n    case "::":\n      var vd = vds.head, vds_2 = vds.tail;\n      var bivd = function (s0) {\n        return (binding_inst_var_decls(s0, c, l, vds_2, bconfig, str));\n      };\n      return (\n        if_bool(env_record_has_binding(s, c, l, vd), function(s1, has) {\n            \n            if (has) {\n              return (bivd(s1));\n            } else {\n              return (\n                if_void(\n                  env_record_create_set_mutable_binding(s1, c, l, vd,\n                    Some(bconfig), Coq_value_prim(Coq_prim_undef()), str),\n                  function(s2) { \n                                 return (bivd(s2));}));\n            }}));\n  }\n  \n};\n\nvar execution_ctx_binding_inst = function (s, c, ct, funco, p, args) {\n  var _switch_arg_19 = c.execution_ctx_variable_env;\n  switch (_switch_arg_19.tag) {\n    case "[]":\n      return (\n        function (s, m) {\n            Debug.impossible_with_heap_because(__LOC__, s, m);\n            return (Coq_result_impossible());}(s,\n          "Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst]."));\n    case "::":\n      var l = _switch_arg_19.head, l0 = _switch_arg_19.tail;\n      var str = prog_intro_strictness(p);\n      var follow = function (s_2, names) {\n        var bconfig = codetype_compare(ct, Coq_codetype_eval());\n        var fds = prog_funcdecl(p);\n        return (\n          if_void(binding_inst_function_decls(s_2, c, l, fds, str, bconfig),\n            function(s1) {\n              \n              return (\n                if_bool(env_record_has_binding(s1, c, l, "arguments"),\n                  function(s2, bdefined) {\n                    \n                    var follow2 = function (s10) {\n                      var vds = prog_vardecl(p);\n                      return (\n                        binding_inst_var_decls(s10, c, l, vds, bconfig, str));\n                    };\n                    switch (ct.tag) {\n                      case "Coq_codetype_func":\n                        switch (funco.tag) {\n                          case "Some":\n                            var func = funco.value;\n                            if (bdefined) {\n                              return (follow2(s2));\n                            } else {\n                              return (\n                                if_void(\n                                  binding_inst_arg_obj(s2, c, func, p, names,\n                                    args, l), function(s3) {\n                                    \n                                    return (follow2(s3));}));\n                            }\n                          case "None":\n                            if (bdefined) {\n                              return (follow2(s2));\n                            } else {\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s2,\n                                  "Weird `arguments\' object in [execution_ctx_binding_inst]."));\n                            }\n                        }\n                        \n                      case "Coq_codetype_global":\n                        return (follow2(s2));\n                      case "Coq_codetype_eval":\n                        return (follow2(s2));\n                    }\n                    }));}));\n      };\n      switch (ct.tag) {\n        case "Coq_codetype_func":\n          switch (funco.tag) {\n            case "Some":\n              var func = funco.value;\n              return (\n                if_some(\n                  run_object_method(object_formal_parameters_, s, func),\n                  function(nameso) {\n                    \n                    return (\n                      if_some(nameso, function(names) {\n                          \n                          return (\n                            if_void(\n                              binding_inst_formal_params(s, c, l, args,\n                                names, str), function(s_2) {\n                                \n                                return (follow(s_2, names));}));}));}));\n            case "None":\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent functionnal code type in [execution_ctx_binding_inst]."));\n          }\n          \n        case "Coq_codetype_global":\n          switch (funco.tag) {\n            case "Some":\n              var o = funco.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case "None":\n              return (follow(s, mk_nil()));\n          }\n          \n        case "Coq_codetype_eval":\n          switch (funco.tag) {\n            case "Some":\n              var o = funco.value;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s,\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case "None":\n              return (follow(s, mk_nil()));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar entering_func_code = function (s, c, lf, vthis, args) {\n  return (\n    if_some(run_object_method(object_code_, s, lf), function(bdo) {\n        \n        return (\n          if_some(bdo, function(bd) {\n              \n              var str = funcbody_is_strict(bd);\n              var follow = function (s_2, vthis_2) {\n                return (\n                  if_some(run_object_method(object_scope_, s_2, lf),\n                    function(lexo) {\n                      \n                      return (\n                        if_some(lexo, function(lex) {\n                            \n                            var p = lexical_env_alloc_decl(s_2, lex);\n                            var lex_2 = p[0], s1 = p[1];\n                            var c_2 = execution_ctx_intro_same(lex_2,\n                                        vthis_2, str);\n                            return (\n                              if_void(\n                                execution_ctx_binding_inst(s1, c_2,\n                                  Coq_codetype_func(), Some(lf),\n                                  funcbody_prog(bd), args), function(s2) {\n                                  \n                                  return (run_call_default(s2, c_2, lf));}));\n                          }));}));\n              };\n              if (str) {\n                return (follow(s, vthis));\n              } else {\n                switch (vthis.tag) {\n                  case "Coq_value_prim":\n                    var p = vthis.value;\n                    switch (p.tag) {\n                      case "Coq_prim_undef":\n                        return (\n                          follow(s,\n                            Coq_value_object(\n                              Coq_object_loc_prealloc(Coq_prealloc_global()))));\n                      case "Coq_prim_null":\n                        return (\n                          follow(s,\n                            Coq_value_object(\n                              Coq_object_loc_prealloc(Coq_prealloc_global()))));\n                      case "Coq_prim_bool":\n                        var b = p.value;\n                        return (\n                          if_value(to_object(s, c, vthis), function(s2, v) {\n                              \n                              return (follow(s2, v));}));\n                      case "Coq_prim_number":\n                        var n = p.value;\n                        return (\n                          if_value(to_object(s, c, vthis), function(s2, v) {\n                              \n                              return (follow(s2, v));}));\n                      case "Coq_prim_string":\n                        var s0 = p.value;\n                        return (\n                          if_value(to_object(s, c, vthis), function(s2, v) {\n                              \n                              return (follow(s2, v));}));\n                    }\n                    \n                  case "Coq_value_object":\n                    var lthis = vthis.value;\n                    return (follow(s, vthis));\n                }\n                \n              }}));}));\n};\n\nvar run_object_get_own_prop = function (s, c, l, x) {\n  return (\n    if_some(run_object_method(object_get_own_prop_, s, l), function(b) {\n        \n        var def = function (s_2) {\n          return (\n            if_some(run_object_method(object_properties_, s_2, l),\n              function(p) {\n                \n                return (\n                  res_spec(s_2,\n                    ifx_some_or_default(\n                      convert_option_attributes(HeapStr.read_option(p, x)),\n                      Coq_full_descriptor_undef(), function (x) { return (x);\n                      })));}));\n        };\n        switch (b.tag) {\n          case "Coq_builtin_get_own_prop_default":\n            return (def(s));\n          case "Coq_builtin_get_own_prop_args_obj":\n            return (\n              if_run(def(s), function(s1, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (res_spec(s1, Coq_full_descriptor_undef()));\n                    case "Coq_full_descriptor_some":\n                      var a = d.value;\n                      return (\n                        if_some(\n                          run_object_method(object_parameter_map_, s1, l),\n                          function(lmapo) {\n                            \n                            return (\n                              if_some(lmapo, function(lmap) {\n                                  \n                                  return (\n                                    if_run(\n                                      run_object_get_own_prop(s1, c, lmap, x),\n                                      function(s2, d0) {\n                                        \n                                        var follow = function (s_2, a0) {\n                                          return (\n                                            res_spec(s_2,\n                                              Coq_full_descriptor_some(a0)));\n                                        };\n                                        switch (d0.tag) {\n                                          case "Coq_full_descriptor_undef":\n                                            return (follow(s2, a));\n                                          case "Coq_full_descriptor_some":\n                                            var amap = d0.value;\n                                            return (\n                                              if_value(\n                                                run_object_get(s2, c, lmap,\n                                                  x), function(s3, v) {\n                                                  \n                                                  switch (a.tag) {\n                                                    case "Coq_attributes_data_of":\n                                                      var ad = a.value;\n                                                      return (\n                                                        follow(s3,\n                                                          Coq_attributes_data_of(\n                                                            attributes_data_with_value(\n                                                              ad, v))));\n                                                    case "Coq_attributes_accessor_of":\n                                                      var aa = a.value;\n                                                      return (\n                                                        function (s, m) {\n                                                            Debug.impossible_with_heap_because(\n                                                              __LOC__, s, m);\n                                                            return (\n                                                              Coq_result_impossible(\n                                                                ));}(s3,\n                                                          "[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens."));\n                                                  }\n                                                  }));\n                                        }\n                                        }));}));}));\n                  }\n                  }));\n          case "Coq_builtin_get_own_prop_string":\n            return (\n              if_run(def(s), function(s0, d) {\n                  \n                  switch (d.tag) {\n                    case "Coq_full_descriptor_undef":\n                      return (\n                        if_run(\n                          to_int32(s0, c, Coq_value_prim(Coq_prim_string(x))),\n                          function(s1, k) {\n                            \n                            return (\n                              if_string(\n                                to_string(s1, c,\n                                  Coq_value_prim(\n                                    Coq_prim_number(JsNumber.absolute(k)))),\n                                function(s2, s3) {\n                                  \n                                  if (!(string_eq(x, s3))) {\n                                    return (\n                                      res_spec(s2,\n                                        Coq_full_descriptor_undef()));\n                                  } else {\n                                    return (\n                                      if_string(run_object_prim_value(s2, l),\n                                        function(s4, str) {\n                                          \n                                          return (\n                                            if_run(\n                                              to_int32(s4, c,\n                                                Coq_value_prim(\n                                                  Coq_prim_string(x))),\n                                              function(s5, k0) {\n                                                \n                                                var len = number_of_int(\n                                                            strlength(str));\n                                                if (le_int_decidable(len, k0)) {\n                                                  return (\n                                                    res_spec(s5,\n                                                      Coq_full_descriptor_undef(\n                                                        )));\n                                                } else {\n                                                  var resultStr = string_sub(\n                                                                    str,\n                                                                    int_of_number(\n                                                                    k0), 1);\n                                                  var a = {\n                                                    attributes_data_value: \n                                                    Coq_value_prim(\n                                                      Coq_prim_string(\n                                                        resultStr)),\n                                                    attributes_data_writable: false,\n                                                    attributes_data_enumerable: true,\n                                                    attributes_data_configurable: false\n                                                  };\n                                                  return (\n                                                    res_spec(s5,\n                                                      Coq_full_descriptor_some(\n                                                        Coq_attributes_data_of(\n                                                          a))));\n                                                }}));}));\n                                  }}));}));\n                    case "Coq_full_descriptor_some":\n                      var a = d.value;\n                      return (res_spec(s0, d));\n                  }\n                  }));\n        }\n        }));\n};\n\nvar run_function_has_instance = function (s, c, lv, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_prim":\n      var p = _foo_.value;\n      return (run_error(s, c, Coq_native_error_type()));\n    case "Coq_value_object":\n      var lo = _foo_.value;\n      return (\n        if_some(run_object_method(object_proto_, s, lv), function(vproto) {\n            \n            switch (vproto.tag) {\n              case "Coq_value_prim":\n                var p = vproto.value;\n                switch (p.tag) {\n                  case "Coq_prim_null":\n                    return (\n                      res_ter(s,\n                        res_val(Coq_value_prim(Coq_prim_bool(false)))));\n                  default:\n                    return (\n                      function (s, m) {\n                          Debug.impossible_with_heap_because(__LOC__, s, m);\n                          return (Coq_result_impossible());}(s,\n                        "Primitive found in the prototype chain in [run_object_has_instance_loop]."));\n                }\n                \n              case "Coq_value_object":\n                var proto = vproto.value;\n                if (object_loc_compare(proto, lo)) {\n                  return (\n                    res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                } else {\n                  return (\n                    run_function_has_instance(s, c, proto,\n                      Coq_value_object(lo)));\n                }\n            }\n            }));\n  }\n  \n};\n\nvar run_object_has_instance = function (s, c, b, l, v) {\n  switch (b.tag) {\n    case "Coq_builtin_has_instance_function":\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var w = v.value;\n          return (\n            result_out(\n              Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_bool(false))))));\n        case "Coq_value_object":\n          var lv = v.value;\n          return (\n            if_value(run_object_get(s, c, l, "prototype"), function(s1,\n              vproto) {\n                \n                switch (vproto.tag) {\n                  case "Coq_value_prim":\n                    var p = vproto.value;\n                    return (run_error(s1, c, Coq_native_error_type()));\n                  case "Coq_value_object":\n                    var lproto = vproto.value;\n                    return (\n                      run_function_has_instance(s1, c, lv,\n                        Coq_value_object(lproto)));\n                }\n                }));\n      }\n      \n    case "Coq_builtin_has_instance_after_bind":\n      return (\n        if_some(run_object_method(object_target_function_, s, l),\n          function(ol) {\n            \n            return (\n              if_some(ol, function(l0) {\n                  \n                  return (\n                    if_some(run_object_method(object_has_instance_, s, l0),\n                      function(ob) {\n                        \n                        switch (ob.tag) {\n                          case "Some":\n                            var b0 = ob.value;\n                            return (\n                              run_object_has_instance(s, c, b0, l0, v));\n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));}));}));\n  }\n  \n};\n\nvar from_prop_descriptor = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_full_descriptor_undef":\n      return (\n        result_out(Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_undef())))));\n    case "Coq_full_descriptor_some":\n      var a = _foo_.value;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n          function(s1, l) {\n            \n            var follow = function (s0, x) {\n              var a1 = attributes_data_intro_all_true(\n                         Coq_value_prim(\n                           Coq_prim_bool(attributes_enumerable(a))));\n              return (\n                if_bool(\n                  object_define_own_prop(s0, c, l, "enumerable",\n                    descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                    throw_false), function(s0_2, x0) {\n                    \n                    var a2 = attributes_data_intro_all_true(\n                               Coq_value_prim(\n                                 Coq_prim_bool(attributes_configurable(a))));\n                    return (\n                      if_bool(\n                        object_define_own_prop(s0_2, c, l, "configurable",\n                          descriptor_of_attributes(\n                            Coq_attributes_data_of(a2)), throw_false),\n                        function(s_2, x1) {\n                          \n                          return (\n                            res_ter(s_2, res_val(Coq_value_object(l))));}));\n                  }));\n            };\n            switch (a.tag) {\n              case "Coq_attributes_data_of":\n                var ad = a.value;\n                var a1 = attributes_data_intro_all_true(\n                           ad.attributes_data_value);\n                return (\n                  if_bool(\n                    object_define_own_prop(s1, c, l, "value",\n                      descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                      throw_false), function(s2, x) {\n                      \n                      var a2 = attributes_data_intro_all_true(\n                                 Coq_value_prim(\n                                   Coq_prim_bool(ad.attributes_data_writable)));\n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, "writable",\n                            descriptor_of_attributes(\n                              Coq_attributes_data_of(a2)), throw_false),\n                          function(s3, v) { \n                                            return (follow(s3, v));}));}));\n              case "Coq_attributes_accessor_of":\n                var aa = a.value;\n                var a1 = attributes_data_intro_all_true(\n                           aa.attributes_accessor_get);\n                return (\n                  if_bool(\n                    object_define_own_prop(s1, c, l, "get",\n                      descriptor_of_attributes(Coq_attributes_data_of(a1)),\n                      throw_false), function(s2, x) {\n                      \n                      var a2 = attributes_data_intro_all_true(\n                                 aa.attributes_accessor_set);\n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, "set",\n                            descriptor_of_attributes(\n                              Coq_attributes_data_of(a2)), throw_false),\n                          function(s3, v) { \n                                            return (follow(s3, v));}));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_equal = function (s, c, v1, v2) {\n  var conv_number = function (s0, v) {\n    return (to_number(s0, c, v));\n  };\n  var conv_primitive = function (s0, v) {\n    return (to_primitive(s0, c, v, None()));\n  };\n  var checkTypesThen = function (s0, v3, v4, k) {\n    var ty1 = type_of(v3);\n    var ty2 = type_of(v4);\n    if (type_compare(ty1, ty2)) {\n      return (\n        result_out(\n          Coq_out_ter(s0,\n            res_val(\n              Coq_value_prim(\n                Coq_prim_bool(equality_test_for_same_type(ty1, v3, v4)))))));\n    } else {\n      return (k(ty1, ty2));\n    }\n  };\n  return (\n    checkTypesThen(s, v1, v2, function (ty1, ty2) {\n        var dc_conv = function (v3, f, v4) {\n          return (\n            if_value(f(s, v4), function(s0, v2_2) {\n                \n                return (run_equal(s0, c, v3, v2_2));}));\n        };\n        var so = function (b) {\n          return (\n            result_out(\n              Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_bool(b))))));\n        };\n        if ((type_compare(ty1, Coq_type_null())\n            && type_compare(ty2, Coq_type_undef()))) {\n          return (so(true));\n        } else {\n          if ((type_compare(ty1, Coq_type_undef())\n              && type_compare(ty2, Coq_type_null()))) {\n            return (so(true));\n          } else {\n            if ((type_compare(ty1, Coq_type_number())\n                && type_compare(ty2, Coq_type_string()))) {\n              return (dc_conv(v1, conv_number, v2));\n            } else {\n              if ((type_compare(ty1, Coq_type_string())\n                  && type_compare(ty2, Coq_type_number()))) {\n                return (dc_conv(v2, conv_number, v1));\n              } else {\n                if (type_compare(ty1, Coq_type_bool())) {\n                  return (dc_conv(v2, conv_number, v1));\n                } else {\n                  if (type_compare(ty2, Coq_type_bool())) {\n                    return (dc_conv(v1, conv_number, v2));\n                  } else {\n                    if (((type_compare(ty1, Coq_type_string())\n                         || type_compare(ty1, Coq_type_number()))\n                        && type_compare(ty2, Coq_type_object()))) {\n                      return (dc_conv(v1, conv_primitive, v2));\n                    } else {\n                      if ((type_compare(ty1, Coq_type_object())\n                          && (type_compare(ty2, Coq_type_string())\n                             || type_compare(ty2, Coq_type_number())))) {\n                        return (dc_conv(v2, conv_primitive, v1));\n                      } else {\n                        return (so(false));\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }}));\n};\n\nvar convert_twice = function (ifv, kC, s, v1, v2) {\n  return (\n    ifv(kC(s, v1), function (s1, vc1) {\n        return (\n          ifv(kC(s1, v2), function (s2, vc2) {\n              return (res_spec(s2, [vc1, vc2]));}));}));\n};\n\nvar convert_twice_primitive = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_prim, function (s0, v) {\n        return (to_primitive(s0, c, v, None()));}, s, v1, v2));\n};\n\nvar convert_twice_number = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_number, function (s0, v) {\n        return (to_number(s0, c, v));}, s, v1, v2));\n};\n\nvar convert_twice_string = function (s, c, v1, v2) {\n  return (\n    convert_twice(ifx_string, function (s0, v) {\n        return (to_string(s0, c, v));}, s, v1, v2));\n};\n\nvar issome = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var t = _foo_.value;\n      return (true);\n    case "None":\n      return (false);\n  }\n  \n};\n\nvar run_binary_op_add = function (s, c, v1, v2) {\n  return (\n    if_run(convert_twice_primitive(s, c, v1, v2), function(s1,\n      _tuple_arg_22) {\n        var w1 = _tuple_arg_22[0], w2 = _tuple_arg_22[1];\n        \n        if ((type_compare(type_of(Coq_value_prim(w1)), Coq_type_string())\n            || type_compare(type_of(Coq_value_prim(w2)), Coq_type_string()))) {\n          return (\n            if_run(\n              convert_twice_string(s1, c, Coq_value_prim(w1),\n                Coq_value_prim(w2)), function(s2, _tuple_arg_21) {\n                var str1 = _tuple_arg_21[0], str2 = _tuple_arg_21[1];\n                \n                return (\n                  res_out(\n                    Coq_out_ter(s2,\n                      res_val(\n                        Coq_value_prim(\n                          Coq_prim_string(strappend(str1, str2)))))));}));\n        } else {\n          return (\n            if_run(\n              convert_twice_number(s1, c, Coq_value_prim(w1),\n                Coq_value_prim(w2)), function(s2, _tuple_arg_20) {\n                var n1 = _tuple_arg_20[0], n2 = _tuple_arg_20[1];\n                \n                return (\n                  res_out(\n                    Coq_out_ter(s2,\n                      res_val(Coq_value_prim(Coq_prim_number((n1 + n2)))))));\n              }));\n        }}));\n};\n\nvar run_binary_op_arith = function (mathop, s, c, v1, v2) {\n  return (\n    if_run(convert_twice_number(s, c, v1, v2), function(s1, nn) {\n        \n        var n1 = nn[0], n2 = nn[1];\n        return (\n          res_out(\n            Coq_out_ter(s1,\n              res_val(Coq_value_prim(Coq_prim_number(mathop(n1, n2)))))));}));\n};\n\nvar run_binary_op_shift = function (b_unsigned, mathop, s, c, v1, v2) {\n  if (b_unsigned) {\n    var conv = to_uint32;\n  } else {\n    var conv = to_int32;\n  }\n  return (\n    if_run(conv(s, c, v1), function(s1, k1) {\n        \n        return (\n          if_run(to_uint32(s1, c, v2), function(s2, k2) {\n              \n              var k2_2 = JsNumber.modulo_32(k2);\n              return (\n                res_ter(s2,\n                  res_val(Coq_value_prim(Coq_prim_number(mathop(k1, k2_2))))));\n            }));}));\n};\n\nvar run_binary_op_bitwise = function (mathop, s, c, v1, v2) {\n  return (\n    if_run(to_int32(s, c, v1), function(s1, k1) {\n        \n        return (\n          if_run(to_int32(s1, c, v2), function(s2, k2) {\n              \n              return (\n                res_ter(s2,\n                  res_val(Coq_value_prim(Coq_prim_number(mathop(k1, k2))))));\n            }));}));\n};\n\nvar run_binary_op_compare = function (b_swap, b_neg, s, c, v1, v2) {\n  return (\n    if_run(convert_twice_primitive(s, c, v1, v2), function(s1, ww) {\n        \n        var w1 = ww[0], w2 = ww[1];\n        if (b_swap) {\n          var p = [w2, w1];\n        } else {\n          var p = [w1, w2];\n        }\n        var wa = p[0], wb = p[1];\n        var wr = inequality_test_primitive(wa, wb);\n        if (prim_compare(wr, Coq_prim_undef())) {\n          return (\n            res_out(\n              Coq_out_ter(s1, res_val(Coq_value_prim(Coq_prim_bool(false))))));\n        } else {\n          if ((b_neg && prim_compare(wr, Coq_prim_bool(true)))) {\n            return (\n              res_out(\n                Coq_out_ter(s1,\n                  res_val(Coq_value_prim(Coq_prim_bool(false))))));\n          } else {\n            if ((b_neg && prim_compare(wr, Coq_prim_bool(false)))) {\n              return (\n                res_out(\n                  Coq_out_ter(s1,\n                    res_val(Coq_value_prim(Coq_prim_bool(true))))));\n            } else {\n              return (res_out(Coq_out_ter(s1, res_val(Coq_value_prim(wr)))));\n            }\n          }\n        }}));\n};\n\nvar run_binary_op_instanceof = function (s, c, v1, v2) {\n  switch (v2.tag) {\n    case "Coq_value_prim":\n      var p = v2.value;\n      return (run_error(s, c, Coq_native_error_type()));\n    case "Coq_value_object":\n      var l = v2.value;\n      return (\n        if_some(run_object_method(object_has_instance_, s, l), function(b) {\n            \n            switch (b.tag) {\n              case "None":\n                return (run_error(s, c, Coq_native_error_type()));\n              case "Some":\n                var has_instance_id = b.value;\n                return (\n                  run_object_has_instance(s, c, has_instance_id, l, v1));\n            }\n            }));\n  }\n  \n};\n\nvar run_binary_op_in = function (s, c, v1, v2) {\n  switch (v2.tag) {\n    case "Coq_value_prim":\n      var p = v2.value;\n      return (run_error(s, c, Coq_native_error_type()));\n    case "Coq_value_object":\n      var l = v2.value;\n      return (\n        if_string(to_string(s, c, v1), function(s2, x) {\n            \n            return (object_has_prop(s2, c, l, x));}));\n  }\n  \n};\n\nvar run_binary_op = function (s, c, op, v1, v2) {\n  switch (op.tag) {\n    case "Coq_binary_op_mult":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x * y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_div":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x / y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_mod":\n      return (\n        run_binary_op_arith(function (x, y) { return (JsNumber.fmod(x, y));},\n          s, c, v1, v2));\n    case "Coq_binary_op_sub":\n      return (\n        run_binary_op_arith(function (x, y) { return ((x - y));}, s, c, v1,\n          v2));\n    case "Coq_binary_op_lt":\n      return (run_binary_op_compare(false, false, s, c, v1, v2));\n    case "Coq_binary_op_gt":\n      return (run_binary_op_compare(true, false, s, c, v1, v2));\n    case "Coq_binary_op_le":\n      return (run_binary_op_compare(true, true, s, c, v1, v2));\n    case "Coq_binary_op_ge":\n      return (run_binary_op_compare(false, true, s, c, v1, v2));\n    case "Coq_binary_op_left_shift":\n      return (\n        run_binary_op_shift(false, JsNumber.int32_left_shift, s, c, v1, v2));\n    case "Coq_binary_op_right_shift":\n      return (\n        run_binary_op_shift(false, JsNumber.int32_right_shift, s, c, v1, v2));\n    case "Coq_binary_op_unsigned_right_shift":\n      return (\n        run_binary_op_shift(true, JsNumber.uint32_right_shift, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_and":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_and, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_or":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_or, s, c, v1, v2));\n    case "Coq_binary_op_bitwise_xor":\n      return (\n        run_binary_op_bitwise(JsNumber.int32_bitwise_xor, s, c, v1, v2));\n    case "Coq_binary_op_add":\n      return (run_binary_op_add(s, c, v1, v2));\n    case "Coq_binary_op_instanceof":\n      return (run_binary_op_instanceof(s, c, v1, v2));\n    case "Coq_binary_op_in":\n      return (run_binary_op_in(s, c, v1, v2));\n    case "Coq_binary_op_equal":\n      return (run_equal(s, c, v1, v2));\n    case "Coq_binary_op_disequal":\n      return (\n        if_bool(run_equal(s, c, v1, v2), function(s0, b0) {\n            \n            return (\n              res_ter(s0, res_val(Coq_value_prim(Coq_prim_bool(!(b0))))));}));\n    case "Coq_binary_op_strict_equal":\n      return (\n        result_out(\n          Coq_out_ter(s,\n            res_val(\n              Coq_value_prim(Coq_prim_bool(strict_equality_test(v1, v2)))))));\n    case "Coq_binary_op_strict_disequal":\n      return (\n        result_out(\n          Coq_out_ter(s,\n            res_val(\n              Coq_value_prim(Coq_prim_bool(!(strict_equality_test(v1, v2))))))));\n    case "Coq_binary_op_coma":\n      return (result_out(Coq_out_ter(s, res_val(v2))));\n    case "Coq_binary_op_and":\n      return (Coq_result_impossible());\n    case "Coq_binary_op_or":\n      return (Coq_result_impossible());\n  }\n  \n};\n\nvar run_prepost_op = function (_foo_) {\n  switch (_foo_.tag) {\n    case "Coq_unary_op_delete":\n      return (None());\n    case "Coq_unary_op_void":\n      return (None());\n    case "Coq_unary_op_typeof":\n      return (None());\n    case "Coq_unary_op_post_incr":\n      return (Some([add_one, false]));\n    case "Coq_unary_op_post_decr":\n      return (Some([sub_one, false]));\n    case "Coq_unary_op_pre_incr":\n      return (Some([add_one, true]));\n    case "Coq_unary_op_pre_decr":\n      return (Some([sub_one, true]));\n    case "Coq_unary_op_add":\n      return (None());\n    case "Coq_unary_op_neg":\n      return (None());\n    case "Coq_unary_op_bitwise_not":\n      return (None());\n    case "Coq_unary_op_not":\n      return (None());\n  }\n  \n};\n\nvar run_typeof_value = function (s, _foo_) {\n  switch (_foo_.tag) {\n    case "Coq_value_prim":\n      var w = _foo_.value;\n      return (typeof_prim(w));\n    case "Coq_value_object":\n      var l = _foo_.value;\n      if (is_callable_dec(s, Coq_value_object(l))) {\n        return ("function");\n      } else {\n        return ("object");\n      }\n  }\n  \n};\n\nvar run_unary_op = function (s, c, op, e) {\n  if (prepost_unary_op_dec(op)) {\n    return (\n      if_success(run_expr(s, c, e), function(s1, rv1) {\n          \n          return (\n            if_run(ref_get_value(s1, c, rv1), function(s2, v2) {\n                \n                return (\n                  if_number(to_number(s2, c, v2), function(s3, n1) {\n                      \n                      return (\n                        if_some(run_prepost_op(op), function(po) {\n                            \n                            var number_op = po[0], is_pre = po[1];\n                            var n2 = number_op(n1);\n                            var v = Coq_prim_number((function () {\n                                        if (is_pre) {\n                                          return (n2);\n                                        } else {\n                                          return (n1);\n                                        }}()));\n                            return (\n                              if_void(\n                                ref_put_value(s3, c, rv1,\n                                  Coq_value_prim(Coq_prim_number(n2))),\n                                function(s4) {\n                                  \n                                  return (\n                                    result_out(\n                                      Coq_out_ter(s4,\n                                        res_val(Coq_value_prim(v)))));}));}));\n                    }));}));}));\n  } else {\n    switch (op.tag) {\n      case "Coq_unary_op_delete":\n        return (\n          if_success(run_expr(s, c, e), function(s0, rv) {\n              \n              switch (rv.tag) {\n                case "Coq_resvalue_empty":\n                  return (\n                    res_ter(s0, res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                case "Coq_resvalue_value":\n                  var v = rv.value;\n                  return (\n                    res_ter(s0, res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                case "Coq_resvalue_ref":\n                  var r = rv.ref;\n                  if (ref_kind_comparable(ref_kind_of(r),\n                        Coq_ref_kind_undef())) {\n                    if (r.ref_strict) {\n                      return (run_error(s0, c, Coq_native_error_syntax()));\n                    } else {\n                      return (\n                        res_ter(s0,\n                          res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                    }\n                  } else {\n                    var _switch_arg_23 = r.ref_base;\n                    switch (_switch_arg_23.tag) {\n                      case "Coq_ref_base_type_value":\n                        var v = _switch_arg_23.value;\n                        return (\n                          if_object(to_object(s0, c, v), function(s1, l) {\n                              \n                              return (\n                                object_delete(s1, c, l, r.ref_name,\n                                  r.ref_strict));}));\n                      case "Coq_ref_base_type_env_loc":\n                        var l = _switch_arg_23.value;\n                        if (r.ref_strict) {\n                          return (\n                            run_error(s0, c, Coq_native_error_syntax()));\n                        } else {\n                          return (\n                            env_record_delete_binding(s0, c, l, r.ref_name));\n                        }\n                    }\n                    \n                  }\n              }\n              }));\n      case "Coq_unary_op_typeof":\n        return (\n          if_success(run_expr(s, c, e), function(s1, rv) {\n              \n              switch (rv.tag) {\n                case "Coq_resvalue_empty":\n                  return (\n                    function (s, m) {\n                        Debug.impossible_with_heap_because(__LOC__, s, m);\n                        return (Coq_result_impossible());}(s1,\n                      "Empty result for a `typeof\' in [run_unary_op]."));\n                case "Coq_resvalue_value":\n                  var v = rv.value;\n                  return (\n                    res_ter(s1,\n                      res_val(\n                        Coq_value_prim(\n                          Coq_prim_string(run_typeof_value(s1, v))))));\n                case "Coq_resvalue_ref":\n                  var r = rv.ref;\n                  if (ref_kind_comparable(ref_kind_of(r),\n                        Coq_ref_kind_undef())) {\n                    return (\n                      res_ter(s1,\n                        res_val(Coq_value_prim(Coq_prim_string("undefined")))));\n                  } else {\n                    return (\n                      if_run(ref_get_value(s1, c, Coq_resvalue_ref(r)),\n                        function(s2, v) {\n                          \n                          return (\n                            res_ter(s2,\n                              res_val(\n                                Coq_value_prim(\n                                  Coq_prim_string(run_typeof_value(s2, v))))));\n                        }));\n                  }\n              }\n              }));\n      default:\n        return (\n          if_run(run_expr_get_value(s, c, e), function(s1, v) {\n              \n              switch (op.tag) {\n                case "Coq_unary_op_void":\n                  return (\n                    res_ter(s1, res_val(Coq_value_prim(Coq_prim_undef()))));\n                case "Coq_unary_op_add":\n                  return (to_number(s1, c, v));\n                case "Coq_unary_op_neg":\n                  return (\n                    if_number(to_number(s1, c, v), function(s2, n) {\n                        \n                        return (\n                          res_ter(s2,\n                            res_val(\n                              Coq_value_prim(\n                                Coq_prim_number(JsNumber.neg(n))))));}));\n                case "Coq_unary_op_bitwise_not":\n                  return (\n                    if_run(to_int32(s1, c, v), function(s2, k) {\n                        \n                        return (\n                          res_ter(s2,\n                            res_val(\n                              Coq_value_prim(\n                                Coq_prim_number(\n                                  JsNumber.int32_bitwise_not(k))))));}));\n                case "Coq_unary_op_not":\n                  return (\n                    res_ter(s1,\n                      res_val(\n                        Coq_value_prim(\n                          Coq_prim_bool(!(convert_value_to_boolean(v)))))));\n                default:\n                  return (\n                    function (s, m) {\n                        Debug.impossible_with_heap_because(__LOC__, s, m);\n                        return (Coq_result_impossible());}(s1,\n                      "Undealt regular operator in [run_unary_op]."));\n              }\n              }));\n    }\n    \n  }\n};\n\nvar create_new_function_in = function (s, c, args, bd) {\n  return (\n    creating_function_object(s, c, args, bd, c.execution_ctx_lexical_env,\n      c.execution_ctx_strict));\n};\n\nvar init_object = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (result_out(Coq_out_ter(s, res_val(Coq_value_object(l)))));\n    case "::":\n      var p = _foo_.head, pds_2 = _foo_.tail;\n      var pn = p[0], pb = p[1];\n      var x = string_of_propname(pn);\n      var follows = function (s1, desc) {\n        return (\n          if_success(object_define_own_prop(s1, c, l, x, desc, false),\n            function(s2, rv) { \n                               return (init_object(s2, c, l, pds_2));}));\n      };\n      switch (pb.tag) {\n        case "Coq_propbody_val":\n          var e0 = pb.expr;\n          return (\n            if_run(run_expr_get_value(s, c, e0), function(s1, v0) {\n                \n                var desc = {\n                  descriptor_value: Some(v0),\n                  descriptor_writable: Some(true),\n                  descriptor_get: None(),\n                  descriptor_set: None(),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n        case "Coq_propbody_get":\n          var bd = pb.body;\n          return (\n            if_value(create_new_function_in(s, c, mk_nil(), bd), function(s1,\n              v0) {\n                \n                var desc = {\n                  descriptor_value: None(),\n                  descriptor_writable: None(),\n                  descriptor_get: Some(v0),\n                  descriptor_set: None(),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n        case "Coq_propbody_set":\n          var args = pb.names, bd = pb.body;\n          return (\n            if_value(create_new_function_in(s, c, args, bd), function(s1,\n              v0) {\n                \n                var desc = {\n                  descriptor_value: None(),\n                  descriptor_writable: None(),\n                  descriptor_get: None(),\n                  descriptor_set: Some(v0),\n                  descriptor_enumerable: Some(true),\n                  descriptor_configurable: Some(true)\n                };\n                return (follows(s1, desc));}));\n      }\n      \n  }\n  \n};\n\nvar run_array_element_list = function (s, c, l, oes, n) {\n  switch (oes.tag) {\n    case "[]":\n      return (result_out(Coq_out_ter(s, res_val(Coq_value_object(l)))));\n    case "::":\n      var o = oes.head, oes_2 = oes.tail;\n      switch (o.tag) {\n        case "Some":\n          var e = o.value;\n          var loop_result = function (s0) {\n            return (run_array_element_list(s0, c, l, oes_2, 0.));\n          };\n          return (\n            if_run(run_expr_get_value(s, c, e), function(s0, v) {\n                \n                return (\n                  if_value(run_object_get(s0, c, l, "length"), function(s1,\n                    vlen) {\n                      \n                      return (\n                        if_run(to_uint32(s1, c, vlen), function(s2, ilen) {\n                            \n                            return (\n                              if_string(\n                                to_string(s2, c,\n                                  Coq_value_prim(Coq_prim_number((ilen + n)))),\n                                function(s3, slen) {\n                                  \n                                  var desc = {\n                                    attributes_data_value: v,\n                                    attributes_data_writable: true,\n                                    attributes_data_enumerable: true,\n                                    attributes_data_configurable: true\n                                  };\n                                  return (\n                                    if_bool(\n                                      object_define_own_prop(s3, c, l, slen,\n                                        descriptor_of_attributes(\n                                          Coq_attributes_data_of(desc)),\n                                        false), function(s4, x) {\n                                        \n                                        return (\n                                          if_object(loop_result(s4),\n                                            function(s5, l0) {\n                                              \n                                              return (\n                                                res_ter(s5,\n                                                  res_val(\n                                                    Coq_value_object(l0))));\n                                            }));}));}));}));}));}));\n        case "None":\n          var firstIndex = elision_head_count(mk_cons(None(), oes_2));\n          return (\n            run_array_element_list(s, c, l,\n              elision_head_remove(mk_cons(None(), oes_2)),\n              number_of_int(firstIndex)));\n      }\n      \n  }\n  \n};\n\nvar init_array = function (s, c, l, oes) {\n  var elementList = elision_tail_remove(oes);\n  var elisionLength = elision_tail_count(oes);\n  return (\n    if_object(run_array_element_list(s, c, l, elementList, 0.), function(s0,\n      l0) {\n        \n        return (\n          if_value(run_object_get(s0, c, l0, "length"), function(s1, vlen) {\n              \n              return (\n                if_run(to_uint32(s1, c, vlen), function(s2, ilen) {\n                    \n                    return (\n                      if_run(\n                        to_uint32(s2, c,\n                          Coq_value_prim(\n                            Coq_prim_number(\n                              (ilen + number_of_int(elisionLength))))),\n                        function(s3, len) {\n                          \n                          return (\n                            if_not_throw(\n                              object_put(s3, c, l0, "length",\n                                Coq_value_prim(Coq_prim_number(len)),\n                                throw_false), function(s4, x) {\n                                \n                                return (\n                                  result_out(\n                                    Coq_out_ter(s4,\n                                      res_val(Coq_value_object(l0)))));}));}));\n                  }));}));}));\n};\n\nvar run_var_decl_item = function (s, c, x, _foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var e = _foo_.value;\n      return (\n        if_run(identifier_resolution(s, c, x), function(s1, ir) {\n            \n            return (\n              if_run(run_expr_get_value(s1, c, e), function(s2, v) {\n                  \n                  return (\n                    if_void(ref_put_value(s2, c, Coq_resvalue_ref(ir), v),\n                      function(s3) {\n                        \n                        return (\n                          result_out(\n                            Coq_out_ter(s3,\n                              res_val(Coq_value_prim(Coq_prim_string(x))))));\n                      }));}));}));\n    case "None":\n      return (\n        result_out(\n          Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_string(x))))));\n  }\n  \n};\n\nvar run_var_decl = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (result_out(Coq_out_ter(s, res_empty)));\n    case "::":\n      var y = _foo_.head, xeos_2 = _foo_.tail;\n      var x = y[0], eo = y[1];\n      return (\n        if_value(run_var_decl_item(s, c, x, eo), function(s1, vname) {\n            \n            return (run_var_decl(s1, c, xeos_2));}));\n  }\n  \n};\n\nvar run_list_expr = function (s1, c, vs, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_spec(s1, rev(vs)));\n    case "::":\n      var e = _foo_.head, es_2 = _foo_.tail;\n      return (\n        if_run(run_expr_get_value(s1, c, e), function(s2, v) {\n            \n            return (run_list_expr(s2, c, mk_cons(v, vs), es_2));}));\n  }\n  \n};\n\nvar run_block = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (res_ter(s, res_normal(Coq_resvalue_empty())));\n    case "::":\n      var t = _foo_.head, ts_rev_2 = _foo_.tail;\n      return (\n        if_success(run_block(s, c, ts_rev_2), function(s0, rv0) {\n            \n            return (\n              ifx_success_state(rv0, run_stat(s0, c, t), function (x, x0) {\n                  return (result_out(Coq_out_ter(x, res_normal(x0))));}));}));\n  }\n  \n};\n\nvar run_binary_op_and = function (s, c, e1, e2) {\n  return (\n    if_run(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b1 = convert_value_to_boolean(v1);\n        if (!(b1)) {\n          return (res_ter(s1, res_val(v1)));\n        } else {\n          return (\n            if_run(run_expr_get_value(s1, c, e2), function(s2, v) {\n                \n                return (res_ter(s2, res_val(v)));}));\n        }}));\n};\n\nvar run_binary_op_or = function (s, c, e1, e2) {\n  return (\n    if_run(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b1 = convert_value_to_boolean(v1);\n        if (b1) {\n          return (res_ter(s1, res_val(v1)));\n        } else {\n          return (\n            if_run(run_expr_get_value(s1, c, e2), function(s2, v) {\n                \n                return (res_ter(s2, res_val(v)));}));\n        }}));\n};\n\nvar run_expr_binary_op = function (s, c, op, e1, e2) {\n  switch (op.tag) {\n    case "Coq_binary_op_and":\n      return (run_binary_op_and(s, c, e1, e2));\n    case "Coq_binary_op_or":\n      return (run_binary_op_or(s, c, e1, e2));\n    default:\n      return (\n        if_run(run_expr_get_value(s, c, e1), function(s1, v1) {\n            \n            return (\n              if_run(run_expr_get_value(s1, c, e2), function(s2, v2) {\n                  \n                  return (run_binary_op(s2, c, op, v1, v2));}));}));\n  }\n  \n};\n\nvar run_expr_access = function (s, c, e1, e2) {\n  return (\n    if_run(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        return (\n          if_run(run_expr_get_value(s1, c, e2), function(s2, v2) {\n              \n              if ((value_compare(v1, Coq_value_prim(Coq_prim_undef()))\n                  || value_compare(v1, Coq_value_prim(Coq_prim_null())))) {\n                return (run_error(s2, c, Coq_native_error_type()));\n              } else {\n                return (\n                  if_string(to_string(s2, c, v2), function(s3, x) {\n                      \n                      return (\n                        res_ter(s3,\n                          res_ref(\n                            ref_create_value(v1, x, c.execution_ctx_strict))));\n                    }));\n              }}));}));\n};\n\nvar run_expr_assign = function (s, c, opo, e1, e2) {\n  return (\n    if_success(run_expr(s, c, e1), function(s1, rv1) {\n        \n        var follow = function (s0, rv_2) {\n          switch (rv_2.tag) {\n            case "Coq_resvalue_empty":\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s0,\n                  "Non-value result in [run_expr_assign]."));\n            case "Coq_resvalue_value":\n              var v = rv_2.value;\n              return (\n                if_void(ref_put_value(s0, c, rv1, v), function(s_2) {\n                    \n                    return (result_out(Coq_out_ter(s_2, res_val(v))));}));\n            case "Coq_resvalue_ref":\n              var r = rv_2.ref;\n              return (\n                function (s, m) {\n                    Debug.impossible_with_heap_because(__LOC__, s, m);\n                    return (Coq_result_impossible());}(s0,\n                  "Non-value result in [run_expr_assign]."));\n          }\n          \n        };\n        switch (opo.tag) {\n          case "Some":\n            var op = opo.value;\n            return (\n              if_run(ref_get_value(s1, c, rv1), function(s2, v1) {\n                  \n                  return (\n                    if_run(run_expr_get_value(s2, c, e2), function(s3, v2) {\n                        \n                        return (\n                          if_success(run_binary_op(s3, c, op, v1, v2),\n                            function(s4, v) { \n                                              return (follow(s4, v));}));}));\n                }));\n          case "None":\n            return (\n              if_run(run_expr_get_value(s1, c, e2), function(x, x0) {\n                  \n                  return (follow(x, Coq_resvalue_value(x0)));}));\n        }\n        }));\n};\n\nvar run_expr_function = function (s, c, fo, args, bd) {\n  switch (fo.tag) {\n    case "Some":\n      var fn = fo.value;\n      var p = lexical_env_alloc_decl(s, c.execution_ctx_lexical_env);\n      var lex_2 = p[0], s_2 = p[1];\n      var follow = function (l) {\n        return (\n          if_some(env_record_binds_option(s_2, l), function(e) {\n              \n              return (\n                if_void(env_record_create_immutable_binding(s_2, l, fn),\n                  function(s1) {\n                    \n                    return (\n                      if_object(\n                        creating_function_object(s1, c, args, bd, lex_2,\n                          funcbody_is_strict(bd)), function(s2, l0) {\n                          \n                          return (\n                            if_void(\n                              env_record_initialize_immutable_binding(s2, l,\n                                fn, Coq_value_object(l0)), function(s3) {\n                                \n                                return (\n                                  result_out(\n                                    Coq_out_ter(s3,\n                                      res_val(Coq_value_object(l0)))));}));}));\n                  }));}));\n      };\n      return (\n        destr_list(lex_2, function (x) {\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s_2,\n                "Empty lexical environnment allocated in [run_expr_function]."));\n          }, function (l, x) { return (follow(l));}, {}));\n    case "None":\n      var lex = c.execution_ctx_lexical_env;\n      return (\n        creating_function_object(s, c, args, bd, lex, funcbody_is_strict(bd)));\n  }\n  \n};\n\nvar entering_eval_code = function (s, c, direct, bd, k) {\n  var str = (funcbody_is_strict(bd) || (direct && c.execution_ctx_strict));\n  if (direct) {\n    var c_2 = c;\n  } else {\n    var c_2 = execution_ctx_initial(str);\n  }\n  if (str) {\n    var p = lexical_env_alloc_decl(s, c_2.execution_ctx_lexical_env);\n  } else {\n    var p = [c_2.execution_ctx_lexical_env, s];\n  }\n  var lex = p[0], s_2 = p[1];\n  if (str) {\n    var c1 = execution_ctx_with_lex_same(c_2, lex);\n  } else {\n    var c1 = c_2;\n  }\n  var p0 = funcbody_prog(bd);\n  return (\n    if_void(\n      execution_ctx_binding_inst(s_2, c1, Coq_codetype_eval(), None(), p0,\n        mk_nil()), function(s1) { \n                                  return (k(s1, c1));}));\n};\n\nvar run_eval = function (s, c, is_direct_call, vs) {\n  var _switch_arg_24 = get_arg(0, vs);\n  switch (_switch_arg_24.tag) {\n    case "Coq_value_prim":\n      var p = _switch_arg_24.value;\n      switch (p.tag) {\n        case "Coq_prim_undef":\n          return (\n            result_out(\n              Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_undef())))));\n        case "Coq_prim_null":\n          return (\n            result_out(\n              Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_null())))));\n        case "Coq_prim_bool":\n          var b = p.value;\n          return (\n            result_out(\n              Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_bool(b))))));\n        case "Coq_prim_number":\n          var n = p.value;\n          return (\n            result_out(\n              Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_number(n))))));\n        case "Coq_prim_string":\n          var s0 = p.value;\n          var str = (is_direct_call && c.execution_ctx_strict);\n          var _switch_arg_25 = parse_pickable(s0, str);\n          switch (_switch_arg_25.tag) {\n            case "Some":\n              var p0 = _switch_arg_25.value;\n              return (\n                entering_eval_code(s, c, is_direct_call,\n                  Coq_funcbody_intro(p0, s0), function (s1, c_2) {\n                    return (\n                      if_ter(run_prog(s1, c_2, p0), function(s2, r) {\n                          \n                          var _switch_arg_26 = r.res_type;\n                          switch (_switch_arg_26.tag) {\n                            case "Coq_restype_normal":\n                              return (\n                                ifx_empty_label(s2, r, function (x) {\n                                    var _switch_arg_27 = r.res_value;\n                                    switch (_switch_arg_27.tag) {\n                                      case "Coq_resvalue_empty":\n                                        return (\n                                          res_ter(s2,\n                                            res_val(\n                                              Coq_value_prim(\n                                                Coq_prim_undef()))));\n                                      case "Coq_resvalue_value":\n                                        var v = _switch_arg_27.value;\n                                        return (res_ter(s2, res_val(v)));\n                                      case "Coq_resvalue_ref":\n                                        var r0 = _switch_arg_27.ref;\n                                        return (\n                                          function (s, m) {\n                                              Debug.impossible_with_heap_because(\n                                                __LOC__, s, m);\n                                              return (\n                                                Coq_result_impossible());}(\n                                            s2,\n                                            "Reference found in the result of an `eval\' in [run_eval]."));\n                                    }\n                                    }));\n                            case "Coq_restype_throw":\n                              return (res_ter(s2, res_throw(r.res_value)));\n                            default:\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s2,\n                                  "Forbidden result type returned by an `eval\' in [run_eval]."));\n                          }\n                          }));}));\n            case "None":\n              return (run_error(s, c, Coq_native_error_syntax()));\n          }\n          \n      }\n      \n    case "Coq_value_object":\n      var o = _switch_arg_24.value;\n      return (result_out(Coq_out_ter(s, res_val(Coq_value_object(o)))));\n  }\n  \n};\n\nvar run_expr_call = function (s, c, e1, e2s) {\n  var is_eval_direct = is_syntactic_eval(e1);\n  return (\n    if_success(run_expr(s, c, e1), function(s1, rv) {\n        \n        return (\n          if_run(ref_get_value(s1, c, rv), function(s2, f) {\n              \n              return (\n                if_run(run_list_expr(s2, c, mk_nil(), e2s), function(s3,\n                  vs) {\n                    \n                    switch (f.tag) {\n                      case "Coq_value_prim":\n                        var p = f.value;\n                        return (run_error(s3, c, Coq_native_error_type()));\n                      case "Coq_value_object":\n                        var l = f.value;\n                        if (is_callable_dec(s3, Coq_value_object(l))) {\n                          var follow = function (vthis) {\n                            if (object_loc_compare(l,\n                                  Coq_object_loc_prealloc(\n                                    Coq_prealloc_global_eval()))) {\n                              return (run_eval(s3, c, is_eval_direct, vs));\n                            } else {\n                              return (run_call(s3, c, l, vthis, vs));\n                            }\n                          };\n                          switch (rv.tag) {\n                            case "Coq_resvalue_empty":\n                              return (\n                                function (s, m) {\n                                    Debug.impossible_with_heap_because(\n                                      __LOC__, s, m);\n                                    return (Coq_result_impossible());}(s3,\n                                  "[run_expr_call] unable to call an  empty result."));\n                            case "Coq_resvalue_value":\n                              var v = rv.value;\n                              return (\n                                follow(Coq_value_prim(Coq_prim_undef())));\n                            case "Coq_resvalue_ref":\n                              var r = rv.ref;\n                              var _switch_arg_28 = r.ref_base;\n                              switch (_switch_arg_28.tag) {\n                                case "Coq_ref_base_type_value":\n                                  var v = _switch_arg_28.value;\n                                  if ((ref_kind_comparable(ref_kind_of(r),\n                                         Coq_ref_kind_primitive_base())\n                                      || (ref_kind_comparable(ref_kind_of(r),\n                                            Coq_ref_kind_null())\n                                         || ref_kind_comparable(\n                                              ref_kind_of(r),\n                                              Coq_ref_kind_object())))) {\n                                    return (follow(v));\n                                  } else {\n                                    return (\n                                      function (s, m) {\n                                          Debug.impossible_with_heap_because(\n                                            __LOC__, s, m);\n                                          return (Coq_result_impossible());}(\n                                        s3,\n                                        "[run_expr_call] unable to call a non-property function."));\n                                  }\n                                case "Coq_ref_base_type_env_loc":\n                                  var l0 = _switch_arg_28.value;\n                                  return (\n                                    if_some(\n                                      env_record_implicit_this_value(s3, l0),\n                                      function(v) { \n                                                    return (follow(v));}));\n                              }\n                              \n                          }\n                          \n                        } else {\n                          return (run_error(s3, c, Coq_native_error_type()));\n                        }\n                    }\n                    }));}));}));\n};\n\nvar run_expr_conditionnal = function (s, c, e1, e2, e3) {\n  return (\n    if_run(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = convert_value_to_boolean(v1);\n        if (b) {\n          var e = e2;\n        } else {\n          var e = e3;\n        }\n        return (\n          if_run(run_expr_get_value(s1, c, e), function(s0, r) {\n              \n              return (res_ter(s0, res_val(r)));}));}));\n};\n\nvar run_expr_new = function (s, c, e1, e2s) {\n  return (\n    if_run(run_expr_get_value(s, c, e1), function(s1, v) {\n        \n        return (\n          if_run(run_list_expr(s1, c, mk_nil(), e2s), function(s2, args) {\n              \n              switch (v.tag) {\n                case "Coq_value_prim":\n                  var p = v.value;\n                  return (run_error(s2, c, Coq_native_error_type()));\n                case "Coq_value_object":\n                  var l = v.value;\n                  return (\n                    if_some(run_object_method(object_construct_, s2, l),\n                      function(coo) {\n                        \n                        switch (coo.tag) {\n                          case "Some":\n                            var co = coo.value;\n                            return (run_construct(s2, c, co, l, args));\n                          case "None":\n                            return (\n                              run_error(s2, c, Coq_native_error_type()));\n                        }\n                        }));\n              }\n              }));}));\n};\n\nvar run_stat_label = function (s, c, lab, t) {\n  return (\n    if_break(run_stat(s, c, t), function(s1, r1) {\n        \n        return (\n          result_out(\n            Coq_out_ter(s1, (function () {\n                if (label_compare(r1.res_label, lab)) {\n                  return (res_normal(r1.res_value));\n                } else {\n                  return (r1);\n                }}()))));}));\n};\n\nvar run_stat_with = function (s, c, e1, t2) {\n  return (\n    if_run(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        return (\n          if_object(to_object(s1, c, v1), function(s2, l) {\n              \n              var lex = c.execution_ctx_lexical_env;\n              var p = lexical_env_alloc_object(s2, lex, l, provide_this_true);\n              var lex_2 = p[0], s3 = p[1];\n              var c_2 = execution_ctx_with_lex(c, lex_2);\n              return (run_stat(s3, c_2, t2));}));}));\n};\n\nvar run_stat_if = function (s, c, e1, t2, to0) {\n  return (\n    if_run(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = convert_value_to_boolean(v1);\n        if (b) {\n          return (run_stat(s1, c, t2));\n        } else {\n          switch (to0.tag) {\n            case "Some":\n              var t3 = to0.value;\n              return (run_stat(s1, c, t3));\n            case "None":\n              return (\n                result_out(Coq_out_ter(s1, res_normal(Coq_resvalue_empty()))));\n          }\n          \n        }}));\n};\n\nvar run_stat_while = function (s, c, rv, labs, e1, t2) {\n  return (\n    if_run(run_expr_get_value(s, c, e1), function(s1, v1) {\n        \n        var b = convert_value_to_boolean(v1);\n        if (b) {\n          return (\n            if_ter(run_stat(s1, c, t2), function(s2, r) {\n                \n                if (!(resvalue_compare(r.res_value, Coq_resvalue_empty()))) {\n                  var rv_2 = r.res_value;\n                } else {\n                  var rv_2 = rv;\n                }\n                var loop = function (x) {\n                  return (run_stat_while(s2, c, rv_2, labs, e1, t2));\n                };\n                if ((!(restype_compare(r.res_type, Coq_restype_continue()))\n                    || !(res_label_in(r, labs)))) {\n                  if ((restype_compare(r.res_type, Coq_restype_break())\n                      && res_label_in(r, labs))) {\n                    return (res_ter(s2, res_normal(rv_2)));\n                  } else {\n                    if (!(restype_compare(r.res_type, Coq_restype_normal()))) {\n                      return (res_ter(s2, r));\n                    } else {\n                      return (loop({}));\n                    }\n                  }\n                } else {\n                  return (loop({}));\n                }}));\n        } else {\n          return (res_ter(s1, res_normal(rv)));\n        }}));\n};\n\nvar run_stat_switch_end = function (s, c, rv, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (result_out(Coq_out_ter(s, res_normal(rv))));\n    case "::":\n      var y = _foo_.head, scs_2 = _foo_.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            ifx_success_state(rv, run_block(s, c, rev(ts)),\n              function (s1, rv1) {\n                return (run_stat_switch_end(s1, c, rv1, scs_2));}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_no_default = function (s, c, vi, rv, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (result_out(Coq_out_ter(s, res_normal(rv))));\n    case "::":\n      var y = _foo_.head, scs_2 = _foo_.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            if_run(run_expr_get_value(s, c, e), function(s1, v1) {\n                \n                var b = strict_equality_test(v1, vi);\n                if (b) {\n                  return (\n                    if_success(run_block(s1, c, rev(ts)), function(s2, rv2) {\n                        \n                        return (run_stat_switch_end(s2, c, rv2, scs_2));}));\n                } else {\n                  return (run_stat_switch_no_default(s1, c, vi, rv, scs_2));\n                }}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_default = function (s, c, ts, scs) {\n  return (\n    if_success(run_block(s, c, rev(ts)), function(s1, rv) {\n        \n        return (run_stat_switch_end(s1, c, rv, scs));}));\n};\n\nvar run_stat_switch_with_default_B = function (s, c, vi, rv, ts0, scs) {\n  switch (scs.tag) {\n    case "[]":\n      return (run_stat_switch_with_default_default(s, c, ts0, scs));\n    case "::":\n      var y = scs.head, scs_2 = scs.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          return (\n            if_run(run_expr_get_value(s, c, e), function(s1, v1) {\n                \n                var b = strict_equality_test(v1, vi);\n                if (b) {\n                  return (\n                    if_success(run_block(s1, c, rev(ts)), function(s2, rv2) {\n                        \n                        return (run_stat_switch_end(s2, c, rv2, scs_2));}));\n                } else {\n                  return (\n                    run_stat_switch_with_default_B(s1, c, vi, rv, ts0, scs_2));\n                }}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_A = function (s, c, found, vi, rv, scs1, ts0, scs2) {\n  switch (scs1.tag) {\n    case "[]":\n      if (found) {\n        return (run_stat_switch_with_default_default(s, c, ts0, scs2));\n      } else {\n        return (run_stat_switch_with_default_B(s, c, vi, rv, ts0, scs2));\n      }\n    case "::":\n      var y = scs1.head, scs_2 = scs1.tail;\n      switch (y.tag) {\n        case "Coq_switchclause_intro":\n          var e = y.arg, ts = y.stats;\n          var follow = function (s0) {\n            return (\n              ifx_success_state(rv, run_block(s0, c, rev(ts)),\n                function (s1, rv0) {\n                  return (\n                    run_stat_switch_with_default_A(s1, c, true, vi, rv0,\n                      scs_2, ts0, scs2));}));\n          };\n          if (found) {\n            return (follow(s));\n          } else {\n            return (\n              if_run(run_expr_get_value(s, c, e), function(s1, v1) {\n                  \n                  var b = strict_equality_test(v1, vi);\n                  if (b) {\n                    return (follow(s1));\n                  } else {\n                    return (\n                      run_stat_switch_with_default_A(s1, c, false, vi, rv,\n                        scs_2, ts0, scs2));\n                  }}));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch = function (s, c, labs, e, sb) {\n  return (\n    if_run(run_expr_get_value(s, c, e), function(s1, vi) {\n        \n        var follow = function (w) {\n          return (\n            if_success(\n              if_break(w, function(s2, r) {\n                  \n                  if (res_label_in(r, labs)) {\n                    return (\n                      result_out(Coq_out_ter(s2, res_normal(r.res_value))));\n                  } else {\n                    return (result_out(Coq_out_ter(s2, r)));\n                  }}), function(s0, r) { \n                                         return (res_ter(s0, res_normal(r)));\n              }));\n        };\n        switch (sb.tag) {\n          case "Coq_switchbody_nodefault":\n            var scs = sb.clauses;\n            return (\n              follow(\n                run_stat_switch_no_default(s1, c, vi, Coq_resvalue_empty(),\n                  scs)));\n          case "Coq_switchbody_withdefault":\n            var scs1 = sb.clauses_before, ts = sb.clause_default,\n              scs2 = sb.clauses_after;\n            return (\n              follow(\n                run_stat_switch_with_default_A(s1, c, false, vi,\n                  Coq_resvalue_empty(), scs1, ts, scs2)));\n        }\n        }));\n};\n\nvar run_stat_do_while = function (s, c, rv, labs, e1, t2) {\n  return (\n    if_ter(run_stat(s, c, t2), function(s1, r) {\n        \n        if (resvalue_compare(r.res_value, Coq_resvalue_empty())) {\n          var rv_2 = rv;\n        } else {\n          var rv_2 = r.res_value;\n        }\n        var loop = function (x) {\n          return (\n            if_run(run_expr_get_value(s1, c, e1), function(s2, v1) {\n                \n                var b = convert_value_to_boolean(v1);\n                if (b) {\n                  return (run_stat_do_while(s2, c, rv_2, labs, e1, t2));\n                } else {\n                  return (res_ter(s2, res_normal(rv_2)));\n                }}));\n        };\n        if ((restype_compare(r.res_type, Coq_restype_continue())\n            && res_label_in(r, labs))) {\n          return (loop({}));\n        } else {\n          if ((restype_compare(r.res_type, Coq_restype_break())\n              && res_label_in(r, labs))) {\n            return (res_ter(s1, res_normal(rv_2)));\n          } else {\n            if (!(restype_compare(r.res_type, Coq_restype_normal()))) {\n              return (res_ter(s1, r));\n            } else {\n              return (loop({}));\n            }\n          }\n        }}));\n};\n\nvar run_stat_try = function (s, c, t1, t2o, t3o) {\n  var finallycont = function (s1, r) {\n    switch (t3o.tag) {\n      case "Some":\n        var t3 = t3o.value;\n        return (\n          if_success(run_stat(s1, c, t3), function(s2, rv_2) {\n              \n              return (res_ter(s2, r));}));\n      case "None":\n        return (res_ter(s1, r));\n    }\n    \n  };\n  return (\n    ifx_any_or_throw(run_stat(s, c, t1), finallycont, function (s1, v) {\n        switch (t2o.tag) {\n          case "Some":\n            var y = t2o.value;\n            var x = y[0], t2 = y[1];\n            var lex = c.execution_ctx_lexical_env;\n            var p = lexical_env_alloc_decl(s1, lex);\n            var lex_2 = p[0], s_2 = p[1];\n            switch (lex_2.tag) {\n              case "[]":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s_2,\n                    "Empty lexical environnment in [run_stat_try]."));\n              case "::":\n                var l = lex_2.head, oldlex = lex_2.tail;\n                return (\n                  if_void(\n                    env_record_create_set_mutable_binding(s_2, c, l, x,\n                      None(), v, throw_irrelevant), function(s2) {\n                      \n                      var c_2 = execution_ctx_with_lex(c, lex_2);\n                      return (\n                        if_ter(run_stat(s2, c_2, t2), function(s3, r) {\n                            \n                            return (finallycont(s3, r));}));}));\n            }\n            \n          case "None":\n            return (finallycont(s1, res_throw(Coq_resvalue_value(v))));\n        }\n        }));\n};\n\nvar run_stat_throw = function (s, c, e) {\n  return (\n    if_run(run_expr_get_value(s, c, e), function(s1, v1) {\n        \n        return (res_ter(s1, res_throw(Coq_resvalue_value(v1))));}));\n};\n\nvar run_stat_return = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "Some":\n      var e = _foo_.value;\n      return (\n        if_run(run_expr_get_value(s, c, e), function(s1, v1) {\n            \n            return (res_ter(s1, res_return(Coq_resvalue_value(v1))));}));\n    case "None":\n      return (\n        result_out(\n          Coq_out_ter(s,\n            res_return(Coq_resvalue_value(Coq_value_prim(Coq_prim_undef()))))));\n  }\n  \n};\n\nvar run_stat_for_loop = function (s, c, labs, rv, eo2, eo3, t) {\n  var follows = function (s0) {\n    return (\n      if_ter(run_stat(s0, c, t), function(s1, r) {\n          \n          if (!(resvalue_compare(r.res_value, Coq_resvalue_empty()))) {\n            var rv_2 = r.res_value;\n          } else {\n            var rv_2 = rv;\n          }\n          var loop = function (s2) {\n            return (run_stat_for_loop(s2, c, labs, rv_2, eo2, eo3, t));\n          };\n          if ((restype_compare(r.res_type, Coq_restype_break())\n              && res_label_in(r, labs))) {\n            return (res_ter(s1, res_normal(rv_2)));\n          } else {\n            if ((restype_compare(r.res_type, Coq_restype_normal())\n                || (restype_compare(r.res_type, Coq_restype_continue())\n                   && res_label_in(r, labs)))) {\n              switch (eo3.tag) {\n                case "Some":\n                  var e3 = eo3.value;\n                  return (\n                    if_run(run_expr_get_value(s1, c, e3), function(s2, v3) {\n                        \n                        return (loop(s2));}));\n                case "None":\n                  return (loop(s1));\n              }\n              \n            } else {\n              return (res_ter(s1, r));\n            }\n          }}));\n  };\n  switch (eo2.tag) {\n    case "Some":\n      var e2 = eo2.value;\n      return (\n        if_run(run_expr_get_value(s, c, e2), function(s0, v2) {\n            \n            var b = convert_value_to_boolean(v2);\n            if (b) {\n              return (follows(s0));\n            } else {\n              return (res_ter(s0, res_normal(rv)));\n            }}));\n    case "None":\n      return (follows(s));\n  }\n  \n};\n\nvar run_stat_for = function (s, c, labs, eo1, eo2, eo3, t) {\n  var follows = function (s0) {\n    return (\n      run_stat_for_loop(s0, c, labs, Coq_resvalue_empty(), eo2, eo3, t));\n  };\n  switch (eo1.tag) {\n    case "Some":\n      var e1 = eo1.value;\n      return (\n        if_run(run_expr_get_value(s, c, e1), function(s0, v1) {\n            \n            return (follows(s0));}));\n    case "None":\n      return (follows(s));\n  }\n  \n};\n\nvar run_stat_for_var = function (s, c, labs, ds, eo2, eo3, t) {\n  return (\n    if_ter(run_stat(s, c, Coq_stat_var_decl(ds)), function(s0, r) {\n        \n        return (\n          run_stat_for_loop(s0, c, labs, Coq_resvalue_empty(), eo2, eo3, t));\n      }));\n};\n\nvar run_expr = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_expr_this":\n      return (\n        result_out(Coq_out_ter(s, res_val(c.execution_ctx_this_binding))));\n    case "Coq_expr_identifier":\n      var x = _term_.name;\n      return (\n        if_run(identifier_resolution(s, c, x), function(s0, r) {\n            \n            return (res_ter(s0, res_ref(r)));}));\n    case "Coq_expr_literal":\n      var i = _term_.value;\n      return (\n        result_out(\n          Coq_out_ter(s, res_val(Coq_value_prim(convert_literal_to_prim(i))))));\n    case "Coq_expr_object":\n      var pds = _term_.fields;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_object(), mk_nil()),\n          function(s1, l) { \n                            return (init_object(s1, c, l, pds));}));\n    case "Coq_expr_array":\n      var oes = _term_.elements;\n      return (\n        if_object(\n          run_construct_prealloc(s, c, Coq_prealloc_array(), mk_nil()),\n          function(s1, l) { \n                            return (init_array(s1, c, l, oes));}));\n    case "Coq_expr_function":\n      var fo = _term_.func_name_opt, args = _term_.arg_names,\n        bd = _term_.body;\n      return (run_expr_function(s, c, fo, args, bd));\n    case "Coq_expr_access":\n      var e1 = _term_.obj, e2 = _term_.field;\n      return (run_expr_access(s, c, e1, e2));\n    case "Coq_expr_member":\n      var e1 = _term_.obj, f = _term_.field_name;\n      return (\n        run_expr(s, c,\n          Coq_expr_access(e1, Coq_expr_literal(Coq_literal_string(f)))));\n    case "Coq_expr_new":\n      var e1 = _term_.func, e2s = _term_.args;\n      return (run_expr_new(s, c, e1, e2s));\n    case "Coq_expr_call":\n      var e1 = _term_.func, e2s = _term_.args;\n      return (run_expr_call(s, c, e1, e2s));\n    case "Coq_expr_unary_op":\n      var op = _term_.op, e0 = _term_.arg;\n      return (run_unary_op(s, c, op, e0));\n    case "Coq_expr_binary_op":\n      var e1 = _term_.arg1, op = _term_.op, e2 = _term_.arg2;\n      return (run_expr_binary_op(s, c, op, e1, e2));\n    case "Coq_expr_conditional":\n      var e1 = _term_.cond, e2 = _term_.then_branch, e3 = _term_.else_branch;\n      return (run_expr_conditionnal(s, c, e1, e2, e3));\n    case "Coq_expr_assign":\n      var e1 = _term_.left_expr, opo = _term_.op_opt, e2 = _term_.right_expr;\n      return (run_expr_assign(s, c, opo, e1, e2));\n  }\n  \n};\n\nvar run_stat = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_stat_expr":\n      var e = _term_.expr;\n      return (\n        if_run(run_expr_get_value(s, c, e), function(s0, r) {\n            \n            return (res_ter(s0, res_val(r)));}));\n    case "Coq_stat_label":\n      var lab = _term_.label, t0 = _term_.stat;\n      return (run_stat_label(s, c, Coq_label_string(lab), t0));\n    case "Coq_stat_block":\n      var ts = _term_.stats;\n      return (run_block(s, c, rev(ts)));\n    case "Coq_stat_var_decl":\n      var xeos = _term_.decls;\n      return (run_var_decl(s, c, xeos));\n    case "Coq_stat_if":\n      var e1 = _term_.cond, t2 = _term_.then_branch,\n        to0 = _term_.else_branch;\n      return (run_stat_if(s, c, e1, t2, to0));\n    case "Coq_stat_do_while":\n      var ls = _term_.labels, t1 = _term_.body, e2 = _term_.cond;\n      return (run_stat_do_while(s, c, Coq_resvalue_empty(), ls, e2, t1));\n    case "Coq_stat_while":\n      var ls = _term_.labels, e1 = _term_.cond, t2 = _term_.body;\n      return (run_stat_while(s, c, Coq_resvalue_empty(), ls, e1, t2));\n    case "Coq_stat_with":\n      var e1 = _term_.obj, t2 = _term_.stat;\n      return (run_stat_with(s, c, e1, t2));\n    case "Coq_stat_throw":\n      var e = _term_.arg;\n      return (run_stat_throw(s, c, e));\n    case "Coq_stat_return":\n      var eo = _term_.arg_opt;\n      return (run_stat_return(s, c, eo));\n    case "Coq_stat_break":\n      var so = _term_.label;\n      return (result_out(Coq_out_ter(s, res_break(so))));\n    case "Coq_stat_continue":\n      var so = _term_.label;\n      return (result_out(Coq_out_ter(s, res_continue(so))));\n    case "Coq_stat_try":\n      var t1 = _term_.body, t2o = _term_.catch_stats_opt,\n        t3o = _term_.finally_opt;\n      return (run_stat_try(s, c, t1, t2o, t3o));\n    case "Coq_stat_for":\n      var ls = _term_.labels, eo1 = _term_.init, eo2 = _term_.cond,\n        eo3 = _term_.step, s0 = _term_.body;\n      return (run_stat_for(s, c, ls, eo1, eo2, eo3, s0));\n    case "Coq_stat_for_var":\n      var ls = _term_.labels, ds = _term_.init, eo2 = _term_.cond,\n        eo3 = _term_.step, s0 = _term_.body;\n      return (run_stat_for_var(s, c, ls, ds, eo2, eo3, s0));\n    case "Coq_stat_for_in":\n      var ls = _term_.labels, e1 = _term_.id, e2 = _term_.obj,\n        s0 = _term_.body;\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}("stat_for_in"));\n    case "Coq_stat_for_in_var":\n      var ls = _term_.labels, x = _term_.id, e1o = _term_.init,\n        e2 = _term_.obj, s0 = _term_.body;\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}("stat_for_in_var"));\n    case "Coq_stat_debugger":\n      return (result_out(Coq_out_ter(s, res_empty)));\n    case "Coq_stat_switch":\n      var labs = _term_.labels, e = _term_.arg, sb = _term_.body;\n      return (run_stat_switch(s, c, labs, e, sb));\n  }\n  \n};\n\nvar run_elements = function (s, c, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (result_out(Coq_out_ter(s, res_normal(Coq_resvalue_empty()))));\n    case "::":\n      var el = _foo_.head, els_rev_2 = _foo_.tail;\n      return (\n        if_success(run_elements(s, c, els_rev_2), function(s0, rv0) {\n            \n            switch (el.tag) {\n              case "Coq_element_stat":\n                var t = el.stat;\n                return (\n                  if_ter(run_stat(s0, c, t), function(s1, r1) {\n                      \n                      var r2 = res_overwrite_value_if_empty(rv0, r1);\n                      return (res_out(Coq_out_ter(s1, r2)));}));\n              case "Coq_element_func_decl":\n                var name = el.func_name, args = el.arg_names, bd = el.body;\n                return (res_ter(s0, res_normal(rv0)));\n            }\n            }));\n  }\n  \n};\n\nvar run_prog = function (s, c, _term_) {\n  switch (_term_.tag) {\n    case "Coq_prog_intro":\n      var str = _term_.strictness, els = _term_.elements;\n      return (run_elements(s, c, rev(els)));\n  }\n  \n};\n\nvar push = function (s, c, l, args, ilen) {\n  var vlen = ilen;\n  switch (args.tag) {\n    case "[]":\n      return (\n        if_not_throw(\n          object_put(s, c, l, "length",\n            Coq_value_prim(Coq_prim_number(vlen)), throw_true), function(s0,\n          x) {\n            \n            return (\n              result_out(\n                Coq_out_ter(s0,\n                  res_val(Coq_value_prim(Coq_prim_number(vlen))))));}));\n    case "::":\n      var v = args.head, vs = args.tail;\n      return (\n        if_string(to_string(s, c, Coq_value_prim(Coq_prim_number(vlen))),\n          function(s0, slen) {\n            \n            return (\n              if_not_throw(object_put(s0, c, l, slen, v, throw_true),\n                function(s1, x) { \n                                  return (push(s1, c, l, vs, (ilen + 1.)));}));\n          }));\n  }\n  \n};\n\nvar run_object_is_sealed = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_method(object_extensible_, s, l), function(ext) {\n            \n            return (\n              res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(!(ext))))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_run(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if (attributes_configurable(a)) {\n                  return (\n                    res_ter(s0,\n                      res_val(Coq_value_prim(Coq_prim_bool(false)))));\n                } else {\n                  return (run_object_is_sealed(s0, c, l, xs_2));\n                }\n            }\n            }));\n  }\n  \n};\n\nvar run_object_seal = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_heap_set_extensible(false, s, l), function(s0) {\n            \n            return (res_ter(s0, res_val(Coq_value_object(l))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_run(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_seal]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if (attributes_configurable(a)) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: None(),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: Some(false)\n                  };\n                  var a_2 = attributes_update(a, desc);\n                } else {\n                  var a_2 = a;\n                }\n                return (\n                  if_bool(\n                    object_define_own_prop(s0, c, l, x,\n                      descriptor_of_attributes(a_2), true), function(s1,\n                    x0) { \n                          return (run_object_seal(s1, c, l, xs_2));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_object_freeze = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_heap_set_extensible(false, s, l), function(s0) {\n            \n            return (res_ter(s0, res_val(Coq_value_object(l))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_run(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                if ((attributes_is_data_dec(a) && attributes_writable(a))) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: Some(false),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: None()\n                  };\n                  var a_2 = attributes_update(a, desc);\n                } else {\n                  var a_2 = a;\n                }\n                if (attributes_configurable(a_2)) {\n                  var desc = {\n                    descriptor_value: None(),\n                    descriptor_writable: None(),\n                    descriptor_get: None(),\n                    descriptor_set: None(),\n                    descriptor_enumerable: None(),\n                    descriptor_configurable: Some(false)\n                  };\n                  var a_3 = attributes_update(a_2, desc);\n                } else {\n                  var a_3 = a_2;\n                }\n                return (\n                  if_bool(\n                    object_define_own_prop(s0, c, l, x,\n                      descriptor_of_attributes(a_3), true), function(s1,\n                    x0) { \n                          return (run_object_freeze(s1, c, l, xs_2));}));\n            }\n            }));\n  }\n  \n};\n\nvar run_object_is_frozen = function (s, c, l, _foo_) {\n  switch (_foo_.tag) {\n    case "[]":\n      return (\n        if_some(run_object_method(object_extensible_, s, l), function(ext) {\n            \n            return (\n              res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(!(ext))))));}));\n    case "::":\n      var x = _foo_.head, xs_2 = _foo_.tail;\n      return (\n        if_run(run_object_get_own_prop(s, c, l, x), function(s0, d) {\n            \n            var check_configurable = function (a) {\n              if (attributes_configurable(a)) {\n                return (\n                  res_ter(s0, res_val(Coq_value_prim(Coq_prim_bool(false)))));\n              } else {\n                return (run_object_is_frozen(s0, c, l, xs_2));\n              }\n            };\n            switch (d.tag) {\n              case "Coq_full_descriptor_undef":\n                return (\n                  function (s, m) {\n                      Debug.impossible_with_heap_because(__LOC__, s, m);\n                      return (Coq_result_impossible());}(s0,\n                    "[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\'t."));\n              case "Coq_full_descriptor_some":\n                var a = d.value;\n                switch (a.tag) {\n                  case "Coq_attributes_data_of":\n                    var ad = a.value;\n                    if (attributes_writable(Coq_attributes_data_of(ad))) {\n                      return (\n                        res_ter(s0,\n                          res_val(Coq_value_prim(Coq_prim_bool(false)))));\n                    } else {\n                      return (\n                        check_configurable(Coq_attributes_data_of(ad)));\n                    }\n                  case "Coq_attributes_accessor_of":\n                    var aa = a.value;\n                    return (\n                      check_configurable(Coq_attributes_accessor_of(aa)));\n                }\n                \n            }\n            }));\n  }\n  \n};\n\nvar run_get_args_for_apply = function (s, c, l, index, n) {\n  if ((index < n)) {\n    return (\n      if_string(to_string(s, c, Coq_value_prim(Coq_prim_number(index))),\n        function(s0, sindex) {\n          \n          return (\n            if_value(run_object_get(s0, c, l, sindex), function(s1, v) {\n                \n                var tail_args = run_get_args_for_apply(s1, c, l,\n                                  (index + 1.), n);\n                return (\n                  if_run(tail_args, function(s2, tail) {\n                      \n                      return (res_spec(s2, mk_cons(v, tail)));}));}));}));\n  } else {\n    return (res_spec(s, mk_nil()));\n  }\n};\n\nvar valueToStringForJoin = function (s, c, l, k) {\n  return (\n    if_string(to_string(s, c, Coq_value_prim(Coq_prim_number(k))),\n      function(s0, prop) {\n        \n        return (\n          if_value(run_object_get(s0, c, l, prop), function(s1, v) {\n              \n              switch (v.tag) {\n                case "Coq_value_prim":\n                  var p = v.value;\n                  switch (p.tag) {\n                    case "Coq_prim_undef":\n                      return (res_spec(s1, ""));\n                    case "Coq_prim_null":\n                      return (res_spec(s1, ""));\n                    case "Coq_prim_bool":\n                      var b = p.value;\n                      return (\n                        if_string(to_string(s1, c, v), function(s2, s3) {\n                            \n                            return (res_spec(s2, s3));}));\n                    case "Coq_prim_number":\n                      var n = p.value;\n                      return (\n                        if_string(to_string(s1, c, v), function(s2, s3) {\n                            \n                            return (res_spec(s2, s3));}));\n                    case "Coq_prim_string":\n                      var s2 = p.value;\n                      return (\n                        if_string(to_string(s1, c, v), function(s3, s4) {\n                            \n                            return (res_spec(s3, s4));}));\n                  }\n                  \n                case "Coq_value_object":\n                  var o = v.value;\n                  return (\n                    if_string(to_string(s1, c, v), function(s2, s3) {\n                        \n                        return (res_spec(s2, s3));}));\n              }\n              }));}));\n};\n\nvar run_array_join_elements = function (s, c, l, k, length0, sep, sR) {\n  if ((k < length0)) {\n    var ss = strappend(sR, sep);\n    var sE = valueToStringForJoin(s, c, l, k);\n    return (\n      if_run(sE, function(s0, element) {\n          \n          var sR0 = strappend(ss, element);\n          return (\n            run_array_join_elements(s0, c, l, (k + 1.), length0, sep, sR0));\n        }));\n  } else {\n    return (res_ter(s, res_val(Coq_value_prim(Coq_prim_string(sR)))));\n  }\n};\n\nvar run_call_prealloc = function (s, c, b, vthis, args) {\n  switch (b.tag) {\n    case "Coq_prealloc_global_is_finite":\n      var v = get_arg(0, args);\n      return (\n        if_number(to_number(s, c, v), function(s0, n) {\n            \n            return (\n              res_ter(s0,\n                res_val(\n                  Coq_value_prim(\n                    Coq_prim_bool(\n                      !(\n                        (JsNumber.isnan(n)\n                        || ((n === JsNumber.infinity)\n                           || (n === JsNumber.neg_infinity)))))))));}));\n    case "Coq_prealloc_global_is_nan":\n      var v = get_arg(0, args);\n      return (\n        if_number(to_number(s, c, v), function(s0, n) {\n            \n            return (\n              res_ter(s0,\n                res_val(Coq_value_prim(Coq_prim_bool(JsNumber.isnan(n))))));\n          }));\n    case "Coq_prealloc_object":\n      var value0 = get_arg(0, args);\n      switch (value0.tag) {\n        case "Coq_value_prim":\n          var p = value0.value;\n          switch (p.tag) {\n            case "Coq_prim_undef":\n              return (run_construct_prealloc(s, c, b, args));\n            case "Coq_prim_null":\n              return (run_construct_prealloc(s, c, b, args));\n            case "Coq_prim_bool":\n              var b0 = p.value;\n              return (to_object(s, c, value0));\n            case "Coq_prim_number":\n              var n = p.value;\n              return (to_object(s, c, value0));\n            case "Coq_prim_string":\n              var s0 = p.value;\n              return (to_object(s, c, value0));\n          }\n          \n        case "Coq_value_object":\n          var o = value0.value;\n          return (to_object(s, c, value0));\n      }\n      \n    case "Coq_prealloc_object_get_proto_of":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(run_object_method(object_proto_, s, l), function(proto) {\n                \n                return (res_ter(s, res_val(proto)));}));\n      }\n      \n    case "Coq_prealloc_object_get_own_prop_descriptor":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_string(to_string(s, c, get_arg(1, args)), function(s1, x) {\n                \n                return (\n                  if_run(run_object_get_own_prop(s1, c, l, x), function(s2,\n                    d) { \n                         return (from_prop_descriptor(s2, c, d));}));}));\n      }\n      \n    case "Coq_prealloc_object_define_prop":\n      var o = get_arg(0, args);\n      var p = get_arg(1, args);\n      var attr = get_arg(2, args);\n      switch (o.tag) {\n        case "Coq_value_prim":\n          var p0 = o.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = o.value;\n          return (\n            if_string(to_string(s, c, p), function(s1, name) {\n                \n                return (\n                  if_run(run_to_descriptor(s1, c, attr), function(s2, desc) {\n                      \n                      return (\n                        if_bool(\n                          object_define_own_prop(s2, c, l, name, desc, true),\n                          function(s3, x) {\n                            \n                            return (\n                              res_ter(s3, res_val(Coq_value_object(l))));}));\n                    }));}));\n      }\n      \n    case "Coq_prealloc_object_seal":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_seal(s, c, l, _x_));}));\n      }\n      \n    case "Coq_prealloc_object_freeze":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_freeze(s, c, l, _x_));}));\n      }\n      \n    case "Coq_prealloc_object_prevent_extensions":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_binds_option(s, l), function(o) {\n                \n                var o1 = object_with_extension(o, false);\n                var s_2 = object_write(s, l, o1);\n                return (res_ter(s_2, res_val(Coq_value_object(l))));}));\n      }\n      \n    case "Coq_prealloc_object_is_sealed":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_is_sealed(s, c, l, _x_));}));\n      }\n      \n    case "Coq_prealloc_object_is_frozen":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(object_properties_keys_as_list_option(s, l),\n              function(_x_) { \n                              return (run_object_is_frozen(s, c, l, _x_));}));\n      }\n      \n    case "Coq_prealloc_object_is_extensible":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (run_error(s, c, Coq_native_error_type()));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_some(run_object_method(object_extensible_, s, l),\n              function(r) {\n                \n                return (\n                  res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(r)))));}));\n      }\n      \n    case "Coq_prealloc_object_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_prim":\n          var p = vthis.value;\n          switch (p.tag) {\n            case "Coq_prim_undef":\n              return (\n                result_out(\n                  Coq_out_ter(s,\n                    res_val(\n                      Coq_value_prim(Coq_prim_string("[object Undefined]"))))));\n            case "Coq_prim_null":\n              return (\n                result_out(\n                  Coq_out_ter(s,\n                    res_val(Coq_value_prim(Coq_prim_string("[object Null]"))))));\n            case "Coq_prim_bool":\n              var b0 = p.value;\n              return (\n                if_object(to_object(s, c, vthis), function(s1, l) {\n                    \n                    return (\n                      if_some(run_object_method(object_class_, s1, l),\n                        function(s0) {\n                          \n                          return (\n                            res_ter(s1,\n                              res_val(\n                                Coq_value_prim(\n                                  Coq_prim_string(\n                                    strappend("[object ", strappend(s0, "]")))))));\n                        }));}));\n            case "Coq_prim_number":\n              var n = p.value;\n              return (\n                if_object(to_object(s, c, vthis), function(s1, l) {\n                    \n                    return (\n                      if_some(run_object_method(object_class_, s1, l),\n                        function(s0) {\n                          \n                          return (\n                            res_ter(s1,\n                              res_val(\n                                Coq_value_prim(\n                                  Coq_prim_string(\n                                    strappend("[object ", strappend(s0, "]")))))));\n                        }));}));\n            case "Coq_prim_string":\n              var s0 = p.value;\n              return (\n                if_object(to_object(s, c, vthis), function(s1, l) {\n                    \n                    return (\n                      if_some(run_object_method(object_class_, s1, l),\n                        function(s2) {\n                          \n                          return (\n                            res_ter(s1,\n                              res_val(\n                                Coq_value_prim(\n                                  Coq_prim_string(\n                                    strappend("[object ", strappend(s2, "]")))))));\n                        }));}));\n          }\n          \n        case "Coq_value_object":\n          var o = vthis.value;\n          return (\n            if_object(to_object(s, c, vthis), function(s1, l) {\n                \n                return (\n                  if_some(run_object_method(object_class_, s1, l),\n                    function(s0) {\n                      \n                      return (\n                        res_ter(s1,\n                          res_val(\n                            Coq_value_prim(\n                              Coq_prim_string(\n                                strappend("[object ", strappend(s0, "]")))))));\n                    }));}));\n      }\n      \n    case "Coq_prealloc_object_proto_value_of":\n      return (to_object(s, c, vthis));\n    case "Coq_prealloc_object_proto_has_own_prop":\n      var v = get_arg(0, args);\n      return (\n        if_string(to_string(s, c, v), function(s1, x) {\n            \n            return (\n              if_object(to_object(s1, c, vthis), function(s2, l) {\n                  \n                  return (\n                    if_run(run_object_get_own_prop(s2, c, l, x), function(s3,\n                      d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (\n                              res_ter(s3,\n                                res_val(Coq_value_prim(Coq_prim_bool(false)))));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (\n                              res_ter(s3,\n                                res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                        }\n                        }));}));}));\n    case "Coq_prealloc_object_proto_is_prototype_of":\n      var v = get_arg(0, args);\n      switch (v.tag) {\n        case "Coq_value_prim":\n          var p = v.value;\n          return (\n            result_out(\n              Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_bool(false))))));\n        case "Coq_value_object":\n          var l = v.value;\n          return (\n            if_object(to_object(s, c, vthis), function(s1, lo) {\n                \n                return (object_proto_is_prototype_of(s1, lo, l));}));\n      }\n      \n    case "Coq_prealloc_object_proto_prop_is_enumerable":\n      var v = get_arg(0, args);\n      return (\n        if_string(to_string(s, c, v), function(s1, x) {\n            \n            return (\n              if_object(to_object(s1, c, vthis), function(s2, l) {\n                  \n                  return (\n                    if_run(run_object_get_own_prop(s2, c, l, x), function(s3,\n                      d) {\n                        \n                        switch (d.tag) {\n                          case "Coq_full_descriptor_undef":\n                            return (\n                              res_ter(s3,\n                                res_val(Coq_value_prim(Coq_prim_bool(false)))));\n                          case "Coq_full_descriptor_some":\n                            var a = d.value;\n                            return (\n                              res_ter(s3,\n                                res_val(\n                                  Coq_value_prim(\n                                    Coq_prim_bool(attributes_enumerable(a))))));\n                        }\n                        }));}));}));\n    case "Coq_prealloc_function_proto":\n      return (\n        result_out(Coq_out_ter(s, res_val(Coq_value_prim(Coq_prim_undef())))));\n    case "Coq_prealloc_function_proto_to_string":\n      if (is_callable_dec(s, vthis)) {\n        return (\n          function (s) {\n              Debug.not_yet_implemented_because(__LOC__, s);\n              return (Coq_result_not_yet_implemented());}(\n            "Function.prototype.toString() is implementation dependent."));\n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_apply":\n      var thisArg = get_arg(0, args);\n      var argArray = get_arg(1, args);\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_prim":\n            var p = vthis.value;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            switch (argArray.tag) {\n              case "Coq_value_prim":\n                var p = argArray.value;\n                switch (p.tag) {\n                  case "Coq_prim_undef":\n                    return (run_call(s, c, thisobj, thisArg, mk_nil()));\n                  case "Coq_prim_null":\n                    return (run_call(s, c, thisobj, thisArg, mk_nil()));\n                  case "Coq_prim_bool":\n                    var b0 = p.value;\n                    return (run_error(s, c, Coq_native_error_type()));\n                  case "Coq_prim_number":\n                    var n = p.value;\n                    return (run_error(s, c, Coq_native_error_type()));\n                  case "Coq_prim_string":\n                    var s0 = p.value;\n                    return (run_error(s, c, Coq_native_error_type()));\n                }\n                \n              case "Coq_value_object":\n                var array = argArray.value;\n                return (\n                  if_value(run_object_get(s, c, array, "length"),\n                    function(s0, v) {\n                      \n                      return (\n                        if_run(to_uint32(s0, c, v), function(s1, ilen) {\n                            \n                            return (\n                              if_run(\n                                run_get_args_for_apply(s1, c, array, 0.,\n                                  ilen), function(s2, arguments_) {\n                                  \n                                  return (\n                                    run_call(s2, c, thisobj, thisArg,\n                                      arguments_));}));}));}));\n            }\n            \n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_call":\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_prim":\n            var p = vthis.value;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            var _tuple_arg_29 = get_arg_first_and_rest(args);\n            var thisArg = _tuple_arg_29[0], a = _tuple_arg_29[1];\n            return (run_call(s, c, thisobj, thisArg, a));\n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_function_proto_bind":\n      if (is_callable_dec(s, vthis)) {\n        switch (vthis.tag) {\n          case "Coq_value_prim":\n            var p = vthis.value;\n            return (\n              function (s, m) {\n                  Debug.impossible_with_heap_because(__LOC__, s, m);\n                  return (Coq_result_impossible());}(s,\n                "Value is callable, but isn\'t an object."));\n          case "Coq_value_object":\n            var thisobj = vthis.value;\n            var _tuple_arg_30 = get_arg_first_and_rest(args);\n            var vthisArg = _tuple_arg_30[0], a = _tuple_arg_30[1];\n            var o1 = object_new(\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(Coq_prealloc_object_proto())),\n                       "Object");\n            var o2 = object_with_get(o1, Coq_builtin_get_function());\n            var o3 = object_with_details(o2, None(), None(), None(),\n                       Some(thisobj), Some(vthisArg), Some(a), None());\n            var o4 = object_set_class(o3, "Function");\n            var o5 = object_set_proto(o4,\n                       Coq_value_object(\n                         Coq_object_loc_prealloc(\n                           Coq_prealloc_function_proto())));\n            var o6 = object_with_invokation(o5,\n                       Some(Coq_construct_after_bind()),\n                       Some(Coq_call_after_bind()),\n                       Some(Coq_builtin_has_instance_after_bind()));\n            var o7 = object_set_extensible(o6, true);\n            var _tuple_arg_31 = object_alloc(s, o7);\n            var l = _tuple_arg_31[0], s_2 = _tuple_arg_31[1];\n            var vlength = if_some(\n                            run_object_method(object_class_, s_2, thisobj),\n                            function(class0) {\n                              \n                              if (string_eq(class0, "Function")) {\n                                return (\n                                  if_number(\n                                    run_object_get(s_2, c, thisobj, "length"),\n                                    function(s10, n) {\n                                      \n                                      return (\n                                        if_run(\n                                          to_int32(s10, c,\n                                            Coq_value_prim(\n                                              Coq_prim_number(n))),\n                                          function(s11, ilen) {\n                                            \n                                            if ((ilen\n                                                < number_of_int(\n                                                    LibList.length(a)))) {\n                                              return (res_spec(s11, 0.));\n                                            } else {\n                                              return (\n                                                res_spec(s11,\n                                                  (ilen\n                                                  - number_of_int(\n                                                      LibList.length(a)))));\n                                            }}));}));\n                              } else {\n                                return (res_spec(s_2, 0.));\n                              }});\n            return (\n              if_run(vlength, function(s10, length0) {\n                  \n                  var a0 = {\n                    attributes_data_value: Coq_value_prim(\n                                             Coq_prim_number(length0)),\n                    attributes_data_writable: false,\n                    attributes_data_enumerable: false,\n                    attributes_data_configurable: false\n                  };\n                  return (\n                    if_some(\n                      object_heap_map_properties_option(s10, l,\n                        function (p) {\n                          return (\n                            HeapStr.write(p, "length",\n                              Coq_attributes_data_of(a0)));}),\n                      function(s11) {\n                        \n                        var vthrower = Coq_value_object(\n                                         Coq_object_loc_prealloc(\n                                           Coq_prealloc_throw_type_error()));\n                        var a1 = {\n                          attributes_accessor_get: vthrower,\n                          attributes_accessor_set: vthrower,\n                          attributes_accessor_enumerable: false,\n                          attributes_accessor_configurable: false\n                        };\n                        return (\n                          if_bool(\n                            object_define_own_prop(s11, c, l, "caller",\n                              descriptor_of_attributes(\n                                Coq_attributes_accessor_of(a1)), false),\n                            function(s12, x) {\n                              \n                              return (\n                                if_bool(\n                                  object_define_own_prop(s12, c, l,\n                                    "arguments",\n                                    descriptor_of_attributes(\n                                      Coq_attributes_accessor_of(a1)), false),\n                                  function(s13, x0) {\n                                    \n                                    return (\n                                      res_ter(s13,\n                                        res_val(Coq_value_object(l))));}));}));\n                      }));}));\n        }\n        \n      } else {\n        return (run_error(s, c, Coq_native_error_type()));\n      }\n    case "Coq_prealloc_bool":\n      return (\n        result_out((function () {\n            var v = get_arg(0, args);\n            return (\n              Coq_out_ter(s,\n                res_val(\n                  Coq_value_prim(Coq_prim_bool(convert_value_to_boolean(v))))));\n          }())));\n    case "Coq_prealloc_bool_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_prim":\n          var p = vthis.value;\n          switch (p.tag) {\n            case "Coq_prim_undef":\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_null":\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_bool":\n              var b0 = p.value;\n              return (\n                res_ter(s,\n                  res_val(\n                    Coq_value_prim(\n                      Coq_prim_string(convert_bool_to_string(b0))))));\n            case "Coq_prim_number":\n              var n = p.value;\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_string":\n              var s0 = p.value;\n              return (run_error(s, c, Coq_native_error_type()));\n          }\n          \n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_prim":\n                                var p = v.value;\n                                switch (p.tag) {\n                                  case "Coq_prim_undef":\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_null":\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_bool":\n                                    var b0 = p.value;\n                                    return (\n                                      res_ter(s,\n                                        res_val(\n                                          Coq_value_prim(\n                                            Coq_prim_string(\n                                              convert_bool_to_string(b0))))));\n                                  case "Coq_prim_number":\n                                    var n = p.value;\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_string":\n                                    var s1 = p.value;\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                }\n                                \n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_bool_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_prim":\n          var p = vthis.value;\n          switch (p.tag) {\n            case "Coq_prim_undef":\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_null":\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_bool":\n              var b0 = p.value;\n              return (\n                res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(b0)))));\n            case "Coq_prim_number":\n              var n = p.value;\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_string":\n              var s0 = p.value;\n              return (run_error(s, c, Coq_native_error_type()));\n          }\n          \n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_prim":\n                                var p = v.value;\n                                switch (p.tag) {\n                                  case "Coq_prim_undef":\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_null":\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_bool":\n                                    var b0 = p.value;\n                                    return (\n                                      res_ter(s,\n                                        res_val(\n                                          Coq_value_prim(Coq_prim_bool(b0)))));\n                                  case "Coq_prim_number":\n                                    var n = p.value;\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_string":\n                                    var s1 = p.value;\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                }\n                                \n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_number":\n      if (list_eq_nil_decidable(args)) {\n        return (\n          result_out(\n            Coq_out_ter(s,\n              res_val(Coq_value_prim(Coq_prim_number(JsNumber.zero))))));\n      } else {\n        var v = get_arg(0, args);return (to_number(s, c, v));\n      }\n    case "Coq_prealloc_number_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_prim":\n          var p = vthis.value;\n          switch (p.tag) {\n            case "Coq_prim_undef":\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_null":\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_bool":\n              var b0 = p.value;\n              return (run_error(s, c, Coq_native_error_type()));\n            case "Coq_prim_number":\n              var n = p.value;\n              return (\n                res_ter(s, res_val(Coq_value_prim(Coq_prim_number(n)))));\n            case "Coq_prim_string":\n              var s0 = p.value;\n              return (run_error(s, c, Coq_native_error_type()));\n          }\n          \n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            ifx_some_or_default(run_object_method(object_class_, s, l),\n              run_error(s, c, Coq_native_error_type()), function (s0) {\n                if (string_eq(s0, "Number")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, s, l),\n                      run_error(s, c, Coq_native_error_type()),\n                      function (wo) {\n                        switch (wo.tag) {\n                          case "Some":\n                            var v = wo.value;\n                            switch (v.tag) {\n                              case "Coq_value_prim":\n                                var p = v.value;\n                                switch (p.tag) {\n                                  case "Coq_prim_undef":\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_null":\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_bool":\n                                    var b0 = p.value;\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                  case "Coq_prim_number":\n                                    var n = p.value;\n                                    return (\n                                      res_ter(s,\n                                        res_val(\n                                          Coq_value_prim(Coq_prim_number(n)))));\n                                  case "Coq_prim_string":\n                                    var s1 = p.value;\n                                    return (\n                                      run_error(s, c,\n                                        Coq_native_error_type()));\n                                }\n                                \n                              case "Coq_value_object":\n                                var o = v.value;\n                                return (\n                                  run_error(s, c, Coq_native_error_type()));\n                            }\n                            \n                          case "None":\n                            return (\n                              run_error(s, c, Coq_native_error_type()));\n                        }\n                        }));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_array":\n      return (run_construct_prealloc(s, c, Coq_prealloc_array(), args));\n    case "Coq_prealloc_array_is_array":\n      var arg = get_arg(0, args);\n      switch (arg.tag) {\n        case "Coq_value_prim":\n          var p = arg.value;\n          return (res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(false)))));\n        case "Coq_value_object":\n          var arg0 = arg.value;\n          return (\n            if_some(run_object_method(object_class_, s, arg0),\n              function(class0) {\n                \n                if (string_eq(class0, "Array")) {\n                  return (\n                    res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(true)))));\n                } else {\n                  return (\n                    res_ter(s, res_val(Coq_value_prim(Coq_prim_bool(false)))));\n                }}));\n      }\n      \n    case "Coq_prealloc_array_proto_to_string":\n      return (\n        if_object(to_object(s, c, vthis), function(s0, array) {\n            \n            return (\n              if_value(run_object_get(s0, c, array, "join"), function(s1,\n                vfunc) {\n                  \n                  if (is_callable_dec(s1, vfunc)) {\n                    switch (vfunc.tag) {\n                      case "Coq_value_prim":\n                        var p = vfunc.value;\n                        return (\n                          function (s, m) {\n                              Debug.impossible_with_heap_because(__LOC__, s,\n                                m);\n                              return (Coq_result_impossible());}(s1,\n                            "Value is callable, but isn\'t an object."));\n                      case "Coq_value_object":\n                        var func = vfunc.value;\n                        return (\n                          run_call(s1, c, func, Coq_value_object(array),\n                            mk_nil()));\n                    }\n                    \n                  } else {\n                    return (\n                      run_call_prealloc(s1, c,\n                        Coq_prealloc_object_proto_to_string(),\n                        Coq_value_object(array), mk_nil()));\n                  }}));}));\n    case "Coq_prealloc_array_proto_join":\n      var vsep = get_arg(0, args);\n      return (\n        if_object(to_object(s, c, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_run(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        if (!(\n                              value_compare(vsep,\n                                Coq_value_prim(Coq_prim_undef())))) {\n                          var rsep = vsep;\n                        } else {\n                          var rsep = Coq_value_prim(Coq_prim_string(","));\n                        }\n                        return (\n                          if_string(to_string(s2, c, rsep), function(s3,\n                            sep) {\n                              \n                              if ((ilen == 0.0)) {\n                                return (\n                                  res_ter(s3,\n                                    res_val(\n                                      Coq_value_prim(Coq_prim_string("")))));\n                              } else {\n                                var sR = valueToStringForJoin(s3, c, l, 0.);\n                                return (\n                                  if_run(sR, function(s4, sR0) {\n                                      \n                                      return (\n                                        run_array_join_elements(s4, c, l, 1.,\n                                          ilen, sep, sR0));}));\n                              }}));}));}));}));\n    case "Coq_prealloc_array_proto_pop":\n      return (\n        if_object(to_object(s, c, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_run(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        if ((ilen == 0.0)) {\n                          return (\n                            if_not_throw(\n                              object_put(s2, c, l, "length",\n                                Coq_value_prim(\n                                  Coq_prim_number(JsNumber.zero)),\n                                throw_true), function(s3, x) {\n                                \n                                return (\n                                  result_out(\n                                    Coq_out_ter(s3,\n                                      res_val(\n                                        Coq_value_prim(Coq_prim_undef())))));\n                              }));\n                        } else {\n                          return (\n                            if_string(\n                              to_string(s2, c,\n                                Coq_value_prim(Coq_prim_number((ilen - 1.)))),\n                              function(s3, sindx) {\n                                \n                                return (\n                                  if_value(run_object_get(s3, c, l, sindx),\n                                    function(s4, velem) {\n                                      \n                                      return (\n                                        if_not_throw(\n                                          object_delete_default(s4, c, l,\n                                            sindx, throw_true), function(s5,\n                                          x) {\n                                            \n                                            return (\n                                              if_not_throw(\n                                                object_put(s5, c, l,\n                                                  "length",\n                                                  Coq_value_prim(\n                                                    Coq_prim_string(sindx)),\n                                                  throw_true), function(s6,\n                                                x0) {\n                                                  \n                                                  return (\n                                                    result_out(\n                                                      Coq_out_ter(s6,\n                                                        res_val(velem))));}));\n                                          }));}));}));\n                        }}));}));}));\n    case "Coq_prealloc_array_proto_push":\n      return (\n        if_object(to_object(s, c, vthis), function(s0, l) {\n            \n            return (\n              if_value(run_object_get(s0, c, l, "length"), function(s1,\n                vlen) {\n                  \n                  return (\n                    if_run(to_uint32(s1, c, vlen), function(s2, ilen) {\n                        \n                        return (push(s2, c, l, args, ilen));}));}));}));\n    case "Coq_prealloc_string":\n      if (list_eq_nil_decidable(args)) {\n        return (res_ter(s, res_val(Coq_value_prim(Coq_prim_string("")))));\n      } else {\n        var value0 = get_arg(0, args);\n        return (\n          if_string(to_string(s, c, value0), function(s0, s1) {\n              \n              return (\n                res_ter(s0, res_val(Coq_value_prim(Coq_prim_string(s1)))));}));\n      }\n    case "Coq_prealloc_string_proto_to_string":\n      switch (vthis.tag) {\n        case "Coq_value_prim":\n          var p = vthis.value;\n          if (type_compare(type_of(vthis), Coq_type_string())) {\n            return (res_ter(s, res_val(vthis)));\n          } else {\n            return (run_error(s, c, Coq_native_error_type()));\n          }\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            if_some(run_object_method(object_class_, s, l), function(s0) {\n                \n                if (string_eq(s0, "String")) {\n                  return (run_object_prim_value(s, l));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_string_proto_value_of":\n      switch (vthis.tag) {\n        case "Coq_value_prim":\n          var p = vthis.value;\n          if (type_compare(type_of(vthis), Coq_type_string())) {\n            return (res_ter(s, res_val(vthis)));\n          } else {\n            return (run_error(s, c, Coq_native_error_type()));\n          }\n        case "Coq_value_object":\n          var l = vthis.value;\n          return (\n            if_some(run_object_method(object_class_, s, l), function(s0) {\n                \n                if (string_eq(s0, "String")) {\n                  return (run_object_prim_value(s, l));\n                } else {\n                  return (run_error(s, c, Coq_native_error_type()));\n                }}));\n      }\n      \n    case "Coq_prealloc_error":\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_error_proto())), v));\n    case "Coq_prealloc_native_error":\n      var ne = b.error;\n      var v = get_arg(0, args);\n      return (\n        build_error(s, c,\n          Coq_value_object(\n            Coq_object_loc_prealloc(Coq_prealloc_native_error_proto(ne))), v));\n    case "Coq_prealloc_throw_type_error":\n      return (run_error(s, c, Coq_native_error_type()));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Coq_result_not_yet_implemented());}(\n          strappend("Call prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented"))));\n  }\n  \n};\n\nvar run_call = function (s, c, l, vthis, args) {\n  return (\n    if_some(run_object_method(object_call_, s, l), function(co) {\n        \n        return (\n          if_some(co, function(c0) {\n              \n              switch (c0.tag) {\n                case "Coq_call_default":\n                  return (entering_func_code(s, c, l, vthis, args));\n                case "Coq_call_after_bind":\n                  return (\n                    if_some(run_object_method(object_bound_args_, s, l),\n                      function(oarg) {\n                        \n                        return (\n                          if_some(oarg, function(boundArgs) {\n                              \n                              return (\n                                if_some(\n                                  run_object_method(object_bound_this_, s, l),\n                                  function(obnd) {\n                                    \n                                    return (\n                                      if_some(obnd, function(boundThis) {\n                                          \n                                          return (\n                                            if_some(\n                                              run_object_method(\n                                                object_target_function_, s,\n                                                l), function(otrg) {\n                                                \n                                                return (\n                                                  if_some(otrg,\n                                                    function(target) {\n                                                      \n                                                      var arguments_ = \n                                                      LibList.append(\n                                                        boundArgs, args);\n                                                      return (\n                                                        run_call(s, c,\n                                                          target, boundThis,\n                                                          arguments_));}));}));\n                                        }));}));}));}));\n                case "Coq_call_prealloc":\n                  var b = c0.prealloc;\n                  return (run_call_prealloc(s, c, b, vthis, args));\n              }\n              }));}));\n};\n\nvar run_javascript_from_state = function (s, p) {\n  var c = execution_ctx_initial(prog_intro_strictness(p));\n  return (\n    if_void(\n      execution_ctx_binding_inst(s, c, Coq_codetype_global(), None(), p,\n        mk_nil()), function(s_2) { \n                                   return (run_prog(s_2, c, p));}));\n};\n\nvar run_javascript_from_result = function (w, p) {\n  return (\n    if_success(w, function(s, _pat_any_32) {\n        \n        return (run_javascript_from_state(s, p));}));\n};\n\nvar run_javascript = function (p) {\n  return (run_javascript_from_state(state_initial, p));\n};\n}// end of with Datatypes\n}// end of with JsCommon\n}// end of with JsCommonAux\n}// end of with JsInit\n}// end of with JsInterpreterMonads\n}// end of with JsPreliminary\n}// end of with JsSyntax\n}// end of with JsSyntaxAux\n}// end of with LibList\n}// end of with LibOption\n}// end of with LibProd\n}// end of with Shared\n\nreturn {\n  convert_number_to_bool: convert_number_to_bool, \n  convert_string_to_bool: convert_string_to_bool, \n  convert_prim_to_boolean: convert_prim_to_boolean, \n  convert_value_to_boolean: convert_value_to_boolean, \n  convert_prim_to_number: convert_prim_to_number, \n  convert_number_to_integer: convert_number_to_integer, \n  convert_bool_to_string: convert_bool_to_string, \n  convert_prim_to_string: convert_prim_to_string, \n  equality_test_for_same_type: equality_test_for_same_type, \n  strict_equality_test: strict_equality_test, \n  inequality_test_number: inequality_test_number, \n  inequality_test_string: inequality_test_string, \n  inequality_test_primitive: inequality_test_primitive, \n  typeof_prim: typeof_prim, \n  string_of_propname: string_of_propname, \n  run_object_method: run_object_method, \n  run_object_heap_set_extensible: run_object_heap_set_extensible, \n  object_has_prop: object_has_prop, \n  build_error: build_error, \n  run_error: run_error, \n  out_error_or_void: out_error_or_void, \n  out_error_or_cst: out_error_or_cst, \n  object_get_builtin: object_get_builtin, \n  run_object_get: run_object_get, \n  run_object_get_prop: run_object_get_prop, \n  object_proto_is_prototype_of: object_proto_is_prototype_of, \n  object_default_value: object_default_value, \n  to_primitive: to_primitive, \n  to_number: to_number, \n  to_integer: to_integer, \n  to_int32: to_int32, \n  to_uint32: to_uint32, \n  to_string: to_string, \n  object_can_put: object_can_put, \n  run_object_define_own_prop_array_loop: run_object_define_own_prop_array_loop, \n  object_define_own_prop: object_define_own_prop, \n  run_to_descriptor: run_to_descriptor, \n  prim_new_object: prim_new_object, \n  to_object: to_object, \n  run_object_prim_value: run_object_prim_value, \n  prim_value_get: prim_value_get, \n  env_record_has_binding: env_record_has_binding, \n  lexical_env_get_identifier_ref: lexical_env_get_identifier_ref, \n  object_delete_default: object_delete_default, \n  object_delete: object_delete, \n  env_record_delete_binding: env_record_delete_binding, \n  env_record_implicit_this_value: env_record_implicit_this_value, \n  identifier_resolution: identifier_resolution, \n  env_record_get_binding_value: env_record_get_binding_value, \n  ref_get_value: ref_get_value, \n  run_expr_get_value: run_expr_get_value, \n  object_put_complete: object_put_complete, \n  object_put: object_put, \n  env_record_set_mutable_binding: env_record_set_mutable_binding, \n  prim_value_put: prim_value_put, \n  ref_put_value: ref_put_value, \n  env_record_create_mutable_binding: env_record_create_mutable_binding, \n  env_record_create_set_mutable_binding: env_record_create_set_mutable_binding, \n  env_record_create_immutable_binding: env_record_create_immutable_binding, \n  env_record_initialize_immutable_binding: env_record_initialize_immutable_binding, \n  call_object_new: call_object_new, \n  array_args_map_loop: array_args_map_loop, \n  string_of_prealloc: string_of_prealloc, \n  run_construct_prealloc: run_construct_prealloc, \n  run_construct_default: run_construct_default, \n  run_construct: run_construct, \n  run_call_default: run_call_default, \n  creating_function_object_proto: creating_function_object_proto, \n  creating_function_object: creating_function_object, \n  binding_inst_formal_params: binding_inst_formal_params, \n  binding_inst_function_decls: binding_inst_function_decls, \n  make_arg_getter: make_arg_getter, \n  make_arg_setter: make_arg_setter, \n  arguments_object_map_loop: arguments_object_map_loop, \n  arguments_object_map: arguments_object_map, \n  create_arguments_object: create_arguments_object, \n  binding_inst_arg_obj: binding_inst_arg_obj, \n  binding_inst_var_decls: binding_inst_var_decls, \n  execution_ctx_binding_inst: execution_ctx_binding_inst, \n  entering_func_code: entering_func_code, \n  run_object_get_own_prop: run_object_get_own_prop, \n  run_function_has_instance: run_function_has_instance, \n  run_object_has_instance: run_object_has_instance, \n  from_prop_descriptor: from_prop_descriptor, \n  run_equal: run_equal, \n  convert_twice: convert_twice, \n  convert_twice_primitive: convert_twice_primitive, \n  convert_twice_number: convert_twice_number, \n  convert_twice_string: convert_twice_string, \n  issome: issome, \n  run_binary_op_add: run_binary_op_add, \n  run_binary_op_arith: run_binary_op_arith, \n  run_binary_op_shift: run_binary_op_shift, \n  run_binary_op_bitwise: run_binary_op_bitwise, \n  run_binary_op_compare: run_binary_op_compare, \n  run_binary_op_instanceof: run_binary_op_instanceof, \n  run_binary_op_in: run_binary_op_in, \n  run_binary_op: run_binary_op, \n  run_prepost_op: run_prepost_op, \n  run_typeof_value: run_typeof_value, \n  run_unary_op: run_unary_op, \n  create_new_function_in: create_new_function_in, \n  init_object: init_object, \n  run_array_element_list: run_array_element_list, \n  init_array: init_array, \n  run_var_decl_item: run_var_decl_item, \n  run_var_decl: run_var_decl, \n  run_list_expr: run_list_expr, \n  run_block: run_block, \n  run_binary_op_and: run_binary_op_and, \n  run_binary_op_or: run_binary_op_or, \n  run_expr_binary_op: run_expr_binary_op, \n  run_expr_access: run_expr_access, \n  run_expr_assign: run_expr_assign, \n  run_expr_function: run_expr_function, \n  entering_eval_code: entering_eval_code, \n  run_eval: run_eval, \n  run_expr_call: run_expr_call, \n  run_expr_conditionnal: run_expr_conditionnal, \n  run_expr_new: run_expr_new, \n  run_stat_label: run_stat_label, \n  run_stat_with: run_stat_with, \n  run_stat_if: run_stat_if, \n  run_stat_while: run_stat_while, \n  run_stat_switch_end: run_stat_switch_end, \n  run_stat_switch_no_default: run_stat_switch_no_default, \n  run_stat_switch_with_default_default: run_stat_switch_with_default_default, \n  run_stat_switch_with_default_B: run_stat_switch_with_default_B, \n  run_stat_switch_with_default_A: run_stat_switch_with_default_A, \n  run_stat_switch: run_stat_switch, \n  run_stat_do_while: run_stat_do_while, \n  run_stat_try: run_stat_try, \n  run_stat_throw: run_stat_throw, \n  run_stat_return: run_stat_return, \n  run_stat_for_loop: run_stat_for_loop, \n  run_stat_for: run_stat_for, \n  run_stat_for_var: run_stat_for_var, \n  run_expr: run_expr, \n  run_stat: run_stat, \n  run_elements: run_elements, \n  run_prog: run_prog, \n  push: push, \n  run_object_is_sealed: run_object_is_sealed, \n  run_object_seal: run_object_seal, \n  run_object_freeze: run_object_freeze, \n  run_object_is_frozen: run_object_is_frozen, \n  run_get_args_for_apply: run_get_args_for_apply, \n  valueToStringForJoin: valueToStringForJoin, \n  run_array_join_elements: run_array_join_elements, \n  run_call_prealloc: run_call_prealloc, \n  run_call: run_call, \n  run_javascript_from_state: run_javascript_from_state, \n  run_javascript_from_result: run_javascript_from_result, \n  run_javascript: run_javascript};\n})();\n'},

/* --------------------- JsInterpreter.pseudo --------------------- */
  { file: 'JsInterpreter.pseudo', contents: 'var JsInterpreter = (function() {\nwith (Datatypes) {\nwith (JsCommon) {\nwith (JsCommonAux) {\nwith (JsInit) {\nwith (JsInterpreterMonads) {\nwith (JsPreliminary) {\nwith (JsSyntax) {\nwith (JsSyntaxAux) {\nwith (LibList) {\nwith (LibOption) {\nwith (LibProd) {\nwith (Shared) {\n\nvar convert_number_to_bool = function (n) {\n  if ((JsNumber.isposzero(n) || (JsNumber.isnegzero(n) || JsNumber.isnan(n)))) {\n    return (false);\n  } else {\n    return (true);\n  }\n};\n\n\n\nvar convert_string_to_bool = function (s) {\n  if (string_eq(s, "")) {\n    return (false);\n  } else {\n    return (true);\n  }\n};\n\n\n\nvar convert_prim_to_boolean = function (_foo_) {\n  switch (_foo_) {\n    case Coq_prim_undef:\n      return (false);\n    case Coq_prim_null:\n      return (false);\n    case Coq_prim_bool(b):\n      return (b);\n    case Coq_prim_number(n):\n      return (convert_number_to_bool(n));\n    case Coq_prim_string(s):\n      return (convert_string_to_bool(s));\n  }\n  \n};\n\n\n\nvar convert_value_to_boolean = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_prim(p):\n      return (convert_prim_to_boolean(p));\n    case Coq_value_object(o):\n      return (true);\n  }\n  \n};\n\n\n\nvar convert_prim_to_number = function (_foo_) {\n  switch (_foo_) {\n    case Coq_prim_undef:\n      return (JsNumber.nan);\n    case Coq_prim_null:\n      return (JsNumber.zero);\n    case Coq_prim_bool(b):\n      if (b) {\n        return (JsNumber.one);\n      } else {\n        return (JsNumber.zero);\n      }\n    case Coq_prim_number(n):\n      return (n);\n    case Coq_prim_string(s):\n      return (JsNumber.from_string(s));\n  }\n  \n};\n\n\n\nvar convert_number_to_integer = function (n) {\n  if (JsNumber.isnan(n)) {\n    return (JsNumber.zero);\n  } else {\n    if ((JsNumber.isposzero(n)\n        || (JsNumber.isnegzero(n)\n           || ((n === JsNumber.infinity) || (n === JsNumber.neg_infinity))))) {\n      return (n);\n    } else {\n      return ((JsNumber.sign(n) * JsNumber.floor(JsNumber.absolute(n))));\n    }\n  }\n};\n\n\n\nvar convert_bool_to_string = function (_foo_) {\n  switch (_foo_) {\n    case true:\n      return ("true");\n    case false:\n      return ("false");\n  }\n  \n};\n\n\n\nvar convert_prim_to_string = function (_foo_) {\n  switch (_foo_) {\n    case Coq_prim_undef:\n      return ("undefined");\n    case Coq_prim_null:\n      return ("null");\n    case Coq_prim_bool(b):\n      return (convert_bool_to_string(b));\n    case Coq_prim_number(n):\n      return (JsNumber.to_string(n));\n    case Coq_prim_string(s):\n      return (s);\n  }\n  \n};\n\n\n\nvar equality_test_for_same_type = function (ty, v1, v2) {\n  switch (ty) {\n    case Coq_type_undef:\n      return (true);\n    case Coq_type_null:\n      return (true);\n    case Coq_type_bool:\n      return (value_compare(v1, v2));\n    case Coq_type_number:\n      switch (v1) {\n        case Coq_value_prim(p):\n          switch (p) {\n            case Coq_prim_undef:\n              return (false);\n            case Coq_prim_null:\n              return (false);\n            case Coq_prim_bool(b):\n              return (false);\n            case Coq_prim_number(n1):\n              switch (v2) {\n                case Coq_value_prim(p0):\n                  switch (p0) {\n                    case Coq_prim_undef:\n                      return (false);\n                    case Coq_prim_null:\n                      return (false);\n                    case Coq_prim_bool(b):\n                      return (false);\n                    case Coq_prim_number(n2):\n                      if (JsNumber.isnan(n1)) {\n                        return (false);\n                      } else {\n                        if (JsNumber.isnan(n2)) {\n                          return (false);\n                        } else {\n                          if ((JsNumber.isposzero(n1)\n                              && JsNumber.isnegzero(n2))) {\n                            return (true);\n                          } else {\n                            if ((JsNumber.isnegzero(n1)\n                                && JsNumber.isposzero(n2))) {\n                              return (true);\n                            } else {\n                              return ((n1 === n2));\n                            }\n                          }\n                        }\n                      }\n                    case Coq_prim_string(s):\n                      return (false);\n                  }\n                  \n                case Coq_value_object(o):\n                  return (false);\n              }\n              \n            case Coq_prim_string(s):\n              return (false);\n          }\n          \n        case Coq_value_object(o):\n          return (false);\n      }\n      \n    case Coq_type_string:\n      return (value_compare(v1, v2));\n    case Coq_type_object:\n      return (value_compare(v1, v2));\n  }\n  \n};\n\n\n\nvar strict_equality_test = function (v1, v2) {\n  var ty1 = type_of(v1);\n  var ty2 = type_of(v2);\n  if (type_compare(ty1, ty2)) {\n    return (equality_test_for_same_type(ty1, v1, v2));\n  } else {\n    return (false);\n  }\n};\n\n\n\nvar inequality_test_number = function (n1, n2) {\n  if ((JsNumber.isnan(n1) || JsNumber.isnan(n2))) {\n    return (Prim_undef);\n  } else {\n    if ((n1 === n2)) {\n      return (false);\n    } else {\n      if ((JsNumber.isposzero(n1) && JsNumber.isnegzero(n2))) {\n        return (false);\n      } else {\n        if ((JsNumber.isnegzero(n1) && JsNumber.isposzero(n2))) {\n          return (false);\n        } else {\n          if ((n1 === JsNumber.infinity)) {\n            return (false);\n          } else {\n            if ((n2 === JsNumber.infinity)) {\n              return (true);\n            } else {\n              if ((n2 === JsNumber.neg_infinity)) {\n                return (false);\n              } else {\n                if ((n1 === JsNumber.neg_infinity)) {\n                  return (true);\n                } else {\n                  return ((n1 < n2));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n\n\nvar inequality_test_string = function (s1, s2) {\n  return (string_lt(s1, s2));\n};\n\n\n\nvar inequality_test_primitive = function (w1, w2) {\n  switch (w1) {\n    case Coq_prim_undef:\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case Coq_prim_null:\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case Coq_prim_bool(b):\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case Coq_prim_number(n):\n      return (\n        inequality_test_number(convert_prim_to_number(w1),\n          convert_prim_to_number(w2)));\n    case Coq_prim_string(s1):\n      switch (w2) {\n        case Coq_prim_undef:\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case Coq_prim_null:\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case Coq_prim_bool(b):\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case Coq_prim_number(n):\n          return (\n            inequality_test_number(convert_prim_to_number(w1),\n              convert_prim_to_number(w2)));\n        case Coq_prim_string(s2):\n          return (inequality_test_string(s1, s2));\n      }\n      \n  }\n  \n};\n\n\n\nvar typeof_prim = function (_foo_) {\n  switch (_foo_) {\n    case Coq_prim_undef:\n      return ("undefined");\n    case Coq_prim_null:\n      return ("object");\n    case Coq_prim_bool(b):\n      return ("boolean");\n    case Coq_prim_number(n):\n      return ("number");\n    case Coq_prim_string(s):\n      return ("string");\n  }\n  \n};\n\n\n\nvar string_of_propname = function (_foo_) {\n  switch (_foo_) {\n    case Coq_propname_identifier(s):\n      return (s);\n    case Coq_propname_string(s):\n      return (s);\n    case Coq_propname_number(n):\n      return (JsNumber.to_string(n));\n  }\n  \n};\n\n\n\nvar run_object_method = function (proj, l) {\n  return (LibOption.map(proj, object_binds_option(l)));\n};\n\n\n\nvar run_object_heap_set_extensible = function (b, l) {\n  return (\n    LibOption.map(function (o) {\n        return (object_write(l, object_set_extensible(o, b)));},\n      object_binds_option(l)));\n};\n\n\n\nvar object_has_prop = function (l, x) {\n  var%some b = run_object_method(object_has_prop_, l);\n  switch (b) {\n    case Coq_builtin_has_prop_default:\n      var%run d = run_object_get_prop(l, x);\n      return (!(full_descriptor_compare(d, Full_descriptor_undef)));\n  }\n  \n};\n\nvar build_error = function (vproto, vmsg) {\n  var o = object_new(vproto, "Error");\n  var (l, s_2) = object_alloc(o);\n  if (value_compare(vmsg, Prim_undef)) {\n    return (l);\n  } else {\n    var%value vstr = to_string(vmsg);\n    var a = {\n      attributes_data_value: vstr,\n      attributes_data_writable: true,\n      attributes_data_enumerable: false,\n      attributes_data_configurable: true\n    };\n    var%success rv = object_define_own_prop(l, "message",\n                       descriptor_of_attributes(a), throw_true);\n    return (l);\n  }\n};\n\nvar run_error = function (ne) {\n  var%object l = build_error(Prealloc_native_error_proto(ne), Prim_undef);\n  return (Result_some(Specret_out(res_throw(l))));\n};\n\nvar out_error_or_void = function (str, ne) {\n  if (str) {\n    return (run_error(ne));\n  } else {\n    return (out_void());\n  }\n};\n\nvar out_error_or_cst = function (str, ne, v) {\n  if (str) {\n    return (run_error(ne));\n  } else {\n    return (v);\n  }\n};\n\nvar object_get_builtin = function (b, vthis, l, x) {\n  var def = function (l0) {\n    var%run d = run_object_get_prop(l0, x);\n    switch (d) {\n      case Coq_full_descriptor_undef:\n        return (Prim_undef);\n      case Coq_full_descriptor_some(a):\n        switch (a) {\n          case Coq_attributes_data_of(ad):\n            return (ad.attributes_data_value);\n          case Coq_attributes_accessor_of(aa):\n            switch (aa.attributes_accessor_get) {\n              case Coq_value_prim(p):\n                switch (p) {\n                  case Coq_prim_undef:\n                    return (Prim_undef);\n                  case Coq_prim_null:\n                    return (Result_impossible);\n                  case Coq_prim_bool(b0):\n                    return (Result_impossible);\n                  case Coq_prim_number(n):\n                    return (Result_impossible);\n                  case Coq_prim_string(s2):\n                    return (Result_impossible);\n                }\n                \n              case Coq_value_object(lf):\n                return (run_call(lf, vthis, mk_nil));\n            }\n            \n        }\n        \n    }\n    \n  };\n  var function0 = function () {\n    var%value v = def(l);\n    if (spec_function_get_error_case_dec(x, v)) {\n      return (run_error(Native_error_type));\n    } else {\n      return (v);\n    }\n  };\n  switch (b) {\n    case Coq_builtin_get_default:\n      return (def(l));\n    case Coq_builtin_get_function:\n      return (function0());\n    case Coq_builtin_get_args_obj:\n      var%some lmapo = run_object_method(object_parameter_map_, l);\n      var%some lmap = lmapo;\n      var%run d = run_object_get_own_prop(lmap, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (function0());\n        case Coq_full_descriptor_some(a):\n          return (run_object_get(lmap, x));\n      }\n      \n  }\n  \n};\n\nvar run_object_get = function (l, x) {\n  var%some b = run_object_method(object_get_, l);\n  return (object_get_builtin(b, l, l, x));\n};\n\nvar run_object_get_prop = function (l, x) {\n  var%some b = run_object_method(object_get_prop_, l);\n  switch (b) {\n    case Coq_builtin_get_prop_default:\n      var%run d = run_object_get_own_prop(l, x);\n      if (full_descriptor_compare(d, Full_descriptor_undef)) {\n        var%some proto = run_object_method(object_proto_, l);\n        switch (proto) {\n          case Coq_value_prim(p):\n            switch (p) {\n              case Coq_prim_null:\n                return (Full_descriptor_undef);\n              default:\n                return (\n                  function (m) {\n                      Debug.impossible_with_heap_because(__LOC__, m);\n                      return (Result_impossible);}(\n                    "Found a non-null primitive value as a prototype in [run_object_get_prop]."));\n            }\n            \n          case Coq_value_object(lproto):\n            return (run_object_get_prop(lproto, x));\n        }\n        \n      } else {\n        return (d);\n      }\n  }\n  \n};\n\nvar object_proto_is_prototype_of = function (l0, l) {\n  var%some b = run_object_method(object_proto_, l);\n  switch (b) {\n    case Coq_value_prim(p):\n      switch (p) {\n        case Coq_prim_null:\n          return (false);\n        default:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_method] returned a primitive in [object_proto_is_prototype_of_body]."));\n      }\n      \n    case Coq_value_object(l_2):\n      if (object_loc_compare(l_2, l0)) {\n        return (true);\n      } else {\n        return (object_proto_is_prototype_of(l0, l_2));\n      }\n  }\n  \n};\n\nvar object_default_value = function (l, prefo) {\n  var%some b = run_object_method(object_default_value_, l);\n  switch (b) {\n    case Coq_builtin_default_value_default:\n      var gpref = unsome_default(Preftype_number, prefo);\n      var lpref = other_preftypes(gpref);\n      var sub0 = function (x, k) {\n        var%value vfo = run_object_get(l, x);\n        var%some co = run_callable(vfo);\n        switch (co) {\n          case Some(b0):\n            var%object lfunc = vfo;\n            var%value v = run_call(lfunc, l, mk_nil);\n            switch (v) {\n              case Coq_value_prim(w):\n                return (w);\n              case Coq_value_object(l0):\n                return (k());\n            }\n            \n          case None:\n            return (k());\n        }\n        \n      };\n      var gmeth = method_of_preftype(gpref);\n      return (\n        sub0(gmeth, function () {\n            var lmeth = method_of_preftype(lpref);\n            return (\n              sub0(lmeth, function () {\n                  return (run_error(Native_error_type));}));}));\n  }\n  \n};\n\nvar to_primitive = function (v, prefo) {\n  switch (v) {\n    case Coq_value_prim(w):\n      return (w);\n    case Coq_value_object(l):\n      var%prim r = object_default_value(l, prefo);\n      return (r);\n  }\n  \n};\n\nvar to_number = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_prim(w):\n      return (convert_prim_to_number(w));\n    case Coq_value_object(l):\n      var%prim w = to_primitive(l, Some(Preftype_number));\n      return (convert_prim_to_number(w));\n  }\n  \n};\n\nvar to_integer = function (v) {\n  var%number n = to_number(v);\n  return (convert_number_to_integer(n));\n};\n\nvar to_int32 = function (v) {\n  var%number n = to_number(v);\n  return (JsNumber.to_int32(n));\n};\n\nvar to_uint32 = function (v) {\n  var%number n = to_number(v);\n  return (JsNumber.to_uint32(n));\n};\n\nvar to_string = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_prim(w):\n      return (convert_prim_to_string(w));\n    case Coq_value_object(l):\n      var%prim w = to_primitive(l, Some(Preftype_string));\n      return (convert_prim_to_string(w));\n  }\n  \n};\n\nvar object_can_put = function (l, x) {\n  var%some b = run_object_method(object_can_put_, l);\n  switch (b) {\n    case Coq_builtin_can_put_default:\n      var%run d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          var%some vproto = run_object_method(object_proto_, l);\n          switch (vproto) {\n            case Coq_value_prim(p):\n              switch (p) {\n                case Coq_prim_null:\n                  var%some b0 = run_object_method(object_extensible_, l);\n                  return (b0);\n                default:\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "Non-null primitive get as a prototype value in [object_can_put]."));\n              }\n              \n            case Coq_value_object(lproto):\n              var%run d_2 = run_object_get_prop(lproto, x);\n              switch (d_2) {\n                case Coq_full_descriptor_undef:\n                  var%some b0 = run_object_method(object_extensible_, l);\n                  return (b0);\n                case Coq_full_descriptor_some(a):\n                  switch (a) {\n                    case Coq_attributes_data_of(ad):\n                      var%some ext = run_object_method(object_extensible_, l);\n                      return (\n                        (function () {\n                          if (ext) {\n                            return (ad.attributes_data_writable);\n                          } else {\n                            return (false);\n                          }\n                        }())\n                        );\n                    case Coq_attributes_accessor_of(aa):\n                      return (\n                        !(\n                          value_compare(aa.attributes_accessor_set,\n                            Prim_undef)));\n                  }\n                  \n              }\n              \n          }\n          \n        case Coq_full_descriptor_some(a):\n          switch (a) {\n            case Coq_attributes_data_of(ad):\n              return (ad.attributes_data_writable);\n            case Coq_attributes_accessor_of(aa):\n              return (\n                !(value_compare(aa.attributes_accessor_set, Prim_undef)));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar run_object_define_own_prop_array_loop = function (l, newLen, oldLen, newLenDesc, newWritable, throwcont, def) {\n  if ((newLen < oldLen)) {\n    var oldLen_2 = (oldLen - 1.);\n    var%string slen = to_string(oldLen_2);\n    var%bool deleteSucceeded = object_delete(l, slen, false);\n    if (!(deleteSucceeded)) {\n      var newLenDesc0 = descriptor_with_value(newLenDesc,\n                          Some((oldLen_2 + 1.)));\n      if (!(newWritable)) {\n        var newLenDesc1 = descriptor_with_writable(newLenDesc0, Some(false));\n      } else {\n        var newLenDesc1 = newLenDesc0;\n      }\n      var%bool x = def("length", newLenDesc1, false);\n      return (out_error_or_cst(throwcont, Native_error_type, false));\n    } else {\n      return (\n        run_object_define_own_prop_array_loop(l, newLen, oldLen_2,\n          newLenDesc, newWritable, throwcont, def));\n    }\n  } else {\n    if (!(newWritable)) {\n      return (\n        def("length", {\n            descriptor_value: None,\n            descriptor_writable: Some(false),\n            descriptor_get: None,\n            descriptor_set: None,\n            descriptor_enumerable: None,\n            descriptor_configurable: None}, false));\n    } else {\n      return (true);\n    }\n  }\n};\n\nvar object_define_own_prop = function (l, x, desc, throwcont) {\n  var reject = function (throwcont0) {\n    return (out_error_or_cst(throwcont0, Native_error_type, false));\n  };\n  var def = function (x0, desc0, throwcont0) {\n    var%run d = run_object_get_own_prop(l, x0);\n    var%some ext = run_object_method(object_extensible_, l);\n    switch (d) {\n      case Coq_full_descriptor_undef:\n        if (ext) {\n          if ((descriptor_is_generic_dec(desc0)\n              || descriptor_is_data_dec(desc0))) {\n            var a = attributes_data_of_descriptor(desc0);\n          } else {\n            var a = attributes_accessor_of_descriptor(desc0);\n          }\n          var%some _ = object_heap_map_properties_option(l, function (p) {\n                           return (HeapStr.write(p, x0, a));});\n          return (true);\n        } else {\n          return (reject(throwcont0));\n        }\n      case Coq_full_descriptor_some(a):\n        var object_define_own_prop_write = function (a0) {\n          var a_2 = attributes_update(a0, desc0);\n          var%some _ = object_heap_map_properties_option(l, function (p) {\n                           return (HeapStr.write(p, x0, a_2));});\n          return (true);\n        };\n        if (descriptor_contains_dec(descriptor_of_attributes(a), desc0)) {\n          return (true);\n        } else {\n          if (attributes_change_enumerable_on_non_configurable_dec(a, desc0)) {\n            return (reject(throwcont0));\n          } else {\n            if (descriptor_is_generic_dec(desc0)) {\n              return (object_define_own_prop_write(a));\n            } else {\n              if (!(\n                    bool_eq(attributes_is_data_dec(a),\n                      descriptor_is_data_dec(desc0)))) {\n                if (attributes_configurable(a)) {\n                  switch (a) {\n                    case Coq_attributes_data_of(ad):\n                      var a_2 = attributes_accessor_of_attributes_data(ad);\n                      break;\n                    case Coq_attributes_accessor_of(aa):\n                      var a_2 = attributes_data_of_attributes_accessor(aa);\n                      break;\n                  }\n                  \n                  var%some _ = object_heap_map_properties_option(l,\n                                 function (p) {\n                                   return (HeapStr.write(p, x0, a_2));});\n                  return (object_define_own_prop_write(a_2));\n                } else {\n                  return (reject(throwcont0));\n                }\n              } else {\n                if ((attributes_is_data_dec(a)\n                    && descriptor_is_data_dec(desc0))) {\n                  switch (a) {\n                    case Coq_attributes_data_of(ad):\n                      if (attributes_change_data_on_non_configurable_dec(ad,\n                            desc0)) {\n                        return (reject(throwcont0));\n                      } else {\n                        return (object_define_own_prop_write(a));\n                      }\n                    case Coq_attributes_accessor_of(a0):\n                      return (\n                        function (m) {\n                            Debug.impossible_with_heap_because(__LOC__, m);\n                            return (Result_impossible);}(\n                          "data is not accessor in [defineOwnProperty]"));\n                  }\n                  \n                } else {\n                  if ((!(attributes_is_data_dec(a))\n                      && descriptor_is_accessor_dec(desc0))) {\n                    switch (a) {\n                      case Coq_attributes_data_of(a0):\n                        return (\n                          function (m) {\n                              Debug.impossible_with_heap_because(__LOC__, m);\n                              return (Result_impossible);}(\n                            "accessor is not data in [defineOwnProperty]"));\n                      case Coq_attributes_accessor_of(aa):\n                        if (attributes_change_accessor_on_non_configurable_dec(\n                              aa, desc0)) {\n                          return (reject(throwcont0));\n                        } else {\n                          return (object_define_own_prop_write(a));\n                        }\n                    }\n                    \n                  } else {\n                    return (\n                      function (m) {\n                          Debug.impossible_with_heap_because(__LOC__, m);\n                          return (Result_impossible);}(\n                        "cases are mutually exclusives in [defineOwnProperty]"));\n                  }\n                }\n              }\n            }\n          }\n        }\n    }\n    \n  };\n  var%some b = run_object_method(object_define_own_prop_, l);\n  switch (b) {\n    case Coq_builtin_define_own_prop_default:\n      return (def(x, desc, throwcont));\n    case Coq_builtin_define_own_prop_array:\n      var%run d = run_object_get_own_prop(l, "length");\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "Array length property descriptor cannot be undefined."));\n        case Coq_full_descriptor_some(attr):\n          switch (attr) {\n            case Coq_attributes_data_of(a):\n              var oldLen = a.attributes_data_value;\n              switch (oldLen) {\n                case Coq_value_prim(w):\n                  var oldLen0 = JsNumber.to_uint32(convert_prim_to_number(w));\n                  var descValueOpt = desc.descriptor_value;\n                  if (string_eq(x, "length")) {\n                    switch (descValueOpt) {\n                      case Some(descValue):\n                        var%run newLen = to_uint32(descValue);\n                        var%number newLenN = to_number(descValue);\n                        if (!((newLen === newLenN))) {\n                          return (run_error(Native_error_range));\n                        } else {\n                          var newLenDesc = descriptor_with_value(desc,\n                                             Some(newLen));\n                          if (le_int_decidable(oldLen0, newLen)) {\n                            return (def("length", newLenDesc, throwcont));\n                          } else {\n                            if (!(a.attributes_data_writable)) {\n                              return (reject(throwcont));\n                            } else {\n                              switch (newLenDesc.descriptor_writable) {\n                                case Some(b0):\n                                  if (b0) {\n                                    var newWritable = true;\n                                  } else {\n                                    var newWritable = false;\n                                  }\n                                  break;\n                                case None:\n                                  var newWritable = true;\n                                  break;\n                              }\n                              \n                              if (!(newWritable)) {\n                                var newLenDesc0 = descriptor_with_writable(\n                                                    newLenDesc, Some(true));\n                              } else {\n                                var newLenDesc0 = newLenDesc;\n                              }\n                              var%bool succ = def("length", newLenDesc0,\n                                                throwcont);\n                              if (!(succ)) {\n                                return (false);\n                              } else {\n                                return (\n                                  run_object_define_own_prop_array_loop(l,\n                                    newLen, oldLen0, newLenDesc0,\n                                    newWritable, throwcont, def));\n                              }\n                            }\n                          }\n                        }\n                      case None:\n                        return (def("length", desc, throwcont));\n                    }\n                    \n                  } else {\n                    var%run ilen = to_uint32(x);\n                    var%string slen = to_string(ilen);\n                    if ((string_eq(x, slen) && !((ilen == 4294967295.)))) {\n                      var%run index = to_uint32(x);\n                      if ((le_int_decidable(oldLen0, index)\n                          && !(a.attributes_data_writable))) {\n                        return (reject(throwcont));\n                      } else {\n                        var%bool b0 = def(x, desc, false);\n                        if (!(b0)) {\n                          return (reject(throwcont));\n                        } else {\n                          if (le_int_decidable(oldLen0, index)) {\n                            var a0 = descriptor_with_value(\n                                       descriptor_of_attributes(a),\n                                       Some((index + 1.)));\n                            return (def("length", a0, false));\n                          } else {\n                            return (true);\n                          }\n                        }\n                      }\n                    } else {\n                      return (def(x, desc, throwcont));\n                    }\n                  }\n                case Coq_value_object(l0):\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "Spec asserts length of array is number."));\n              }\n              \n            case Coq_attributes_accessor_of(a):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Array length property descriptor cannot be accessor."));\n          }\n          \n      }\n      \n    case Coq_builtin_define_own_prop_args_obj:\n      var%some lmapo = run_object_method(object_parameter_map_, l);\n      var%some lmap = lmapo;\n      var%run d = run_object_get_own_prop(lmap, x);\n      var%bool b0 = def(x, desc, false);\n      if (b0) {\n        var follow = function () {\n          return (true);\n        };\n        switch (d) {\n          case Coq_full_descriptor_undef:\n            return (follow());\n          case Coq_full_descriptor_some(a):\n            if (descriptor_is_accessor_dec(desc)) {\n              var%bool x0 = object_delete(lmap, x, false);\n              return (follow());\n            } else {\n              var follow0 = function () {\n                if (option_compare(bool_eq, desc.descriptor_writable,\n                      Some(false))) {\n                  var%bool x0 = object_delete(lmap, x, false);\n                  return (follow());\n                } else {\n                  return (follow());\n                }\n              };\n              switch (desc.descriptor_value) {\n                case Some(v):\n                  var%void _ = object_put(lmap, x, v, throwcont);\n                  return (follow0());\n                case None:\n                  return (follow0());\n              }\n              \n            }\n        }\n        \n      } else {\n        return (reject(throwcont));\n      }\n  }\n  \n};\n\nvar run_to_descriptor = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_prim(p):\n      return (throw_result(run_error(Native_error_type)));\n    case Coq_value_object(l):\n      var sub0 = function (desc, name, conv, k) {\n        var%bool has = object_has_prop(l, name);\n        if (!(has)) {\n          return (k(desc));\n        } else {\n          var%value v0 = run_object_get(l, name);\n          var%run r = conv(v0, desc);\n          return (k(r));\n        }\n      };\n      return (\n        sub0(descriptor_intro_empty, "enumerable", function (v1, desc) {\n            var b = convert_value_to_boolean(v1);\n            return (descriptor_with_enumerable(desc, Some(b)));},\n          function (desc) {\n            return (\n              sub0(desc, "configurable", function (v2, desc0) {\n                  var b = convert_value_to_boolean(v2);\n                  return (descriptor_with_configurable(desc0, Some(b)));},\n                function (desc0) {\n                  return (\n                    sub0(desc0, "value", function (v3, desc1) {\n                        return (descriptor_with_value(desc1, Some(v3)));},\n                      function (desc1) {\n                        return (\n                          sub0(desc1, "writable", function (v4, desc2) {\n                              var b = convert_value_to_boolean(v4);\n                              return (\n                                descriptor_with_writable(desc2, Some(b)));},\n                            function (desc2) {\n                              return (\n                                sub0(desc2, "get", function (v5, desc3) {\n                                    if ((!(is_callable_dec(v5))\n                                        && !(value_compare(v5, Prim_undef)))) {\n                                      return (\n                                        throw_result(\n                                          run_error(Native_error_type)));\n                                    } else {\n                                      return (\n                                        descriptor_with_get(desc3, Some(v5)));\n                                    }}, function (desc3) {\n                                    return (\n                                      sub0(desc3, "set",\n                                        function (v6, desc4) {\n                                          if ((!(is_callable_dec(v6))\n                                              && !(\n                                                   value_compare(v6,\n                                                     Prim_undef)))) {\n                                            return (\n                                              throw_result(\n                                                run_error(Native_error_type)));\n                                          } else {\n                                            return (\n                                              descriptor_with_set(desc4,\n                                                Some(v6)));\n                                          }}, function (desc4) {\n                                          if (((!(\n                                                  option_compare(\n                                                    value_compare,\n                                                    desc4.descriptor_get,\n                                                    None))\n                                               || !(\n                                                    option_compare(\n                                                      value_compare,\n                                                      desc4.descriptor_set,\n                                                      None)))\n                                              && (!(\n                                                    option_compare(\n                                                      value_compare,\n                                                      desc4.descriptor_value,\n                                                      None))\n                                                 || !(\n                                                      option_compare(bool_eq,\n                                                        desc4.descriptor_writable,\n                                                        None))))) {\n                                            return (\n                                              throw_result(\n                                                run_error(Native_error_type)));\n                                          } else {\n                                            return (desc4);\n                                          }}));}));}));}));}));}));\n  }\n  \n};\n\nvar prim_new_object = function (_foo_) {\n  switch (_foo_) {\n    case Coq_prim_bool(b):\n      return (\n        (function () {\n          var o1 = object_new(Prealloc_bool_proto, "Boolean");\n          var o = object_with_primitive_value(o1, b);\n          var (l, s1) = object_alloc(o);\n          return (l);\n        }())\n        );\n    case Coq_prim_number(n):\n      return (\n        (function () {\n          var o1 = object_new(Prealloc_number_proto, "Number");\n          var o = object_with_primitive_value(o1, n);\n          var (l, s1) = object_alloc(o);\n          return (l);\n        }())\n        );\n    case Coq_prim_string(s0):\n      var o2 = object_new(Prealloc_string_proto, "String");\n      var o1 = object_with_get_own_property(o2, Builtin_get_own_prop_string);\n      var o = object_with_primitive_value(o1, s0);\n      var (l, s1) = object_alloc(o);\n      var%some _ = object_heap_map_properties_option(l, function (p) {\n                       return (\n                         HeapStr.write(p, "length",\n                           attributes_data_intro_constant(strlength(s0))));});\n      return (l);\n    default:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[prim_new_object] received an null or undef."));\n  }\n  \n};\n\nvar to_object = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_prim(w):\n      switch (w) {\n        case Coq_prim_undef:\n          return (run_error(Native_error_type));\n        case Coq_prim_null:\n          return (run_error(Native_error_type));\n        case Coq_prim_bool(b):\n          return (prim_new_object(w));\n        case Coq_prim_number(n):\n          return (prim_new_object(w));\n        case Coq_prim_string(s0):\n          return (prim_new_object(w));\n      }\n      \n    case Coq_value_object(l):\n      return (l);\n  }\n  \n};\n\nvar run_object_prim_value = function (l) {\n  var%some ov = run_object_method(object_prim_value_, l);\n  var%some v = ov;\n  return (v);\n};\n\nvar prim_value_get = function (v, x) {\n  var%object l = to_object(v);\n  return (object_get_builtin(Builtin_get_default, v, l, x));\n};\n\nvar env_record_has_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      return (HeapStr.indom_dec(ed, x));\n    case Coq_env_record_object(l0, pt):\n      return (object_has_prop(l0, x));\n  }\n  \n};\n\nvar lexical_env_get_identifier_ref = function (x, x0, str) {\n  switch (x) {\n    case []:\n      return (ref_create_value(Prim_undef, x0, str));\n    case (l::x_2):\n      var%bool has = env_record_has_binding(l, x0);\n      if (has) {\n        return (ref_create_env_loc(l, x0, str));\n      } else {\n        return (lexical_env_get_identifier_ref(x_2, x0, str));\n      }\n  }\n  \n};\n\nvar object_delete_default = function (l, x, str) {\n  var%run d = run_object_get_own_prop(l, x);\n  switch (d) {\n    case Coq_full_descriptor_undef:\n      return (true);\n    case Coq_full_descriptor_some(a):\n      if (attributes_configurable(a)) {\n        var%some _ = object_heap_map_properties_option(l, function (p) {\n                         return (HeapStr.rem(p, x));});\n        return (true);\n      } else {\n        return (out_error_or_cst(str, Native_error_type, false));\n      }\n  }\n  \n};\n\nvar object_delete = function (l, x, str) {\n  var%some b = run_object_method(object_delete_, l);\n  switch (b) {\n    case Coq_builtin_delete_default:\n      return (object_delete_default(l, x, str));\n    case Coq_builtin_delete_args_obj:\n      var%some mo = run_object_method(object_parameter_map_, l);\n      var%some m = mo;\n      var%run d = run_object_get_own_prop(m, x);\n      var%bool b0 = object_delete_default(l, x, str);\n      if (b0) {\n        switch (d) {\n          case Coq_full_descriptor_undef:\n            return (b0);\n          case Coq_full_descriptor_some(a):\n            var%bool b_2 = object_delete(m, x, false);\n            return (b0);\n        }\n        \n      } else {\n        return (b0);\n      }\n  }\n  \n};\n\nvar env_record_delete_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      switch (HeapStr.read_option(ed, x)) {\n        case Some(p):\n          var (mu, v) = p;\n          switch (mu) {\n            case Coq_mutability_uninitialized_immutable:\n              return (false);\n            case Coq_mutability_immutable:\n              return (false);\n            case Coq_mutability_nondeletable:\n              return (false);\n            case Coq_mutability_deletable:\n              var s_2 = env_record_write(l, decl_env_record_rem(ed, x));\n              return (true);\n          }\n          \n        case None:\n          return (true);\n      }\n      \n    case Coq_env_record_object(l0, pt):\n      return (object_delete(l0, x, throw_false));\n  }\n  \n};\n\nvar env_record_implicit_this_value = function (l) {\n  return (\n    ifx_some_or_default(env_record_binds_option(l), None, function (e) {\n        return (\n          Some((function () {\n              switch (e) {\n                case Coq_env_record_decl(ed):\n                  return (Prim_undef);\n                case Coq_env_record_object(l0, provide_this):\n                  if (provide_this) {\n                    return (l0);\n                  } else {\n                    return (Prim_undef);\n                  }\n              }\n              }())));}));\n};\n\nvar identifier_resolution = function (x) {\n  var x0 = c.execution_ctx_lexical_env;\n  var str = c.execution_ctx_strict;\n  return (lexical_env_get_identifier_ref(x0, x, str));\n};\n\nvar env_record_get_binding_value = function (l, x, str) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      var%some rm = HeapStr.read_option(ed, x);\n      var (mu, v) = rm;\n      if (mutability_compare(mu, Mutability_uninitialized_immutable)) {\n        return (out_error_or_cst(str, Native_error_ref, Prim_undef));\n      } else {\n        return (v);\n      }\n    case Coq_env_record_object(l0, pt):\n      var%bool has = object_has_prop(l0, x);\n      if (has) {\n        return (run_object_get(l0, x));\n      } else {\n        return (out_error_or_cst(str, Native_error_ref, Prim_undef));\n      }\n  }\n  \n};\n\nvar ref_get_value = function (_foo_) {\n  switch (_foo_) {\n    case Coq_resvalue_empty:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[ref_get_value] received an empty result."));\n    case Coq_resvalue_value(v):\n      return (v);\n    case Coq_resvalue_ref(r):\n      var for_base_or_object = function (tt) {\n        switch (r.ref_base) {\n          case Coq_ref_base_type_value(v):\n            if (ref_kind_comparable(ref_kind_of(r), Ref_kind_primitive_base)) {\n              var%value v = prim_value_get(v, r.ref_name);\n              return (v);\n            } else {\n              switch (v) {\n                case Coq_value_prim(p):\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "[ref_get_value] received a primitive value whose kind is not primitive."));\n                case Coq_value_object(l):\n                  var%value v = run_object_get(l, r.ref_name);\n                  return (v);\n              }\n              \n            }\n          case Coq_ref_base_type_env_loc(l):\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "[ref_get_value] received a reference to a value whose base type is an environnment record."));\n        }\n        \n      };\n      switch (ref_kind_of(r)) {\n        case Coq_ref_kind_null:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[ref_get_value] received a reference whose base is [null]."));\n        case Coq_ref_kind_undef:\n          return (throw_result(run_error(Native_error_ref)));\n        case Coq_ref_kind_primitive_base:\n          return (for_base_or_object({}));\n        case Coq_ref_kind_object:\n          return (for_base_or_object({}));\n        case Coq_ref_kind_env_record:\n          switch (r.ref_base) {\n            case Coq_ref_base_type_value(v):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "[ref_get_value] received a reference to an environnment record whose base type is a value."));\n            case Coq_ref_base_type_env_loc(l):\n              var%value v = env_record_get_binding_value(l, r.ref_name,\n                              r.ref_strict);\n              return (v);\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar run_expr_get_value = function (e) {\n  var%success rv = run_expr(e);\n  return (ref_get_value(rv));\n};\n\nvar object_put_complete = function (b, vthis, l, x, v, str) {\n  switch (b) {\n    case Coq_builtin_put_default:\n      var%bool b0 = object_can_put(l, x);\n      if (b0) {\n        var%run d = run_object_get_own_prop(l, x);\n        var follow = function (x0) {\n          var%run d_2 = run_object_get_prop(l, x);\n          var follow_2 = function (x1) {\n            switch (vthis) {\n              case Coq_value_prim(wthis):\n                return (out_error_or_void(str, Native_error_type));\n              case Coq_value_object(lthis):\n                var desc = descriptor_intro_data(v, true, true, true);\n                var%success rv = object_define_own_prop(l, x, desc, str);\n                return (res_void());\n            }\n            \n          };\n          switch (d_2) {\n            case Coq_full_descriptor_undef:\n              return (follow_2({}));\n            case Coq_full_descriptor_some(a):\n              switch (a) {\n                case Coq_attributes_data_of(a0):\n                  return (follow_2({}));\n                case Coq_attributes_accessor_of(aa_2):\n                  switch (aa_2.attributes_accessor_set) {\n                    case Coq_value_prim(p):\n                      return (\n                        function (m) {\n                            Debug.impossible_with_heap_because(__LOC__, m);\n                            return (Result_impossible);}(\n                          "[object_put_complete] found a primitive in an `set\' accessor."));\n                    case Coq_value_object(lfsetter):\n                      var%success rv = run_call(lfsetter, vthis,\n                                         mk_cons(v, mk_nil));\n                      return (res_void());\n                  }\n                  \n              }\n              \n          }\n          \n        };\n        switch (d) {\n          case Coq_full_descriptor_undef:\n            return (follow({}));\n          case Coq_full_descriptor_some(a):\n            switch (a) {\n              case Coq_attributes_data_of(ad):\n                switch (vthis) {\n                  case Coq_value_prim(wthis):\n                    return (out_error_or_void(str, Native_error_type));\n                  case Coq_value_object(lthis):\n                    var desc = {\n                      descriptor_value: Some(v),\n                      descriptor_writable: None,\n                      descriptor_get: None,\n                      descriptor_set: None,\n                      descriptor_enumerable: None,\n                      descriptor_configurable: None\n                    };\n                    var%success rv = object_define_own_prop(l, x, desc, str);\n                    return (res_void());\n                }\n                \n              case Coq_attributes_accessor_of(a0):\n                return (follow({}));\n            }\n            \n        }\n        \n      } else {\n        return (out_error_or_void(str, Native_error_type));\n      }\n  }\n  \n};\n\nvar object_put = function (l, x, v, str) {\n  var%some b = run_object_method(object_put_, l);\n  return (object_put_complete(b, l, l, x, v, str));\n};\n\nvar env_record_set_mutable_binding = function (l, x, v, str) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      var%some rm = HeapStr.read_option(ed, x);\n      var (mu, v_old) = rm;\n      if (!(mutability_compare(mu, Mutability_immutable))) {\n        return (res_void(env_record_write_decl_env(l, x, mu, v)));\n      } else {\n        return (out_error_or_void(str, Native_error_type));\n      }\n    case Coq_env_record_object(l0, pt):\n      return (object_put(l0, x, v, str));\n  }\n  \n};\n\nvar prim_value_put = function (w, x, v, str) {\n  var%object l = to_object(w);\n  return (object_put_complete(Builtin_put_default, w, l, x, v, str));\n};\n\nvar ref_put_value = function (rv, v) {\n  switch (rv) {\n    case Coq_resvalue_empty:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[ref_put_value] received an empty result."));\n    case Coq_resvalue_value(v0):\n      return (run_error(Native_error_ref));\n    case Coq_resvalue_ref(r):\n      if (ref_kind_comparable(ref_kind_of(r), Ref_kind_undef)) {\n        if (r.ref_strict) {\n          return (run_error(Native_error_ref));\n        } else {\n          return (object_put(Prealloc_global, r.ref_name, v, throw_false));\n        }\n      } else {\n        if ((ref_kind_comparable(ref_kind_of(r), Ref_kind_primitive_base)\n            || (ref_kind_comparable(ref_kind_of(r), Ref_kind_null)\n               || ref_kind_comparable(ref_kind_of(r), Ref_kind_object)))) {\n          switch (r.ref_base) {\n            case Coq_ref_base_type_value(v_2):\n              if (ref_kind_comparable(ref_kind_of(r),\n                    Ref_kind_primitive_base)) {\n                switch (v_2) {\n                  case Coq_value_prim(w):\n                    return (prim_value_put(w, r.ref_name, v, r.ref_strict));\n                  case Coq_value_object(o):\n                    return (\n                      function (m) {\n                          Debug.impossible_with_heap_because(__LOC__, m);\n                          return (Result_impossible);}(\n                        "[ref_put_value] impossible case"));\n                }\n                \n              } else {\n                switch (v_2) {\n                  case Coq_value_prim(p):\n                    return (\n                      function (m) {\n                          Debug.impossible_with_heap_because(__LOC__, m);\n                          return (Result_impossible);}(\n                        "[ref_put_value] impossible case"));\n                  case Coq_value_object(l):\n                    return (object_put(l, r.ref_name, v, r.ref_strict));\n                }\n                \n              }\n            case Coq_ref_base_type_env_loc(l):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "[ref_put_value] contradicts ref_is_property"));\n          }\n          \n        } else {\n          switch (r.ref_base) {\n            case Coq_ref_base_type_value(v0):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "[ref_put_value] impossible spec"));\n            case Coq_ref_base_type_env_loc(l):\n              return (\n                env_record_set_mutable_binding(l, r.ref_name, v,\n                  r.ref_strict));\n          }\n          \n        }\n      }\n  }\n  \n};\n\nvar env_record_create_mutable_binding = function (l, x, deletable_opt) {\n  var deletable = unsome_default(false, deletable_opt);\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      if (HeapStr.indom_dec(ed, x)) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared environnment record in [env_record_create_mutable_binding]."));\n      } else {\n        var s_2 = env_record_write_decl_env(l, x,\n                    mutability_of_bool(deletable), Prim_undef);\n        return (res_void());\n      }\n    case Coq_env_record_object(l0, pt):\n      var%bool has = object_has_prop(l0, x);\n      if (has) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared binding in [env_record_create_mutable_binding]."));\n      } else {\n        var a = {\n          attributes_data_value: Prim_undef,\n          attributes_data_writable: true,\n          attributes_data_enumerable: true,\n          attributes_data_configurable: deletable\n        };\n        var%success rv = object_define_own_prop(l0, x,\n                           descriptor_of_attributes(a), throw_true);\n        return (res_void());\n      }\n  }\n  \n};\n\nvar env_record_create_set_mutable_binding = function (l, x, deletable_opt, v, str) {\n  var%void _ = env_record_create_mutable_binding(l, x, deletable_opt);\n  return (env_record_set_mutable_binding(l, x, v, str));\n};\n\nvar env_record_create_immutable_binding = function (l, x) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      if (HeapStr.indom_dec(ed, x)) {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Already declared environnment record in [env_record_create_immutable_binding]."));\n      } else {\n        return (\n          res_void(\n            env_record_write_decl_env(l, x,\n              Mutability_uninitialized_immutable, Prim_undef)));\n      }\n    case Coq_env_record_object(o, p):\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[env_record_create_immutable_binding] received an environnment record object."));\n  }\n  \n};\n\nvar env_record_initialize_immutable_binding = function (l, x, v) {\n  var%some e = env_record_binds_option(l);\n  switch (e) {\n    case Coq_env_record_decl(ed):\n      var%some evs = decl_env_record_option(ed, x);\n      if (prod_compare(mutability_compare, value_compare, evs,\n            [Mutability_uninitialized_immutable, Prim_undef])) {\n        var s_2 = env_record_write_decl_env(l, x, Mutability_immutable, v);\n        return (res_void());\n      } else {\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Non suitable binding in [env_record_initialize_immutable_binding]."));\n      }\n    case Coq_env_record_object(o, p):\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "[env_record_initialize_immutable_binding] received an environnment record object."));\n  }\n  \n};\n\nvar call_object_new = function (v) {\n  switch (type_of(v)) {\n    case Coq_type_undef:\n      return (\n        (function () {\n          var o = object_new(Prealloc_object_proto, "Object");\n          var p = object_alloc(o);\n          var (l, s_2) = p;\n          return (l);\n        }())\n        );\n    case Coq_type_null:\n      return (\n        (function () {\n          var o = object_new(Prealloc_object_proto, "Object");\n          var p = object_alloc(o);\n          var (l, s_2) = p;\n          return (l);\n        }())\n        );\n    case Coq_type_bool:\n      return (to_object(v));\n    case Coq_type_number:\n      return (to_object(v));\n    case Coq_type_string:\n      return (to_object(v));\n    case Coq_type_object:\n      return (v);\n  }\n  \n};\n\nvar array_args_map_loop = function (l, args, ind) {\n  switch (args) {\n    case []:\n      return (res_void());\n    case (h::rest):\n      var%some _ = object_heap_map_properties_option(l, function (p) {\n                       return (\n                         HeapStr.write(p, JsNumber.to_string(ind),\n                           attributes_data_intro_all_true(h)));});\n      return (array_args_map_loop(l, rest, (ind + 1.)));\n  }\n  \n};\n\nvar string_of_prealloc = function (_foo_) {\n  switch (_foo_) {\n    case Coq_prealloc_global:\n      return ("global");\n    case Coq_prealloc_global_eval:\n      return ("global_eval");\n    case Coq_prealloc_global_parse_int:\n      return ("global_parse_int");\n    case Coq_prealloc_global_parse_float:\n      return ("global_parse_float");\n    case Coq_prealloc_global_is_finite:\n      return ("global_is_finite");\n    case Coq_prealloc_global_is_nan:\n      return ("global_is_nan");\n    case Coq_prealloc_global_decode_uri:\n      return ("global_decode_uri");\n    case Coq_prealloc_global_decode_uri_component:\n      return ("global_decode_uri_component");\n    case Coq_prealloc_global_encode_uri:\n      return ("global_encode_uri");\n    case Coq_prealloc_global_encode_uri_component:\n      return ("global_encode_uri_component");\n    case Coq_prealloc_object:\n      return ("object");\n    case Coq_prealloc_object_get_proto_of:\n      return ("object_get_proto_of");\n    case Coq_prealloc_object_get_own_prop_descriptor:\n      return ("object_get_own_prop_descriptor");\n    case Coq_prealloc_object_get_own_prop_name:\n      return ("object_get_own_prop_name");\n    case Coq_prealloc_object_create:\n      return ("object_create");\n    case Coq_prealloc_object_define_prop:\n      return ("object_define_prop");\n    case Coq_prealloc_object_define_props:\n      return ("object_define_props");\n    case Coq_prealloc_object_seal:\n      return ("object_seal");\n    case Coq_prealloc_object_freeze:\n      return ("object_freeze");\n    case Coq_prealloc_object_prevent_extensions:\n      return ("object_prevent_extensions");\n    case Coq_prealloc_object_is_sealed:\n      return ("object_is_sealed");\n    case Coq_prealloc_object_is_frozen:\n      return ("object_is_frozen");\n    case Coq_prealloc_object_is_extensible:\n      return ("object_is_extensible");\n    case Coq_prealloc_object_keys:\n      return ("object_keys");\n    case Coq_prealloc_object_keys_call:\n      return ("object_keys_call");\n    case Coq_prealloc_object_proto:\n      return ("object_proto_");\n    case Coq_prealloc_object_proto_to_string:\n      return ("object_proto_to_string");\n    case Coq_prealloc_object_proto_value_of:\n      return ("object_proto_value_of");\n    case Coq_prealloc_object_proto_has_own_prop:\n      return ("object_proto_has_own_prop");\n    case Coq_prealloc_object_proto_is_prototype_of:\n      return ("object_proto_is_prototype_of");\n    case Coq_prealloc_object_proto_prop_is_enumerable:\n      return ("object_proto_prop_is_enumerable");\n    case Coq_prealloc_function:\n      return ("function");\n    case Coq_prealloc_function_proto:\n      return ("function_proto");\n    case Coq_prealloc_function_proto_to_string:\n      return ("function_proto_to_string");\n    case Coq_prealloc_function_proto_apply:\n      return ("function_proto_apply");\n    case Coq_prealloc_function_proto_call:\n      return ("function_proto_call");\n    case Coq_prealloc_function_proto_bind:\n      return ("function_proto_bind");\n    case Coq_prealloc_bool:\n      return ("bool");\n    case Coq_prealloc_bool_proto:\n      return ("bool_proto");\n    case Coq_prealloc_bool_proto_to_string:\n      return ("bool_proto_to_string");\n    case Coq_prealloc_bool_proto_value_of:\n      return ("bool_proto_value_of");\n    case Coq_prealloc_number:\n      return ("number");\n    case Coq_prealloc_number_proto:\n      return ("number_proto");\n    case Coq_prealloc_number_proto_to_string:\n      return ("number_proto_to_string");\n    case Coq_prealloc_number_proto_value_of:\n      return ("number_proto_value_of");\n    case Coq_prealloc_number_proto_to_fixed:\n      return ("number_proto_to_fixed");\n    case Coq_prealloc_number_proto_to_exponential:\n      return ("number_proto_to_exponential");\n    case Coq_prealloc_number_proto_to_precision:\n      return ("number_proto_to_precision");\n    case Coq_prealloc_array:\n      return ("array");\n    case Coq_prealloc_array_is_array:\n      return ("array_is_array");\n    case Coq_prealloc_array_proto:\n      return ("array_proto");\n    case Coq_prealloc_array_proto_to_string:\n      return ("array_proto_to_string");\n    case Coq_prealloc_array_proto_join:\n      return ("array_proto_join");\n    case Coq_prealloc_array_proto_pop:\n      return ("array_proto_pop");\n    case Coq_prealloc_array_proto_push:\n      return ("array_proto_push");\n    case Coq_prealloc_string:\n      return ("string");\n    case Coq_prealloc_string_proto:\n      return ("string_proto");\n    case Coq_prealloc_string_proto_to_string:\n      return ("string_proto_to_string");\n    case Coq_prealloc_string_proto_value_of:\n      return ("string_proto_value_of");\n    case Coq_prealloc_string_proto_char_at:\n      return ("string_proto_char_at");\n    case Coq_prealloc_string_proto_char_code_at:\n      return ("string_proto_char_code_at");\n    case Coq_prealloc_math:\n      return ("math");\n    case Coq_prealloc_mathop(m):\n      return ("mathop");\n    case Coq_prealloc_date:\n      return ("date");\n    case Coq_prealloc_regexp:\n      return ("regexp");\n    case Coq_prealloc_error:\n      return ("error");\n    case Coq_prealloc_error_proto:\n      return ("error_proto");\n    case Coq_prealloc_native_error(n):\n      return ("native_error");\n    case Coq_prealloc_native_error_proto(n):\n      return ("native_error_proto");\n    case Coq_prealloc_error_proto_to_string:\n      return ("error_proto_to_string");\n    case Coq_prealloc_throw_type_error:\n      return ("throw_type_error");\n    case Coq_prealloc_json:\n      return ("json");\n  }\n  \n};\n\nvar run_construct_prealloc = function (b, args) {\n  switch (b) {\n    case Coq_prealloc_object:\n      var v = get_arg(0, args);\n      return (call_object_new(v));\n    case Coq_prealloc_bool:\n      return (\n        (function () {\n          var v = get_arg(0, args);\n          var b0 = convert_value_to_boolean(v);\n          var o1 = object_new(Prealloc_bool_proto, "Boolean");\n          var o = object_with_primitive_value(o1, b0);\n          var p = object_alloc(o);\n          var (l, s_2) = p;\n          return (l);\n        }())\n        );\n    case Coq_prealloc_number:\n      var follow = function (v) {\n        var o1 = object_new(Prealloc_number_proto, "Number");\n        var o = object_with_primitive_value(o1, v);\n        var (l, s1) = object_alloc(o);\n        return (l);\n      };\n      if (list_eq_nil_decidable(args)) {\n        return (follow(JsNumber.zero));\n      } else {\n        var v = get_arg(0, args);\n        var%number x0 = to_number(v);\n        return (follow(x0));\n      }\n    case Coq_prealloc_array:\n      var o_2 = object_new(Prealloc_array_proto, "Array");\n      var o = object_for_array(o_2, Builtin_define_own_prop_array);\n      var p = object_alloc(o);\n      var (l, s_2) = p;\n      var follow = function (length0) {\n        var%some _ = object_heap_map_properties_option(l, function (p0) {\n                         return (\n                           HeapStr.write(p0, "length", {\n                               attributes_data_value: length0,\n                               attributes_data_writable: true,\n                               attributes_data_enumerable: false,\n                               attributes_data_configurable: false}));});\n        return (l);\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 1)) {\n        var v = get_arg(0, args);\n        switch (v) {\n          case Coq_value_prim(p0):\n            switch (p0) {\n              case Coq_prim_undef:\n                var%some _ = object_heap_map_properties_option(l,\n                               function (p1) {\n                                 return (\n                                   HeapStr.write(p1, "0",\n                                     attributes_data_intro_all_true(v)));});\n                return (follow(1.0));\n              case Coq_prim_null:\n                var%some _ = object_heap_map_properties_option(l,\n                               function (p1) {\n                                 return (\n                                   HeapStr.write(p1, "0",\n                                     attributes_data_intro_all_true(v)));});\n                return (follow(1.0));\n              case Coq_prim_bool(b0):\n                var%some _ = object_heap_map_properties_option(l,\n                               function (p1) {\n                                 return (\n                                   HeapStr.write(p1, "0",\n                                     attributes_data_intro_all_true(v)));});\n                return (follow(1.0));\n              case Coq_prim_number(vlen):\n                var%run ilen = to_uint32(vlen);\n                if ((ilen === vlen)) {\n                  return (follow(ilen));\n                } else {\n                  return (run_error(Native_error_range));\n                }\n              case Coq_prim_string(s0):\n                var%some _ = object_heap_map_properties_option(l,\n                               function (p1) {\n                                 return (\n                                   HeapStr.write(p1, "0",\n                                     attributes_data_intro_all_true(v)));});\n                return (follow(1.0));\n            }\n            \n          case Coq_value_object(o0):\n            var%some _ = object_heap_map_properties_option(l, function (p0) {\n                             return (\n                               HeapStr.write(p0, "0",\n                                 attributes_data_intro_all_true(v)));});\n            return (follow(1.0));\n        }\n        \n      } else {\n        var%some _ = object_heap_map_properties_option(l, function (p0) {\n                         return (\n                           HeapStr.write(p0, "length", {\n                               attributes_data_value: arg_len,\n                               attributes_data_writable: true,\n                               attributes_data_enumerable: false,\n                               attributes_data_configurable: false}));});\n        var%void _ = array_args_map_loop(l, args, 0.);\n        return (l);\n      }\n    case Coq_prealloc_string:\n      var o2 = object_new(Prealloc_string_proto, "String");\n      var o1 = object_with_get_own_property(o2, Builtin_get_own_prop_string);\n      var follow = function (s1) {\n        var o = object_with_primitive_value(o1, s1);\n        var (l, s2) = object_alloc(o);\n        var lenDesc = attributes_data_intro_constant(strlength(s1));\n        var%some _ = object_heap_map_properties_option(l, function (p) {\n                         return (HeapStr.write(p, "length", lenDesc));});\n        return (l);\n      };\n      var arg_len = LibList.length(args);\n      if (nat_eq(arg_len, 0)) {\n        return (follow(""));\n      } else {\n        var arg = get_arg(0, args);\n        var%string s1 = to_string(arg);\n        return (follow(s1));\n      }\n    case Coq_prealloc_error:\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_error_proto, v));\n    case Coq_prealloc_native_error(ne):\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_native_error_proto(ne), v));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}(\n          strappend("Construct prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented."))));\n  }\n  \n};\n\nvar run_construct_default = function (l, args) {\n  var%value v1 = run_object_get(l, "prototype");\n  if (type_compare(type_of(v1), Type_object)) {\n    var vproto = v1;\n  } else {\n    var vproto = Prealloc_object_proto;\n  }\n  var o = object_new(vproto, "Object");\n  var p = object_alloc(o);\n  var (l_2, s2) = p;\n  var%value v2 = run_call(l, l_2, args);\n  if (type_compare(type_of(v2), Type_object)) {\n    var vr = v2;\n  } else {\n    var vr = l_2;\n  }\n  return (vr);\n};\n\nvar run_construct = function (co, l, args) {\n  switch (co) {\n    case Coq_construct_default:\n      return (run_construct_default(l, args));\n    case Coq_construct_after_bind:\n      var%some otrg = run_object_method(object_target_function_, l);\n      var%some target = otrg;\n      var%some oco = run_object_method(object_construct_, target);\n      switch (oco) {\n        case Some(co0):\n          var%some oarg = run_object_method(object_bound_args_, l);\n          var%some boundArgs = oarg;\n          var arguments_ = LibList.append(boundArgs, args);\n          return (run_construct(co0, target, arguments_));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n    case Coq_construct_prealloc(b):\n      return (run_construct_prealloc(b, args));\n  }\n  \n};\n\nvar run_call_default = function (lf) {\n  var def = Prim_undef;\n  var%some oC = run_object_method(object_code_, lf);\n  switch (oC) {\n    case Some(bd):\n      if (list_eq_nil_decidable(prog_elements(funcbody_prog(bd)))) {\n        return (def);\n      } else {\n        return (\n          ifx_success_or_return(run_prog(funcbody_prog(bd)), function () {\n              return (Prim_undef);}, function (rv) { return (rv);}));\n      }\n    case None:\n      return (def);\n  }\n  \n};\n\nvar creating_function_object_proto = function (l) {\n  var%object lproto = run_construct_prealloc(Prealloc_object, mk_nil);\n  var a1 = {\n    attributes_data_value: l,\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  var%bool b = object_define_own_prop(lproto, "constructor",\n                 descriptor_of_attributes(a1), false);\n  var a2 = {\n    attributes_data_value: lproto,\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  return (\n    object_define_own_prop(l, "prototype", descriptor_of_attributes(a2),\n      false));\n};\n\nvar creating_function_object = function (names, bd, x, str) {\n  var o = object_new(Prealloc_function_proto, "Function");\n  var o1 = object_with_get(o, Builtin_get_function);\n  var o2 = object_with_invokation(o1, Some(Construct_default),\n             Some(Call_default), Some(Builtin_has_instance_function));\n  var o3 = object_with_details(o2, Some(x), Some(names), Some(bd), None,\n             None, None, None);\n  var p = object_alloc(o3);\n  var (l, s1) = p;\n  var a1 = {\n    attributes_data_value: LibList.length(names),\n    attributes_data_writable: false,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: false\n  };\n  var%bool b2 = object_define_own_prop(l, "length",\n                  descriptor_of_attributes(a1), false);\n  var%bool b3 = creating_function_object_proto(l);\n  if (!(str)) {\n    return (l);\n  } else {\n    var vthrower = Prealloc_throw_type_error;\n    var a2 = {\n      attributes_accessor_get: vthrower,\n      attributes_accessor_set: vthrower,\n      attributes_accessor_enumerable: false,\n      attributes_accessor_configurable: false\n    };\n    var%bool b4 = object_define_own_prop(l, "caller",\n                    descriptor_of_attributes(a2), false);\n    var%bool b5 = object_define_own_prop(l, "arguments",\n                    descriptor_of_attributes(a2), false);\n    return (l);\n  }\n};\n\nvar binding_inst_formal_params = function (l, args, names, str) {\n  switch (names) {\n    case []:\n      return (res_void());\n    case (argname::names_2):\n      var v = hd(Prim_undef, args);\n      var args_2 = tl(args);\n      var%bool hb = env_record_has_binding(l, argname);\n      var follow = function () {\n        var%void _ = env_record_set_mutable_binding(l, argname, v, str);\n        return (binding_inst_formal_params(l, args_2, names_2, str));\n      };\n      if (hb) {\n        return (follow());\n      } else {\n        var%void _ = env_record_create_mutable_binding(l, argname, None);\n        return (follow());\n      }\n  }\n  \n};\n\nvar binding_inst_function_decls = function (l, fds, str, bconfig) {\n  switch (fds) {\n    case []:\n      return (res_void());\n    case (fd::fds_2):\n      var fbd = fd.funcdecl_body;\n      var str_fd = funcbody_is_strict(fbd);\n      var fparams = fd.funcdecl_parameters;\n      var fname = fd.funcdecl_name;\n      var%object fo = creating_function_object(fparams, fbd,\n                        c.execution_ctx_variable_env, str_fd);\n      var follow = function () {\n        var%void _ = env_record_set_mutable_binding(l, fname, fo, str);\n        return (binding_inst_function_decls(l, fds_2, str, bconfig));\n      };\n      var%bool has = env_record_has_binding(l, fname);\n      if (has) {\n        if (nat_eq(l, env_loc_global_env_record)) {\n          var%run d = run_object_get_prop(Prealloc_global, fname);\n          switch (d) {\n            case Coq_full_descriptor_undef:\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Undefined full descriptor in [binding_inst_function_decls]."));\n            case Coq_full_descriptor_some(a):\n              if (attributes_configurable(a)) {\n                var a_2 = {\n                  attributes_data_value: Prim_undef,\n                  attributes_data_writable: true,\n                  attributes_data_enumerable: true,\n                  attributes_data_configurable: bconfig\n                };\n                var%bool x = object_define_own_prop(Prealloc_global, fname,\n                               descriptor_of_attributes(a_2), true);\n                return (follow());\n              } else {\n                if ((descriptor_is_accessor_dec(descriptor_of_attributes(a))\n                    || (!(attributes_writable(a))\n                       || !(attributes_enumerable(a))))) {\n                  return (run_error(Native_error_type));\n                } else {\n                  return (follow());\n                }\n              }\n          }\n          \n        } else {\n          return (follow());\n        }\n      } else {\n        var%void _ = env_record_create_mutable_binding(l, fname,\n                       Some(bconfig));\n        return (follow());\n      }\n  }\n  \n};\n\nvar make_arg_getter = function (x, x0) {\n  var xbd = strappend("return ", strappend(x, ";"));\n  var bd = Funcbody_intro(\n             Prog_intro(true,\n               mk_cons(Element_stat(Stat_return(Some(Expr_identifier(x)))),\n                 mk_nil)), xbd);\n  return (creating_function_object(mk_nil, bd, x0, true));\n};\n\nvar make_arg_setter = function (x, x0) {\n  var xparam = strappend(x, "_arg");\n  var xbd = strappend(x, strappend(" = ", strappend(xparam, ";")));\n  var bd = Funcbody_intro(\n             Prog_intro(true,\n               mk_cons(\n                 Element_stat(\n                   Stat_expr(\n                     Expr_assign(Expr_identifier(x), None,\n                       Expr_identifier(xparam)))), mk_nil)), xbd);\n  return (creating_function_object(mk_cons(xparam, mk_nil), bd, x0, true));\n};\n\nvar arguments_object_map_loop = function (l, xs, len, args, x, str, lmap, xsmap) {\n  return (\n    function (fO, fS, n) {\n        if (int_eq(n, 0)) {\n          return (fO({}));\n        } else {\n          return (fS((n - 1)));\n        }}(function (_pat_any_1) {\n        if (list_eq_nil_decidable(xsmap)) {\n          return (res_void());\n        } else {\n          var%some o = object_binds_option(l);\n          var o_2 = object_for_args_object(o, lmap, Builtin_get_args_obj,\n                      Builtin_get_own_prop_args_obj,\n                      Builtin_define_own_prop_args_obj,\n                      Builtin_delete_args_obj);\n          return (res_void(object_write(l, o_2)));\n        }}, function (len_2) {\n        var tdl = take_drop_last(args);\n        var (rmlargs, largs) = tdl;\n        var arguments_object_map_loop_2 = function (xsmap0) {\n          return (\n            arguments_object_map_loop(l, xs, len_2, rmlargs, x, str, lmap,\n              xsmap0));\n        };\n        var a = attributes_data_intro_all_true(largs);\n        var%bool b = object_define_own_prop(l, convert_prim_to_string(len_2),\n                       descriptor_of_attributes(a), false);\n        if (ge_nat_decidable(len_2, LibList.length(xs))) {\n          return (arguments_object_map_loop_2(xsmap));\n        } else {\n          var dummy = "";\n          var x0 = nth_def(dummy, len_2, xs);\n          if ((str || mem_decide(string_eq, x0, xsmap))) {\n            return (arguments_object_map_loop_2(xsmap));\n          } else {\n            var%object lgetter = make_arg_getter(x0, x);\n            var%object lsetter = make_arg_setter(x0, x);\n            var a_2 = {\n              attributes_accessor_get: lgetter,\n              attributes_accessor_set: lsetter,\n              attributes_accessor_enumerable: false,\n              attributes_accessor_configurable: true\n            };\n            var%bool b_2 = object_define_own_prop(lmap,\n                             convert_prim_to_string(len_2),\n                             descriptor_of_attributes(a_2), false);\n            return (arguments_object_map_loop_2(mk_cons(x0, xsmap)));\n          }\n        }}, len));\n};\n\nvar arguments_object_map = function (l, xs, args, x, str) {\n  var%object lmap = run_construct_prealloc(Prealloc_object, mk_nil);\n  return (\n    arguments_object_map_loop(l, xs, LibList.length(args), args, x, str,\n      lmap, mk_nil));\n};\n\nvar create_arguments_object = function (lf, xs, args, x, str) {\n  var o = object_create_builtin(Prealloc_object_proto, "Arguments",\n            Heap.empty);\n  var p = object_alloc(o);\n  var (l, s_2) = p;\n  var a = {\n    attributes_data_value: LibList.length(args),\n    attributes_data_writable: true,\n    attributes_data_enumerable: false,\n    attributes_data_configurable: true\n  };\n  var%bool b = object_define_own_prop(l, "length",\n                 descriptor_of_attributes(a), false);\n  var%void _ = arguments_object_map(l, xs, args, x, str);\n  if (str) {\n    var vthrower = Prealloc_throw_type_error;\n    var a0 = {\n      attributes_accessor_get: vthrower,\n      attributes_accessor_set: vthrower,\n      attributes_accessor_enumerable: false,\n      attributes_accessor_configurable: false\n    };\n    var%bool b_2 = object_define_own_prop(l, "caller",\n                     descriptor_of_attributes(a0), false);\n    var%bool b_3 = object_define_own_prop(l, "callee",\n                     descriptor_of_attributes(a0), false);\n    return (l);\n  } else {\n    var a0 = {\n      attributes_data_value: lf,\n      attributes_data_writable: true,\n      attributes_data_enumerable: false,\n      attributes_data_configurable: true\n    };\n    var%bool b_2 = object_define_own_prop(l, "callee",\n                     descriptor_of_attributes(a0), false);\n    return (l);\n  }\n};\n\nvar binding_inst_arg_obj = function (lf, p, xs, args, l) {\n  var arguments_ = "arguments";\n  var str = prog_intro_strictness(p);\n  var%object largs = create_arguments_object(lf, xs, args,\n                       c.execution_ctx_variable_env, str);\n  if (str) {\n    var%void _ = env_record_create_immutable_binding(l, arguments_);\n    return (env_record_initialize_immutable_binding(l, arguments_, largs));\n  } else {\n    return (\n      env_record_create_set_mutable_binding(l, arguments_, None, largs,\n        false));\n  }\n};\n\nvar binding_inst_var_decls = function (l, vds, bconfig, str) {\n  switch (vds) {\n    case []:\n      return (res_void());\n    case (vd::vds_2):\n      var bivd = function () {\n        return (binding_inst_var_decls(l, vds_2, bconfig, str));\n      };\n      var%bool has = env_record_has_binding(l, vd);\n      if (has) {\n        return (bivd());\n      } else {\n        var%void _ = env_record_create_set_mutable_binding(l, vd,\n                       Some(bconfig), Prim_undef, str);\n        return (bivd());\n      }\n  }\n  \n};\n\nvar execution_ctx_binding_inst = function (ct, funco, p, args) {\n  switch (c.execution_ctx_variable_env) {\n    case []:\n      return (\n        function (m) {\n            Debug.impossible_with_heap_because(__LOC__, m);\n            return (Result_impossible);}(\n          "Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst]."));\n    case (l::l0):\n      var str = prog_intro_strictness(p);\n      var follow = function (names) {\n        var bconfig = codetype_compare(ct, Codetype_eval);\n        var fds = prog_funcdecl(p);\n        var%void _ = binding_inst_function_decls(l, fds, str, bconfig);\n        var%bool bdefined = env_record_has_binding(l, "arguments");\n        var follow2 = function () {\n          var vds = prog_vardecl(p);\n          return (binding_inst_var_decls(l, vds, bconfig, str));\n        };\n        switch (ct) {\n          case Coq_codetype_func:\n            switch (funco) {\n              case Some(func):\n                if (bdefined) {\n                  return (follow2());\n                } else {\n                  var%void _ = binding_inst_arg_obj(func, p, names, args, l);\n                  return (follow2());\n                }\n              case None:\n                if (bdefined) {\n                  return (follow2());\n                } else {\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "Weird `arguments\' object in [execution_ctx_binding_inst]."));\n                }\n            }\n            \n          case Coq_codetype_global:\n            return (follow2());\n          case Coq_codetype_eval:\n            return (follow2());\n        }\n        \n      };\n      switch (ct) {\n        case Coq_codetype_func:\n          switch (funco) {\n            case Some(func):\n              var%some nameso = run_object_method(object_formal_parameters_,\n                                  func);\n              var%some names = nameso;\n              var%void _ = binding_inst_formal_params(l, args, names, str);\n              return (follow(names));\n            case None:\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent functionnal code type in [execution_ctx_binding_inst]."));\n          }\n          \n        case Coq_codetype_global:\n          switch (funco) {\n            case Some(o):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case None:\n              return (follow(mk_nil));\n          }\n          \n        case Coq_codetype_eval:\n          switch (funco) {\n            case Some(o):\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Non coherent non-functionnal code type in [execution_ctx_binding_inst]."));\n            case None:\n              return (follow(mk_nil));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar entering_func_code = function (lf, vthis, args) {\n  var%some bdo = run_object_method(object_code_, lf);\n  var%some bd = bdo;\n  var str = funcbody_is_strict(bd);\n  var follow = function (vthis_2) {\n    var%some lexo = run_object_method(object_scope_, lf);\n    var%some lex = lexo;\n    var p = lexical_env_alloc_decl(lex);\n    var (lex_2, s1) = p;\n    var c_2 = execution_ctx_intro_same(lex_2, vthis_2, str);\n    var%void _ = execution_ctx_binding_inst(Codetype_func, Some(lf),\n                   funcbody_prog(bd), args);\n    return (run_call_default(lf));\n  };\n  if (str) {\n    return (follow(vthis));\n  } else {\n    switch (vthis) {\n      case Coq_value_prim(p):\n        switch (p) {\n          case Coq_prim_undef:\n            return (follow(Prealloc_global));\n          case Coq_prim_null:\n            return (follow(Prealloc_global));\n          case Coq_prim_bool(b):\n            var%value v = to_object(vthis);\n            return (follow(v));\n          case Coq_prim_number(n):\n            var%value v = to_object(vthis);\n            return (follow(v));\n          case Coq_prim_string(s0):\n            var%value v = to_object(vthis);\n            return (follow(v));\n        }\n        \n      case Coq_value_object(lthis):\n        return (follow(vthis));\n    }\n    \n  }\n};\n\nvar run_object_get_own_prop = function (l, x) {\n  var%some b = run_object_method(object_get_own_prop_, l);\n  var def = function () {\n    var%some p = run_object_method(object_properties_, l);\n    return (\n      ifx_some_or_default(\n        convert_option_attributes(HeapStr.read_option(p, x)),\n        Full_descriptor_undef, function (x) { return (x);}));\n  };\n  switch (b) {\n    case Coq_builtin_get_own_prop_default:\n      return (def());\n    case Coq_builtin_get_own_prop_args_obj:\n      var%run d = def();\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (Full_descriptor_undef);\n        case Coq_full_descriptor_some(a):\n          var%some lmapo = run_object_method(object_parameter_map_, l);\n          var%some lmap = lmapo;\n          var%run d0 = run_object_get_own_prop(lmap, x);\n          var follow = function (a0) {\n            return (a0);\n          };\n          switch (d0) {\n            case Coq_full_descriptor_undef:\n              return (follow(a));\n            case Coq_full_descriptor_some(amap):\n              var%value v = run_object_get(lmap, x);\n              switch (a) {\n                case Coq_attributes_data_of(ad):\n                  return (follow(attributes_data_with_value(ad, v)));\n                case Coq_attributes_accessor_of(aa):\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens."));\n              }\n              \n          }\n          \n      }\n      \n    case Coq_builtin_get_own_prop_string:\n      var%run d = def();\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          var%run k = to_int32(x);\n          var%string s3 = to_string(JsNumber.absolute(k));\n          if (!(string_eq(x, s3))) {\n            return (Full_descriptor_undef);\n          } else {\n            var%string str = run_object_prim_value(l);\n            var%run k0 = to_int32(x);\n            var len = strlength(str);\n            if (le_int_decidable(len, k0)) {\n              return (Full_descriptor_undef);\n            } else {\n              var resultStr = string_sub(str, int_of_number(k0), 1);\n              var a = {\n                attributes_data_value: resultStr,\n                attributes_data_writable: false,\n                attributes_data_enumerable: true,\n                attributes_data_configurable: false\n              };\n              return (a);\n            }\n          }\n        case Coq_full_descriptor_some(a):\n          return (d);\n      }\n      \n  }\n  \n};\n\nvar run_function_has_instance = function (lv, _foo_) {\n  switch (_foo_) {\n    case Coq_value_prim(p):\n      return (run_error(Native_error_type));\n    case Coq_value_object(lo):\n      var%some vproto = run_object_method(object_proto_, lv);\n      switch (vproto) {\n        case Coq_value_prim(p):\n          switch (p) {\n            case Coq_prim_null:\n              return (false);\n            default:\n              return (\n                function (m) {\n                    Debug.impossible_with_heap_because(__LOC__, m);\n                    return (Result_impossible);}(\n                  "Primitive found in the prototype chain in [run_object_has_instance_loop]."));\n          }\n          \n        case Coq_value_object(proto):\n          if (object_loc_compare(proto, lo)) {\n            return (true);\n          } else {\n            return (run_function_has_instance(proto, lo));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_object_has_instance = function (b, l, v) {\n  switch (b) {\n    case Coq_builtin_has_instance_function:\n      switch (v) {\n        case Coq_value_prim(w):\n          return (false);\n        case Coq_value_object(lv):\n          var%value vproto = run_object_get(l, "prototype");\n          switch (vproto) {\n            case Coq_value_prim(p):\n              return (run_error(Native_error_type));\n            case Coq_value_object(lproto):\n              return (run_function_has_instance(lv, lproto));\n          }\n          \n      }\n      \n    case Coq_builtin_has_instance_after_bind:\n      var%some ol = run_object_method(object_target_function_, l);\n      var%some l0 = ol;\n      var%some ob = run_object_method(object_has_instance_, l0);\n      switch (ob) {\n        case Some(b0):\n          return (run_object_has_instance(b0, l0, v));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n  }\n  \n};\n\nvar from_prop_descriptor = function (_foo_) {\n  switch (_foo_) {\n    case Coq_full_descriptor_undef:\n      return (Prim_undef);\n    case Coq_full_descriptor_some(a):\n      var%object l = run_construct_prealloc(Prealloc_object, mk_nil);\n      var follow = function (x) {\n        var a1 = attributes_data_intro_all_true(attributes_enumerable(a));\n        var%bool x0 = object_define_own_prop(l, "enumerable",\n                        descriptor_of_attributes(a1), throw_false);\n        var a2 = attributes_data_intro_all_true(attributes_configurable(a));\n        var%bool x1 = object_define_own_prop(l, "configurable",\n                        descriptor_of_attributes(a2), throw_false);\n        return (l);\n      };\n      switch (a) {\n        case Coq_attributes_data_of(ad):\n          var a1 = attributes_data_intro_all_true(ad.attributes_data_value);\n          var%bool x = object_define_own_prop(l, "value",\n                         descriptor_of_attributes(a1), throw_false);\n          var a2 = attributes_data_intro_all_true(\n                     ad.attributes_data_writable);\n          var%bool v = object_define_own_prop(l, "writable",\n                         descriptor_of_attributes(a2), throw_false);\n          return (follow(v));\n        case Coq_attributes_accessor_of(aa):\n          var a1 = attributes_data_intro_all_true(aa.attributes_accessor_get);\n          var%bool x = object_define_own_prop(l, "get",\n                         descriptor_of_attributes(a1), throw_false);\n          var a2 = attributes_data_intro_all_true(aa.attributes_accessor_set);\n          var%bool v = object_define_own_prop(l, "set",\n                         descriptor_of_attributes(a2), throw_false);\n          return (follow(v));\n      }\n      \n  }\n  \n};\n\nvar run_equal = function (v1, v2) {\n  var conv_number = function (v) {\n    return (to_number(v));\n  };\n  var conv_primitive = function (v) {\n    return (to_primitive(v, None));\n  };\n  var checkTypesThen = function (v3, v4, k) {\n    var ty1 = type_of(v3);\n    var ty2 = type_of(v4);\n    if (type_compare(ty1, ty2)) {\n      return (equality_test_for_same_type(ty1, v3, v4));\n    } else {\n      return (k(ty1, ty2));\n    }\n  };\n  return (\n    checkTypesThen(v1, v2, function (ty1, ty2) {\n        var dc_conv = function (v3, f, v4) {\n          var%value v2_2 = f(v4);\n          return (run_equal(v3, v2_2));\n        };\n        var so = function (b) {\n          return (b);\n        };\n        if ((type_compare(ty1, Type_null) && type_compare(ty2, Type_undef))) {\n          return (so(true));\n        } else {\n          if ((type_compare(ty1, Type_undef) && type_compare(ty2, Type_null))) {\n            return (so(true));\n          } else {\n            if ((type_compare(ty1, Type_number)\n                && type_compare(ty2, Type_string))) {\n              return (dc_conv(v1, conv_number, v2));\n            } else {\n              if ((type_compare(ty1, Type_string)\n                  && type_compare(ty2, Type_number))) {\n                return (dc_conv(v2, conv_number, v1));\n              } else {\n                if (type_compare(ty1, Type_bool)) {\n                  return (dc_conv(v2, conv_number, v1));\n                } else {\n                  if (type_compare(ty2, Type_bool)) {\n                    return (dc_conv(v1, conv_number, v2));\n                  } else {\n                    if (((type_compare(ty1, Type_string)\n                         || type_compare(ty1, Type_number))\n                        && type_compare(ty2, Type_object))) {\n                      return (dc_conv(v1, conv_primitive, v2));\n                    } else {\n                      if ((type_compare(ty1, Type_object)\n                          && (type_compare(ty2, Type_string)\n                             || type_compare(ty2, Type_number)))) {\n                        return (dc_conv(v2, conv_primitive, v1));\n                      } else {\n                        return (so(false));\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }}));\n};\n\nvar convert_twice = function (ifv, kC, v1, v2) {\n  return (\n    ifv(kC(v1), function (vc1) {\n        return (ifv(kC(v2), function (vc2) { return ([vc1, vc2]);}));}));\n};\n\nvar convert_twice_primitive = function (v1, v2) {\n  return (\n    convert_twice(ifx_prim, function (v) { return (to_primitive(v, None));},\n      v1, v2));\n};\n\nvar convert_twice_number = function (v1, v2) {\n  return (\n    convert_twice(ifx_number, function (v) { return (to_number(v));}, v1, v2));\n};\n\nvar convert_twice_string = function (v1, v2) {\n  return (\n    convert_twice(ifx_string, function (v) { return (to_string(v));}, v1, v2));\n};\n\nvar issome = function (_foo_) {\n  switch (_foo_) {\n    case Some(t):\n      return (true);\n    case None:\n      return (false);\n  }\n  \n};\n\nvar run_binary_op_add = function (v1, v2) {\n  var%run (w1, w2) = convert_twice_primitive(v1, v2);\n  if ((type_compare(type_of(w1), Type_string)\n      || type_compare(type_of(w2), Type_string))) {\n    var%run (str1, str2) = convert_twice_string(w1, w2);\n    return (strappend(str1, str2));\n  } else {\n    var%run (n1, n2) = convert_twice_number(w1, w2);return ((n1 + n2));\n  }\n};\n\nvar run_binary_op_arith = function (mathop, v1, v2) {\n  var%run nn = convert_twice_number(v1, v2);\n  var (n1, n2) = nn;\n  return (mathop(n1, n2));\n};\n\nvar run_binary_op_shift = function (b_unsigned, mathop, v1, v2) {\n  if (b_unsigned) {\n    var conv = to_uint32;\n  } else {\n    var conv = to_int32;\n  }\n  var%run k1 = conv(v1);\n  var%run k2 = to_uint32(v2);\n  var k2_2 = JsNumber.modulo_32(k2);\n  return (mathop(k1, k2_2));\n};\n\nvar run_binary_op_bitwise = function (mathop, v1, v2) {\n  var%run k1 = to_int32(v1);\n  var%run k2 = to_int32(v2);\n  return (mathop(k1, k2));\n};\n\nvar run_binary_op_compare = function (b_swap, b_neg, v1, v2) {\n  var%run ww = convert_twice_primitive(v1, v2);\n  var (w1, w2) = ww;\n  if (b_swap) {\n    var p = [w2, w1];\n  } else {\n    var p = [w1, w2];\n  }\n  var (wa, wb) = p;\n  var wr = inequality_test_primitive(wa, wb);\n  if (prim_compare(wr, Prim_undef)) {\n    return (false);\n  } else {\n    if ((b_neg && prim_compare(wr, true))) {\n      return (false);\n    } else {\n      if ((b_neg && prim_compare(wr, false))) {\n        return (true);\n      } else {\n        return (wr);\n      }\n    }\n  }\n};\n\nvar run_binary_op_instanceof = function (v1, v2) {\n  switch (v2) {\n    case Coq_value_prim(p):\n      return (run_error(Native_error_type));\n    case Coq_value_object(l):\n      var%some b = run_object_method(object_has_instance_, l);\n      switch (b) {\n        case None:\n          return (run_error(Native_error_type));\n        case Some(has_instance_id):\n          return (run_object_has_instance(has_instance_id, l, v1));\n      }\n      \n  }\n  \n};\n\nvar run_binary_op_in = function (v1, v2) {\n  switch (v2) {\n    case Coq_value_prim(p):\n      return (run_error(Native_error_type));\n    case Coq_value_object(l):\n      var%string x = to_string(v1);\n      return (object_has_prop(l, x));\n  }\n  \n};\n\nvar run_binary_op = function (op, v1, v2) {\n  switch (op) {\n    case Coq_binary_op_mult:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x * y));}, v1, v2));\n    case Coq_binary_op_div:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x / y));}, v1, v2));\n    case Coq_binary_op_mod:\n      return (\n        run_binary_op_arith(function (x, y) { return (JsNumber.fmod(x, y));},\n          v1, v2));\n    case Coq_binary_op_sub:\n      return (\n        run_binary_op_arith(function (x, y) { return ((x - y));}, v1, v2));\n    case Coq_binary_op_lt:\n      return (run_binary_op_compare(false, false, v1, v2));\n    case Coq_binary_op_gt:\n      return (run_binary_op_compare(true, false, v1, v2));\n    case Coq_binary_op_le:\n      return (run_binary_op_compare(true, true, v1, v2));\n    case Coq_binary_op_ge:\n      return (run_binary_op_compare(false, true, v1, v2));\n    case Coq_binary_op_left_shift:\n      return (run_binary_op_shift(false, JsNumber.int32_left_shift, v1, v2));\n    case Coq_binary_op_right_shift:\n      return (\n        run_binary_op_shift(false, JsNumber.int32_right_shift, v1, v2));\n    case Coq_binary_op_unsigned_right_shift:\n      return (\n        run_binary_op_shift(true, JsNumber.uint32_right_shift, v1, v2));\n    case Coq_binary_op_bitwise_and:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_and, v1, v2));\n    case Coq_binary_op_bitwise_or:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_or, v1, v2));\n    case Coq_binary_op_bitwise_xor:\n      return (run_binary_op_bitwise(JsNumber.int32_bitwise_xor, v1, v2));\n    case Coq_binary_op_add:\n      return (run_binary_op_add(v1, v2));\n    case Coq_binary_op_instanceof:\n      return (run_binary_op_instanceof(v1, v2));\n    case Coq_binary_op_in:\n      return (run_binary_op_in(v1, v2));\n    case Coq_binary_op_equal:\n      return (run_equal(v1, v2));\n    case Coq_binary_op_disequal:\n      var%bool b0 = run_equal(v1, v2);\n      return (!(b0));\n    case Coq_binary_op_strict_equal:\n      return (strict_equality_test(v1, v2));\n    case Coq_binary_op_strict_disequal:\n      return (!(strict_equality_test(v1, v2)));\n    case Coq_binary_op_coma:\n      return (v2);\n    case Coq_binary_op_and:\n      return (Result_impossible);\n    case Coq_binary_op_or:\n      return (Result_impossible);\n  }\n  \n};\n\nvar run_prepost_op = function (_foo_) {\n  switch (_foo_) {\n    case Coq_unary_op_delete:\n      return (None);\n    case Coq_unary_op_void:\n      return (None);\n    case Coq_unary_op_typeof:\n      return (None);\n    case Coq_unary_op_post_incr:\n      return (Some([add_one, false]));\n    case Coq_unary_op_post_decr:\n      return (Some([sub_one, false]));\n    case Coq_unary_op_pre_incr:\n      return (Some([add_one, true]));\n    case Coq_unary_op_pre_decr:\n      return (Some([sub_one, true]));\n    case Coq_unary_op_add:\n      return (None);\n    case Coq_unary_op_neg:\n      return (None);\n    case Coq_unary_op_bitwise_not:\n      return (None);\n    case Coq_unary_op_not:\n      return (None);\n  }\n  \n};\n\nvar run_typeof_value = function (_foo_) {\n  switch (_foo_) {\n    case Coq_value_prim(w):\n      return (typeof_prim(w));\n    case Coq_value_object(l):\n      if (is_callable_dec(l)) {\n        return ("function");\n      } else {\n        return ("object");\n      }\n  }\n  \n};\n\nvar run_unary_op = function (op, e) {\n  if (prepost_unary_op_dec(op)) {\n    var%success rv1 = run_expr(e);\n    var%run v2 = ref_get_value(rv1);\n    var%number n1 = to_number(v2);\n    var%some po = run_prepost_op(op);\n    var (number_op, is_pre) = po;\n    var n2 = number_op(n1);\n    var v = (function () {\n      if (is_pre) {\n        return (n2);\n      } else {\n        return (n1);\n      }\n    }())\n    ;\n    var%void _ = ref_put_value(rv1, n2);\n    return (v);\n  } else {\n    switch (op) {\n      case Coq_unary_op_delete:\n        var%success rv = run_expr(e);\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (true);\n          case Coq_resvalue_value(v):\n            return (true);\n          case Coq_resvalue_ref(r):\n            if (ref_kind_comparable(ref_kind_of(r), Ref_kind_undef)) {\n              if (r.ref_strict) {\n                return (run_error(Native_error_syntax));\n              } else {\n                return (true);\n              }\n            } else {\n              switch (r.ref_base) {\n                case Coq_ref_base_type_value(v):\n                  var%object l = to_object(v);\n                  return (object_delete(l, r.ref_name, r.ref_strict));\n                case Coq_ref_base_type_env_loc(l):\n                  if (r.ref_strict) {\n                    return (run_error(Native_error_syntax));\n                  } else {\n                    return (env_record_delete_binding(l, r.ref_name));\n                  }\n              }\n              \n            }\n        }\n        \n      case Coq_unary_op_typeof:\n        var%success rv = run_expr(e);\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Empty result for a `typeof\' in [run_unary_op]."));\n          case Coq_resvalue_value(v):\n            return (run_typeof_value(v));\n          case Coq_resvalue_ref(r):\n            if (ref_kind_comparable(ref_kind_of(r), Ref_kind_undef)) {\n              return ("undefined");\n            } else {\n              var%run v = ref_get_value(r);return (run_typeof_value(v));\n            }\n        }\n        \n      default:\n        var%run v = run_expr_get_value(e);\n        switch (op) {\n          case Coq_unary_op_void:\n            return (Prim_undef);\n          case Coq_unary_op_add:\n            return (to_number(v));\n          case Coq_unary_op_neg:\n            var%number n = to_number(v);\n            return (JsNumber.neg(n));\n          case Coq_unary_op_bitwise_not:\n            var%run k = to_int32(v);\n            return (JsNumber.int32_bitwise_not(k));\n          case Coq_unary_op_not:\n            return (!(convert_value_to_boolean(v)));\n          default:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Undealt regular operator in [run_unary_op]."));\n        }\n        \n    }\n    \n  }\n};\n\nvar create_new_function_in = function (args, bd) {\n  return (\n    creating_function_object(args, bd, c.execution_ctx_lexical_env,\n      c.execution_ctx_strict));\n};\n\nvar init_object = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (l);\n    case (p::pds_2):\n      var (pn, pb) = p;\n      var x = string_of_propname(pn);\n      var follows = function (desc) {\n        var%success rv = object_define_own_prop(l, x, desc, false);\n        return (init_object(l, pds_2));\n      };\n      switch (pb) {\n        case Coq_propbody_val(e0):\n          var%run v0 = run_expr_get_value(e0);\n          var desc = {\n            descriptor_value: Some(v0),\n            descriptor_writable: Some(true),\n            descriptor_get: None,\n            descriptor_set: None,\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n        case Coq_propbody_get(bd):\n          var%value v0 = create_new_function_in(mk_nil, bd);\n          var desc = {\n            descriptor_value: None,\n            descriptor_writable: None,\n            descriptor_get: Some(v0),\n            descriptor_set: None,\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n        case Coq_propbody_set(args, bd):\n          var%value v0 = create_new_function_in(args, bd);\n          var desc = {\n            descriptor_value: None,\n            descriptor_writable: None,\n            descriptor_get: None,\n            descriptor_set: Some(v0),\n            descriptor_enumerable: Some(true),\n            descriptor_configurable: Some(true)\n          };\n          return (follows(desc));\n      }\n      \n  }\n  \n};\n\nvar run_array_element_list = function (l, oes, n) {\n  switch (oes) {\n    case []:\n      return (l);\n    case (o::oes_2):\n      switch (o) {\n        case Some(e):\n          var loop_result = function () {\n            return (run_array_element_list(l, oes_2, 0.));\n          };\n          var%run v = run_expr_get_value(e);\n          var%value vlen = run_object_get(l, "length");\n          var%run ilen = to_uint32(vlen);\n          var%string slen = to_string((ilen + n));\n          var desc = {\n            attributes_data_value: v,\n            attributes_data_writable: true,\n            attributes_data_enumerable: true,\n            attributes_data_configurable: true\n          };\n          var%bool x = object_define_own_prop(l, slen,\n                         descriptor_of_attributes(desc), false);\n          var%object l0 = loop_result();\n          return (l0);\n        case None:\n          var firstIndex = elision_head_count(mk_cons(None, oes_2));\n          return (\n            run_array_element_list(l,\n              elision_head_remove(mk_cons(None, oes_2)), firstIndex));\n      }\n      \n  }\n  \n};\n\nvar init_array = function (l, oes) {\n  var elementList = elision_tail_remove(oes);\n  var elisionLength = elision_tail_count(oes);\n  var%object l0 = run_array_element_list(l, elementList, 0.);\n  var%value vlen = run_object_get(l0, "length");\n  var%run ilen = to_uint32(vlen);\n  var%run len = to_uint32((ilen + elisionLength));\n  var%not_throw x = object_put(l0, "length", len, throw_false);\n  return (l0);\n};\n\nvar run_var_decl_item = function (x, _foo_) {\n  switch (_foo_) {\n    case Some(e):\n      var%run ir = identifier_resolution(x);\n      var%run v = run_expr_get_value(e);\n      var%void _ = ref_put_value(ir, v);\n      return (x);\n    case None:\n      return (x);\n  }\n  \n};\n\nvar run_var_decl = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (res_empty);\n    case (y::xeos_2):\n      var (x, eo) = y;\n      var%value vname = run_var_decl_item(x, eo);\n      return (run_var_decl(xeos_2));\n  }\n  \n};\n\nvar run_list_expr = function (vs, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rev(vs));\n    case (e::es_2):\n      var%run v = run_expr_get_value(e);\n      return (run_list_expr(mk_cons(v, vs), es_2));\n  }\n  \n};\n\nvar run_block = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (Resvalue_empty);\n    case (t::ts_rev_2):\n      var%success rv0 = run_block(ts_rev_2);\n      return (\n        ifx_success_state(rv0, run_stat(t), function (x0) { return (x0);}));\n  }\n  \n};\n\nvar run_binary_op_and = function (e1, e2) {\n  var%run v1 = run_expr_get_value(e1);\n  var b1 = convert_value_to_boolean(v1);\n  if (!(b1)) {\n    return (v1);\n  } else {\n    var%run v = run_expr_get_value(e2);return (v);\n  }\n};\n\nvar run_binary_op_or = function (e1, e2) {\n  var%run v1 = run_expr_get_value(e1);\n  var b1 = convert_value_to_boolean(v1);\n  if (b1) {\n    return (v1);\n  } else {\n    var%run v = run_expr_get_value(e2);return (v);\n  }\n};\n\nvar run_expr_binary_op = function (op, e1, e2) {\n  switch (op) {\n    case Coq_binary_op_and:\n      return (run_binary_op_and(e1, e2));\n    case Coq_binary_op_or:\n      return (run_binary_op_or(e1, e2));\n    default:\n      var%run v1 = run_expr_get_value(e1);\n      var%run v2 = run_expr_get_value(e2);\n      return (run_binary_op(op, v1, v2));\n  }\n  \n};\n\nvar run_expr_access = function (e1, e2) {\n  var%run v1 = run_expr_get_value(e1);\n  var%run v2 = run_expr_get_value(e2);\n  if ((value_compare(v1, Prim_undef) || value_compare(v1, Prim_null))) {\n    return (run_error(Native_error_type));\n  } else {\n    var%string x = to_string(v2);\n    return (ref_create_value(v1, x, c.execution_ctx_strict));\n  }\n};\n\nvar run_expr_assign = function (opo, e1, e2) {\n  var%success rv1 = run_expr(e1);\n  var follow = function (rv_2) {\n    switch (rv_2) {\n      case Coq_resvalue_empty:\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Non-value result in [run_expr_assign]."));\n      case Coq_resvalue_value(v):\n        var%void _ = ref_put_value(rv1, v);\n        return (v);\n      case Coq_resvalue_ref(r):\n        return (\n          function (m) {\n              Debug.impossible_with_heap_because(__LOC__, m);\n              return (Result_impossible);}(\n            "Non-value result in [run_expr_assign]."));\n    }\n    \n  };\n  switch (opo) {\n    case Some(op):\n      var%run v1 = ref_get_value(rv1);\n      var%run v2 = run_expr_get_value(e2);\n      var%success v = run_binary_op(op, v1, v2);\n      return (follow(v));\n    case None:\n      var%run x0 = run_expr_get_value(e2);\n      return (follow(x0));\n  }\n  \n};\n\nvar run_expr_function = function (fo, args, bd) {\n  switch (fo) {\n    case Some(fn):\n      var p = lexical_env_alloc_decl(c.execution_ctx_lexical_env);\n      var (lex_2, s_2) = p;\n      var follow = function (l) {\n        var%some e = env_record_binds_option(l);\n        var%void _ = env_record_create_immutable_binding(l, fn);\n        var%object l0 = creating_function_object(args, bd, lex_2,\n                          funcbody_is_strict(bd));\n        var%void _ = env_record_initialize_immutable_binding(l, fn, l0);\n        return (l0);\n      };\n      return (\n        destr_list(lex_2, function (x) {\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Empty lexical environnment allocated in [run_expr_function]."));\n          }, function (l, x) { return (follow(l));}, {}));\n    case None:\n      var lex = c.execution_ctx_lexical_env;\n      return (\n        creating_function_object(args, bd, lex, funcbody_is_strict(bd)));\n  }\n  \n};\n\nvar entering_eval_code = function (direct, bd, k) {\n  var str = (funcbody_is_strict(bd) || (direct && c.execution_ctx_strict));\n  if (direct) {\n    var c_2 = c;\n  } else {\n    var c_2 = execution_ctx_initial(str);\n  }\n  if (str) {\n    var p = lexical_env_alloc_decl(c_2.execution_ctx_lexical_env);\n  } else {\n    var p = [c_2.execution_ctx_lexical_env, s];\n  }\n  var (lex, s_2) = p;\n  if (str) {\n    var c1 = execution_ctx_with_lex_same(lex);\n  } else {\n    var c1 = c_2;\n  }\n  var p0 = funcbody_prog(bd);\n  var%void _ = execution_ctx_binding_inst(Codetype_eval, None, p0, mk_nil);\n  return (k());\n};\n\nvar run_eval = function (is_direct_call, vs) {\n  switch (get_arg(0, vs)) {\n    case Coq_value_prim(p):\n      switch (p) {\n        case Coq_prim_undef:\n          return (Prim_undef);\n        case Coq_prim_null:\n          return (Prim_null);\n        case Coq_prim_bool(b):\n          return (b);\n        case Coq_prim_number(n):\n          return (n);\n        case Coq_prim_string(s0):\n          var str = (is_direct_call && c.execution_ctx_strict);\n          switch (parse_pickable(s0, str)) {\n            case Some(p0):\n              return (\n                entering_eval_code(is_direct_call, Funcbody_intro(p0, s0),\n                  function () {\n                    var%ter r = run_prog(p0);\n                    switch (r.res_type) {\n                      case Coq_restype_normal:\n                        return (\n                          ifx_empty_label(r, function (x) {\n                              switch (r.res_value) {\n                                case Coq_resvalue_empty:\n                                  return (Prim_undef);\n                                case Coq_resvalue_value(v):\n                                  return (v);\n                                case Coq_resvalue_ref(r0):\n                                  return (\n                                    function (m) {\n                                        Debug.impossible_with_heap_because(\n                                          __LOC__, m);\n                                        return (Result_impossible);}(\n                                      "Reference found in the result of an `eval\' in [run_eval]."));\n                              }\n                              }));\n                      case Coq_restype_throw:\n                        return (res_throw(r.res_value));\n                      default:\n                        return (\n                          function (m) {\n                              Debug.impossible_with_heap_because(__LOC__, m);\n                              return (Result_impossible);}(\n                            "Forbidden result type returned by an `eval\' in [run_eval]."));\n                    }\n                    }));\n            case None:\n              return (run_error(Native_error_syntax));\n          }\n          \n      }\n      \n    case Coq_value_object(o):\n      return (o);\n  }\n  \n};\n\nvar run_expr_call = function (e1, e2s) {\n  var is_eval_direct = is_syntactic_eval(e1);\n  var%success rv = run_expr(e1);\n  var%run f = ref_get_value(rv);\n  var%run vs = run_list_expr(mk_nil, e2s);\n  switch (f) {\n    case Coq_value_prim(p):\n      return (run_error(Native_error_type));\n    case Coq_value_object(l):\n      if (is_callable_dec(l)) {\n        var follow = function (vthis) {\n          if (object_loc_compare(l, Prealloc_global_eval)) {\n            return (run_eval(is_eval_direct, vs));\n          } else {\n            return (run_call(l, vthis, vs));\n          }\n        };\n        switch (rv) {\n          case Coq_resvalue_empty:\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "[run_expr_call] unable to call an  empty result."));\n          case Coq_resvalue_value(v):\n            return (follow(Prim_undef));\n          case Coq_resvalue_ref(r):\n            switch (r.ref_base) {\n              case Coq_ref_base_type_value(v):\n                if ((ref_kind_comparable(ref_kind_of(r),\n                       Ref_kind_primitive_base)\n                    || (ref_kind_comparable(ref_kind_of(r), Ref_kind_null)\n                       || ref_kind_comparable(ref_kind_of(r),\n                            Ref_kind_object)))) {\n                  return (follow(v));\n                } else {\n                  return (\n                    function (m) {\n                        Debug.impossible_with_heap_because(__LOC__, m);\n                        return (Result_impossible);}(\n                      "[run_expr_call] unable to call a non-property function."));\n                }\n              case Coq_ref_base_type_env_loc(l0):\n                var%some v = env_record_implicit_this_value(l0);\n                return (follow(v));\n            }\n            \n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n  }\n  \n};\n\nvar run_expr_conditionnal = function (e1, e2, e3) {\n  var%run v1 = run_expr_get_value(e1);\n  var b = convert_value_to_boolean(v1);\n  if (b) {\n    var e = e2;\n  } else {\n    var e = e3;\n  }\n  var%run r = run_expr_get_value(e);\n  return (r);\n};\n\nvar run_expr_new = function (e1, e2s) {\n  var%run v = run_expr_get_value(e1);\n  var%run args = run_list_expr(mk_nil, e2s);\n  switch (v) {\n    case Coq_value_prim(p):\n      return (run_error(Native_error_type));\n    case Coq_value_object(l):\n      var%some coo = run_object_method(object_construct_, l);\n      switch (coo) {\n        case Some(co):\n          return (run_construct(co, l, args));\n        case None:\n          return (run_error(Native_error_type));\n      }\n      \n  }\n  \n};\n\nvar run_stat_label = function (lab, t) {\n  var%break r1 = run_stat(t);\n  return (\n    (function () {\n      if (label_compare(r1.res_label, lab)) {\n        return (r1.res_value);\n      } else {\n        return (r1);\n      }\n    }())\n    );\n};\n\nvar run_stat_with = function (e1, t2) {\n  var%run v1 = run_expr_get_value(e1);\n  var%object l = to_object(v1);\n  var lex = c.execution_ctx_lexical_env;\n  var p = lexical_env_alloc_object(lex, l, provide_this_true);\n  var (lex_2, s3) = p;\n  var c_2 = execution_ctx_with_lex(lex_2);\n  return (run_stat(t2));\n};\n\nvar run_stat_if = function (e1, t2, to0) {\n  var%run v1 = run_expr_get_value(e1);\n  var b = convert_value_to_boolean(v1);\n  if (b) {\n    return (run_stat(t2));\n  } else {\n    switch (to0) {\n      case Some(t3):\n        return (run_stat(t3));\n      case None:\n        return (Resvalue_empty);\n    }\n    \n  }\n};\n\nvar run_stat_while = function (rv, labs, e1, t2) {\n  var%run v1 = run_expr_get_value(e1);\n  var b = convert_value_to_boolean(v1);\n  if (b) {\n    var%ter r = run_stat(t2);\n    if (!(resvalue_compare(r.res_value, Resvalue_empty))) {\n      var rv_2 = r.res_value;\n    } else {\n      var rv_2 = rv;\n    }\n    var loop = function (x) {\n      return (run_stat_while(rv_2, labs, e1, t2));\n    };\n    if ((!(restype_compare(r.res_type, Restype_continue))\n        || !(res_label_in(r, labs)))) {\n      if ((restype_compare(r.res_type, Restype_break)\n          && res_label_in(r, labs))) {\n        return (rv_2);\n      } else {\n        if (!(restype_compare(r.res_type, Restype_normal))) {\n          return (r);\n        } else {\n          return (loop({}));\n        }\n      }\n    } else {\n      return (loop({}));\n    }\n  } else {\n    return (rv);\n  }\n};\n\nvar run_stat_switch_end = function (rv, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rv);\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          return (\n            ifx_success_state(rv, run_block(rev(ts)), function (rv1) {\n                return (run_stat_switch_end(rv1, scs_2));}));\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_no_default = function (vi, rv, _foo_) {\n  switch (_foo_) {\n    case []:\n      return (rv);\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var%run v1 = run_expr_get_value(e);\n          var b = strict_equality_test(v1, vi);\n          if (b) {\n            var%success rv2 = run_block(rev(ts));\n            return (run_stat_switch_end(rv2, scs_2));\n          } else {\n            return (run_stat_switch_no_default(vi, rv, scs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_default = function (ts, scs) {\n  var%success rv = run_block(rev(ts));\n  return (run_stat_switch_end(rv, scs));\n};\n\nvar run_stat_switch_with_default_B = function (vi, rv, ts0, scs) {\n  switch (scs) {\n    case []:\n      return (run_stat_switch_with_default_default(ts0, scs));\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var%run v1 = run_expr_get_value(e);\n          var b = strict_equality_test(v1, vi);\n          if (b) {\n            var%success rv2 = run_block(rev(ts));\n            return (run_stat_switch_end(rv2, scs_2));\n          } else {\n            return (run_stat_switch_with_default_B(vi, rv, ts0, scs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch_with_default_A = function (found, vi, rv, scs1, ts0, scs2) {\n  switch (scs1) {\n    case []:\n      if (found) {\n        return (run_stat_switch_with_default_default(ts0, scs2));\n      } else {\n        return (run_stat_switch_with_default_B(vi, rv, ts0, scs2));\n      }\n    case (y::scs_2):\n      switch (y) {\n        case Coq_switchclause_intro(e, ts):\n          var follow = function () {\n            return (\n              ifx_success_state(rv, run_block(rev(ts)), function (rv0) {\n                  return (\n                    run_stat_switch_with_default_A(true, vi, rv0, scs_2, ts0,\n                      scs2));}));\n          };\n          if (found) {\n            return (follow());\n          } else {\n            var%run v1 = run_expr_get_value(e);\n            var b = strict_equality_test(v1, vi);\n            if (b) {\n              return (follow());\n            } else {\n              return (\n                run_stat_switch_with_default_A(false, vi, rv, scs_2, ts0,\n                  scs2));\n            }\n          }\n      }\n      \n  }\n  \n};\n\nvar run_stat_switch = function (labs, e, sb) {\n  var%run vi = run_expr_get_value(e);\n  var follow = function (w) {\n    var%success r = var%break r = w;\n      if (res_label_in(r, labs)) {\n        return (r.res_value);\n      } else {\n        return (r);\n      };\n    return (r);\n  };\n  switch (sb) {\n    case Coq_switchbody_nodefault(scs):\n      return (follow(run_stat_switch_no_default(vi, Resvalue_empty, scs)));\n    case Coq_switchbody_withdefault(scs1, ts, scs2):\n      return (\n        follow(\n          run_stat_switch_with_default_A(false, vi, Resvalue_empty, scs1, ts,\n            scs2)));\n  }\n  \n};\n\nvar run_stat_do_while = function (rv, labs, e1, t2) {\n  var%ter r = run_stat(t2);\n  if (resvalue_compare(r.res_value, Resvalue_empty)) {\n    var rv_2 = rv;\n  } else {\n    var rv_2 = r.res_value;\n  }\n  var loop = function (x) {\n    var%run v1 = run_expr_get_value(e1);\n    var b = convert_value_to_boolean(v1);\n    if (b) {\n      return (run_stat_do_while(rv_2, labs, e1, t2));\n    } else {\n      return (rv_2);\n    }\n  };\n  if ((restype_compare(r.res_type, Restype_continue)\n      && res_label_in(r, labs))) {\n    return (loop({}));\n  } else {\n    if ((restype_compare(r.res_type, Restype_break) && res_label_in(r, labs))) {\n      return (rv_2);\n    } else {\n      if (!(restype_compare(r.res_type, Restype_normal))) {\n        return (r);\n      } else {\n        return (loop({}));\n      }\n    }\n  }\n};\n\nvar run_stat_try = function (t1, t2o, t3o) {\n  var finallycont = function (r) {\n    switch (t3o) {\n      case Some(t3):\n        var%success rv_2 = run_stat(t3);\n        return (r);\n      case None:\n        return (r);\n    }\n    \n  };\n  return (\n    ifx_any_or_throw(run_stat(t1), finallycont, function (v) {\n        switch (t2o) {\n          case Some(y):\n            var (x, t2) = y;\n            var lex = c.execution_ctx_lexical_env;\n            var p = lexical_env_alloc_decl(lex);\n            var (lex_2, s_2) = p;\n            switch (lex_2) {\n              case []:\n                return (\n                  function (m) {\n                      Debug.impossible_with_heap_because(__LOC__, m);\n                      return (Result_impossible);}(\n                    "Empty lexical environnment in [run_stat_try]."));\n              case (l::oldlex):\n                var%void _ = env_record_create_set_mutable_binding(l, x,\n                               None, v, throw_irrelevant);\n                var c_2 = execution_ctx_with_lex(lex_2);\n                var%ter r = run_stat(t2);\n                return (finallycont(r));\n            }\n            \n          case None:\n            return (finallycont(res_throw(v)));\n        }\n        }));\n};\n\nvar run_stat_throw = function (e) {\n  var%run v1 = run_expr_get_value(e);\n  return (res_throw(v1));\n};\n\nvar run_stat_return = function (_foo_) {\n  switch (_foo_) {\n    case Some(e):\n      var%run v1 = run_expr_get_value(e);\n      return (res_return(v1));\n    case None:\n      return (res_return(Prim_undef));\n  }\n  \n};\n\nvar run_stat_for_loop = function (labs, rv, eo2, eo3, t) {\n  var follows = function () {\n    var%ter r = run_stat(t);\n    if (!(resvalue_compare(r.res_value, Resvalue_empty))) {\n      var rv_2 = r.res_value;\n    } else {\n      var rv_2 = rv;\n    }\n    var loop = function () {\n      return (run_stat_for_loop(labs, rv_2, eo2, eo3, t));\n    };\n    if ((restype_compare(r.res_type, Restype_break) && res_label_in(r, labs))) {\n      return (rv_2);\n    } else {\n      if ((restype_compare(r.res_type, Restype_normal)\n          || (restype_compare(r.res_type, Restype_continue)\n             && res_label_in(r, labs)))) {\n        switch (eo3) {\n          case Some(e3):\n            var%run v3 = run_expr_get_value(e3);\n            return (loop());\n          case None:\n            return (loop());\n        }\n        \n      } else {\n        return (r);\n      }\n    }\n  };\n  switch (eo2) {\n    case Some(e2):\n      var%run v2 = run_expr_get_value(e2);\n      var b = convert_value_to_boolean(v2);\n      if (b) {\n        return (follows());\n      } else {\n        return (rv);\n      }\n    case None:\n      return (follows());\n  }\n  \n};\n\nvar run_stat_for = function (labs, eo1, eo2, eo3, t) {\n  var follows = function () {\n    return (run_stat_for_loop(labs, Resvalue_empty, eo2, eo3, t));\n  };\n  switch (eo1) {\n    case Some(e1):\n      var%run v1 = run_expr_get_value(e1);\n      return (follows());\n    case None:\n      return (follows());\n  }\n  \n};\n\nvar run_stat_for_var = function (labs, ds, eo2, eo3, t) {\n  var%ter r = run_stat(Stat_var_decl(ds));\n  return (run_stat_for_loop(labs, Resvalue_empty, eo2, eo3, t));\n};\n\nvar run_expr = function (_term_) {\n  switch (_term_) {\n    case Coq_expr_this:\n      return (c.execution_ctx_this_binding);\n    case Coq_expr_identifier(x):\n      var%run r = identifier_resolution(x);\n      return (r);\n    case Coq_expr_literal(i):\n      return (convert_literal_to_prim(i));\n    case Coq_expr_object(pds):\n      var%object l = run_construct_prealloc(Prealloc_object, mk_nil);\n      return (init_object(l, pds));\n    case Coq_expr_array(oes):\n      var%object l = run_construct_prealloc(Prealloc_array, mk_nil);\n      return (init_array(l, oes));\n    case Coq_expr_function(fo, args, bd):\n      return (run_expr_function(fo, args, bd));\n    case Coq_expr_access(e1, e2):\n      return (run_expr_access(e1, e2));\n    case Coq_expr_member(e1, f):\n      return (run_expr(Expr_access(e1, Expr_literal(Literal_string(f)))));\n    case Coq_expr_new(e1, e2s):\n      return (run_expr_new(e1, e2s));\n    case Coq_expr_call(e1, e2s):\n      return (run_expr_call(e1, e2s));\n    case Coq_expr_unary_op(op, e0):\n      return (run_unary_op(op, e0));\n    case Coq_expr_binary_op(e1, op, e2):\n      return (run_expr_binary_op(op, e1, e2));\n    case Coq_expr_conditional(e1, e2, e3):\n      return (run_expr_conditionnal(e1, e2, e3));\n    case Coq_expr_assign(e1, opo, e2):\n      return (run_expr_assign(opo, e1, e2));\n  }\n  \n};\n\nvar run_stat = function (_term_) {\n  switch (_term_) {\n    case Coq_stat_expr(e):\n      var%run r = run_expr_get_value(e);\n      return (r);\n    case Coq_stat_label(lab, t0):\n      return (run_stat_label(Label_string(lab), t0));\n    case Coq_stat_block(ts):\n      return (run_block(rev(ts)));\n    case Coq_stat_var_decl(xeos):\n      return (run_var_decl(xeos));\n    case Coq_stat_if(e1, t2, to0):\n      return (run_stat_if(e1, t2, to0));\n    case Coq_stat_do_while(ls, t1, e2):\n      return (run_stat_do_while(Resvalue_empty, ls, e2, t1));\n    case Coq_stat_while(ls, e1, t2):\n      return (run_stat_while(Resvalue_empty, ls, e1, t2));\n    case Coq_stat_with(e1, t2):\n      return (run_stat_with(e1, t2));\n    case Coq_stat_throw(e):\n      return (run_stat_throw(e));\n    case Coq_stat_return(eo):\n      return (run_stat_return(eo));\n    case Coq_stat_break(so):\n      return (res_break(so));\n    case Coq_stat_continue(so):\n      return (res_continue(so));\n    case Coq_stat_try(t1, t2o, t3o):\n      return (run_stat_try(t1, t2o, t3o));\n    case Coq_stat_for(ls, eo1, eo2, eo3, s0):\n      return (run_stat_for(ls, eo1, eo2, eo3, s0));\n    case Coq_stat_for_var(ls, ds, eo2, eo3, s0):\n      return (run_stat_for_var(ls, ds, eo2, eo3, s0));\n    case Coq_stat_for_in(ls, e1, e2, s0):\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}("stat_for_in"));\n    case Coq_stat_for_in_var(ls, x, e1o, e2, s0):\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}("stat_for_in_var"));\n    case Coq_stat_debugger:\n      return (res_empty);\n    case Coq_stat_switch(labs, e, sb):\n      return (run_stat_switch(labs, e, sb));\n  }\n  \n};\n\nvar run_elements = function (_foo_) {\n  switch (_foo_) {\n    case []:\n      return (Resvalue_empty);\n    case (el::els_rev_2):\n      var%success rv0 = run_elements(els_rev_2);\n      switch (el) {\n        case Coq_element_stat(t):\n          var%ter r1 = run_stat(t);\n          var r2 = res_overwrite_value_if_empty(rv0, r1);\n          return (r2);\n        case Coq_element_func_decl(name, args, bd):\n          return (rv0);\n      }\n      \n  }\n  \n};\n\nvar run_prog = function (_term_) {\n  switch (_term_) {\n    case Coq_prog_intro(str, els):\n      return (run_elements(rev(els)));\n  }\n  \n};\n\nvar push = function (l, args, ilen) {\n  var vlen = ilen;\n  switch (args) {\n    case []:\n      var%not_throw x = object_put(l, "length", vlen, throw_true);\n      return (vlen);\n    case (v::vs):\n      var%string slen = to_string(vlen);\n      var%not_throw x = object_put(l, slen, v, throw_true);\n      return (push(l, vs, (ilen + 1.)));\n  }\n  \n};\n\nvar run_object_is_sealed = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some ext = run_object_method(object_extensible_, l);\n      return (!(ext));\n    case (x::xs_2):\n      var%run d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if (attributes_configurable(a)) {\n            return (false);\n          } else {\n            return (run_object_is_sealed(l, xs_2));\n          }\n      }\n      \n  }\n  \n};\n\nvar run_object_seal = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some _ = run_object_heap_set_extensible(false, l);\n      return (l);\n    case (x::xs_2):\n      var%run d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_seal]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if (attributes_configurable(a)) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: None,\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: Some(false)\n            };\n            var a_2 = attributes_update(a, desc);\n          } else {\n            var a_2 = a;\n          }\n          var%bool x0 = object_define_own_prop(l, x,\n                          descriptor_of_attributes(a_2), true);\n          return (run_object_seal(l, xs_2));\n      }\n      \n  }\n  \n};\n\nvar run_object_freeze = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some _ = run_object_heap_set_extensible(false, l);\n      return (l);\n    case (x::xs_2):\n      var%run d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          if ((attributes_is_data_dec(a) && attributes_writable(a))) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: Some(false),\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: None\n            };\n            var a_2 = attributes_update(a, desc);\n          } else {\n            var a_2 = a;\n          }\n          if (attributes_configurable(a_2)) {\n            var desc = {\n              descriptor_value: None,\n              descriptor_writable: None,\n              descriptor_get: None,\n              descriptor_set: None,\n              descriptor_enumerable: None,\n              descriptor_configurable: Some(false)\n            };\n            var a_3 = attributes_update(a_2, desc);\n          } else {\n            var a_3 = a_2;\n          }\n          var%bool x0 = object_define_own_prop(l, x,\n                          descriptor_of_attributes(a_3), true);\n          return (run_object_freeze(l, xs_2));\n      }\n      \n  }\n  \n};\n\nvar run_object_is_frozen = function (l, _foo_) {\n  switch (_foo_) {\n    case []:\n      var%some ext = run_object_method(object_extensible_, l);\n      return (!(ext));\n    case (x::xs_2):\n      var%run d = run_object_get_own_prop(l, x);\n      var check_configurable = function (a) {\n        if (attributes_configurable(a)) {\n          return (false);\n        } else {\n          return (run_object_is_frozen(l, xs_2));\n        }\n      };\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (\n            function (m) {\n                Debug.impossible_with_heap_because(__LOC__, m);\n                return (Result_impossible);}(\n              "[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\'t."));\n        case Coq_full_descriptor_some(a):\n          switch (a) {\n            case Coq_attributes_data_of(ad):\n              if (attributes_writable(ad)) {\n                return (false);\n              } else {\n                return (check_configurable(ad));\n              }\n            case Coq_attributes_accessor_of(aa):\n              return (check_configurable(aa));\n          }\n          \n      }\n      \n  }\n  \n};\n\nvar run_get_args_for_apply = function (l, index, n) {\n  if ((index < n)) {\n    var%string sindex = to_string(index);\n    var%value v = run_object_get(l, sindex);\n    var tail_args = run_get_args_for_apply(l, (index + 1.), n);\n    var%run tail = tail_args;\n    return (mk_cons(v, tail));\n  } else {\n    return (mk_nil);\n  }\n};\n\nvar valueToStringForJoin = function (l, k) {\n  var%string prop = to_string(k);\n  var%value v = run_object_get(l, prop);\n  switch (v) {\n    case Coq_value_prim(p):\n      switch (p) {\n        case Coq_prim_undef:\n          return ("");\n        case Coq_prim_null:\n          return ("");\n        case Coq_prim_bool(b):\n          var%string s3 = to_string(v);\n          return (s3);\n        case Coq_prim_number(n):\n          var%string s3 = to_string(v);\n          return (s3);\n        case Coq_prim_string(s2):\n          var%string s4 = to_string(v);\n          return (s4);\n      }\n      \n    case Coq_value_object(o):\n      var%string s3 = to_string(v);\n      return (s3);\n  }\n  \n};\n\nvar run_array_join_elements = function (l, k, length0, sep, sR) {\n  if ((k < length0)) {\n    var ss = strappend(sR, sep);\n    var sE = valueToStringForJoin(l, k);\n    var%run element = sE;\n    var sR0 = strappend(ss, element);\n    return (run_array_join_elements(l, (k + 1.), length0, sep, sR0));\n  } else {\n    return (sR);\n  }\n};\n\nvar run_call_prealloc = function (b, vthis, args) {\n  switch (b) {\n    case Coq_prealloc_global_is_finite:\n      var v = get_arg(0, args);\n      var%number n = to_number(v);\n      return (\n        !(\n          (JsNumber.isnan(n)\n          || ((n === JsNumber.infinity) || (n === JsNumber.neg_infinity)))));\n    case Coq_prealloc_global_is_nan:\n      var v = get_arg(0, args);\n      var%number n = to_number(v);\n      return (JsNumber.isnan(n));\n    case Coq_prealloc_object:\n      var value0 = get_arg(0, args);\n      switch (value0) {\n        case Coq_value_prim(p):\n          switch (p) {\n            case Coq_prim_undef:\n              return (run_construct_prealloc(b, args));\n            case Coq_prim_null:\n              return (run_construct_prealloc(b, args));\n            case Coq_prim_bool(b0):\n              return (to_object(value0));\n            case Coq_prim_number(n):\n              return (to_object(value0));\n            case Coq_prim_string(s0):\n              return (to_object(value0));\n          }\n          \n        case Coq_value_object(o):\n          return (to_object(value0));\n      }\n      \n    case Coq_prealloc_object_get_proto_of:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%some proto = run_object_method(object_proto_, l);\n          return (proto);\n      }\n      \n    case Coq_prealloc_object_get_own_prop_descriptor:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%string x = to_string(get_arg(1, args));\n          var%run d = run_object_get_own_prop(l, x);\n          return (from_prop_descriptor(d));\n      }\n      \n    case Coq_prealloc_object_define_prop:\n      var o = get_arg(0, args);\n      var p = get_arg(1, args);\n      var attr = get_arg(2, args);\n      switch (o) {\n        case Coq_value_prim(p0):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%string name = to_string(p);\n          var%run desc = run_to_descriptor(attr);\n          var%bool x = object_define_own_prop(l, name, desc, true);\n          return (l);\n      }\n      \n    case Coq_prealloc_object_seal:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_seal(l, _x_));\n      }\n      \n    case Coq_prealloc_object_freeze:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_freeze(l, _x_));\n      }\n      \n    case Coq_prealloc_object_prevent_extensions:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%some o = object_binds_option(l);\n          var o1 = object_with_extension(o, false);\n          var s_2 = object_write(l, o1);\n          return (l);\n      }\n      \n    case Coq_prealloc_object_is_sealed:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_is_sealed(l, _x_));\n      }\n      \n    case Coq_prealloc_object_is_frozen:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%some _x_ = object_properties_keys_as_list_option(l);\n          return (run_object_is_frozen(l, _x_));\n      }\n      \n    case Coq_prealloc_object_is_extensible:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (run_error(Native_error_type));\n        case Coq_value_object(l):\n          var%some r = run_object_method(object_extensible_, l);\n          return (r);\n      }\n      \n    case Coq_prealloc_object_proto_to_string:\n      switch (vthis) {\n        case Coq_value_prim(p):\n          switch (p) {\n            case Coq_prim_undef:\n              return ("[object Undefined]");\n            case Coq_prim_null:\n              return ("[object Null]");\n            case Coq_prim_bool(b0):\n              var%object l = to_object(vthis);\n              var%some s0 = run_object_method(object_class_, l);\n              return (strappend("[object ", strappend(s0, "]")));\n            case Coq_prim_number(n):\n              var%object l = to_object(vthis);\n              var%some s0 = run_object_method(object_class_, l);\n              return (strappend("[object ", strappend(s0, "]")));\n            case Coq_prim_string(s0):\n              var%object l = to_object(vthis);\n              var%some s2 = run_object_method(object_class_, l);\n              return (strappend("[object ", strappend(s2, "]")));\n          }\n          \n        case Coq_value_object(o):\n          var%object l = to_object(vthis);\n          var%some s0 = run_object_method(object_class_, l);\n          return (strappend("[object ", strappend(s0, "]")));\n      }\n      \n    case Coq_prealloc_object_proto_value_of:\n      return (to_object(vthis));\n    case Coq_prealloc_object_proto_has_own_prop:\n      var v = get_arg(0, args);\n      var%string x = to_string(v);\n      var%object l = to_object(vthis);\n      var%run d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (false);\n        case Coq_full_descriptor_some(a):\n          return (true);\n      }\n      \n    case Coq_prealloc_object_proto_is_prototype_of:\n      var v = get_arg(0, args);\n      switch (v) {\n        case Coq_value_prim(p):\n          return (false);\n        case Coq_value_object(l):\n          var%object lo = to_object(vthis);\n          return (object_proto_is_prototype_of(lo, l));\n      }\n      \n    case Coq_prealloc_object_proto_prop_is_enumerable:\n      var v = get_arg(0, args);\n      var%string x = to_string(v);\n      var%object l = to_object(vthis);\n      var%run d = run_object_get_own_prop(l, x);\n      switch (d) {\n        case Coq_full_descriptor_undef:\n          return (false);\n        case Coq_full_descriptor_some(a):\n          return (attributes_enumerable(a));\n      }\n      \n    case Coq_prealloc_function_proto:\n      return (Prim_undef);\n    case Coq_prealloc_function_proto_to_string:\n      if (is_callable_dec(vthis)) {\n        return (\n          function (s) {\n              Debug.not_yet_implemented_because(__LOC__, s);\n              return (Result_not_yet_implemented);}(\n            "Function.prototype.toString() is implementation dependent."));\n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_apply:\n      var thisArg = get_arg(0, args);\n      var argArray = get_arg(1, args);\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_prim(p):\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n          case Coq_value_object(thisobj):\n            switch (argArray) {\n              case Coq_value_prim(p):\n                switch (p) {\n                  case Coq_prim_undef:\n                    return (run_call(thisobj, thisArg, mk_nil));\n                  case Coq_prim_null:\n                    return (run_call(thisobj, thisArg, mk_nil));\n                  case Coq_prim_bool(b0):\n                    return (run_error(Native_error_type));\n                  case Coq_prim_number(n):\n                    return (run_error(Native_error_type));\n                  case Coq_prim_string(s0):\n                    return (run_error(Native_error_type));\n                }\n                \n              case Coq_value_object(array):\n                var%value v = run_object_get(array, "length");\n                var%run ilen = to_uint32(v);\n                var%run arguments_ = run_get_args_for_apply(array, 0., ilen);\n                return (run_call(thisobj, thisArg, arguments_));\n            }\n            \n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_call:\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_prim(p):\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n          case Coq_value_object(thisobj):\n            var (thisArg, a) = get_arg_first_and_rest(args);\n            return (run_call(thisobj, thisArg, a));\n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_function_proto_bind:\n      if (is_callable_dec(vthis)) {\n        switch (vthis) {\n          case Coq_value_prim(p):\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n          case Coq_value_object(thisobj):\n            var (vthisArg, a) = get_arg_first_and_rest(args);\n            var o1 = object_new(Prealloc_object_proto, "Object");\n            var o2 = object_with_get(o1, Builtin_get_function);\n            var o3 = object_with_details(o2, None, None, None, Some(thisobj),\n                       Some(vthisArg), Some(a), None);\n            var o4 = object_set_class(o3, "Function");\n            var o5 = object_set_proto(o4, Prealloc_function_proto);\n            var o6 = object_with_invokation(o5, Some(Construct_after_bind),\n                       Some(Call_after_bind),\n                       Some(Builtin_has_instance_after_bind));\n            var o7 = object_set_extensible(o6, true);\n            var (l, s_2) = object_alloc(o7);\n            var vlength = (function () {\n              var%some class0 = run_object_method(object_class_, thisobj);\n              if (string_eq(class0, "Function")) {\n                var%number n = run_object_get(thisobj, "length");\n                var%run ilen = to_int32(n);\n                if ((ilen < LibList.length(a))) {\n                  return (0.);\n                } else {\n                  return ((ilen - LibList.length(a)));\n                }\n              } else {\n                return (0.);\n              }\n            }())\n            ;\n            var%run length0 = vlength;\n            var a0 = {\n              attributes_data_value: length0,\n              attributes_data_writable: false,\n              attributes_data_enumerable: false,\n              attributes_data_configurable: false\n            };\n            var%some _ = object_heap_map_properties_option(l, function (p) {\n                             return (HeapStr.write(p, "length", a0));});\n            var vthrower = Prealloc_throw_type_error;\n            var a1 = {\n              attributes_accessor_get: vthrower,\n              attributes_accessor_set: vthrower,\n              attributes_accessor_enumerable: false,\n              attributes_accessor_configurable: false\n            };\n            var%bool x = object_define_own_prop(l, "caller",\n                           descriptor_of_attributes(a1), false);\n            var%bool x0 = object_define_own_prop(l, "arguments",\n                            descriptor_of_attributes(a1), false);\n            return (l);\n        }\n        \n      } else {\n        return (run_error(Native_error_type));\n      }\n    case Coq_prealloc_bool:\n      return (\n        (function () {\n          var v = get_arg(0, args);\n          return (convert_value_to_boolean(v));\n        }())\n        );\n    case Coq_prealloc_bool_proto_to_string:\n      switch (vthis) {\n        case Coq_value_prim(p):\n          switch (p) {\n            case Coq_prim_undef:\n              return (run_error(Native_error_type));\n            case Coq_prim_null:\n              return (run_error(Native_error_type));\n            case Coq_prim_bool(b0):\n              return (convert_bool_to_string(b0));\n            case Coq_prim_number(n):\n              return (run_error(Native_error_type));\n            case Coq_prim_string(s0):\n              return (run_error(Native_error_type));\n          }\n          \n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_prim(p):\n                                switch (p) {\n                                  case Coq_prim_undef:\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_null:\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_bool(b0):\n                                    return (convert_bool_to_string(b0));\n                                  case Coq_prim_number(n):\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_string(s1):\n                                    return (run_error(Native_error_type));\n                                }\n                                \n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_bool_proto_value_of:\n      switch (vthis) {\n        case Coq_value_prim(p):\n          switch (p) {\n            case Coq_prim_undef:\n              return (run_error(Native_error_type));\n            case Coq_prim_null:\n              return (run_error(Native_error_type));\n            case Coq_prim_bool(b0):\n              return (b0);\n            case Coq_prim_number(n):\n              return (run_error(Native_error_type));\n            case Coq_prim_string(s0):\n              return (run_error(Native_error_type));\n          }\n          \n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Boolean")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_prim(p):\n                                switch (p) {\n                                  case Coq_prim_undef:\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_null:\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_bool(b0):\n                                    return (b0);\n                                  case Coq_prim_number(n):\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_string(s1):\n                                    return (run_error(Native_error_type));\n                                }\n                                \n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_number:\n      if (list_eq_nil_decidable(args)) {\n        return (JsNumber.zero);\n      } else {\n        var v = get_arg(0, args);return (to_number(v));\n      }\n    case Coq_prealloc_number_proto_value_of:\n      switch (vthis) {\n        case Coq_value_prim(p):\n          switch (p) {\n            case Coq_prim_undef:\n              return (run_error(Native_error_type));\n            case Coq_prim_null:\n              return (run_error(Native_error_type));\n            case Coq_prim_bool(b0):\n              return (run_error(Native_error_type));\n            case Coq_prim_number(n):\n              return (n);\n            case Coq_prim_string(s0):\n              return (run_error(Native_error_type));\n          }\n          \n        case Coq_value_object(l):\n          return (\n            ifx_some_or_default(run_object_method(object_class_, l),\n              run_error(Native_error_type), function (s0) {\n                if (string_eq(s0, "Number")) {\n                  return (\n                    ifx_some_or_default(\n                      run_object_method(object_prim_value_, l),\n                      run_error(Native_error_type), function (wo) {\n                        switch (wo) {\n                          case Some(v):\n                            switch (v) {\n                              case Coq_value_prim(p):\n                                switch (p) {\n                                  case Coq_prim_undef:\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_null:\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_bool(b0):\n                                    return (run_error(Native_error_type));\n                                  case Coq_prim_number(n):\n                                    return (n);\n                                  case Coq_prim_string(s1):\n                                    return (run_error(Native_error_type));\n                                }\n                                \n                              case Coq_value_object(o):\n                                return (run_error(Native_error_type));\n                            }\n                            \n                          case None:\n                            return (run_error(Native_error_type));\n                        }\n                        }));\n                } else {\n                  return (run_error(Native_error_type));\n                }}));\n      }\n      \n    case Coq_prealloc_array:\n      return (run_construct_prealloc(Prealloc_array, args));\n    case Coq_prealloc_array_is_array:\n      var arg = get_arg(0, args);\n      switch (arg) {\n        case Coq_value_prim(p):\n          return (false);\n        case Coq_value_object(arg0):\n          var%some class0 = run_object_method(object_class_, arg0);\n          if (string_eq(class0, "Array")) {\n            return (true);\n          } else {\n            return (false);\n          }\n      }\n      \n    case Coq_prealloc_array_proto_to_string:\n      var%object array = to_object(vthis);\n      var%value vfunc = run_object_get(array, "join");\n      if (is_callable_dec(vfunc)) {\n        switch (vfunc) {\n          case Coq_value_prim(p):\n            return (\n              function (m) {\n                  Debug.impossible_with_heap_because(__LOC__, m);\n                  return (Result_impossible);}(\n                "Value is callable, but isn\'t an object."));\n          case Coq_value_object(func):\n            return (run_call(func, array, mk_nil));\n        }\n        \n      } else {\n        return (\n          run_call_prealloc(Prealloc_object_proto_to_string, array, mk_nil));\n      }\n    case Coq_prealloc_array_proto_join:\n      var vsep = get_arg(0, args);\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%run ilen = to_uint32(vlen);\n      if (!(value_compare(vsep, Prim_undef))) {\n        var rsep = vsep;\n      } else {\n        var rsep = ",";\n      }\n      var%string sep = to_string(rsep);\n      if ((ilen == 0.0)) {\n        return ("");\n      } else {\n        var sR = valueToStringForJoin(l, 0.);\n        var%run sR0 = sR;\n        return (run_array_join_elements(l, 1., ilen, sep, sR0));\n      }\n    case Coq_prealloc_array_proto_pop:\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%run ilen = to_uint32(vlen);\n      if ((ilen == 0.0)) {\n        var%not_throw x = object_put(l, "length", JsNumber.zero, throw_true);\n        return (Prim_undef);\n      } else {\n        var%string sindx = to_string((ilen - 1.));\n        var%value velem = run_object_get(l, sindx);\n        var%not_throw x = object_delete_default(l, sindx, throw_true);\n        var%not_throw x0 = object_put(l, "length", sindx, throw_true);\n        return (velem);\n      }\n    case Coq_prealloc_array_proto_push:\n      var%object l = to_object(vthis);\n      var%value vlen = run_object_get(l, "length");\n      var%run ilen = to_uint32(vlen);\n      return (push(l, args, ilen));\n    case Coq_prealloc_string:\n      if (list_eq_nil_decidable(args)) {\n        return ("");\n      } else {\n        var value0 = get_arg(0, args);\n        var%string s1 = to_string(value0);\n        return (s1);\n      }\n    case Coq_prealloc_string_proto_to_string:\n      switch (vthis) {\n        case Coq_value_prim(p):\n          if (type_compare(type_of(vthis), Type_string)) {\n            return (vthis);\n          } else {\n            return (run_error(Native_error_type));\n          }\n        case Coq_value_object(l):\n          var%some s0 = run_object_method(object_class_, l);\n          if (string_eq(s0, "String")) {\n            return (run_object_prim_value(l));\n          } else {\n            return (run_error(Native_error_type));\n          }\n      }\n      \n    case Coq_prealloc_string_proto_value_of:\n      switch (vthis) {\n        case Coq_value_prim(p):\n          if (type_compare(type_of(vthis), Type_string)) {\n            return (vthis);\n          } else {\n            return (run_error(Native_error_type));\n          }\n        case Coq_value_object(l):\n          var%some s0 = run_object_method(object_class_, l);\n          if (string_eq(s0, "String")) {\n            return (run_object_prim_value(l));\n          } else {\n            return (run_error(Native_error_type));\n          }\n      }\n      \n    case Coq_prealloc_error:\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_error_proto, v));\n    case Coq_prealloc_native_error(ne):\n      var v = get_arg(0, args);\n      return (build_error(Prealloc_native_error_proto(ne), v));\n    case Coq_prealloc_throw_type_error:\n      return (run_error(Native_error_type));\n    default:\n      return (\n        function (s) {\n            Debug.not_yet_implemented_because(__LOC__, s);\n            return (Result_not_yet_implemented);}(\n          strappend("Call prealloc_",\n            strappend(string_of_prealloc(b), " not yet implemented"))));\n  }\n  \n};\n\nvar run_call = function (l, vthis, args) {\n  var%some co = run_object_method(object_call_, l);\n  var%some c0 = co;\n  switch (c0) {\n    case Coq_call_default:\n      return (entering_func_code(l, vthis, args));\n    case Coq_call_after_bind:\n      var%some oarg = run_object_method(object_bound_args_, l);\n      var%some boundArgs = oarg;\n      var%some obnd = run_object_method(object_bound_this_, l);\n      var%some boundThis = obnd;\n      var%some otrg = run_object_method(object_target_function_, l);\n      var%some target = otrg;\n      var arguments_ = LibList.append(boundArgs, args);\n      return (run_call(target, boundThis, arguments_));\n    case Coq_call_prealloc(b):\n      return (run_call_prealloc(b, vthis, args));\n  }\n  \n};\n\nvar run_javascript_from_state = function (p) {\n  var c = execution_ctx_initial(prog_intro_strictness(p));\n  var%void _ = execution_ctx_binding_inst(Codetype_global, None, p, mk_nil);\n  return (run_prog(p));\n};\n\nvar run_javascript_from_result = function (w, p) {\n  var%success _pat_any_5 = w;\n  return (run_javascript_from_state(p));\n};\n\nvar run_javascript = function (p) {\n  return (run_javascript_from_state(p));\n};\n}// end of with Datatypes\n}// end of with JsCommon\n}// end of with JsCommonAux\n}// end of with JsInit\n}// end of with JsInterpreterMonads\n}// end of with JsPreliminary\n}// end of with JsSyntax\n}// end of with JsSyntaxAux\n}// end of with LibList\n}// end of with LibOption\n}// end of with LibProd\n}// end of with Shared\n\nreturn {\n  convert_number_to_bool: convert_number_to_bool, \n  convert_string_to_bool: convert_string_to_bool, \n  convert_prim_to_boolean: convert_prim_to_boolean, \n  convert_value_to_boolean: convert_value_to_boolean, \n  convert_prim_to_number: convert_prim_to_number, \n  convert_number_to_integer: convert_number_to_integer, \n  convert_bool_to_string: convert_bool_to_string, \n  convert_prim_to_string: convert_prim_to_string, \n  equality_test_for_same_type: equality_test_for_same_type, \n  strict_equality_test: strict_equality_test, \n  inequality_test_number: inequality_test_number, \n  inequality_test_string: inequality_test_string, \n  inequality_test_primitive: inequality_test_primitive, \n  typeof_prim: typeof_prim, \n  string_of_propname: string_of_propname, \n  run_object_method: run_object_method, \n  run_object_heap_set_extensible: run_object_heap_set_extensible, \n  object_has_prop: object_has_prop, \n  build_error: build_error, \n  run_error: run_error, \n  out_error_or_void: out_error_or_void, \n  out_error_or_cst: out_error_or_cst, \n  object_get_builtin: object_get_builtin, \n  run_object_get: run_object_get, \n  run_object_get_prop: run_object_get_prop, \n  object_proto_is_prototype_of: object_proto_is_prototype_of, \n  object_default_value: object_default_value, \n  to_primitive: to_primitive, \n  to_number: to_number, \n  to_integer: to_integer, \n  to_int32: to_int32, \n  to_uint32: to_uint32, \n  to_string: to_string, \n  object_can_put: object_can_put, \n  run_object_define_own_prop_array_loop: run_object_define_own_prop_array_loop, \n  object_define_own_prop: object_define_own_prop, \n  run_to_descriptor: run_to_descriptor, \n  prim_new_object: prim_new_object, \n  to_object: to_object, \n  run_object_prim_value: run_object_prim_value, \n  prim_value_get: prim_value_get, \n  env_record_has_binding: env_record_has_binding, \n  lexical_env_get_identifier_ref: lexical_env_get_identifier_ref, \n  object_delete_default: object_delete_default, \n  object_delete: object_delete, \n  env_record_delete_binding: env_record_delete_binding, \n  env_record_implicit_this_value: env_record_implicit_this_value, \n  identifier_resolution: identifier_resolution, \n  env_record_get_binding_value: env_record_get_binding_value, \n  ref_get_value: ref_get_value, \n  run_expr_get_value: run_expr_get_value, \n  object_put_complete: object_put_complete, \n  object_put: object_put, \n  env_record_set_mutable_binding: env_record_set_mutable_binding, \n  prim_value_put: prim_value_put, \n  ref_put_value: ref_put_value, \n  env_record_create_mutable_binding: env_record_create_mutable_binding, \n  env_record_create_set_mutable_binding: env_record_create_set_mutable_binding, \n  env_record_create_immutable_binding: env_record_create_immutable_binding, \n  env_record_initialize_immutable_binding: env_record_initialize_immutable_binding, \n  call_object_new: call_object_new, \n  array_args_map_loop: array_args_map_loop, \n  string_of_prealloc: string_of_prealloc, \n  run_construct_prealloc: run_construct_prealloc, \n  run_construct_default: run_construct_default, \n  run_construct: run_construct, \n  run_call_default: run_call_default, \n  creating_function_object_proto: creating_function_object_proto, \n  creating_function_object: creating_function_object, \n  binding_inst_formal_params: binding_inst_formal_params, \n  binding_inst_function_decls: binding_inst_function_decls, \n  make_arg_getter: make_arg_getter, \n  make_arg_setter: make_arg_setter, \n  arguments_object_map_loop: arguments_object_map_loop, \n  arguments_object_map: arguments_object_map, \n  create_arguments_object: create_arguments_object, \n  binding_inst_arg_obj: binding_inst_arg_obj, \n  binding_inst_var_decls: binding_inst_var_decls, \n  execution_ctx_binding_inst: execution_ctx_binding_inst, \n  entering_func_code: entering_func_code, \n  run_object_get_own_prop: run_object_get_own_prop, \n  run_function_has_instance: run_function_has_instance, \n  run_object_has_instance: run_object_has_instance, \n  from_prop_descriptor: from_prop_descriptor, \n  run_equal: run_equal, \n  convert_twice: convert_twice, \n  convert_twice_primitive: convert_twice_primitive, \n  convert_twice_number: convert_twice_number, \n  convert_twice_string: convert_twice_string, \n  issome: issome, \n  run_binary_op_add: run_binary_op_add, \n  run_binary_op_arith: run_binary_op_arith, \n  run_binary_op_shift: run_binary_op_shift, \n  run_binary_op_bitwise: run_binary_op_bitwise, \n  run_binary_op_compare: run_binary_op_compare, \n  run_binary_op_instanceof: run_binary_op_instanceof, \n  run_binary_op_in: run_binary_op_in, \n  run_binary_op: run_binary_op, \n  run_prepost_op: run_prepost_op, \n  run_typeof_value: run_typeof_value, \n  run_unary_op: run_unary_op, \n  create_new_function_in: create_new_function_in, \n  init_object: init_object, \n  run_array_element_list: run_array_element_list, \n  init_array: init_array, \n  run_var_decl_item: run_var_decl_item, \n  run_var_decl: run_var_decl, \n  run_list_expr: run_list_expr, \n  run_block: run_block, \n  run_binary_op_and: run_binary_op_and, \n  run_binary_op_or: run_binary_op_or, \n  run_expr_binary_op: run_expr_binary_op, \n  run_expr_access: run_expr_access, \n  run_expr_assign: run_expr_assign, \n  run_expr_function: run_expr_function, \n  entering_eval_code: entering_eval_code, \n  run_eval: run_eval, \n  run_expr_call: run_expr_call, \n  run_expr_conditionnal: run_expr_conditionnal, \n  run_expr_new: run_expr_new, \n  run_stat_label: run_stat_label, \n  run_stat_with: run_stat_with, \n  run_stat_if: run_stat_if, \n  run_stat_while: run_stat_while, \n  run_stat_switch_end: run_stat_switch_end, \n  run_stat_switch_no_default: run_stat_switch_no_default, \n  run_stat_switch_with_default_default: run_stat_switch_with_default_default, \n  run_stat_switch_with_default_B: run_stat_switch_with_default_B, \n  run_stat_switch_with_default_A: run_stat_switch_with_default_A, \n  run_stat_switch: run_stat_switch, \n  run_stat_do_while: run_stat_do_while, \n  run_stat_try: run_stat_try, \n  run_stat_throw: run_stat_throw, \n  run_stat_return: run_stat_return, \n  run_stat_for_loop: run_stat_for_loop, \n  run_stat_for: run_stat_for, \n  run_stat_for_var: run_stat_for_var, \n  run_expr: run_expr, \n  run_stat: run_stat, \n  run_elements: run_elements, \n  run_prog: run_prog, \n  push: push, \n  run_object_is_sealed: run_object_is_sealed, \n  run_object_seal: run_object_seal, \n  run_object_freeze: run_object_freeze, \n  run_object_is_frozen: run_object_is_frozen, \n  run_get_args_for_apply: run_get_args_for_apply, \n  valueToStringForJoin: valueToStringForJoin, \n  run_array_join_elements: run_array_join_elements, \n  run_call_prealloc: run_call_prealloc, \n  run_call: run_call, \n  run_javascript_from_state: run_javascript_from_state, \n  run_javascript_from_result: run_javascript_from_result, \n  run_javascript: run_javascript};\n})();\n'},

/* --------------------- JsInterpreter.ml --------------------- */
  { file: 'JsInterpreter.ml', contents: 'open Datatypes\nopen JsCommon\nopen JsCommonAux\nopen JsInit\nopen JsInterpreterMonads\nopen JsPreliminary\nopen JsSyntax\nopen JsSyntaxAux\nopen LibList\nopen LibOption\nopen LibProd\nopen Shared\n\n(*------------JS preliminary -----------*)\n\n(** val convert_number_to_bool : number -> bool **)\n\nlet convert_number_to_bool n =\n  if    (JsNumber.isposzero n)\n     || (JsNumber.isnegzero n)\n     || (JsNumber.isnan n)\n  then false\n  else true\n\n(** val convert_string_to_bool : string -> bool **)\n\nlet convert_string_to_bool s =\n  if string_eq s "" then false else true\n  (* Arthur hack string.empty *)\n\n(** val convert_prim_to_boolean : prim -> bool **)\n\nlet convert_prim_to_boolean _foo_ = match _foo_ with\n| Coq_prim_undef -> false\n| Coq_prim_null -> false\n| Coq_prim_bool b -> b\n| Coq_prim_number n -> convert_number_to_bool n\n| Coq_prim_string s -> convert_string_to_bool s\n\n(** val convert_value_to_boolean : value -> bool **)\n\nlet convert_value_to_boolean _foo_ = match _foo_ with\n| Coq_value_prim p -> convert_prim_to_boolean p\n| Coq_value_object o -> true\n\n(** val convert_prim_to_number : prim -> number **)\n\nlet convert_prim_to_number _foo_ = match _foo_ with\n| Coq_prim_undef -> JsNumber.nan\n| Coq_prim_null -> JsNumber.zero\n| Coq_prim_bool b -> if b then JsNumber.one else JsNumber.zero\n| Coq_prim_number n -> n\n| Coq_prim_string s -> JsNumber.from_string s\n\n(** val convert_number_to_integer : number -> number **)\n\nlet convert_number_to_integer n =\n  if JsNumber.isnan n\n  then JsNumber.zero\n  else if   (JsNumber.isposzero n)\n         || (JsNumber.isnegzero n)\n         || (n === JsNumber.infinity)\n         || (n === JsNumber.neg_infinity)\n       then n\n       else  (JsNumber.sign n) *. (JsNumber.floor (JsNumber.absolute n))\n\n(** val convert_bool_to_string : bool -> string **)\n\nlet convert_bool_to_string _foo_ = match _foo_ with\n| true -> "true"\n| false -> "false"\n\n(** val convert_prim_to_string : prim -> string **)\n\nlet convert_prim_to_string _foo_ = match _foo_ with\n| Coq_prim_undef ->\n  "undefined"\n| Coq_prim_null -> "null"\n| Coq_prim_bool b -> convert_bool_to_string b\n| Coq_prim_number n -> JsNumber.to_string n\n| Coq_prim_string s -> s\n\n(** val equality_test_for_same_type : coq_type -> value -> value -> bool **)\n\nlet equality_test_for_same_type ty v1 v2 =\n  match ty with\n  | Coq_type_undef -> true\n  | Coq_type_null -> true\n  | Coq_type_bool -> value_compare v1 v2\n  | Coq_type_number ->\n    (match v1 with\n     | Coq_value_prim p ->\n       (match p with\n        | Coq_prim_undef -> false\n        | Coq_prim_null -> false\n        | Coq_prim_bool b -> false\n        | Coq_prim_number n1 ->\n          (match v2 with\n           | Coq_value_prim p0 ->\n             (match p0 with\n              | Coq_prim_undef -> false\n              | Coq_prim_null -> false\n              | Coq_prim_bool b -> false\n              | Coq_prim_number n2 ->\n                if JsNumber.isnan n1\n                then false\n                else if JsNumber.isnan n2\n                     then false\n                     else if   (JsNumber.isposzero n1)\n                            && (JsNumber.isnegzero n2)\n                          then true\n                          else if   (JsNumber.isnegzero n1)\n                                &&  (JsNumber.isposzero n2)\n                               then true\n                               else n1 === n2\n              | Coq_prim_string s -> false)\n           | Coq_value_object o -> false)\n        | Coq_prim_string s -> false)\n     | Coq_value_object o -> false)\n  | Coq_type_string -> value_compare v1 v2\n  | Coq_type_object -> value_compare v1 v2\n\n(** val strict_equality_test : value -> value -> bool **)\n\nlet strict_equality_test v1 v2 =\n  let ty1 = type_of v1 in\n  let ty2 = type_of v2 in\n  if type_compare ty1 ty2\n  then equality_test_for_same_type ty1 v1 v2\n  else false\n\n(** val inequality_test_number : number -> number -> prim **)\n\nlet inequality_test_number n1 n2 =\n  if (JsNumber.isnan n1) || (JsNumber.isnan n2)\n  then Coq_prim_undef\n  else if n1 === n2\n       then Coq_prim_bool false\n       else if   (JsNumber.isposzero n1)\n              && (JsNumber.isnegzero n2)\n            then Coq_prim_bool false\n            else if (JsNumber.isnegzero n1)\n                 && (JsNumber.isposzero n2)\n                 then Coq_prim_bool false\n                 else if n1 === JsNumber.infinity\n                      then Coq_prim_bool false\n                      else if n2 === JsNumber.infinity\n                           then Coq_prim_bool true\n                           else if n2 === JsNumber.neg_infinity\n                                then Coq_prim_bool false\n                                else if n1 === JsNumber.neg_infinity\n                                     then Coq_prim_bool true\n                                     else Coq_prim_bool (n1 < n2)\n\n(** val inequality_test_string : string -> string -> bool **)\n\n(* ARTHUR hack \nlet rec inequality_test_string s1 s2 =\n  match s1 with\n  | [] ->\n    (match s2 with\n     | [] -> false\n     | a::s -> true)\n  | c1::s1_2 ->\n    (match s2 with\n     | [] -> false\n     | c2::s2_2 ->\n       if ascii_comparable c1 c2\n       then inequality_test_string s1_2 s2_2\n       else lt_int_decidable (int_of_char c1) (int_of_char c2))\n*)\nlet inequality_test_string s1 s2 = string_lt s1 s2\n\n\n(** val inequality_test_primitive : prim -> prim -> prim **)\n\nlet inequality_test_primitive w1 w2 =\n  match w1 with\n  | Coq_prim_undef ->\n    inequality_test_number (convert_prim_to_number w1)\n      (convert_prim_to_number w2)\n  | Coq_prim_null ->\n    inequality_test_number (convert_prim_to_number w1)\n      (convert_prim_to_number w2)\n  | Coq_prim_bool b ->\n    inequality_test_number (convert_prim_to_number w1)\n      (convert_prim_to_number w2)\n  | Coq_prim_number n ->\n    inequality_test_number (convert_prim_to_number w1)\n      (convert_prim_to_number w2)\n  | Coq_prim_string s1 ->\n    (match w2 with\n     | Coq_prim_undef ->\n       inequality_test_number (convert_prim_to_number w1)\n         (convert_prim_to_number w2)\n     | Coq_prim_null ->\n       inequality_test_number (convert_prim_to_number w1)\n         (convert_prim_to_number w2)\n     | Coq_prim_bool b ->\n       inequality_test_number (convert_prim_to_number w1)\n         (convert_prim_to_number w2)\n     | Coq_prim_number n ->\n       inequality_test_number (convert_prim_to_number w1)\n         (convert_prim_to_number w2)\n     | Coq_prim_string s2 -> Coq_prim_bool (inequality_test_string s1 s2))\n\n(** val typeof_prim : prim -> string **)\n\nlet typeof_prim _foo_ = match _foo_ with\n| Coq_prim_undef ->\n  "undefined"\n| Coq_prim_null -> "object"\n| Coq_prim_bool b -> "boolean"\n| Coq_prim_number n -> "number"\n| Coq_prim_string s -> "string"\n\n(** val string_of_propname : propname -> prop_name **)\n\nlet string_of_propname _foo_ = match _foo_ with\n| Coq_propname_identifier s -> s\n| Coq_propname_string s -> s\n| Coq_propname_number n -> JsNumber.to_string n\n\n(*---------------------------------*)\n\n\n(** val run_object_method :\n    (coq_object -> \'a1) -> state -> object_loc -> \'a1 option **)\n\nlet run_object_method proj s l =\n  LibOption.map proj (object_binds_option s l)\n\n(*---DEBUG\n  let run_object_method proj s l =\n   let opt = object_binds_option s l in\n     begin match opt with\n       | None -> Debug.run_object_method l\n       | _ -> ()\n     end;\n     LibOption.map proj opt\n*)\n\n\n(** val run_object_heap_set_extensible :\n    bool -> state -> object_loc -> state option **)\n\nlet run_object_heap_set_extensible b s l =\n  LibOption.map (fun o -> object_write s l (object_set_extensible o b))\n    (object_binds_option s l)\n\n(* DEBUG\n   let run_object_heap_set_extensible b s l =\n   let opt = object_binds_option s l in\n     begin match opt with\n       | None -> Debug.run_object_heap_set_extensible l\n       | _ -> ()\n     end;\n     LibOption.map (fun o -> object_write s l (object_set_extensible o b)) opt\n*)\n\n(** val object_has_prop :\n    state -> execution_ctx -> object_loc -> prop_name -> result **)\n\nlet rec object_has_prop s c l x =\n  let%some b = (run_object_method object_has_prop_ s l) in\n  match b with Coq_builtin_has_prop_default ->\n    let%run (s1, d) = (run_object_get_prop s c l x) in\n    res_ter s1\n      (res_val (Coq_value_prim (Coq_prim_bool\n                                  (not\n                                     (full_descriptor_compare d Coq_full_descriptor_undef)))))\n\n(** val build_error : state -> value -> value -> result **)\n\nand build_error s c vproto vmsg =\n  let o = object_new vproto ("Error") in\n  let (l, s_2) = object_alloc s o in\n  if value_compare vmsg (Coq_value_prim Coq_prim_undef)\n  then result_out (Coq_out_ter (s_2, (res_val (Coq_value_object l))))\n  else (\n    let%value (s_3, vstr) = to_string s_2 c vmsg in\n    let a = { attributes_data_value = vstr; attributes_data_writable = true;\n      attributes_data_enumerable = false; attributes_data_configurable = true } in\n    let%success (s_4, rv) = object_define_own_prop s_3 c l "message" (descriptor_of_attributes (Coq_attributes_data_of a)) throw_true in\n    result_out (Coq_out_ter (s_4, (res_val (Coq_value_object l))))\n  )\n\n(** val run_error : state -> native_error -> \'a1 specres **)\n\nand run_error s c ne =\n  let%object (s_2, l) = (build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                                            (Coq_prealloc_native_error_proto ne))) (Coq_value_prim Coq_prim_undef)) in\n  Coq_result_some (Coq_specret_out (Coq_out_ter (s_2,\n                                                 (res_throw (Coq_resvalue_value (Coq_value_object l))))))\n\n(** val out_error_or_void :\n    state -> strictness_flag -> native_error -> result **)\n\nand out_error_or_void s c str ne =\n  if str then run_error s c ne else result_out (out_void s)\n\n(** val out_error_or_cst :\n    state -> strictness_flag -> native_error -> value -> result **)\n\nand out_error_or_cst s c str ne v =\n  if str then run_error s c ne else result_out (Coq_out_ter (s, (res_val v)))\n\n(** val object_get_builtin :\n    state -> execution_ctx -> builtin_get -> value -> object_loc\n    -> prop_name -> result **)\n\nand object_get_builtin s c b vthis l x =\n  let def s0 l0 =\n    let%run (s1, d) = (run_object_get_prop s0 c l0 x) in\n    match d with\n    | Coq_full_descriptor_undef ->\n      res_ter s1 (res_val (Coq_value_prim Coq_prim_undef))\n    | Coq_full_descriptor_some a ->\n      (match a with\n       | Coq_attributes_data_of ad ->\n         res_ter s1 (res_val ad.attributes_data_value)\n       | Coq_attributes_accessor_of aa ->\n         (match aa.attributes_accessor_get with\n          | Coq_value_prim p ->\n            (match p with\n             | Coq_prim_undef ->\n               res_ter s1 (res_val (Coq_value_prim Coq_prim_undef))\n             | Coq_prim_null -> Coq_result_impossible\n             | Coq_prim_bool b0 -> Coq_result_impossible\n             | Coq_prim_number n -> Coq_result_impossible\n             | Coq_prim_string s2 -> Coq_result_impossible)\n          | Coq_value_object lf -> run_call s1 c lf vthis [])) in\n  let function0 s0 =\n    let%value (s_2, v) = (def s0 l) in\n    if spec_function_get_error_case_dec s_2 x v\n    then run_error s_2 c Coq_native_error_type\n    else res_ter s_2 (res_val v) in\n  match b with\n  | Coq_builtin_get_default -> def s l\n  | Coq_builtin_get_function -> function0 s\n  | Coq_builtin_get_args_obj ->\n    let%some lmapo = (run_object_method object_parameter_map_ s l) in\n    let%some lmap = (lmapo) in\n    let%run (s0, d) = (run_object_get_own_prop s c lmap x) in\n    match d with\n    | Coq_full_descriptor_undef -> function0 s0\n    | Coq_full_descriptor_some a -> run_object_get s0 c lmap x\n\n(** val run_object_get :\n    state -> execution_ctx -> object_loc -> prop_name -> result **)\n\nand run_object_get s c l x =\n  let%some b = (run_object_method object_get_ s l) in\n  object_get_builtin s c b (Coq_value_object l) l x\n\n(** val run_object_get_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    full_descriptor specres **)\n\nand run_object_get_prop s c l x =\n  let%some b = (run_object_method object_get_prop_ s l) in\n  match b with Coq_builtin_get_prop_default ->\n    let%run (s1, d) = (run_object_get_own_prop s c l x) in\n    if full_descriptor_compare d Coq_full_descriptor_undef\n    then let%some proto = (run_object_method object_proto_ s1 l) in\n      match proto with\n      | Coq_value_prim p ->\n        (match p with\n         | Coq_prim_null -> res_spec s1 Coq_full_descriptor_undef\n         | _ ->\n           (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n             s1\n             ("Found a non-null primitive value as a prototype in [run_object_get_prop]."))\n      | Coq_value_object lproto ->\n        run_object_get_prop s1 c lproto x\n    else res_spec s1 d\n\n(** val object_proto_is_prototype_of :\n    state -> object_loc -> object_loc -> result **)\n\nand object_proto_is_prototype_of s l0 l =\n  let%some b = (run_object_method object_proto_ s l) in\n  match b with\n  | Coq_value_prim p ->\n    (match p with\n     | Coq_prim_null ->\n       result_out (Coq_out_ter (s,\n                                (res_val (Coq_value_prim (Coq_prim_bool false)))))\n     | _ ->\n       (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n         s\n         ("[run_object_method] returned a primitive in [object_proto_is_prototype_of_body]."))\n  | Coq_value_object l_2 ->\n    if object_loc_compare l_2 l0\n    then result_out (Coq_out_ter (s,\n                                  (res_val (Coq_value_prim (Coq_prim_bool true)))))\n    else object_proto_is_prototype_of s l0 l_2\n\n(** val object_default_value :\n    state -> execution_ctx -> object_loc -> preftype option ->\n    result **)\n\nand object_default_value s c l prefo =\n  let%some b = (run_object_method object_default_value_ s l) in\n  match b with Coq_builtin_default_value_default ->\n    let gpref = unsome_default Coq_preftype_number prefo in\n    let lpref = other_preftypes gpref in\n    let sub0 s_2 x k =\n      let%value (s1, vfo) = (run_object_get s_2 c l x) in\n      let%some co = (run_callable s1 vfo) in\n      match co with\n      | Some b0 ->\n        let%object (s2, lfunc) = (result_out (Coq_out_ter (s1, (res_val vfo)))) in\n        let%value (s3, v) = (run_call s2 c lfunc (Coq_value_object l) []) in begin\n          match v with\n          | Coq_value_prim w ->\n            result_out (Coq_out_ter (s3, (res_val (Coq_value_prim w))))\n          | Coq_value_object l0 -> k s3\n        end\n      | None -> k s1 in\n    let gmeth = (method_of_preftype gpref) in\n    sub0 s gmeth (fun s_2 ->\n        let lmeth = method_of_preftype lpref in\n        sub0 s_2 lmeth (fun s_3 -> run_error s_3 c Coq_native_error_type))\n\n(** val to_primitive :\n    state -> execution_ctx -> value -> preftype option -> result **)\n\nand to_primitive s c v prefo =\n  match v with\n  | Coq_value_prim w ->\n    result_out (Coq_out_ter (s, (res_val (Coq_value_prim w))))\n  | Coq_value_object l ->\n    let%prim (s0, r) = (object_default_value s c l prefo) in\n    res_ter s0 (res_val (Coq_value_prim r))\n\n(** val to_number :\n    state -> execution_ctx -> value -> result **)\n\nand to_number s c _foo_ = match _foo_ with\n  | Coq_value_prim w ->\n    result_out (Coq_out_ter (s, (res_val (Coq_value_prim (Coq_prim_number (convert_prim_to_number w))))))\n  | Coq_value_object l ->\n    let%prim (s1, w) = (to_primitive s c (Coq_value_object l) (Some Coq_preftype_number)) in\n    res_ter s1 (res_val (Coq_value_prim (Coq_prim_number (convert_prim_to_number w))))\n\n(** val to_integer :\n    state -> execution_ctx -> value -> result **)\n\nand to_integer s c v =\n  let%number (s1, n) = to_number s c v in\n  res_ter s1\n    (res_val (Coq_value_prim (Coq_prim_number\n                                (convert_number_to_integer n))))\n\n(** val to_int32 :\n    state -> execution_ctx -> value -> float specres **)\n\nand to_int32 s c v =\n  let%number (s_2, n) = to_number s c v in res_spec s_2 (JsNumber.to_int32 n)\n\n(** val to_uint32 :\n    state -> execution_ctx -> value -> float specres **)\n\nand to_uint32 s c v =\n  let%number (s_2, n) = to_number s c v in res_spec s_2 (JsNumber.to_uint32 n)\n\n(** val to_string :\n    state -> execution_ctx -> value -> result **)\n\nand to_string s c _foo_ = match _foo_ with\n  | Coq_value_prim w ->\n    result_out (Coq_out_ter (s,\n                             (res_val (Coq_value_prim (Coq_prim_string (convert_prim_to_string w))))))\n  | Coq_value_object l ->\n    let%prim (s1, w) = (to_primitive s c (Coq_value_object l) (Some Coq_preftype_string)) in\n    res_ter s1\n      (res_val (Coq_value_prim (Coq_prim_string (convert_prim_to_string w))))\n\n(** val object_can_put :\n    state -> execution_ctx -> object_loc -> prop_name -> result **)\n\nand object_can_put s c l x =\n  let%some b = (run_object_method object_can_put_ s l) in\n  match b with Coq_builtin_can_put_default ->\n    let%run (s1, d) = (run_object_get_own_prop s c l x) in begin\n      match d with\n      | Coq_full_descriptor_undef ->\n        let%some vproto = (run_object_method object_proto_ s1 l) in begin\n          match vproto with\n          | Coq_value_prim p ->\n            (match p with\n             | Coq_prim_null ->\n               let%some b0= (run_object_method object_extensible_ s1 l) in\n               res_ter s1 (res_val (Coq_value_prim (Coq_prim_bool b0)))\n             | _ ->\n               (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                 s1\n                 ("Non-null primitive get as a prototype value in [object_can_put]."))\n          | Coq_value_object lproto ->\n            let%run (s2, d_2) = (run_object_get_prop s1 c lproto x) in\n            match d_2 with\n            | Coq_full_descriptor_undef ->\n              let%some b0= (run_object_method object_extensible_ s2 l) in\n              res_ter s2 (res_val (Coq_value_prim (Coq_prim_bool b0)))\n            | Coq_full_descriptor_some a ->\n              (match a with\n               | Coq_attributes_data_of ad ->\n                 let%some ext = (run_object_method object_extensible_ s2 l) in\n                 res_ter s2\n                   (if ext\n                    then res_val (Coq_value_prim (Coq_prim_bool\n                                                    ad.attributes_data_writable))\n                    else res_val (Coq_value_prim (Coq_prim_bool false)))\n               | Coq_attributes_accessor_of aa ->\n                 res_ter s2\n                   (res_val (Coq_value_prim (Coq_prim_bool\n                                               (not\n                                                  (value_compare aa.attributes_accessor_set\n                                                     (Coq_value_prim Coq_prim_undef)))))))\n        end\n      | Coq_full_descriptor_some a ->\n        (match a with\n         | Coq_attributes_data_of ad ->\n           res_ter s1\n             (res_val (Coq_value_prim (Coq_prim_bool\n                                         ad.attributes_data_writable)))\n         | Coq_attributes_accessor_of aa ->\n           res_ter s1\n             (res_val (Coq_value_prim (Coq_prim_bool\n                                         (not\n                                            (value_compare aa.attributes_accessor_set (Coq_value_prim\n                                                                                            Coq_prim_undef)))))))\n    end\n\n(** val run_object_define_own_prop_array_loop :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    descriptor -> bool -> bool -> (state -> prop_name -> descriptor ->\n    strictness_flag -> __ specres) -> result **)\n\nand run_object_define_own_prop_array_loop s c l newLen oldLen newLenDesc newWritable throwcont def =\n  if newLen < oldLen\n  then let oldLen_2 = (oldLen -. 1.) in\n    let%string (s0, slen) = (to_string s c (Coq_value_prim (Coq_prim_number oldLen_2))) in\n    let%bool (s1, deleteSucceeded) = (object_delete s0 c l slen false) in\n    if not deleteSucceeded\n    then let newLenDesc0 =\n           (descriptor_with_value\n              newLenDesc\n              (Some (Coq_value_prim\n                       (Coq_prim_number (oldLen_2 +. 1.))))) in\n      let newLenDesc1 = (if not newWritable\n                         then descriptor_with_writable newLenDesc0 (Some false)\n                         else newLenDesc0) in\n      let%bool (s2, x) = (def s1 ("length")\n                            newLenDesc1 false) in\n      out_error_or_cst s2 c throwcont Coq_native_error_type\n        (Coq_value_prim (Coq_prim_bool false))\n    else run_object_define_own_prop_array_loop s1 c l\n        newLen oldLen_2 newLenDesc newWritable throwcont def\n  else if not newWritable\n  then def s ("length")\n      { descriptor_value = None; descriptor_writable = (Some false);\n        descriptor_get = None; descriptor_set = None;\n        descriptor_enumerable = None; descriptor_configurable = None }\n      false\n  else res_ter s (res_val (Coq_value_prim (Coq_prim_bool true)))\n\n(** val object_define_own_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    descriptor -> strictness_flag -> result **)\n\nand object_define_own_prop s c l x desc throwcont =\n  let reject s0 throwcont0 =\n    out_error_or_cst\n      s0 c throwcont0 Coq_native_error_type (Coq_value_prim\n                                             (Coq_prim_bool false)) in\n  let def s0 x0 desc0 throwcont0 =\n    let%run (s1, d) = (run_object_get_own_prop s0 c l x0) in\n    let%some ext = (run_object_method object_extensible_ s1 l) in\n    match d with\n    | Coq_full_descriptor_undef ->\n      if ext\n      then let a = (if (descriptor_is_generic_dec desc0) || (descriptor_is_data_dec desc0)\n                    then Coq_attributes_data_of\n                        (attributes_data_of_descriptor desc0)\n                    else Coq_attributes_accessor_of\n                        (attributes_accessor_of_descriptor desc0)) in\n        let%some s2 = (object_heap_map_properties_option s1 l\n                         (fun p -> HeapStr.write p x0 a)) in\n        res_ter s2\n          (res_val (Coq_value_prim (Coq_prim_bool true)))\n      else reject s1 throwcont0\n    | Coq_full_descriptor_some a ->\n      let object_define_own_prop_write s2 a0 =\n          let a_2 = attributes_update a0 desc0 in\n          let%some s3 = (object_heap_map_properties_option s2 l (fun p -> HeapStr.write p x0 a_2)) in\n          res_ter s3 (res_val (Coq_value_prim (Coq_prim_bool true))) in\n      if descriptor_contains_dec (descriptor_of_attributes a) desc0\n      then res_ter s1 (res_val (Coq_value_prim (Coq_prim_bool true)))\n      else if attributes_change_enumerable_on_non_configurable_dec a desc0\n      then reject s1 throwcont0\n      else if descriptor_is_generic_dec desc0\n      then object_define_own_prop_write s1 a\n      else if not (bool_eq (attributes_is_data_dec a) (descriptor_is_data_dec desc0))\n      then if attributes_configurable a\n        then let a_2 = (match a with\n            | Coq_attributes_data_of ad ->\n              Coq_attributes_accessor_of (attributes_accessor_of_attributes_data ad)\n            | Coq_attributes_accessor_of aa ->\n              Coq_attributes_data_of (attributes_data_of_attributes_accessor aa)) in\n          let%some s2 = (object_heap_map_properties_option\n                           s1 l (fun p -> HeapStr.write p x0 a_2)) in\n          object_define_own_prop_write s2 a_2\n        else reject s1 throwcont0\n      else if (attributes_is_data_dec a) && (descriptor_is_data_dec desc0)\n      then (match a with\n          | Coq_attributes_data_of ad ->\n            if attributes_change_data_on_non_configurable_dec ad desc0\n            then reject s1 throwcont0\n            else object_define_own_prop_write s1 a\n          | Coq_attributes_accessor_of a0 ->\n            (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n              s0\n              ("data is not accessor in [defineOwnProperty]"))\n      else if (not (attributes_is_data_dec a)) && (descriptor_is_accessor_dec desc0)\n      then (match a with\n          | Coq_attributes_data_of a0 ->\n            (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n              s0\n              ("accessor is not data in [defineOwnProperty]")\n          | Coq_attributes_accessor_of aa ->\n            if attributes_change_accessor_on_non_configurable_dec aa desc0\n            then reject s1 throwcont0\n            else object_define_own_prop_write s1 a)\n      else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s0\n          ("cases are mutually exclusives in [defineOwnProperty]") in\n  let%some b = (run_object_method object_define_own_prop_ s l) in\n  match b with\n  | Coq_builtin_define_own_prop_default -> def s x desc throwcont\n  | Coq_builtin_define_own_prop_array ->\n    let%run (s0, d) = (run_object_get_own_prop s c l ("length")) in begin\n      match d with\n      | Coq_full_descriptor_undef ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s0\n          ("Array length property descriptor cannot be undefined.")\n      | Coq_full_descriptor_some attr ->\n        (match attr with\n         | Coq_attributes_data_of a ->\n           let  oldLen = (a.attributes_data_value) in begin\n             match oldLen with\n             | Coq_value_prim w ->\n               let oldLen0 = (JsNumber.to_uint32 (convert_prim_to_number w)) in\n               let descValueOpt = (desc.descriptor_value) in\n               if string_eq x ("length")\n               then (match descValueOpt with\n                   | Some descValue ->\n                     let%run (s1, newLen) = (to_uint32 s0 c descValue) in\n                     let%number (s2, newLenN) = to_number s1 c descValue in\n                     if not (newLen === newLenN)\n                     then run_error s2 c Coq_native_error_range\n                     else let newLenDesc =\n                            (descriptor_with_value desc (Some (Coq_value_prim (Coq_prim_number newLen)))) in\n                       if le_int_decidable oldLen0 newLen\n                       then def s2 ("length") newLenDesc throwcont\n                       else if not a.attributes_data_writable\n                       then reject s2 throwcont\n                       else let newWritable = (match newLenDesc.descriptor_writable with\n                           | Some b0 -> if b0 then true else false\n                           | None -> true) in\n                         let newLenDesc0 = (if not newWritable\n                                            then descriptor_with_writable newLenDesc (Some true)\n                                            else newLenDesc) in\n                         let%bool (s3, succ) = (def s2 ("length") newLenDesc0 throwcont) in\n                         if not succ\n                         then res_ter s3 (res_val (Coq_value_prim (Coq_prim_bool false)))\n                         else run_object_define_own_prop_array_loop s3 c l newLen oldLen0 newLenDesc0 newWritable throwcont def\n                   | None -> def s0 ("length") desc throwcont)\n               else let%run (s1, ilen) = (to_uint32 s0 c (Coq_value_prim (Coq_prim_string x))) in\n                 let%string (s2, slen) = (to_string s1 c (Coq_value_prim (Coq_prim_number ilen))) in\n                 if (string_eq x slen) && (not ( ilen = 4294967295.))\n                 then let%run (s3, index) = (to_uint32 s2 c (Coq_value_prim (Coq_prim_string x))) in\n                   if  (le_int_decidable oldLen0 index) && (not a.attributes_data_writable)\n                   then reject s3 throwcont\n                   else let%bool (s4, b0) = (def s3 x desc false) in\n                     if not b0\n                     then reject s4 throwcont\n                     else if le_int_decidable oldLen0 index\n                     then let a0 =\n                            descriptor_with_value (descriptor_of_attributes (Coq_attributes_data_of a))\n                              (Some (Coq_value_prim (Coq_prim_number (index +. 1.)))) in\n                       def s4 ("length") a0 false\n                     else res_ter s4 (res_val (Coq_value_prim (Coq_prim_bool true)))\n                 else def s2 x desc throwcont\n             | Coq_value_object l0 ->\n               (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                 s0\n                 ("Spec asserts length of array is number.")\n           end\n         | Coq_attributes_accessor_of a ->\n           (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n             s0\n             ("Array length property descriptor cannot be accessor."))\n    end\n  | Coq_builtin_define_own_prop_args_obj ->\n    let%some lmapo = (run_object_method object_parameter_map_ s l) in\n    let%some lmap = (lmapo) in\n    let%run (s0, d) = (run_object_get_own_prop s c lmap x) in\n    let%bool (s1, b0) = (def s0 x desc false) in\n    if b0\n    then let follow s2 = res_ter s2 (res_val (Coq_value_prim (Coq_prim_bool true))) in\n      match d with\n      | Coq_full_descriptor_undef -> follow s1\n      | Coq_full_descriptor_some a ->\n        if descriptor_is_accessor_dec desc\n        then let%bool (s2, x0) = (object_delete s1 c lmap x false) in follow s2\n        else let follow0 s2 =\n               if option_compare bool_eq desc.descriptor_writable (Some false)\n               then let%bool (s3, x0) = (object_delete s2 c lmap x false) in\n                 follow s3\n               else follow s2 in\n          match desc.descriptor_value with\n          | Some v ->\n            let%void s2 = (object_put s1 c lmap x v throwcont) in follow0 s2\n          | None -> follow0 s1\n    else reject s1 throwcont\n\n(** val run_to_descriptor :\n    state -> execution_ctx -> value -> descriptor specres **)\n\nand run_to_descriptor s c _foo_ = match _foo_ with\n  | Coq_value_prim p -> throw_result (run_error s c Coq_native_error_type)\n  | Coq_value_object l ->\n    let sub0 s0 desc name conv k =\n      let%bool (s1, has) = object_has_prop s0 c l name in\n      if not has\n      then k s1 desc\n      else let%value (s2, v0) = run_object_get s1 c l name in\n        let%run (s3, r) = conv s2 v0 desc in k s3 r\n    in\n    sub0 s descriptor_intro_empty ("enumerable")\n      (fun s1 v1 desc ->\n         let b = convert_value_to_boolean v1 in\n         res_spec s1 (descriptor_with_enumerable desc (Some b))) (fun s1_2 desc ->\n          sub0 s1_2 desc ("configurable")\n            (fun s2 v2 desc0 ->\n               let b = convert_value_to_boolean v2 in\n               res_spec s2 (descriptor_with_configurable desc0 (Some b)))\n            (fun s2_2 desc0 ->\n               sub0 s2_2 desc0 ("value")\n                 (fun s3 v3 desc1 ->\n                    res_spec s3 (descriptor_with_value desc1 (Some v3)))\n                 (fun s3_2 desc1 ->\n                    sub0 s3_2 desc1\n                      ("writable")\n                      (fun s4 v4 desc2 ->\n                         let b = convert_value_to_boolean v4 in\n                         res_spec s4 (descriptor_with_writable desc2 (Some b)))\n                      (fun s4_2 desc2 ->\n                         sub0 s4_2 desc2 ("get") (fun s5 v5 desc3 ->\n                             if (not (is_callable_dec s5 v5))\n                             && (not (value_compare v5 (Coq_value_prim Coq_prim_undef)))\n                             then throw_result (run_error s5 c Coq_native_error_type)\n                             else res_spec s5 (descriptor_with_get desc3 (Some v5)))\n                           (fun s5_2 desc3 ->\n                              sub0 s5_2 desc3 ("set") (fun s6 v6 desc4 ->\n                                  if (not (is_callable_dec s6 v6))\n                                  && (not (value_compare v6 (Coq_value_prim Coq_prim_undef)))\n                                  then throw_result (run_error s6 c Coq_native_error_type)\n                                  else res_spec s6 (descriptor_with_set desc4 (Some v6)))\n                                (fun s7 desc4 ->\n                                   if ((not (option_compare value_compare desc4.descriptor_get None))\n                                       ||\n                                       (not (option_compare value_compare desc4.descriptor_set None)))\n                                      &&\n                                      ((not (option_compare value_compare desc4.descriptor_value None))\n                                       ||\n                                       (not (option_compare bool_eq desc4.descriptor_writable None)))\n                                   then throw_result (run_error s7 c Coq_native_error_type)\n                                   else res_spec s7 desc4))))))\n\n(** val prim_new_object : state -> prim -> result **)\n\nand prim_new_object s _foo_ = match _foo_ with\n  | Coq_prim_bool b ->\n    result_out\n      (let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_bool_proto)) ("Boolean")) in\n       let o = (object_with_primitive_value o1 (Coq_value_prim (Coq_prim_bool b))) in\n       let (l, s1) = object_alloc s o in\n       Coq_out_ter (s1, (res_val (Coq_value_object l))))\n  | Coq_prim_number n ->\n    result_out\n      (let o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_number_proto)) ("Number")) in\n       let o = (object_with_primitive_value o1 (Coq_value_prim (Coq_prim_number n))) in\n       let (l, s1) = object_alloc s o in\n       Coq_out_ter (s1, (res_val (Coq_value_object l))))\n  | Coq_prim_string s0 ->\n    let o2 = (object_new (Coq_value_object (Coq_object_loc_prealloc Coq_prealloc_string_proto)) ("String")) in\n    let o1 = (object_with_get_own_property o2 Coq_builtin_get_own_prop_string) in\n    let o = (object_with_primitive_value o1 (Coq_value_prim (Coq_prim_string s0))) in\n    let (l, s1) = object_alloc s o in\n    let%some s_2 = (object_heap_map_properties_option\n                      s1 l\n                      (fun p ->\n                         HeapStr.write p ("length")\n                           (Coq_attributes_data_of\n                              (attributes_data_intro_constant\n                                 (Coq_value_prim\n                                    (Coq_prim_number (number_of_int (strlength s0)))))))) in\n    res_ter s_2 (res_val (Coq_value_object l))\n  | _ ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("[prim_new_object] received an null or undef.")\n\n(** val to_object : state -> value -> result **)\n\nand to_object s c _foo_ = match _foo_ with\n  | Coq_value_prim w ->\n    (match w with\n     | Coq_prim_undef -> run_error s c Coq_native_error_type\n     | Coq_prim_null -> run_error s c Coq_native_error_type\n     | Coq_prim_bool b -> prim_new_object s w\n     | Coq_prim_number n -> prim_new_object s w\n     | Coq_prim_string s0 -> prim_new_object s w)\n  | Coq_value_object l ->\n    result_out (Coq_out_ter (s, (res_val (Coq_value_object l))))\n\n(** val run_object_prim_value : state -> object_loc -> result **)\n\nand run_object_prim_value s l =\n  let%some ov = (run_object_method object_prim_value_ s l) in\n      let%some v = (ov) in  res_ter s (res_val v)\n\n(** val prim_value_get :\n    state -> execution_ctx -> value -> prop_name -> result **)\n\nand prim_value_get s c v x =\n  let%object (s_2, l) = (to_object s c v) in\n      object_get_builtin s_2 c Coq_builtin_get_default v l x\n\n(** val env_record_has_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> result **)\n\nand env_record_has_binding s c l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        result_out (Coq_out_ter (s,\n                                 (res_val (Coq_value_prim (Coq_prim_bool\n                                                             (HeapStr.indom_dec ed x))))))\n      | Coq_env_record_object (l0, pt) -> object_has_prop s c l0 x\n\n(** val lexical_env_get_identifier_ref :\n    state -> execution_ctx -> lexical_env -> prop_name ->\n    strictness_flag -> ref specres **)\n\nand lexical_env_get_identifier_ref s c x x0 str =\n  match x with\n  | [] ->\n    res_spec s (ref_create_value (Coq_value_prim Coq_prim_undef) x0 str)\n  | l :: x_2 ->\n    let%bool (s1, has) = (env_record_has_binding s c l x0) in\n        if has\n        then res_spec s1 (ref_create_env_loc l x0 str)\n        else lexical_env_get_identifier_ref s1 c x_2 x0 str\n\n(** val object_delete_default :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    strictness_flag -> result **)\n\nand object_delete_default s c l x str =\n  let%run (s1, d) = (run_object_get_own_prop s c l x) in\n      match d with\n      | Coq_full_descriptor_undef ->\n        res_ter s1 (res_val (Coq_value_prim (Coq_prim_bool true)))\n      | Coq_full_descriptor_some a ->\n        if attributes_configurable a\n        then let%some\n             s_2 = (object_heap_map_properties_option s1 l (fun p ->\n                 HeapStr.rem p x)) in\n                res_ter s_2 (res_val (Coq_value_prim (Coq_prim_bool true)))\n        else out_error_or_cst s1 c str Coq_native_error_type (Coq_value_prim\n                                                              (Coq_prim_bool false))\n\n(** val object_delete :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    strictness_flag -> result **)\n\nand object_delete s c l x str =\n  let%some b = (run_object_method object_delete_ s l) in\n      match b with\n      | Coq_builtin_delete_default -> object_delete_default s c l x str\n      | Coq_builtin_delete_args_obj ->\n        let%some mo = (run_object_method object_parameter_map_ s l) in\n            let%some m = (mo) in\n                let%run (s1, d) = (run_object_get_own_prop s c m x) in\n                    let%bool (s2, b0) = (object_delete_default s1 c l x str) in\n                        if b0\n                        then (match d with\n                            | Coq_full_descriptor_undef ->\n                              res_ter s2\n                                (res_val (Coq_value_prim (Coq_prim_bool b0)))\n                            | Coq_full_descriptor_some a ->\n                              let%bool \n                                (s3, b_2) = (object_delete s2 c m x false) in\n                                   res_ter s3\n                                     (res_val (Coq_value_prim (Coq_prim_bool b0))))\n                        else res_ter s2 (res_val (Coq_value_prim (Coq_prim_bool b0)))\n\n(** val env_record_delete_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> result **)\n\nand env_record_delete_binding s c l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        (match HeapStr.read_option ed x with\n         | Some p ->\n           let (mu, v) = p in\n           (match mu with\n            | Coq_mutability_uninitialized_immutable ->\n              result_out (Coq_out_ter (s,\n                                       (res_val (Coq_value_prim (Coq_prim_bool false)))))\n            | Coq_mutability_immutable ->\n              result_out (Coq_out_ter (s,\n                                       (res_val (Coq_value_prim (Coq_prim_bool false)))))\n            | Coq_mutability_nondeletable ->\n              result_out (Coq_out_ter (s,\n                                       (res_val (Coq_value_prim (Coq_prim_bool false)))))\n            | Coq_mutability_deletable ->\n              let s_2 =\n                env_record_write s l (Coq_env_record_decl\n                                        (decl_env_record_rem ed x))\n              in\n              result_out (Coq_out_ter (s_2,\n                                       (res_val (Coq_value_prim (Coq_prim_bool true))))))\n         | None ->\n           result_out (Coq_out_ter (s,\n                                    (res_val (Coq_value_prim (Coq_prim_bool true))))))\n      | Coq_env_record_object (l0, pt) ->\n        object_delete s c l0 x throw_false\n\n(** val env_record_implicit_this_value : state -> env_loc -> value option **)\n\nand env_record_implicit_this_value s l =\n  ifx_some_or_default (env_record_binds_option s l) None (fun e ->\n      Some\n        (match e with\n         | Coq_env_record_decl ed -> Coq_value_prim Coq_prim_undef\n         | Coq_env_record_object (l0, provide_this) ->\n           if provide_this\n           then Coq_value_object l0\n           else Coq_value_prim Coq_prim_undef))\n\n(** val identifier_resolution :\n    state -> execution_ctx -> prop_name -> ref specres **)\n\nand identifier_resolution s c x =\n  let x0 = c.execution_ctx_lexical_env in\n  let str = c.execution_ctx_strict in\n  lexical_env_get_identifier_ref s c x0 x str\n\n(** val env_record_get_binding_value :\n    state -> execution_ctx -> env_loc -> prop_name ->\n    strictness_flag -> result **)\n\nand env_record_get_binding_value s c l x str =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        let%some rm = (HeapStr.read_option ed x) in\n            let (mu, v) = rm in\n            if mutability_compare mu Coq_mutability_uninitialized_immutable\n            then out_error_or_cst s c str Coq_native_error_ref (Coq_value_prim\n                                                                Coq_prim_undef)\n            else res_ter s (res_val v)\n      | Coq_env_record_object (l0, pt) ->\n        let%bool (s1, has) = (object_has_prop s c l0 x) in\n            if has\n            then run_object_get s1 c l0 x\n            else out_error_or_cst s1 c str Coq_native_error_ref (Coq_value_prim\n                                                                 Coq_prim_undef)\n\n(** val ref_get_value :\n    state -> execution_ctx -> resvalue -> value specres **)\n\nand ref_get_value s c _foo_ = match _foo_ with\n  | Coq_resvalue_empty ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("[ref_get_value] received an empty result.")\n  | Coq_resvalue_value v -> res_spec s v\n  | Coq_resvalue_ref r ->\n    let \n      for_base_or_object = (fun tt ->\n        match r.ref_base with\n        | Coq_ref_base_type_value v ->\n          if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base\n          then let%value (s2, v) = (prim_value_get s c v r.ref_name) in res_spec s2 v\n          else (match v with\n              | Coq_value_prim p ->\n                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                  s\n                  ("[ref_get_value] received a primitive value whose kind is not primitive.")\n              | Coq_value_object l ->\n                let%value (s2, v) = (run_object_get s c l r.ref_name) in res_spec s2 v)\n        | Coq_ref_base_type_env_loc l ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("[ref_get_value] received a reference to a value whose base type is an environnment record.")) in\n         match ref_kind_of r with\n         | Coq_ref_kind_null ->\n           (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n             s\n             ("[ref_get_value] received a reference whose base is [null].")\n         | Coq_ref_kind_undef -> throw_result (run_error s c Coq_native_error_ref)\n         | Coq_ref_kind_primitive_base -> for_base_or_object ()\n         | Coq_ref_kind_object -> for_base_or_object ()\n         | Coq_ref_kind_env_record ->\n           (match r.ref_base with\n            | Coq_ref_base_type_value v ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s\n                ("[ref_get_value] received a reference to an environnment record whose base type is a value.")\n            | Coq_ref_base_type_env_loc l ->\n              let%value\n                \n                (s2, v) = (env_record_get_binding_value s c l r.ref_name r.ref_strict) in res_spec s2 v)\n\n(* DEBUG\n   and ref_get_value runs s c r =\n   let res = ref_get_value runs s c r in match res with\n   | JsInterpreterMonads.Coq_result_some crs ->\n     begin match crs with\n       | (Coq_specret_val (_,rs)) ->\n         begin match rs with\n           | Coq_value_prim cvp ->\n             begin match cvp with\n               | Coq_prim_undef -> Debug.ref_get_value_2 r; res\n               | _ -> res\n             end\n         | _ -> res\n         end\n       | _ -> res\n     end\n     | _ -> res\n*)\n\n\n(** val run_expr_get_value :\n    state -> execution_ctx -> expr -> value specres **)\n\nand run_expr_get_value s c e =\n  let%success (s0, rv) = (run_expr s c e) in\n      ref_get_value s0 c rv\n\n(** val object_put_complete :\n    builtin_put -> state -> execution_ctx -> value -> object_loc\n    -> prop_name -> value -> strictness_flag -> result_void **)\n\nand object_put_complete b s c vthis l x v str =\n  match b with Coq_builtin_put_default ->\n    let%bool (s1, b0) = (object_can_put s c l x) in\n        if b0\n        then let%run (s2, d) = (run_object_get_own_prop s1 c l x) in\n            let \n              follow = (fun x0 ->\n                let%run (s3, d_2) = (run_object_get_prop s2 c l x) in\n                    let  follow_2 = (fun x1 ->\n                        match vthis with\n                        | Coq_value_prim wthis ->\n                          out_error_or_void s3 c str Coq_native_error_type\n                        | Coq_value_object lthis ->\n                          let \n                            desc = (descriptor_intro_data v true true true) in\n                               let%success\n                                 \n                                 (s4, rv) = (object_define_own_prop s3 c l x desc str) in  res_void s4) in\n                        match d_2 with\n                        | Coq_full_descriptor_undef -> follow_2 ()\n                        | Coq_full_descriptor_some a ->\n                          (match a with\n                           | Coq_attributes_data_of a0 -> follow_2 ()\n                           | Coq_attributes_accessor_of aa_2 ->\n                             (match aa_2.attributes_accessor_set with\n                              | Coq_value_prim p ->\n                                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                  s3\n                                  ("[object_put_complete] found a primitive in an `set\\\' accessor.")\n                              | Coq_value_object lfsetter ->\n                                let%success\n                                   (s4, rv) = (run_call s3 c lfsetter vthis\n                                     (v :: [])) in  res_void s4))) in\n                 match d with\n                 | Coq_full_descriptor_undef -> follow ()\n                 | Coq_full_descriptor_some a ->\n                   (match a with\n                    | Coq_attributes_data_of ad ->\n                      (match vthis with\n                       | Coq_value_prim wthis ->\n                         out_error_or_void s2 c str Coq_native_error_type\n                       | Coq_value_object lthis ->\n                         let  desc = ({ descriptor_value = (Some v);\n                                       descriptor_writable = None; descriptor_get = None;\n                                       descriptor_set = None; descriptor_enumerable = None;\n                                       descriptor_configurable = None }) in\n                             let%success\n                               \n                               (s3, rv) = (object_define_own_prop s2 c l x desc str) in  res_void s3)\n                    | Coq_attributes_accessor_of a0 -> follow ())\n        else out_error_or_void s1 c str Coq_native_error_type\n\n(** val object_put :\n    state -> execution_ctx -> object_loc -> prop_name -> value\n    -> strictness_flag -> result_void **)\n\nand object_put s c l x v str =\n  let%some b = (run_object_method object_put_ s l) in\n      object_put_complete b s c (Coq_value_object l) l x v str\n\n(** val env_record_set_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> value ->\n    strictness_flag -> result_void **)\n\nand env_record_set_mutable_binding s c l x v str =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        let%some rm = (HeapStr.read_option ed x) in\n            let (mu, v_old) = rm in\n            if not (mutability_compare mu Coq_mutability_immutable)\n            then res_void (env_record_write_decl_env s l x mu v)\n            else out_error_or_void s c str Coq_native_error_type\n      | Coq_env_record_object (l0, pt) -> object_put s c l0 x v str\n\n(** val prim_value_put :\n    state -> execution_ctx -> prim -> prop_name -> value ->\n    strictness_flag -> result_void **)\n\nand prim_value_put s c w x v str =\n  let%object (s1, l) = (to_object s c (Coq_value_prim w)) in\n      object_put_complete Coq_builtin_put_default s1 c (Coq_value_prim w)\n        l x v str\n\n(** val ref_put_value :\n    state -> execution_ctx -> resvalue -> value -> result_void **)\n\nand ref_put_value s c rv v =\n  match rv with\n  | Coq_resvalue_empty ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("[ref_put_value] received an empty result.")\n  | Coq_resvalue_value v0 -> run_error s c Coq_native_error_ref\n  | Coq_resvalue_ref r ->\n    if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_undef\n    then if r.ref_strict\n      then run_error s c Coq_native_error_ref\n      else object_put s c (Coq_object_loc_prealloc\n                             Coq_prealloc_global) r.ref_name v throw_false\n    else if \n          (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base)\n       || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_null)\n       || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_object)\n    then (match r.ref_base with\n        | Coq_ref_base_type_value v_2 ->\n          if ref_kind_comparable (ref_kind_of r)\n              Coq_ref_kind_primitive_base\n          then (match v_2 with\n              | Coq_value_prim w ->\n                prim_value_put s c w r.ref_name v r.ref_strict\n              | Coq_value_object o ->\n                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                  s\n                  ("[ref_put_value] impossible case"))\n          else (match v_2 with\n              | Coq_value_prim p ->\n                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                  s\n                  ("[ref_put_value] impossible case")\n              | Coq_value_object l ->\n                object_put s c l r.ref_name v r.ref_strict)\n        | Coq_ref_base_type_env_loc l ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("[ref_put_value] contradicts ref_is_property"))\n    else (match r.ref_base with\n        | Coq_ref_base_type_value v0 ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("[ref_put_value] impossible spec")\n        | Coq_ref_base_type_env_loc l ->\n          env_record_set_mutable_binding s c l r.ref_name v\n            r.ref_strict)\n\n(** val env_record_create_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> bool\n    option -> result_void **)\n\nand env_record_create_mutable_binding s c l x deletable_opt =\n  let  deletable = (unsome_default false deletable_opt) in\n      let%some e = (env_record_binds_option s l) in\n          match e with\n          | Coq_env_record_decl ed ->\n            if HeapStr.indom_dec ed x\n            then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s\n                ("Already declared environnment record in [env_record_create_mutable_binding].")\n            else let\n                 s_2 = (env_record_write_decl_env s l x\n                   (mutability_of_bool deletable) (Coq_value_prim\n                                                     Coq_prim_undef)) in res_void s_2\n          | Coq_env_record_object (l0, pt) ->\n            let%bool (s1, has) = (object_has_prop s c l0 x) in\n                if has\n                then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                    s1\n                    ("Already declared binding in [env_record_create_mutable_binding].")\n                else let  a = ({ attributes_data_value = (Coq_value_prim\n                                                              Coq_prim_undef); attributes_data_writable = true;\n                                   attributes_data_enumerable = true;\n                                   attributes_data_configurable = deletable }) in\n                    let%success\n                       (s2, rv) = (object_define_own_prop s1 c l0 x\n                         (descriptor_of_attributes (Coq_attributes_data_of a))\n                         throw_true) in  res_void s2\n\n(** val env_record_create_set_mutable_binding :\n    state -> execution_ctx -> env_loc -> prop_name -> bool\n    option -> value -> strictness_flag -> result_void **)\n\nand env_record_create_set_mutable_binding s c l x deletable_opt v str =\n  let%void \n    s0 = (env_record_create_mutable_binding s c l x deletable_opt) in  env_record_set_mutable_binding s0 c l x v str\n\n(** val env_record_create_immutable_binding :\n    state -> env_loc -> prop_name -> result_void **)\n\nand env_record_create_immutable_binding s l x =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        if HeapStr.indom_dec ed x\n        then (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("Already declared environnment record in [env_record_create_immutable_binding].")\n        else res_void\n            (env_record_write_decl_env s l x\n               Coq_mutability_uninitialized_immutable (Coq_value_prim\n                                                         Coq_prim_undef))\n      | Coq_env_record_object (o, p) ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("[env_record_create_immutable_binding] received an environnment record object.")\n\n(** val env_record_initialize_immutable_binding :\n    state -> env_loc -> prop_name -> value -> result_void **)\n\nand env_record_initialize_immutable_binding s l x v =\n  let%some e = (env_record_binds_option s l) in\n      match e with\n      | Coq_env_record_decl ed ->\n        let%some evs = (decl_env_record_option ed x) in\n            if prod_compare mutability_compare value_compare evs\n                (Coq_mutability_uninitialized_immutable, (Coq_value_prim\n                                                            Coq_prim_undef))\n            then let s_2 = (env_record_write_decl_env s l x Coq_mutability_immutable v) in res_void s_2\n            else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s\n                ("Non suitable binding in [env_record_initialize_immutable_binding].")\n      | Coq_env_record_object (o, p) ->\n        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n          s\n          ("[env_record_initialize_immutable_binding] received an environnment record object.")\n\n(** val call_object_new : state -> value -> result **)\n\nand call_object_new s c v =\n  match type_of v with\n  | Coq_type_undef ->\n    result_out\n      (let o = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                          Coq_prealloc_object_proto))\n            ("Object")) in\n             let  p = (object_alloc s o) in\n                 let (l, s_2) = p in Coq_out_ter (s_2, (res_val (Coq_value_object l))))\n  | Coq_type_null ->\n    result_out\n      (let o = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                          Coq_prealloc_object_proto))\n            ("Object")) in\n             let  p = (object_alloc s o) in\n                 let (l, s_2) = p in Coq_out_ter (s_2, (res_val (Coq_value_object l))))\n  | Coq_type_bool -> to_object s c v\n  | Coq_type_number -> to_object s c v\n  | Coq_type_string -> to_object s c v\n  | Coq_type_object -> result_out (Coq_out_ter (s, (res_val v)))\n\n(** val array_args_map_loop :\n    state -> execution_ctx -> object_loc -> value list -> float\n    -> result_void **)\n\nand array_args_map_loop s c l args ind =\n  match args with\n  | [] -> res_void s\n  | h :: rest ->\n    let%some s_2 = (object_heap_map_properties_option s l (fun p ->\n           HeapStr.write p (JsNumber.to_string ind)\n             (Coq_attributes_data_of (attributes_data_intro_all_true h)))) in\n             array_args_map_loop s_2 c l rest (ind +. 1.)\n\n(** val string_of_prealloc : prealloc -> string **)\n\nand string_of_prealloc _foo_ = match _foo_ with\n  | Coq_prealloc_global -> "global"\n  | Coq_prealloc_global_eval ->\n    "global_eval"\n  | Coq_prealloc_global_parse_int ->\n    "global_parse_int"\n  | Coq_prealloc_global_parse_float ->\n    "global_parse_float"\n  | Coq_prealloc_global_is_finite ->\n    "global_is_finite"\n  | Coq_prealloc_global_is_nan ->\n    "global_is_nan"\n  | Coq_prealloc_global_decode_uri ->\n    "global_decode_uri"\n  | Coq_prealloc_global_decode_uri_component ->\n    "global_decode_uri_component"\n  | Coq_prealloc_global_encode_uri ->\n    "global_encode_uri"\n  | Coq_prealloc_global_encode_uri_component ->\n    "global_encode_uri_component"\n  | Coq_prealloc_object -> "object"\n  | Coq_prealloc_object_get_proto_of ->\n    "object_get_proto_of"\n  | Coq_prealloc_object_get_own_prop_descriptor ->\n    "object_get_own_prop_descriptor"\n  | Coq_prealloc_object_get_own_prop_name ->\n    "object_get_own_prop_name"\n  | Coq_prealloc_object_create ->\n    "object_create"\n  | Coq_prealloc_object_define_prop ->\n    "object_define_prop"\n  | Coq_prealloc_object_define_props ->\n    "object_define_props"\n  | Coq_prealloc_object_seal ->\n    "object_seal"\n  | Coq_prealloc_object_freeze ->\n    "object_freeze"\n  | Coq_prealloc_object_prevent_extensions ->\n    "object_prevent_extensions"\n  | Coq_prealloc_object_is_sealed ->\n    "object_is_sealed"\n  | Coq_prealloc_object_is_frozen ->\n    "object_is_frozen"\n  | Coq_prealloc_object_is_extensible ->\n    "object_is_extensible"\n  | Coq_prealloc_object_keys ->\n    "object_keys"\n  | Coq_prealloc_object_keys_call ->\n    "object_keys_call"\n  | Coq_prealloc_object_proto ->\n    "object_proto_"\n  | Coq_prealloc_object_proto_to_string ->\n    "object_proto_to_string"\n  | Coq_prealloc_object_proto_value_of ->\n    "object_proto_value_of"\n  | Coq_prealloc_object_proto_has_own_prop ->\n    "object_proto_has_own_prop"\n  | Coq_prealloc_object_proto_is_prototype_of ->\n    "object_proto_is_prototype_of"\n  | Coq_prealloc_object_proto_prop_is_enumerable ->\n    "object_proto_prop_is_enumerable"\n  | Coq_prealloc_function ->\n    "function"\n  | Coq_prealloc_function_proto ->\n    "function_proto"\n  | Coq_prealloc_function_proto_to_string ->\n    "function_proto_to_string"\n  | Coq_prealloc_function_proto_apply ->\n    "function_proto_apply"\n  | Coq_prealloc_function_proto_call ->\n    "function_proto_call"\n  | Coq_prealloc_function_proto_bind ->\n    "function_proto_bind"\n  | Coq_prealloc_bool -> "bool"\n  | Coq_prealloc_bool_proto ->\n    "bool_proto"\n  | Coq_prealloc_bool_proto_to_string ->\n    "bool_proto_to_string"\n  | Coq_prealloc_bool_proto_value_of ->\n    "bool_proto_value_of"\n  | Coq_prealloc_number -> "number"\n  | Coq_prealloc_number_proto ->\n    "number_proto"\n  | Coq_prealloc_number_proto_to_string ->\n    "number_proto_to_string"\n  | Coq_prealloc_number_proto_value_of ->\n    "number_proto_value_of"\n  | Coq_prealloc_number_proto_to_fixed ->\n    "number_proto_to_fixed"\n  | Coq_prealloc_number_proto_to_exponential ->\n    "number_proto_to_exponential"\n  | Coq_prealloc_number_proto_to_precision ->\n    "number_proto_to_precision"\n  | Coq_prealloc_array -> "array"\n  | Coq_prealloc_array_is_array ->\n    "array_is_array"\n  | Coq_prealloc_array_proto ->\n    "array_proto"\n  | Coq_prealloc_array_proto_to_string ->\n    "array_proto_to_string"\n  | Coq_prealloc_array_proto_join ->\n    "array_proto_join"\n  | Coq_prealloc_array_proto_pop ->\n    "array_proto_pop"\n  | Coq_prealloc_array_proto_push ->\n    "array_proto_push"\n  | Coq_prealloc_string -> "string"\n  | Coq_prealloc_string_proto ->\n    "string_proto"\n  | Coq_prealloc_string_proto_to_string ->\n    "string_proto_to_string"\n  | Coq_prealloc_string_proto_value_of ->\n    "string_proto_value_of"\n  | Coq_prealloc_string_proto_char_at ->\n    "string_proto_char_at"\n  | Coq_prealloc_string_proto_char_code_at ->\n    "string_proto_char_code_at"\n  | Coq_prealloc_math -> "math"\n  | Coq_prealloc_mathop m -> "mathop"\n  | Coq_prealloc_date -> "date"\n  | Coq_prealloc_regexp -> "regexp"\n  | Coq_prealloc_error -> "error"\n  | Coq_prealloc_error_proto ->\n    "error_proto"\n  | Coq_prealloc_native_error n ->\n    "native_error"\n  | Coq_prealloc_native_error_proto n ->\n    "native_error_proto"\n  | Coq_prealloc_error_proto_to_string ->\n    "error_proto_to_string"\n  | Coq_prealloc_throw_type_error ->\n    "throw_type_error"\n  | Coq_prealloc_json -> "json"\n\n(** val run_construct_prealloc :\n    state -> execution_ctx -> prealloc -> value list -> result **)\n\nand run_construct_prealloc s c b args =\n  match b with\n  | Coq_prealloc_object ->\n    let v = (get_arg 0 args) in call_object_new s c v\n  | Coq_prealloc_bool ->\n    result_out\n      (let  v = (get_arg 0 args) in\n           let  b0 = (convert_value_to_boolean v) in\n               let\n                  o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                                  Coq_prealloc_bool_proto))\n                    ("Boolean")) in\n                     let\n                        o = (object_with_primitive_value o1 (Coq_value_prim (Coq_prim_bool\n                                                                          b0))) in\n                           let  p = (object_alloc s o) in\n                               let (l, s_2) = p in\n                               Coq_out_ter (s_2, (res_val (Coq_value_object l))))\n  | Coq_prealloc_number ->\n    let \n      follow = (fun s_2 v ->\n        let\n           o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                           Coq_prealloc_number_proto))\n             ("Number")) in\n              let  o = (object_with_primitive_value o1 v) in\n                  let (l, s1) = object_alloc s_2 o in\n                  result_out (Coq_out_ter (s1, (res_val (Coq_value_object l))))) in\n         if list_eq_nil_decidable args\n         then follow s (Coq_value_prim (Coq_prim_number JsNumber.zero))\n         else let  v = (get_arg 0 args) in\n             let%number (x, x0) = (to_number s c v) in\n                 follow x (Coq_value_prim (Coq_prim_number x0))\n  | Coq_prealloc_array ->\n    let\n      \n      o_2 = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                       Coq_prealloc_array_proto)) ("Array")) in\n         let \n           o = (object_for_array o_2 Coq_builtin_define_own_prop_array) in\n              let  p = (object_alloc s o) in\n                  let (l, s_2) = p in\n                  let  follow = (fun s_3 length0 ->\n                      let%some\n                         s0 = (object_heap_map_properties_option s_3 l (fun p0 ->\n                             HeapStr.write p0 ("length")\n                               (Coq_attributes_data_of { attributes_data_value =\n                                                           (Coq_value_prim (Coq_prim_number length0));\n                                                         attributes_data_writable = true;\n                                                         attributes_data_enumerable = false;\n                                                         attributes_data_configurable = false }))) in\n                            res_ter s0 (res_val (Coq_value_object l))) in\n                      let  arg_len = (LibList.length args) in\n                          if nat_eq arg_len 1\n                          then let  v = (get_arg 0 args) in\n                              match v with\n                              | Coq_value_prim p0 ->\n                                (match p0 with\n                                 | Coq_prim_undef ->\n                                   let%some\n                                     \n                                     s0 = (object_heap_map_properties_option s_2 l\n                                        (fun p1 ->\n                                           HeapStr.write p1 ("0") (Coq_attributes_data_of\n                                                                  (attributes_data_intro_all_true v)))) in\n                                        follow s0 1.0\n                                 | Coq_prim_null ->\n                                   let%some\n                                     \n                                     s0 = (object_heap_map_properties_option s_2 l\n                                        (fun p1 ->\n                                           HeapStr.write p1 ("0") (Coq_attributes_data_of\n                                                                  (attributes_data_intro_all_true v)))) in\n                                        follow s0 1.0\n                                 | Coq_prim_bool b0 ->\n                                   let%some\n                                     \n                                     s0 = (object_heap_map_properties_option s_2 l\n                                        (fun p1 ->\n                                           HeapStr.write p1 ("0") (Coq_attributes_data_of\n                                                                  (attributes_data_intro_all_true v)))) in\n                                        follow s0 1.0\n                                 | Coq_prim_number vlen ->\n                                   let%run\n                                      (s0, ilen) = (to_uint32 s_2 c (Coq_value_prim\n                                                         (Coq_prim_number vlen))) in\n                                         if ilen === vlen\n                                         then follow s0 ilen\n                                         else run_error s0 c Coq_native_error_range\n                                 | Coq_prim_string s0 ->\n                                   let%some\n                                     \n                                     s1 = (object_heap_map_properties_option s_2 l\n                                        (fun p1 ->\n                                           HeapStr.write p1 ("0") (Coq_attributes_data_of\n                                                                  (attributes_data_intro_all_true v)))) in\n                                        follow s1 1.0)\n                              | Coq_value_object o0 ->\n                                let%some\n                                   s0 = (object_heap_map_properties_option s_2 l\n                                     (fun p0 ->\n                                        HeapStr.write p0 ("0") (Coq_attributes_data_of\n                                                               (attributes_data_intro_all_true v)))) in\n                                      follow s0 1.0\n                          else let%some\n                               s0 = (object_heap_map_properties_option s_2 l\n                                 (fun p0 ->\n                                    HeapStr.write p0\n                                      ("length")\n                                      (Coq_attributes_data_of { attributes_data_value =\n                                                                  (Coq_value_prim (Coq_prim_number\n                                                                                     (number_of_int arg_len)));\n                                                                attributes_data_writable = true;\n                                                                attributes_data_enumerable = false;\n                                                                attributes_data_configurable = false }))) in\n                                  let%void \n                                    s1 = (array_args_map_loop s0 c l args 0.) in  res_ter s1 (res_val (Coq_value_object l))\n  | Coq_prealloc_string ->\n    let\n       o2 = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                       Coq_prealloc_string_proto))\n         ("String")) in\n          let\n            \n            o1 = (object_with_get_own_property o2 Coq_builtin_get_own_prop_string) in\n               let  follow = (fun s0 s1 ->\n                   let\n                      o = (object_with_primitive_value o1 (Coq_value_prim (Coq_prim_string\n                                                                        s1))) in\n                         let (l, s2) = object_alloc s0 o in\n                         let\n                           \n                           lenDesc = (attributes_data_intro_constant (Coq_value_prim\n                                                              (Coq_prim_number (number_of_int (strlength s1))))) in\n                              let%some\n                                 s_2 = (object_heap_map_properties_option s2 l (fun p ->\n                                     HeapStr.write p ("length")\n                                       (Coq_attributes_data_of lenDesc))) in\n                                    res_ter s_2 (res_val (Coq_value_object l))) in\n                   let  arg_len = (LibList.length args) in\n                       if nat_eq arg_len 0\n                       then follow s ""\n                       else let  arg = (get_arg 0 args) in\n                           let%string (s0, s1) = (to_string s c arg) in\n                               follow s0 s1\n  | Coq_prealloc_error ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           Coq_prealloc_error_proto)) v\n  | Coq_prealloc_native_error ne ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           (Coq_prealloc_native_error_proto ne))) v\n  | _ ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      (strappend\n         ("Construct prealloc_")\n         (strappend (string_of_prealloc b)\n            (" not yet implemented.")))\n\n(** val run_construct_default :\n    state -> execution_ctx -> object_loc -> value list -> __\n    specres **)\n\nand run_construct_default s c l args =\n  let%value\n    \n    (s1, v1) = (run_object_get s c l\n       ("prototype")) in\n       let\n          vproto = (if type_compare (type_of v1) Coq_type_object\n          then v1\n          else Coq_value_object (Coq_object_loc_prealloc\n                                   Coq_prealloc_object_proto)) in\n             let\n               \n               o = (object_new vproto ("Object")) in\n                  let  p = (object_alloc s1 o) in\n                      let (l_2, s2) = p in\n                      let%value \n                        (s3, v2) = (run_call s2 c l (Coq_value_object l_2) args) in\n                           let\n                              vr = (if type_compare (type_of v2) Coq_type_object\n                              then v2\n                              else Coq_value_object l_2) in res_ter s3 (res_val vr)\n\n(** val run_construct :\n    state -> execution_ctx -> construct -> object_loc -> value\n    list -> result **)\n\nand run_construct s c co l args =\n  match co with\n  | Coq_construct_default -> run_construct_default s c l args\n  | Coq_construct_after_bind ->\n    let%some otrg = run_object_method object_target_function_ s l in\n    let%some target = (otrg) in\n    let%some oco = run_object_method object_construct_ s target in begin\n      match oco with\n      | Some co0 ->\n        let%some oarg = run_object_method object_bound_args_ s l in\n        let%some boundArgs = oarg in\n        let  arguments_ = (LibList.append boundArgs args) in\n            run_construct s c co0 target arguments_\n      | None -> run_error s c Coq_native_error_type\n    end\n  | Coq_construct_prealloc b -> run_construct_prealloc s c b args\n\n(** val run_call_default :\n    state -> execution_ctx -> object_loc -> result **)\n\nand run_call_default s c lf =\n  let\n    \n    def = (result_out (Coq_out_ter (s, (res_val (Coq_value_prim Coq_prim_undef))))) in\n       let%some oC = (run_object_method object_code_ s lf) in\n           match oC with\n           | Some bd ->\n             if list_eq_nil_decidable (prog_elements (funcbody_prog bd))\n             then def\n             else ifx_success_or_return\n                 (run_prog s c (funcbody_prog bd)) (fun s_2 ->\n                     result_out (Coq_out_ter (s_2,\n                                              (res_val (Coq_value_prim Coq_prim_undef))))) (fun s_2 rv ->\n                     result_out (Coq_out_ter (s_2, (res_normal rv))))\n           | None -> def\n\n(** val creating_function_object_proto :\n    state -> execution_ctx -> object_loc -> result **)\n\nand creating_function_object_proto s c l =\n  let%object \n    (s1, lproto) = (run_construct_prealloc s c Coq_prealloc_object []) in\n       let  a1 = ({ attributes_data_value = (Coq_value_object l);\n                     attributes_data_writable = true; attributes_data_enumerable = false;\n                     attributes_data_configurable = true }) in\n           let%bool\n             \n             (s2, b) = (object_define_own_prop s1 c lproto\n                ("constructor")\n                (descriptor_of_attributes (Coq_attributes_data_of a1)) false) in\n                let  a2 = ({ attributes_data_value = (Coq_value_object lproto);\n                              attributes_data_writable = true; attributes_data_enumerable =\n                                                                 false; attributes_data_configurable = false }) in\n                    object_define_own_prop s2 c l\n                      ("prototype")\n                      (descriptor_of_attributes (Coq_attributes_data_of a2)) false\n\n(** val creating_function_object :\n    state -> execution_ctx -> string list -> funcbody ->\n    lexical_env -> strictness_flag -> result **)\n\nand creating_function_object s c names bd x str =\n  let\n     o = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                     Coq_prealloc_function_proto))\n       ("Function")) in\n        let  o1 = (object_with_get o Coq_builtin_get_function) in\n            let\n              \n              o2 = (object_with_invokation o1 (Some Coq_construct_default) (Some\n                                                                         Coq_call_default) (Some Coq_builtin_has_instance_function)) in\n                 let\n                    o3 = (object_with_details o2 (Some x) (Some names) (Some bd) None None\n                      None None) in\n                       let  p = (object_alloc s o3) in\n                           let (l, s1) = p in\n                           let  a1 = ({ attributes_data_value = (Coq_value_prim\n                                                                    (Coq_prim_number\n                                                                       (number_of_int (LibList.length names))));\n                                         attributes_data_writable = false; attributes_data_enumerable =\n                                                                             false; attributes_data_configurable = false }) in\n                               let%bool\n                                  (s2, b2) = (object_define_own_prop s1 c l\n                                    ("length")\n                                    (descriptor_of_attributes (Coq_attributes_data_of a1))\n                                    false) in\n                                     let%bool \n                                       (s3, b3) = (creating_function_object_proto s2 c l) in\n                                          if not str\n                                          then res_ter s3 (res_val (Coq_value_object l))\n                                          else let  vthrower = (Coq_value_object (Coq_object_loc_prealloc\n                                                                                Coq_prealloc_throw_type_error)) in\n                                              let \n                                                a2 = ({ attributes_accessor_get = vthrower;\n                                                            attributes_accessor_set = vthrower;\n                                                            attributes_accessor_enumerable = false;\n                                                            attributes_accessor_configurable = false }) in\n                                                   let%bool\n                                                     \n                                                     (s4, b4) = (object_define_own_prop s3 c l\n                                                        ("caller")\n                                                        (descriptor_of_attributes\n                                                           (Coq_attributes_accessor_of a2)) false) in\n                                                        let%bool\n                                                          \n                                                          (s5, b5) = (object_define_own_prop s4 c l\n                                                             ("arguments")\n                                                             (descriptor_of_attributes\n                                                                (Coq_attributes_accessor_of a2)) false) in\n                                                             res_ter s5 (res_val (Coq_value_object l))\n\n(** val binding_inst_formal_params :\n    state -> execution_ctx -> env_loc -> value list -> string\n    list -> strictness_flag -> result_void **)\n\nand binding_inst_formal_params s c l args names str =\n  match names with\n  | [] -> res_void s\n  | argname :: names_2 ->\n    let  v = (hd (Coq_value_prim Coq_prim_undef) args) in\n        let  args_2 = (tl args) in\n            let%bool (s1, hb) = (env_record_has_binding s c l argname) in\n                let \n                  follow = (fun s_2 ->\n                    let%void\n                      \n                      s_3= (env_record_set_mutable_binding s_2 c l argname v str) in\n                         binding_inst_formal_params s_3 c l args_2 names_2 str) in\n                     if hb\n                     then follow s1\n                     else let%void\n                          s2 = (env_record_create_mutable_binding s1 c l argname\n                            None) in  follow s2\n\n(** val binding_inst_function_decls :\n    state -> execution_ctx -> env_loc -> funcdecl list ->\n    strictness_flag -> bool -> result_void **)\n\nand binding_inst_function_decls s c l fds str bconfig =\n\n  match fds with\n  | [] -> res_void s\n  | fd :: fds_2 ->\n    let  fbd = (fd.funcdecl_body) in\n        let  str_fd = (funcbody_is_strict fbd) in\n            let  fparams = (fd.funcdecl_parameters) in\n                let  fname = (fd.funcdecl_name) in\n                    let%object\n                       (s1, fo) = (creating_function_object s c fparams fbd\n                         c.execution_ctx_variable_env str_fd) in\n                          let \n                            follow = (fun s2 ->\n                              let%void\n                                 s3= (env_record_set_mutable_binding s2 c l fname\n                                   (Coq_value_object fo) str) in\n                                    binding_inst_function_decls s3 c l fds_2 str bconfig) in\n                               let%bool \n                                 (s2, has) = (env_record_has_binding s1 c l fname) in\n                                    if has\n                                    then if nat_eq l env_loc_global_env_record\n                                      then let%run\n                                           (s3, d) = (run_object_get_prop s2 c\n                                             (Coq_object_loc_prealloc Coq_prealloc_global)\n                                             fname) in\n                                              match d with\n                                              | Coq_full_descriptor_undef ->\n                                                (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                                  s3\n                                                  ("Undefined full descriptor in [binding_inst_function_decls].")\n                                              | Coq_full_descriptor_some a ->\n                                                if attributes_configurable a\n                                                then let  a_2 = ({ attributes_data_value =\n                                                                     (Coq_value_prim Coq_prim_undef);\n                                                                   attributes_data_writable = true;\n                                                                   attributes_data_enumerable = true;\n                                                                   attributes_data_configurable =\n                                                                     bconfig }) in\n                                                    let%bool\n                                                       (s0, x) = (object_define_own_prop s3 c\n                                                         (Coq_object_loc_prealloc\n                                                            Coq_prealloc_global) fname\n                                                         (descriptor_of_attributes\n                                                            (Coq_attributes_data_of a_2))\n                                                         true) in follow s0\n                                                else if \n                                                       (descriptor_is_accessor_dec (descriptor_of_attributes a))                                                  \n                                                    || (not (attributes_writable a))\n                                                    || (not (attributes_enumerable a))\n                                                then run_error s3 c Coq_native_error_type\n                                                else follow s3\n                                      else follow s2\n                                    else let%void\n                                         s3 = (env_record_create_mutable_binding s2 c l\n                                           fname (Some bconfig)) in  follow s3\n\n(** val make_arg_getter :\n    state -> execution_ctx -> prop_name -> lexical_env -> result **)\n\nand make_arg_getter s c x x0 =\n  let xbd =\n    strappend ("return ")\n      (strappend x (";"))\n  in\n  let bd = Coq_funcbody_intro ((Coq_prog_intro (true, ((Coq_element_stat\n                                                          (Coq_stat_return (Some (Coq_expr_identifier x)))) :: []))), xbd)\n  in\n  creating_function_object s c [] bd x0 true\n\n(** val make_arg_setter :\n    state -> execution_ctx -> prop_name -> lexical_env -> result **)\n\nand make_arg_setter s c x x0 =\n  let xparam = strappend x ("_arg") in\n  let xbd =\n    strappend x (strappend (" = ") (strappend xparam ";"))\n  in\n  let bd = Coq_funcbody_intro ((Coq_prog_intro (true, ((Coq_element_stat\n                                                          (Coq_stat_expr (Coq_expr_assign ((Coq_expr_identifier x), None,\n                                                                                           (Coq_expr_identifier xparam))))) :: []))), xbd)\n  in\n  creating_function_object s c (xparam :: []) bd x0 true\n\n(** val arguments_object_map_loop :\n    state -> execution_ctx -> object_loc -> string list ->\n    int -> value list -> lexical_env -> strictness_flag -> object_loc ->\n    string list -> result_void **)\n\nand arguments_object_map_loop s c l xs len args x str lmap xsmap =\n  (fun fO fS n -> if int_eq n 0 then fO () else fS (n-1))\n    (fun _ ->\n       if list_eq_nil_decidable xsmap\n       then res_void s\n       else let%some o = (object_binds_option s l) in\n           let\n              o_2 = (object_for_args_object o lmap Coq_builtin_get_args_obj\n                Coq_builtin_get_own_prop_args_obj\n                Coq_builtin_define_own_prop_args_obj\n                Coq_builtin_delete_args_obj) in\n                 res_void (object_write s l o_2))\n    (fun len_2 ->\n       let  tdl = (take_drop_last args) in\n           let (rmlargs, largs) = tdl in\n           let  arguments_object_map_loop_2 = (fun s0 xsmap0 ->\n               arguments_object_map_loop s0 c l xs len_2 rmlargs x str lmap\n                 xsmap0) in\n               let  a = (attributes_data_intro_all_true largs) in\n                   let%bool\n                     \n                     (s1, b) = (object_define_own_prop s c l\n                        (convert_prim_to_string (Coq_prim_number\n                                                   (number_of_int len_2)))\n                        (descriptor_of_attributes (Coq_attributes_data_of a)) false) in\n                        if ge_nat_decidable len_2 (LibList.length xs)\n                        then arguments_object_map_loop_2 s1 xsmap\n                        else let dummy = "" in\n                          let  x0 = (nth_def dummy len_2 xs) in\n                              if    (str)\n                                 || (mem_decide string_eq x0 xsmap)\n                              then arguments_object_map_loop_2 s1 xsmap\n                              else let%object \n                                  (s2, lgetter) = (make_arg_getter s1 c x0 x) in\n                                     let%object \n                                       (s3, lsetter) = (make_arg_setter s2 c x0 x) in\n                                          let  a_2 = ({ attributes_accessor_get =\n                                                          (Coq_value_object lgetter);\n                                                        attributes_accessor_set = (Coq_value_object\n                                                                                     lsetter); attributes_accessor_enumerable =\n                                                                                                 false; attributes_accessor_configurable =\n                                                                                                          true }) in\n                                              let%bool\n                                                \n                                                (s4, b_2) = (object_define_own_prop s3 c lmap\n                                                   (convert_prim_to_string (Coq_prim_number\n                                                                              (number_of_int len_2)))\n                                                   (descriptor_of_attributes\n                                                      (Coq_attributes_accessor_of a_2)) false) in\n                                                   arguments_object_map_loop_2 s4 (x0 :: xsmap))\n    len\n\n(** val arguments_object_map :\n    state -> execution_ctx -> object_loc -> string list ->\n    value list -> lexical_env -> strictness_flag -> result_void **)\n\nand arguments_object_map s c l xs args x str =\n  let%object \n    (s_2, lmap) = (run_construct_prealloc s c Coq_prealloc_object []) in\n       arguments_object_map_loop s_2 c l xs (LibList.length args) args x\n         str lmap []\n\n(** val create_arguments_object :\n    state -> execution_ctx -> object_loc -> string list ->\n    value list -> lexical_env -> strictness_flag -> result **)\n\nand create_arguments_object s c lf xs args x str =\n  let\n     o = (object_create_builtin (Coq_value_object (Coq_object_loc_prealloc\n                                                Coq_prealloc_object_proto))\n       ("Arguments")\n       Heap.empty) in\n        let  p = (object_alloc s o) in\n            let (l, s_2) = p in\n            let  a = ({ attributes_data_value = (Coq_value_prim (Coq_prim_number\n                                                                     (number_of_int (LibList.length args))));\n                          attributes_data_writable = true; attributes_data_enumerable = false;\n                          attributes_data_configurable = true }) in\n                let%bool\n                  \n                  (s1, b) = (object_define_own_prop s_2 c l\n                     ("length")\n                     (descriptor_of_attributes (Coq_attributes_data_of a)) false) in\n                     let%void \n                       s2= (arguments_object_map s1 c l xs args x str) in\n                          if str\n                          then let  vthrower = (Coq_value_object (Coq_object_loc_prealloc\n                                                                Coq_prealloc_throw_type_error)) in\n                              let  a0 = ({ attributes_accessor_get = vthrower;\n                                            attributes_accessor_set = vthrower;\n                                            attributes_accessor_enumerable = false;\n                                            attributes_accessor_configurable = false }) in\n                                  let%bool\n                                    \n                                    (s3, b_2) = (object_define_own_prop s2 c l\n                                       ("caller")\n                                       (descriptor_of_attributes\n                                          (Coq_attributes_accessor_of a0)) false) in\n                                       let%bool\n                                         \n                                         (s4, b_3) = (object_define_own_prop s3 c l\n                                            ("callee")\n                                            (descriptor_of_attributes\n                                               (Coq_attributes_accessor_of a0)) false) in\n                                            res_ter s4 (res_val (Coq_value_object l))\n                          else let  a0 = ({ attributes_data_value = (Coq_value_object lf);\n                                             attributes_data_writable = true;\n                                             attributes_data_enumerable = false;\n                                             attributes_data_configurable = true }) in\n                              let%bool\n                                 (s3, b_2) = (object_define_own_prop s2 c l\n                                   ("callee")\n                                   (descriptor_of_attributes (Coq_attributes_data_of a0))\n                                   false) in\n                                    res_ter s3 (res_val (Coq_value_object l))\n\n(** val binding_inst_arg_obj :\n    state -> execution_ctx -> object_loc -> prog -> string\n    list -> value list -> env_loc -> result_void **)\n\nand binding_inst_arg_obj s c lf p xs args l =\n  let arguments_ =\n    "arguments"\n  in\n  let  str = (prog_intro_strictness p) in\n      let%object\n         (s1, largs) = (create_arguments_object s c lf xs args\n           c.execution_ctx_variable_env str) in\n            if str\n            then let%void \n                s2= (env_record_create_immutable_binding s1 l arguments_) in\n                   env_record_initialize_immutable_binding s2 l arguments_\n                     (Coq_value_object largs)\n            else env_record_create_set_mutable_binding s1 c l arguments_ None\n                (Coq_value_object largs) false\n\n(** val binding_inst_var_decls :\n    state -> execution_ctx -> env_loc -> string list -> bool\n    -> strictness_flag -> result_void **)\n\nand binding_inst_var_decls s c l vds bconfig str =\n  match vds with\n  | [] -> res_void s\n  | vd :: vds_2 ->\n    let  bivd = (fun s0 ->\n        binding_inst_var_decls s0 c l vds_2 bconfig str) in\n        let%bool (s1, has) = (env_record_has_binding s c l vd) in\n            if has\n            then bivd s1\n            else let%void\n                 s2 = (env_record_create_set_mutable_binding s1 c l vd (Some\n                                                                    bconfig) (Coq_value_prim Coq_prim_undef) str) in  bivd s2\n\n(** val execution_ctx_binding_inst :\n    state -> execution_ctx -> codetype -> object_loc option ->\n    prog -> value list -> result_void **)\n\nand execution_ctx_binding_inst s c ct funco p args =\n  match c.execution_ctx_variable_env with\n  | [] ->\n    (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n      s\n      ("Empty [execution_ctx_variable_env] in [execution_ctx_binding_inst].")\n  | l :: l0 ->\n    let  str = (prog_intro_strictness p) in\n        let  follow = (fun s_2 names ->\n            let \n              bconfig = (codetype_compare ct Coq_codetype_eval) in\n                 let  fds = (prog_funcdecl p) in\n                     let%void\n                       \n                       s1= (binding_inst_function_decls s_2 c l fds str bconfig) in\n                          let%bool\n                            \n                            (s2, bdefined) = (env_record_has_binding s1 c l\n                               ("arguments")) in\n                               let \n                                 follow2 = (fun s10 ->\n                                   let vds = prog_vardecl p in\n                                   binding_inst_var_decls s10 c l vds bconfig str) in\n                                    match ct with\n                                    | Coq_codetype_func ->\n                                      (match funco with\n                                       | Some func ->\n                                         if bdefined\n                                         then follow2 s2\n                                         else let%void\n                                              s3 = (binding_inst_arg_obj s2 c func p names\n                                                args l) in  follow2 s3\n                                       | None ->\n                                         if bdefined\n                                         then follow2 s2\n                                         else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                             s2\n                                             ("Weird `arguments\\\' object in [execution_ctx_binding_inst]."))\n                                    | Coq_codetype_global -> follow2 s2\n                                    | Coq_codetype_eval -> follow2 s2) in\n            match ct with\n            | Coq_codetype_func ->\n              (match funco with\n               | Some func ->\n                 let%some \n                   nameso = (run_object_method object_formal_parameters_ s func) in\n                      let%some names = (nameso) in\n                          let%void\n                            \n                            s_2 = (binding_inst_formal_params s c l args names str) in  follow s_2 names\n               | None ->\n                 (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                   s\n                   ("Non coherent functionnal code type in [execution_ctx_binding_inst]."))\n            | Coq_codetype_global ->\n              (match funco with\n               | Some o ->\n                 (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                   s\n                   ("Non coherent non-functionnal code type in [execution_ctx_binding_inst].")\n               | None -> follow s [])\n            | Coq_codetype_eval ->\n              (match funco with\n               | Some o ->\n                 (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                   s\n                   ("Non coherent non-functionnal code type in [execution_ctx_binding_inst].")\n               | None -> follow s [])\n\n(** val entering_func_code :\n    state -> execution_ctx -> object_loc -> value -> value list\n    -> result **)\n\nand entering_func_code s c lf vthis args =\n  let%some bdo = (run_object_method object_code_ s lf) in\n      let%some bd = (bdo) in\n          let  str = (funcbody_is_strict bd) in\n              let  follow = (fun s_2 vthis_2 ->\n                  let%some lexo = (run_object_method object_scope_ s_2 lf) in\n                      let%some lex = (lexo) in\n                          let  p = (lexical_env_alloc_decl s_2 lex) in\n                              let (lex_2, s1) = p in\n                              let \n                                c_2 = (execution_ctx_intro_same lex_2 vthis_2 str) in\n                                   let%void\n                                      s2= (execution_ctx_binding_inst s1 c_2 Coq_codetype_func\n                                        (Some lf) (funcbody_prog bd) args) in\n                                         run_call_default s2 c_2 lf) in\n                  if str\n                  then follow s vthis\n                  else (match vthis with\n                      | Coq_value_prim p ->\n                        (match p with\n                         | Coq_prim_undef ->\n                           follow s (Coq_value_object (Coq_object_loc_prealloc\n                                                         Coq_prealloc_global))\n                         | Coq_prim_null ->\n                           follow s (Coq_value_object (Coq_object_loc_prealloc\n                                                         Coq_prealloc_global))\n                         | Coq_prim_bool b -> let%value (s2, v) = (to_object s c vthis) in follow s2 v\n                         | Coq_prim_number n -> let%value (s2, v) = (to_object s c vthis) in follow s2 v\n                         | Coq_prim_string s0 ->\n                           let%value (s2, v) = (to_object s c vthis) in follow s2 v)\n                      | Coq_value_object lthis -> follow s vthis)\n\n(** val run_object_get_own_prop :\n    state -> execution_ctx -> object_loc -> prop_name ->\n    full_descriptor specres **)\n\nand run_object_get_own_prop s c l x =\n  let%some b = (run_object_method object_get_own_prop_ s l) in\n      let  def = (fun s_2 ->\n          let%some p = (run_object_method object_properties_ s_2 l) in\n              res_spec s_2\n                (ifx_some_or_default\n                   (convert_option_attributes\n                      (HeapStr.read_option p x))\n                   Coq_full_descriptor_undef (fun x -> x))) in\n          match b with\n          | Coq_builtin_get_own_prop_default -> def s\n          | Coq_builtin_get_own_prop_args_obj ->\n            let%run (s1, d) = (def s) in begin\n                match d with\n                | Coq_full_descriptor_undef ->\n                  res_spec s1 Coq_full_descriptor_undef\n                | Coq_full_descriptor_some a ->\n                  let%some \n                    lmapo = (run_object_method object_parameter_map_ s1 l) in\n                       let%some lmap = (lmapo) in\n                           let%run \n                             (s2, d0) = (run_object_get_own_prop s1 c lmap x) in\n                                let  follow = (fun s_2 a0 ->\n                                    res_spec s_2 (Coq_full_descriptor_some a0)) in\n                                    match d0 with\n                                    | Coq_full_descriptor_undef -> follow s2 a\n                                    | Coq_full_descriptor_some amap ->\n                                      let%value \n                                        (s3, v) = (run_object_get s2 c lmap x) in\n                                           match a with\n                                           | Coq_attributes_data_of ad ->\n                                             follow s3 (Coq_attributes_data_of\n                                                          (attributes_data_with_value ad v))\n                                           | Coq_attributes_accessor_of aa ->\n                                             (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                               s3\n                                               ("[run_object_get_own_prop]:  received an accessor property descriptor in a point where the specification suppose it never happens.")\n            end\n          | Coq_builtin_get_own_prop_string ->\n            let%run (s0, d) = (def s) in\n                match d with\n                | Coq_full_descriptor_undef ->\n                  let%run\n                    \n                    (s1, k) = (to_int32 s0 c (Coq_value_prim (Coq_prim_string x))) in\n                       let%string\n                         \n                         (s2, s3) = (to_string s1 c (Coq_value_prim\n                                            (Coq_prim_number (JsNumber.absolute k)))) in\n                            if not (string_eq x s3)\n                            then res_spec s2 Coq_full_descriptor_undef\n                            else let%string (s4, str) = (run_object_prim_value s2 l) in\n                                let%run\n                                   (s5, k0) = (to_int32 s4 c (Coq_value_prim\n                                                    (Coq_prim_string x))) in\n                                      let  len = (number_of_int (strlength str)) in\n                                          if le_int_decidable len k0\n                                          then res_spec s5 Coq_full_descriptor_undef\n                                          else let resultStr =\n                                                 string_sub str (int_of_number k0) 1\n                                                 (* TODO: check k0 is not negative *)\n                                            in\n                                            let a = { attributes_data_value =\n                                                        (Coq_value_prim (Coq_prim_string\n                                                                           resultStr)); attributes_data_writable =\n                                                                                          false; attributes_data_enumerable = true;\n                                                      attributes_data_configurable = false }\n                                            in\n                                            res_spec s5 (Coq_full_descriptor_some\n                                                           (Coq_attributes_data_of a))\n                | Coq_full_descriptor_some a -> res_spec s0 d\n\n(** val run_function_has_instance :\n    state -> object_loc -> value -> result **)\n\nand run_function_has_instance s c lv _foo_ = match _foo_ with\n  | Coq_value_prim p -> run_error s c Coq_native_error_type\n  | Coq_value_object lo ->\n    let%some vproto = (run_object_method object_proto_ s lv) in\n        match vproto with\n        | Coq_value_prim p ->\n          (match p with\n           | Coq_prim_null ->\n             res_ter s (res_val (Coq_value_prim (Coq_prim_bool false)))\n           | _ ->\n             (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n               s\n               ("Primitive found in the prototype chain in [run_object_has_instance_loop]."))\n        | Coq_value_object proto ->\n          if object_loc_compare proto lo\n          then res_ter s (res_val (Coq_value_prim (Coq_prim_bool true)))\n          else run_function_has_instance s c proto (Coq_value_object\n                                                    lo)\n\n(** val run_object_has_instance :\n    state -> execution_ctx -> builtin_has_instance -> object_loc\n    -> value -> result **)\n\nand run_object_has_instance s c b l v =\n  match b with\n  | Coq_builtin_has_instance_function ->\n    (match v with\n     | Coq_value_prim w ->\n       result_out (Coq_out_ter (s,\n                                (res_val (Coq_value_prim (Coq_prim_bool false)))))\n     | Coq_value_object lv ->\n       let%value\n         \n         (s1, vproto) = (run_object_get s c l\n            ("prototype")) in\n            match vproto with\n            | Coq_value_prim p -> run_error s1 c Coq_native_error_type\n            | Coq_value_object lproto ->\n              run_function_has_instance s1 c lv (Coq_value_object\n                                                 lproto))\n  | Coq_builtin_has_instance_after_bind ->\n    let%some ol = (run_object_method object_target_function_ s l) in\n        let%some l0= (ol) in\n            let%some ob = (run_object_method object_has_instance_ s l0) in\n                match ob with\n                | Some b0 -> run_object_has_instance s c b0 l0 v\n                | None -> run_error s c Coq_native_error_type\n\n(** val from_prop_descriptor :\n    state -> execution_ctx -> full_descriptor -> result **)\n\nand from_prop_descriptor s c _foo_ = match _foo_ with\n  | Coq_full_descriptor_undef ->\n    result_out (Coq_out_ter (s, (res_val (Coq_value_prim Coq_prim_undef))))\n  | Coq_full_descriptor_some a ->\n    let%object \n      (s1, l) = (run_construct_prealloc s c Coq_prealloc_object []) in\n         let  follow = (fun s0 x ->\n             let\n                a1 = (attributes_data_intro_all_true (Coq_value_prim (Coq_prim_bool\n                                                                  (attributes_enumerable a)))) in\n                   let%bool\n                      (s0_2, x0) = (object_define_own_prop s0 c l\n                        ("enumerable")\n                        (descriptor_of_attributes (Coq_attributes_data_of a1))\n                        throw_false) in\n                         let\n                            a2 = (attributes_data_intro_all_true (Coq_value_prim (Coq_prim_bool\n                                                                              (attributes_configurable a)))) in\n                               let%bool\n                                  (s_2, x1) = (object_define_own_prop s0_2 c l\n                                    ("configurable")\n                                    (descriptor_of_attributes (Coq_attributes_data_of a2))\n                                    throw_false) in\n                                     res_ter s_2 (res_val (Coq_value_object l))) in\n             match a with\n             | Coq_attributes_data_of ad ->\n               let \n                 a1 = (attributes_data_intro_all_true ad.attributes_data_value) in\n                    let%bool\n                       (s2, x) = (object_define_own_prop s1 c l\n                         ("value")\n                         (descriptor_of_attributes (Coq_attributes_data_of a1))\n                         throw_false) in\n                          let\n                             a2 = (attributes_data_intro_all_true (Coq_value_prim (Coq_prim_bool\n                                                                               ad.attributes_data_writable))) in\n                                let%bool\n                                   (s3, v) = (object_define_own_prop s2 c l\n                                     ("writable")\n                                     (descriptor_of_attributes (Coq_attributes_data_of a2))\n                                     throw_false) in follow s3 v\n             | Coq_attributes_accessor_of aa ->\n               let\n                 \n                 a1 = (attributes_data_intro_all_true aa.attributes_accessor_get) in\n                    let%bool\n                       (s2, x) = (object_define_own_prop s1 c l ("get")\n                         (descriptor_of_attributes (Coq_attributes_data_of a1))\n                         throw_false) in\n                          let\n                            \n                            a2 = (attributes_data_intro_all_true aa.attributes_accessor_set) in\n                               let%bool\n                                  (s3, v) = (object_define_own_prop s2 c l ("set")\n                                    (descriptor_of_attributes (Coq_attributes_data_of a2))\n                                    throw_false) in follow s3 v\n\n(** val run_equal :\n    state -> execution_ctx -> value -> value -> result **)\n\nand run_equal s c v1 v2 =\n  let conv_number = fun s0 v -> to_number s0 c v in\n  let conv_primitive = fun s0 v -> to_primitive s0 c v None in\n  let  checkTypesThen = (fun s0 v3 v4 k ->\n      let ty1 = type_of v3 in\n      let ty2 = type_of v4 in\n      if type_compare ty1 ty2\n      then result_out (Coq_out_ter (s0,\n                                    (res_val (Coq_value_prim (Coq_prim_bool\n                                                                (equality_test_for_same_type ty1 v3 v4))))))\n      else k ty1 ty2) in\n      checkTypesThen s v1 v2 (fun ty1 ty2 ->\n          let \n            dc_conv = (fun v3 f v4 ->\n              let%value (s0, v2_2) = (f s v4) in run_equal s0 c v3 v2_2) in\n               let so = fun b ->\n                 result_out (Coq_out_ter (s,\n                                          (res_val (Coq_value_prim (Coq_prim_bool b)))))\n               in\n               if (type_compare ty1 Coq_type_null)\n                  && (type_compare ty2 Coq_type_undef)\n               then so true\n               else if (type_compare ty1 Coq_type_undef)\n                   && (type_compare ty2 Coq_type_null)\n               then so true\n               else if (type_compare ty1 Coq_type_number)\n                  && (type_compare ty2 Coq_type_string)\n               then dc_conv v1 conv_number v2\n               else if \n                     (type_compare ty1 Coq_type_string)\n                 &&  (type_compare ty2 Coq_type_number)\n               then dc_conv v2 conv_number v1\n               else if type_compare ty1 Coq_type_bool\n               then dc_conv v2 conv_number v1\n               else if type_compare ty2 Coq_type_bool\n               then dc_conv v1 conv_number v2\n               else if \n                   (   (type_compare ty1 Coq_type_string)\n                    || (type_compare ty1 Coq_type_number))\n                &&\n                   (type_compare ty2 Coq_type_object)\n               then dc_conv v1 conv_primitive v2\n               else if \n                    (type_compare ty1 Coq_type_object)\n                 && (   (type_compare ty2 Coq_type_string)\n                     || (type_compare ty2 Coq_type_number))\n               then dc_conv v2 conv_primitive v1\n               else so false)\n\n(** val convert_twice :\n    (\'a2 resultof -> (state -> \'a1 -> (\'a1 * \'a1) specres) -> (\'a1 * \'a1)\n    specres) -> (state -> value -> \'a2 resultof) -> state -> value -> value\n    -> (\'a1 * \'a1) specres **)\n\nand convert_twice :\n  \'a1 \'a2 . (\'a2 resultof -> (state -> \'a1 -> (\'a1 * \'a1) specres) -> (\'a1 * \'a1) specres) ->\n  (state -> value -> \'a2 resultof) -> state -> value -> value -> (\'a1 * \'a1) specres\n = fun ifv kC s v1 v2 ->\n    ifv (kC s v1) (fun s1 vc1 ->\n        ifv (kC s1 v2) (fun s2 vc2 -> res_spec s2 (vc1, vc2)))\n\n(** val convert_twice_primitive :\n    state -> execution_ctx -> value -> value -> (prim * prim)\n    specres **)\n\nand convert_twice_primitive s c v1 v2 =\n  convert_twice ifx_prim (fun s0 v -> to_primitive s0 c v None) s v1 v2\n\n(** val convert_twice_number :\n    state -> execution_ctx -> value -> value ->\n    (number * number) specres **)\n\nand convert_twice_number s c v1 v2 =\n  convert_twice ifx_number (fun s0 v -> to_number s0 c v) s v1 v2\n\n(** val convert_twice_string :\n    state -> execution_ctx -> value -> value ->\n    (string * string) specres **)\n\nand convert_twice_string s c v1 v2 =\n  convert_twice ifx_string (fun s0 v -> to_string s0 c v) s v1 v2\n\n(** val issome : \'a1 option -> bool **)\n\nand issome : \'a1 . \'a1 option -> bool = fun _foo_ ->\n  match _foo_ with\n  | Some t -> true\n  | None -> false\n\nand run_binary_op_add s c v1 v2 =\n  let%run (s1, (w1, w2)) = (convert_twice_primitive s c v1 v2) in\n  if  (type_compare (type_of (Coq_value_prim w1)) Coq_type_string)\n   || (type_compare (type_of (Coq_value_prim w2)) Coq_type_string)\n  then let%run (s2, (str1, str2)) = (convert_twice_string s1 c (Coq_value_prim w1) (Coq_value_prim w2)) in\n    res_out (Coq_out_ter (s2, (res_val (Coq_value_prim (Coq_prim_string (strappend str1 str2))))))\n  else let%run (s2, (n1, n2)) = (convert_twice_number s1 c (Coq_value_prim w1) (Coq_value_prim w2)) in\n    res_out (Coq_out_ter (s2, (res_val (Coq_value_prim (Coq_prim_number (n1 +. n2))))))\n\nand run_binary_op_arith mathop s c v1 v2 =\n  let%run (s1, nn) = (convert_twice_number s c v1 v2) in\n  let (n1, n2) = nn in\n  res_out (Coq_out_ter (s1, (res_val (Coq_value_prim (Coq_prim_number (mathop n1 n2))))))\n\nand run_binary_op_shift b_unsigned mathop s c v1 v2 =\n  let conv = (if b_unsigned then to_uint32 else to_int32) in\n  let%run (s1, k1) = (conv s c v1) in\n  let%run (s2, k2) = (to_uint32 s1 c v2) in\n  let k2_2 = JsNumber.modulo_32 k2 in\n  res_ter s2 (res_val (Coq_value_prim (Coq_prim_number (mathop k1 k2_2))))\n\nand run_binary_op_bitwise mathop s c v1 v2 =\n  let%run (s1, k1) = (to_int32 s c v1) in\n  let%run (s2, k2) = (to_int32 s1 c v2) in\n  res_ter s2 (res_val (Coq_value_prim (Coq_prim_number (mathop k1 k2))))\n\nand run_binary_op_compare b_swap b_neg s c v1 v2 =\n  let%run (s1, ww) = convert_twice_primitive s c v1 v2 in\n  let (w1, w2) = ww in\n  let p = if b_swap then (w2, w1) else (w1, w2) in\n  let (wa, wb) = p in\n  let wr = inequality_test_primitive wa wb in\n  if prim_compare wr Coq_prim_undef\n  then res_out (Coq_out_ter (s1, res_val (Coq_value_prim (Coq_prim_bool false))))\n  else if (b_neg) && (prim_compare wr (Coq_prim_bool true))\n  then res_out (Coq_out_ter (s1,res_val (Coq_value_prim (Coq_prim_bool false))))\n  else if (b_neg) && (prim_compare wr (Coq_prim_bool false))\n  then res_out (Coq_out_ter (s1,res_val (Coq_value_prim (Coq_prim_bool true))))\n  else res_out (Coq_out_ter (s1,res_val (Coq_value_prim wr)))\n\nand run_binary_op_instanceof s c v1 v2 =\n  match v2 with\n  | Coq_value_prim p -> run_error s c Coq_native_error_type\n  | Coq_value_object l ->\n    let%some b = (run_object_method object_has_instance_ s l) in\n    match b with\n    | None -> run_error s c Coq_native_error_type\n    | Some has_instance_id -> run_object_has_instance s c has_instance_id l v1\n\nand run_binary_op_in s c v1 v2 =\n  match v2 with\n  | Coq_value_prim p -> run_error s c Coq_native_error_type\n  | Coq_value_object l ->\n    let%string (s2, x) = (to_string s c v1) in\n    object_has_prop s2 c l x\n\n(** val run_binary_op :\n    state -> execution_ctx -> binary_op -> value -> value ->\n    result **)\n\nand run_binary_op s c op v1 v2 =\n  match op with\n  | Coq_binary_op_mult -> run_binary_op_arith (fun x y -> x *. y) s c v1 v2\n  | Coq_binary_op_div -> run_binary_op_arith (fun x y -> x /. y) s c v1 v2\n  | Coq_binary_op_mod -> run_binary_op_arith (fun x y -> JsNumber.fmod x y) s c v1 v2\n  | Coq_binary_op_sub -> run_binary_op_arith (fun x y -> x -. y) s c v1 v2\n  | Coq_binary_op_lt -> run_binary_op_compare false false s c v1 v2\n  | Coq_binary_op_gt -> run_binary_op_compare true false s c v1 v2\n  | Coq_binary_op_le -> run_binary_op_compare true true s c v1 v2\n  | Coq_binary_op_ge -> run_binary_op_compare false true s c v1 v2\n  | Coq_binary_op_left_shift -> run_binary_op_shift false JsNumber.int32_left_shift s c v1 v2\n  | Coq_binary_op_right_shift -> run_binary_op_shift false JsNumber.int32_right_shift s c v1 v2\n  | Coq_binary_op_unsigned_right_shift -> run_binary_op_shift true JsNumber.uint32_right_shift s c v1 v2\n  | Coq_binary_op_bitwise_and -> run_binary_op_bitwise JsNumber.int32_bitwise_and s c v1 v2\n  | Coq_binary_op_bitwise_or  -> run_binary_op_bitwise JsNumber.int32_bitwise_or s c v1 v2\n  | Coq_binary_op_bitwise_xor -> run_binary_op_bitwise JsNumber.int32_bitwise_xor s c v1 v2\n  | Coq_binary_op_add -> run_binary_op_add s c v1 v2\n  | Coq_binary_op_instanceof -> run_binary_op_instanceof s c v1 v2\n  | Coq_binary_op_in -> run_binary_op_in s c v1 v2\n  | Coq_binary_op_equal -> run_equal s c v1 v2\n  | Coq_binary_op_disequal ->\n    let%bool (s0, b0) = (run_equal s c v1 v2) in\n    res_ter s0 (res_val (Coq_value_prim (Coq_prim_bool (not b0))))\n  | Coq_binary_op_strict_equal ->\n    result_out (Coq_out_ter (s, (res_val (Coq_value_prim (Coq_prim_bool (strict_equality_test v1 v2))))))\n  | Coq_binary_op_strict_disequal ->\n    result_out (Coq_out_ter (s, (res_val (Coq_value_prim (Coq_prim_bool (not (strict_equality_test v1 v2)))))))\n  | Coq_binary_op_coma -> result_out (Coq_out_ter (s, (res_val v2)))\n  | Coq_binary_op_and -> Coq_result_impossible\n  | Coq_binary_op_or  -> Coq_result_impossible\n\n(** val run_prepost_op : unary_op -> ((number -> number) * bool) option **)\n\nand run_prepost_op _foo_ = match _foo_ with\n  | Coq_unary_op_delete -> None\n  | Coq_unary_op_void -> None\n  | Coq_unary_op_typeof -> None\n  | Coq_unary_op_post_incr -> Some (add_one, false)\n  | Coq_unary_op_post_decr -> Some (sub_one, false)\n  | Coq_unary_op_pre_incr -> Some (add_one, true)\n  | Coq_unary_op_pre_decr -> Some (sub_one, true)\n  | Coq_unary_op_add -> None\n  | Coq_unary_op_neg -> None\n  | Coq_unary_op_bitwise_not -> None\n  | Coq_unary_op_not -> None\n\n(** val run_typeof_value : state -> value -> string **)\n\nand run_typeof_value s _foo_ = match _foo_ with\n  | Coq_value_prim w -> typeof_prim w\n  | Coq_value_object l ->\n    if is_callable_dec s (Coq_value_object l)\n    then "function"\n    else "object"\n\n(** val run_unary_op :\n    state -> execution_ctx -> unary_op -> expr -> result **)\n\nand run_unary_op s c op e =\n  if prepost_unary_op_dec op\n  then let%success (s1, rv1)= (run_expr s c e) in\n      let%run (s2, v2) = (ref_get_value s1 c rv1) in\n          let%number (s3, n1) = (to_number s2 c v2) in\n              let%some po = (run_prepost_op op) in\n                  let (number_op, is_pre) = po in\n                  let  n2 = (number_op n1) in\n                      let \n                        v = (Coq_prim_number (if is_pre then n2 else n1)) in\n                           let%void\n                              s4= (ref_put_value s3 c rv1 (Coq_value_prim\n                                                        (Coq_prim_number n2))) in\n                                 result_out (Coq_out_ter (s4,\n                                                          (res_val (Coq_value_prim v))))\n  else (match op with\n      | Coq_unary_op_delete ->\n        let%success (s0, rv)= (run_expr s c e) in begin\n            match rv with\n            | Coq_resvalue_empty ->\n              res_ter s0 (res_val (Coq_value_prim (Coq_prim_bool true)))\n            | Coq_resvalue_value v ->\n              res_ter s0 (res_val (Coq_value_prim (Coq_prim_bool true)))\n            | Coq_resvalue_ref r ->\n              if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_undef\n              then if r.ref_strict\n                then run_error s0 c Coq_native_error_syntax\n                else res_ter s0\n                    (res_val (Coq_value_prim (Coq_prim_bool true)))\n              else (match r.ref_base with\n                  | Coq_ref_base_type_value v ->\n                    let%object (s1, l) = (to_object s0 c v) in\n                        object_delete s1 c l r.ref_name\n                          r.ref_strict\n                  | Coq_ref_base_type_env_loc l ->\n                    if r.ref_strict\n                    then run_error s0 c Coq_native_error_syntax\n                    else env_record_delete_binding s0 c l r.ref_name)\n        end\n      | Coq_unary_op_typeof ->\n        let%success (s1, rv)= (run_expr s c e) in begin\n            match rv with\n            | Coq_resvalue_empty ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s1\n                ("Empty result for a `typeof\\\' in [run_unary_op].")\n            | Coq_resvalue_value v ->\n              res_ter s1\n                (res_val (Coq_value_prim (Coq_prim_string\n                                            (run_typeof_value s1 v))))\n            | Coq_resvalue_ref r ->\n              if ref_kind_comparable (ref_kind_of r) Coq_ref_kind_undef\n              then res_ter s1\n                  (res_val (Coq_value_prim (Coq_prim_string\n                                              ("undefined"))))\n              else let%run \n                  (s2, v) = (ref_get_value s1 c (Coq_resvalue_ref r)) in\n                     res_ter s2\n                       (res_val (Coq_value_prim (Coq_prim_string\n                                                   (run_typeof_value s2 v))))\n        end\n      | _ ->\n        let%run (s1, v) = (run_expr_get_value s c e) in\n            match op with\n            | Coq_unary_op_void ->\n              res_ter s1 (res_val (Coq_value_prim Coq_prim_undef))\n            | Coq_unary_op_add -> to_number s1 c v\n            | Coq_unary_op_neg ->\n              let%number (s2, n) = (to_number s1 c v) in\n                  res_ter s2\n                    (res_val (Coq_value_prim (Coq_prim_number\n                                                (JsNumber.neg n))))\n            | Coq_unary_op_bitwise_not ->\n              let%run (s2, k) = (to_int32 s1 c v) in\n                  res_ter s2\n                    (res_val (Coq_value_prim (Coq_prim_number (JsNumber.int32_bitwise_not k))))\n            | Coq_unary_op_not ->\n              res_ter s1\n                (res_val (Coq_value_prim (Coq_prim_bool\n                                            (not (convert_value_to_boolean v)))))\n            | _ ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s1\n                ("Undealt regular operator in [run_unary_op]."))\n\n(** val create_new_function_in :\n    state -> execution_ctx -> string list -> funcbody ->\n    result **)\n\nand create_new_function_in s c args bd =\n  creating_function_object s c args bd c.execution_ctx_lexical_env\n    c.execution_ctx_strict\n\n(** val init_object :\n    state -> execution_ctx -> object_loc -> propdefs -> result **)\n\nand init_object s c l _foo_ = match _foo_ with\n  | [] -> result_out (Coq_out_ter (s, (res_val (Coq_value_object l))))\n  | p :: pds_2 ->\n    let (pn, pb) = p in\n    let  x = (string_of_propname pn) in\n        let  follows = (fun s1 desc ->\n            let%success \n              (s2, rv) = (object_define_own_prop s1 c l x desc false) in  init_object s2 c l pds_2) in\n            match pb with\n            | Coq_propbody_val e0 ->\n              let%run (s1, v0) = (run_expr_get_value s c e0) in\n                  let desc = { descriptor_value = (Some v0); descriptor_writable =\n                                                               (Some true); descriptor_get = None; descriptor_set = None;\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n            | Coq_propbody_get bd ->\n              let%value (s1, v0) = (create_new_function_in s c [] bd) in\n                  let desc = { descriptor_value = None; descriptor_writable = None;\n                               descriptor_get = (Some v0); descriptor_set = None;\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n            | Coq_propbody_set (args, bd) ->\n              let%value (s1, v0) = (create_new_function_in s c args bd) in\n                  let desc = { descriptor_value = None; descriptor_writable = None;\n                               descriptor_get = None; descriptor_set = (Some v0);\n                               descriptor_enumerable = (Some true); descriptor_configurable =\n                                                                      (Some true) }\n                  in\n                  follows s1 desc\n\n(** val run_array_element_list :\n    state -> execution_ctx -> object_loc -> expr option list ->\n    float -> result **)\n\nand run_array_element_list s c l oes n =\n  match oes with\n  | [] -> result_out (Coq_out_ter (s, (res_val (Coq_value_object l))))\n  | o :: oes_2 ->\n    (match o with\n     | Some e ->\n       let \n         loop_result = (fun s0 ->\n           run_array_element_list s0 c l oes_2 0.) in\n            let%run (s0, v) = (run_expr_get_value s c e) in\n                let%value\n                   (s1, vlen) = (run_object_get s0 c l\n                     ("length")) in\n                      let%run (s2, ilen) = (to_uint32 s1 c vlen) in\n                          let%string\n                             (s3, slen) = (to_string s2 c (Coq_value_prim (Coq_prim_number\n                                                               (ilen +. n)))) in\n                                let  desc = ({ attributes_data_value = v;\n                                              attributes_data_writable = true;\n                                              attributes_data_enumerable = true;\n                                              attributes_data_configurable = true }) in\n                                    let%bool\n                                       (s4, x) = (object_define_own_prop s3 c l slen\n                                         (descriptor_of_attributes (Coq_attributes_data_of\n                                                                      desc)) false) in\n                                          let%object (s5, l0) = (loop_result s4) in\n                                              res_ter s5 (res_val (Coq_value_object l0))\n     | None ->\n       let  firstIndex = (elision_head_count (None :: oes_2)) in\n           run_array_element_list s c l\n             (elision_head_remove (None :: oes_2)) (number_of_int firstIndex))\n\n(** val init_array :\n    state -> execution_ctx -> object_loc -> expr option list ->\n    result **)\n\nand init_array s c l oes =\n  let  elementList = (elision_tail_remove oes) in\n      let  elisionLength = (elision_tail_count oes) in\n          let%object \n            (s0, l0) = (run_array_element_list s c l elementList 0.) in\n               let%value\n                  (s1, vlen) = (run_object_get s0 c l0\n                    ("length")) in\n                     let%run (s2, ilen) = (to_uint32 s1 c vlen) in\n                         let%run\n                           \n                           (s3, len) = (to_uint32 s2 c (Coq_value_prim (Coq_prim_number\n                                                              (ilen +. number_of_int elisionLength)))) in\n                              let%not_throw\n                                 (s4, x) = (object_put s3 c l0\n                                   ("length")\n                                   (Coq_value_prim (Coq_prim_number len))\n                                   throw_false) in\n                                    result_out (Coq_out_ter (s4,\n                                                             (res_val (Coq_value_object l0))))\n\n(** val run_var_decl_item :\n    state -> execution_ctx -> prop_name -> expr option -> result **)\n\nand run_var_decl_item s c x _foo_ = match _foo_ with\n  | Some e ->\n    let%run (s1, ir) = (identifier_resolution s c x) in\n        let%run (s2, v) = (run_expr_get_value s1 c e) in\n            let%void s3= (ref_put_value s2 c (Coq_resvalue_ref ir) v) in\n                result_out (Coq_out_ter (s3,\n                                         (res_val (Coq_value_prim (Coq_prim_string x)))))\n  | None ->\n    result_out (Coq_out_ter (s,\n                             (res_val (Coq_value_prim (Coq_prim_string x)))))\n\n(** val run_var_decl :\n    state -> execution_ctx -> (prop_name * expr option) list ->\n    result **)\n\nand run_var_decl s c _foo_ = match _foo_ with\n  | [] -> result_out (Coq_out_ter (s, res_empty))\n  | y :: xeos_2 ->\n    let (x, eo) = y in\n    let%value (s1, vname) = (run_var_decl_item s c x eo) in\n        run_var_decl s1 c xeos_2\n\n(** val run_list_expr :\n    state -> execution_ctx -> value list -> expr list -> value\n    list specres **)\n\nand run_list_expr s1 c vs _foo_ = match _foo_ with\n  | [] -> res_spec s1 (rev vs)\n  | e :: es_2 ->\n    let%run (s2, v) = (run_expr_get_value s1 c e) in\n        run_list_expr s2 c (v :: vs) es_2\n\n(** val run_block :\n    state -> execution_ctx -> stat list -> result **)\n\nand run_block s c _foo_ = match _foo_ with\n  | [] -> res_ter s (res_normal Coq_resvalue_empty)\n  | t :: ts_rev_2 ->\n    let%success (s0, rv0)= (run_block s c ts_rev_2) in\n        ifx_success_state rv0 (run_stat s0 c t) (fun x x0 ->\n            result_out (Coq_out_ter (x, (res_normal x0))))\n\nand run_binary_op_and s c e1 e2 =\n  let%run (s1, v1) = (run_expr_get_value s c e1) in\n  let b1 = (convert_value_to_boolean v1) in\n  if not b1\n    then res_ter s1 (res_val v1)\n    else let%run (s2, v) = (run_expr_get_value s1 c e2) in\n    res_ter s2 (res_val v)\n\nand run_binary_op_or s c e1 e2 =\n  let%run (s1, v1) = (run_expr_get_value s c e1) in\n  let b1 = (convert_value_to_boolean v1) in\n  if b1 \n    then res_ter s1 (res_val v1)\n    else let%run (s2, v) = (run_expr_get_value s1 c e2) in\n    res_ter s2 (res_val v)\n\n(** val run_expr_binary_op :\n    state -> execution_ctx -> binary_op -> expr -> expr ->\n    result **)\n\nand run_expr_binary_op s c op e1 e2 =\n  match op with\n  | Coq_binary_op_and -> run_binary_op_and s c e1 e2\n  | Coq_binary_op_or -> run_binary_op_or s c e1 e2\n  | _ ->\n    let%run (s1,v1) = run_expr_get_value s c e1 in\n    let%run (s2,v2) = run_expr_get_value s1 c e2 in\n    run_binary_op s2 c op v1 v2\n\n(** val run_expr_access :\n    state -> execution_ctx -> expr -> expr -> result **)\n\n(* TODO DEPRECATEd\n   and run_expr_access s c e1 e2 =\n   let%run (s1, v1) = (run_expr_get_value s c e1) in\n    let%run (s2, v2) = (run_expr_get_value s1 c e2) in\n      if or_decidable (value_compare v1 (Coq_value_prim Coq_prim_undef))\n           (value_compare v1 (Coq_value_prim Coq_prim_null))\n      then run_error s2 Coq_native_error_type\n      else let%string (s3, x) = (to_string s2 c v2) in\n             res_ter s3\n               (res_ref (ref_create_value v1 x c.execution_ctx_strict))\n*)\n\nand run_expr_access s c e1 e2 =\n  let%run (s1,v1) = run_expr_get_value s c e1 in\n  let%run (s2,v2) = run_expr_get_value s1 c e2 in\n  if    (value_compare v1 (Coq_value_prim Coq_prim_undef))\n     || (value_compare v1 (Coq_value_prim Coq_prim_null))\n  then run_error s2 c Coq_native_error_type\n  else let%string (s3,x) = to_string s2 c v2 in\n    res_ter s3 (res_ref (ref_create_value v1 x c.execution_ctx_strict))\n\n(** val run_expr_assign :\n    state -> execution_ctx -> binary_op option -> expr -> expr\n    -> result **)\n\nand run_expr_assign s c opo e1 e2 =\n  let%success (s1, rv1)= (run_expr s c e1) in\n      let \n        follow = (fun s0 rv_2 ->\n          match rv_2 with\n          | Coq_resvalue_empty ->\n            (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n              s0\n              ("Non-value result in [run_expr_assign].")\n          | Coq_resvalue_value v ->\n            let%void s_2= (ref_put_value s0 c rv1 v) in\n                result_out (Coq_out_ter (s_2, (res_val v)))\n          | Coq_resvalue_ref r ->\n            (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n              s0\n              ("Non-value result in [run_expr_assign].")) in\n           match opo with\n           | Some op ->\n             let%run (s2, v1) = (ref_get_value s1 c rv1) in\n                 let%run (s3, v2) = (run_expr_get_value s2 c e2) in\n                     let%success (s4, v) = (run_binary_op s3 c op v1 v2) in  follow s4 v\n           | None ->\n             let%run (x, x0 )= (run_expr_get_value s1 c e2) in\n                 follow x (Coq_resvalue_value x0)\n\n(** val run_expr_function :\n    state -> execution_ctx -> prop_name option -> string list\n    -> funcbody -> result **)\n\nand run_expr_function s c fo args bd =\n  match fo with\n  | Some fn ->\n    let \n      p = (lexical_env_alloc_decl s c.execution_ctx_lexical_env) in\n         let (lex_2, s_2) = p in\n         let follow = fun l ->\n           let%some e = (env_record_binds_option s_2 l) in\n               let%void s1= (env_record_create_immutable_binding s_2 l fn) in\n                   let%object\n                      (s2, l0) = (creating_function_object s1 c args bd lex_2\n                        (funcbody_is_strict bd)) in\n                         let%void\n                            s3= (env_record_initialize_immutable_binding s2 l fn\n                              (Coq_value_object l0)) in\n                               result_out (Coq_out_ter (s3,\n                                                        (res_val (Coq_value_object l0))))\n         in\n         destr_list lex_2 (fun x ->\n             (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n               s_2\n               ("Empty lexical environnment allocated in [run_expr_function]."))\n           (fun l x -> follow l) ()\n  | None ->\n    let lex = c.execution_ctx_lexical_env in\n    creating_function_object s c args bd lex (funcbody_is_strict bd)\n\n(** val entering_eval_code :\n    state -> execution_ctx -> bool -> funcbody -> (state ->\n    execution_ctx -> result) -> result **)\n\nand entering_eval_code s c direct bd k =\n  let str = ((funcbody_is_strict bd) || (direct && c.execution_ctx_strict)) in\n       let c_2 = (if direct then c else execution_ctx_initial str) in\n           let p = (if str\n              then lexical_env_alloc_decl s c_2.execution_ctx_lexical_env\n              else (c_2.execution_ctx_lexical_env, s)) in\n                 let (lex, s_2) = p in\n                 let c1 = (if str then execution_ctx_with_lex_same c_2 lex else c_2) in\n                      let p0 = (funcbody_prog bd) in\n                          let%void\n                             s1 = (execution_ctx_binding_inst s_2 c1 Coq_codetype_eval None\n                               p0 []) in  k s1 c1\n\n(** val run_eval :\n    state -> execution_ctx -> bool -> value list -> result **)\n\nand run_eval s c is_direct_call vs =\n  match get_arg 0 vs with\n  | Coq_value_prim p ->\n    (match p with\n     | Coq_prim_undef ->\n       result_out (Coq_out_ter (s,\n                                (res_val (Coq_value_prim Coq_prim_undef))))\n     | Coq_prim_null ->\n       result_out (Coq_out_ter (s, (res_val (Coq_value_prim Coq_prim_null))))\n     | Coq_prim_bool b ->\n       result_out (Coq_out_ter (s,\n                                (res_val (Coq_value_prim (Coq_prim_bool b)))))\n     | Coq_prim_number n ->\n       result_out (Coq_out_ter (s,\n                                (res_val (Coq_value_prim (Coq_prim_number n)))))\n     | Coq_prim_string s0 ->\n       let str = (is_direct_call && c.execution_ctx_strict) in\n            match parse_pickable s0 str with\n            | Some p0 ->\n              entering_eval_code s c is_direct_call (Coq_funcbody_intro\n                                                       (p0, s0)) (fun s1 c_2 ->\n                  let%ter (s2, r) = (run_prog s1 c_2 p0) in\n                      match r.res_type with\n                      | Coq_restype_normal ->\n                        ifx_empty_label s2 r (fun x ->\n                            match r.res_value with\n                            | Coq_resvalue_empty ->\n                              res_ter s2 (res_val (Coq_value_prim Coq_prim_undef))\n                            | Coq_resvalue_value v -> res_ter s2 (res_val v)\n                            | Coq_resvalue_ref r0 ->\n                              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                s2\n                                ("Reference found in the result of an `eval\\\' in [run_eval]."))\n                      | Coq_restype_throw -> res_ter s2 (res_throw r.res_value)\n                      | _ ->\n                        (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                          s2\n                          ("Forbidden result type returned by an `eval\\\' in [run_eval]."))\n            | None -> run_error s c Coq_native_error_syntax)\n  | Coq_value_object o ->\n    result_out (Coq_out_ter (s, (res_val (Coq_value_object o))))\n\n(** val run_expr_call :\n    state -> execution_ctx -> expr -> expr list -> result **)\n\nand run_expr_call s c e1 e2s =\n  let  is_eval_direct = (is_syntactic_eval e1) in\n      let%success (s1, rv)= (run_expr s c e1) in\n          let%run (s2, f) = (ref_get_value s1 c rv) in\n              let%run (s3, vs) = (run_list_expr s2 c [] e2s) in\n                  match f with\n                  | Coq_value_prim p -> run_error s3 c Coq_native_error_type\n                  | Coq_value_object l ->\n                    if is_callable_dec s3 (Coq_value_object l)\n                    then let  follow = (fun vthis ->\n                        if object_loc_compare l (Coq_object_loc_prealloc\n                                                      Coq_prealloc_global_eval)\n                        then run_eval s3 c is_eval_direct vs\n                        else run_call s3 c l vthis vs) in\n                        match rv with\n                        | Coq_resvalue_empty ->\n                          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                            s3\n                            ("[run_expr_call] unable to call an  empty result.")\n                        | Coq_resvalue_value v ->\n                          follow (Coq_value_prim Coq_prim_undef)\n                        | Coq_resvalue_ref r ->\n                          (match r.ref_base with\n                           | Coq_ref_base_type_value v ->\n                             if   (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_primitive_base)\n                               || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_null)\n                               || (ref_kind_comparable (ref_kind_of r) Coq_ref_kind_object)\n                             then follow v\n                             else (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                                 s3\n                                 ("[run_expr_call] unable to call a non-property function.")\n                           | Coq_ref_base_type_env_loc l0 ->\n                             let%some v = (env_record_implicit_this_value s3 l0) in  follow v)\n                    else run_error s3 c Coq_native_error_type\n\n(** val run_expr_conditionnal :\n    state -> execution_ctx -> expr -> expr -> expr -> result **)\n\nand run_expr_conditionnal s c e1 e2 e3 =\n  let%run (s1, v1) = (run_expr_get_value s c e1) in\n      let  b = (convert_value_to_boolean v1) in\n          let  e = (if b then e2 else e3) in\n              let%run (s0, r) = (run_expr_get_value s1 c e) in\n                  res_ter s0 (res_val r)\n\n(** val run_expr_new :\n    state -> execution_ctx -> expr -> expr list -> result **)\n\nand run_expr_new s c e1 e2s =\n  let%run (s1, v) = (run_expr_get_value s c e1) in\n      let%run (s2, args) = (run_list_expr s1 c [] e2s) in\n          match v with\n          | Coq_value_prim p -> run_error s2 c Coq_native_error_type\n          | Coq_value_object l ->\n            let%some coo = (run_object_method object_construct_ s2 l) in\n                match coo with\n                | Some co -> run_construct s2 c co l args\n                | None -> run_error s2 c Coq_native_error_type\n\n(** val run_stat_label :\n    state -> execution_ctx -> label -> stat -> result **)\n\nand run_stat_label s c lab t =\n  let%break (s1, r1) = run_stat s c t in\n      result_out (Coq_out_ter (s1,\n                               (if label_compare r1.res_label lab\n                                then res_normal r1.res_value\n                                else r1)))\n\n(** val run_stat_with :\n    state -> execution_ctx -> expr -> stat -> result **)\n\nand run_stat_with s c e1 t2 =\n  let%run (s1, v1) = (run_expr_get_value s c e1) in\n      let%object (s2, l) = (to_object s1 c v1) in\n          let  lex = (c.execution_ctx_lexical_env) in\n              let \n                p = (lexical_env_alloc_object s2 lex l provide_this_true) in\n                   let (lex_2, s3) = p in\n                   let  c_2 = (execution_ctx_with_lex c lex_2) in\n                       run_stat s3 c_2 t2\n\n(** val run_stat_if :\n    state -> execution_ctx -> expr -> stat -> stat option ->\n    result **)\n\nand run_stat_if s c e1 t2 to0 =\n  let%run (s1, v1) = (run_expr_get_value s c e1) in\n      let  b = (convert_value_to_boolean v1) in\n          if b\n          then run_stat s1 c t2\n          else (match to0 with\n              | Some t3 -> run_stat s1 c t3\n              | None ->\n                result_out (Coq_out_ter (s1, (res_normal Coq_resvalue_empty))))\n\n(** val run_stat_while :\n    state -> execution_ctx -> resvalue -> label_set -> expr ->\n    stat -> result **)\n\nand run_stat_while s c rv labs e1 t2 =\n  let%run (s1, v1) = (run_expr_get_value s c e1) in\n      let  b = (convert_value_to_boolean v1) in\n          if b\n          then let%ter (s2, r) = (run_stat s1 c t2) in\n              let\n                 rv_2 = (if not\n                    (resvalue_compare r.res_value Coq_resvalue_empty)\n                 then r.res_value\n                 else rv) in\n                    let  loop = (fun x ->\n                        run_stat_while s2 c rv_2 labs e1 t2) in\n                        if  (not (restype_compare r.res_type Coq_restype_continue))\n                         || (not (res_label_in r labs))\n                        then if \n                             (restype_compare r.res_type Coq_restype_break)\n                           && (res_label_in r labs)\n                          then res_ter s2 (res_normal rv_2)\n                          else if not\n                              (restype_compare r.res_type\n                                 Coq_restype_normal)\n                          then res_ter s2 r\n                          else loop ()\n                        else loop ()\n          else res_ter s1 (res_normal rv)\n\n(** val run_stat_switch_end :\n    state -> execution_ctx -> resvalue -> switchclause list ->\n    result **)\n\nand run_stat_switch_end s c rv _foo_ = match _foo_ with\n  | [] -> result_out (Coq_out_ter (s, (res_normal rv)))\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      ifx_success_state rv (run_block s c (rev ts)) (fun s1 rv1 ->\n          run_stat_switch_end s1 c rv1 scs_2)\n\n(** val run_stat_switch_no_default :\n    state -> execution_ctx -> value -> resvalue -> switchclause\n    list -> result **)\n\nand run_stat_switch_no_default s c vi rv _foo_ = match _foo_ with\n  | [] -> result_out (Coq_out_ter (s, (res_normal rv)))\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let%run (s1, v1) = (run_expr_get_value s c e) in\n          let  b = (strict_equality_test v1 vi) in\n              if b\n              then let%success (s2, rv2)= (run_block s1 c (rev ts)) in\n                  run_stat_switch_end s2 c rv2 scs_2\n              else run_stat_switch_no_default s1 c vi rv scs_2\n\n(** val run_stat_switch_with_default_default :\n    state -> execution_ctx -> stat list -> switchclause list ->\n    result **)\n\nand run_stat_switch_with_default_default s c ts scs =\n  let%success (s1, rv)= (run_block s c (rev ts)) in\n      run_stat_switch_end s1 c rv scs\n\n(** val run_stat_switch_with_default_B :\n    state -> execution_ctx -> value -> resvalue -> stat list ->\n    switchclause list -> result **)\n\nand run_stat_switch_with_default_B s c vi rv ts0 scs = match scs with\n  | [] -> run_stat_switch_with_default_default s c ts0 scs\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let%run (s1, v1) = (run_expr_get_value s c e) in\n          let  b = (strict_equality_test v1 vi) in\n              if b\n              then let%success (s2, rv2)= (run_block s1 c (rev ts)) in\n                  run_stat_switch_end s2 c rv2 scs_2\n              else run_stat_switch_with_default_B s1 c vi rv ts0 scs_2\n\n(** val run_stat_switch_with_default_A :\n    state -> execution_ctx -> bool -> value -> resvalue ->\n    switchclause list -> stat list -> switchclause list -> result **)\n\nand run_stat_switch_with_default_A s c found vi rv scs1 ts0 scs2 =\n  match scs1 with\n  | [] ->\n    if found\n    then run_stat_switch_with_default_default s c ts0 scs2\n    else run_stat_switch_with_default_B s c vi rv ts0 scs2\n  | y :: scs_2 ->\n    match y with Coq_switchclause_intro (e, ts) ->\n      let \n        follow = (fun s0 ->\n          ifx_success_state rv (run_block s0 c (rev ts)) (fun s1 rv0 ->\n              run_stat_switch_with_default_A s1 c true vi rv0 scs_2 ts0 scs2)) in\n           if found\n           then follow s\n           else let%run (s1, v1) = (run_expr_get_value s c e) in\n               let  b = (strict_equality_test v1 vi) in\n                   if b\n                   then follow s1\n                   else run_stat_switch_with_default_A s1 c false vi rv\n                       scs_2 ts0 scs2\n\n(** val run_stat_switch :\n    state -> execution_ctx -> label_set -> expr -> switchbody ->\n    result **)\n\n(* ALTERNATIVE VERSION, WITH LESS FACTORIZATION\nand run_stat_switch s c labs e sb =\n  let%run (s1, vi) = run_expr_get_value s c e in\n  match sb with\n  | Coq_switchbody_nodefault scs ->\n    let%success (s0, r) = begin\n      let%break (s2, r) =\n        run_stat_switch_no_default s1 c vi \n        Coq_resvalue_empty scs in\n      if res_label_in r labs\n      then result_out (Coq_out_ter (s2, (res_normal r.res_value)))\n      else result_out (Coq_out_ter (s2, r))\n      end in\n    res_ter s0 (res_normal r)\n  | Coq_switchbody_withdefault (scs1, ts, scs2) ->\n    let%success (s0, r) = begin\n      let%break (s2, r) = \n        run_stat_switch_with_default_A s1 c false vi\n         Coq_resvalue_empty scs1 ts scs2 in\n      if res_label_in r labs\n      then result_out (Coq_out_ter (s2, (res_normal r.res_value)))\n      else result_out (Coq_out_ter (s2, r)) end in\n    res_ter s0 (res_normal r)\n*)\n\nand run_stat_switch s c labs e sb =\n  let%run (s1, vi) = run_expr_get_value s c e in\n  let  follow = (fun w ->\n    let%success (s0, r) =\n      let%break (s2, r) = w in\n      if res_label_in r labs\n      then result_out (Coq_out_ter (s2, (res_normal r.res_value)))\n      else result_out (Coq_out_ter (s2, r)) in\n    res_ter s0 (res_normal r)) in\n  match sb with\n  | Coq_switchbody_nodefault scs ->\n    follow (run_stat_switch_no_default s1 c vi \n              Coq_resvalue_empty scs)\n  | Coq_switchbody_withdefault (scs1, ts, scs2) ->\n    follow (run_stat_switch_with_default_A s1 c false vi\n              Coq_resvalue_empty scs1 ts scs2)\n\n(** val run_stat_do_while :\n    state -> execution_ctx -> resvalue -> label_set -> expr ->\n    stat -> result **)\n\nand run_stat_do_while s c rv labs e1 t2 =\n  let%ter (s1, r) = (run_stat s c t2) in\n      let\n         rv_2 = (if resvalue_compare r.res_value Coq_resvalue_empty\n         then rv\n         else r.res_value) in\n            let  loop = (fun x ->\n                let%run (s2, v1) = (run_expr_get_value s1 c e1) in\n                    let  b = (convert_value_to_boolean v1) in\n                        if b\n                        then run_stat_do_while s2 c rv_2 labs e1 t2\n                        else res_ter s2 (res_normal rv_2)) in\n                if  (restype_compare r.res_type Coq_restype_continue)\n                   && (res_label_in r labs)\n                then loop ()\n                else if \n                    (restype_compare r.res_type Coq_restype_break)\n                 && (res_label_in r labs)\n                then res_ter s1 (res_normal rv_2)\n                else if not\n                    (restype_compare r.res_type Coq_restype_normal)\n                then res_ter s1 r\n                else loop ()\n\n(** val run_stat_try :\n    state -> execution_ctx -> stat -> (prop_name * stat) option\n    -> stat option -> result **)\n\nand run_stat_try s c t1 t2o t3o =\n  let  finallycont = (fun s1 r ->\n      match t3o with\n      | Some t3 ->\n        let%success (s2, rv_2) = (run_stat s1 c t3) in  res_ter s2 r\n      | None -> res_ter s1 r) in\n      ifx_any_or_throw (run_stat s c t1) finallycont (fun s1 v ->\n          match t2o with\n          | Some y ->\n            let (x, t2) = y in\n            let  lex = (c.execution_ctx_lexical_env) in\n                let  p = (lexical_env_alloc_decl s1 lex) in\n                    let (lex_2, s_2) = p in\n                    (match lex_2 with\n                     | [] ->\n                       (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                         s_2\n                         ("Empty lexical environnment in [run_stat_try].")\n                     | l :: oldlex ->\n                       let%void\n                          s2= (env_record_create_set_mutable_binding s_2 c l x None v\n                            throw_irrelevant) in\n                             let c_2 = execution_ctx_with_lex c lex_2 in\n                             let%ter (s3, r) = (run_stat s2 c_2 t2) in finallycont s3 r)\n          | None -> finallycont s1 (res_throw (Coq_resvalue_value v)))\n\n(** val run_stat_throw :\n    state -> execution_ctx -> expr -> result **)\n\nand run_stat_throw s c e =\n  let%run (s1, v1) = (run_expr_get_value s c e) in\n      res_ter s1 (res_throw (Coq_resvalue_value v1))\n\n(** val run_stat_return :\n    state -> execution_ctx -> expr option -> result **)\n\nand run_stat_return s c _foo_ = match _foo_ with\n  | Some e ->\n    let%run (s1, v1) = (run_expr_get_value s c e) in\n        res_ter s1 (res_return (Coq_resvalue_value v1))\n  | None ->\n    result_out (Coq_out_ter (s,\n                             (res_return (Coq_resvalue_value (Coq_value_prim Coq_prim_undef)))))\n\n(** val run_stat_for_loop :\n    state -> execution_ctx -> label_set -> resvalue -> expr\n    option -> expr option -> stat -> result **)\n\nand run_stat_for_loop s c labs rv eo2 eo3 t =\n  let  follows = (fun s0 ->\n      let%ter (s1, r) = (run_stat s0 c t) in\n          let\n             rv_2 = (if not\n                (resvalue_compare r.res_value Coq_resvalue_empty)\n             then r.res_value\n             else rv) in\n                let  loop = (fun s2 ->\n                    run_stat_for_loop s2 c labs rv_2 eo2 eo3 t) in\n                    if   (restype_compare r.res_type Coq_restype_break)\n                      && (res_label_in r labs)\n                    then res_ter s1 (res_normal rv_2)\n                    else if \n                         (restype_compare r.res_type Coq_restype_normal)\n                      || (    (restype_compare r.res_type Coq_restype_continue)\n                           && (res_label_in r labs))\n                    then (match eo3 with\n                        | Some e3 ->\n                          let%run \n                            (s2, v3) = (run_expr_get_value s1 c e3) in loop s2\n                        | None -> loop s1)\n                    else res_ter s1 r) in\n      match eo2 with\n      | Some e2 ->\n        let%run (s0, v2) = (run_expr_get_value s c e2) in\n            let  b = (convert_value_to_boolean v2) in\n                if b then follows s0 else res_ter s0 (res_normal rv)\n      | None -> follows s\n\n(** val run_stat_for :\n    state -> execution_ctx -> label_set -> expr option -> expr\n    option -> expr option -> stat -> result **)\n\nand run_stat_for s c labs eo1 eo2 eo3 t =\n  let follows = fun s0 ->\n    run_stat_for_loop s0 c labs Coq_resvalue_empty eo2 eo3 t\n  in\n  (match eo1 with\n   | Some e1 ->\n     let%run (s0, v1) = (run_expr_get_value s c e1) in follows s0\n   | None -> follows s)\n\n(** val run_stat_for_var :\n    state -> execution_ctx -> label_set -> (string * expr\n    option) list -> expr option -> expr option -> stat -> result **)\n\nand run_stat_for_var s c labs ds eo2 eo3 t =\n  let%ter (s0, r) = (run_stat s c (Coq_stat_var_decl ds)) in\n      run_stat_for_loop s0 c labs Coq_resvalue_empty eo2 eo3 t\n\n(** val run_expr : state -> execution_ctx -> expr -> result **)\n\nand run_expr s c _term_ = match _term_ with\n  | Coq_expr_this ->\n    result_out (Coq_out_ter (s, (res_val c.execution_ctx_this_binding)))\n  | Coq_expr_identifier x ->\n    let%run (s0, r) = (identifier_resolution s c x) in\n        res_ter s0 (res_ref r)\n  | Coq_expr_literal i ->\n    result_out (Coq_out_ter (s,\n                             (res_val (Coq_value_prim (convert_literal_to_prim i)))))\n  | Coq_expr_object pds ->\n    let%object \n      (s1, l) = (run_construct_prealloc s c Coq_prealloc_object []) in init_object s1 c l pds\n  | Coq_expr_array oes ->\n    let%object \n      (s1, l) = (run_construct_prealloc s c Coq_prealloc_array []) in init_array s1 c l oes\n  | Coq_expr_function (fo, args, bd) -> run_expr_function s c fo args bd\n  | Coq_expr_access (e1, e2) -> run_expr_access s c e1 e2\n  | Coq_expr_member (e1, f) ->\n    run_expr s c (Coq_expr_access (e1, (Coq_expr_literal\n                                          (Coq_literal_string f))))\n  | Coq_expr_new (e1, e2s) -> run_expr_new s c e1 e2s\n  | Coq_expr_call (e1, e2s) -> run_expr_call s c e1 e2s\n  | Coq_expr_unary_op (op, e0) -> run_unary_op s c op e0\n  | Coq_expr_binary_op (e1, op, e2) -> run_expr_binary_op s c op e1 e2\n  | Coq_expr_conditional (e1, e2, e3) ->\n    run_expr_conditionnal s c e1 e2 e3\n  | Coq_expr_assign (e1, opo, e2) -> run_expr_assign s c opo e1 e2\n\n(** val run_stat : state -> execution_ctx -> stat -> result **)\n\nand run_stat s c _term_ = match _term_ with\n  | Coq_stat_expr e ->\n    let%run (s0, r) = (run_expr_get_value s c e) in\n        res_ter s0 (res_val r)\n  | Coq_stat_label (lab, t0) ->\n    run_stat_label s c (Coq_label_string lab) t0\n  | Coq_stat_block ts -> run_block s c (rev ts)\n  | Coq_stat_var_decl xeos -> run_var_decl s c xeos\n  | Coq_stat_if (e1, t2, to0) -> run_stat_if s c e1 t2 to0\n  | Coq_stat_do_while (ls, t1, e2) ->\n    run_stat_do_while s c Coq_resvalue_empty ls e2 t1\n  | Coq_stat_while (ls, e1, t2) ->\n    run_stat_while s c Coq_resvalue_empty ls e1 t2\n  | Coq_stat_with (e1, t2) -> run_stat_with s c e1 t2\n  | Coq_stat_throw e -> run_stat_throw s c e\n  | Coq_stat_return eo -> run_stat_return s c eo\n  | Coq_stat_break so -> result_out (Coq_out_ter (s, (res_break so)))\n  | Coq_stat_continue so -> result_out (Coq_out_ter (s, (res_continue so)))\n  | Coq_stat_try (t1, t2o, t3o) -> run_stat_try s c t1 t2o t3o\n  | Coq_stat_for (ls, eo1, eo2, eo3, s0) ->\n    run_stat_for s c ls eo1 eo2 eo3 s0\n  | Coq_stat_for_var (ls, ds, eo2, eo3, s0) ->\n    run_stat_for_var s c ls ds eo2 eo3 s0\n  | Coq_stat_for_in (ls, e1, e2, s0) ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      ("stat_for_in")\n  | Coq_stat_for_in_var (ls, x, e1o, e2, s0) ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      ("stat_for_in_var")\n  | Coq_stat_debugger -> result_out (Coq_out_ter (s, res_empty))\n  | Coq_stat_switch (labs, e, sb) -> run_stat_switch s c labs e sb\n\n(** val run_elements :\n    state -> execution_ctx -> elements -> result **)\n\nand run_elements s c _foo_ = match _foo_ with\n  | [] -> result_out (Coq_out_ter (s, (res_normal Coq_resvalue_empty)))\n  | el :: els_rev_2 ->\n    let%success (s0, rv0)= (run_elements s c els_rev_2) in\n        match el with\n        | Coq_element_stat t ->\n          let%ter (s1, r1) = (run_stat s0 c t) in\n              let r2 = res_overwrite_value_if_empty rv0 r1 in\n              res_out (Coq_out_ter (s1, r2))\n        | Coq_element_func_decl (name, args, bd) -> res_ter s0 (res_normal rv0)\n\n(** val run_prog : state -> execution_ctx -> prog -> result **)\n\nand run_prog s c _term_ = match _term_ with\n  | Coq_prog_intro (str, els) -> run_elements s c (rev els)\n\n(** val push :\n    state -> execution_ctx -> object_loc -> value list -> float\n    -> result **)\n\nand push s c l args ilen =\n  let vlen = ilen in\n      match args with\n      | [] ->\n        let%not_throw\n           (s0, x) = (object_put s c l ("length")\n             (Coq_value_prim (Coq_prim_number vlen)) throw_true) in\n              result_out (Coq_out_ter (s0,\n                                       (res_val (Coq_value_prim (Coq_prim_number vlen)))))\n      | v :: vs ->\n        let%string \n          (s0, slen) = (to_string s c (Coq_value_prim (Coq_prim_number vlen))) in\n             let%not_throw  (s1, x) = (object_put s0 c l slen v throw_true) in\n                 push s1 c l vs (ilen +. 1.)\n\n(** val run_object_is_sealed :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_is_sealed s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some ext = (run_object_method object_extensible_ s l) in\n        res_ter s (res_val (Coq_value_prim (Coq_prim_bool (not ext))))\n  | x :: xs_2 ->\n    let%run (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_is_sealed]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          if attributes_configurable a\n          then res_ter s0 (res_val (Coq_value_prim (Coq_prim_bool false)))\n          else run_object_is_sealed s0 c l xs_2\n\n(** val run_object_seal :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_seal s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some s0= (run_object_heap_set_extensible false s l) in\n        res_ter s0 (res_val (Coq_value_object l))\n  | x :: xs_2 ->\n    let%run (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_seal]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          let a_2 =\n            if attributes_configurable a\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         None; descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = (Some\n                                                                                         false) }\n              in\n              attributes_update a desc\n            else a\n          in\n          let%bool\n             (s1, x0) = (object_define_own_prop s0 c l x (descriptor_of_attributes a_2)\n               true) in run_object_seal s1 c l xs_2\n\n(** val run_object_freeze :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_freeze s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some s0= (run_object_heap_set_extensible false s l) in\n        res_ter s0 (res_val (Coq_value_object l))\n  | x :: xs_2 ->\n    let%run (s0, d) = (run_object_get_own_prop s c l x) in\n        match d with\n        | Coq_full_descriptor_undef ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s0\n            ("[run_object_freeze]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n        | Coq_full_descriptor_some a ->\n          let a_2 =\n            if (attributes_is_data_dec a) && (attributes_writable a)\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         (Some false); descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = None }\n              in\n              attributes_update a desc\n            else a\n          in\n          let a_3 =\n            if attributes_configurable a_2\n            then let desc = { descriptor_value = None; descriptor_writable =\n                                                         None; descriptor_get = None; descriptor_set = None;\n                              descriptor_enumerable = None; descriptor_configurable = (Some\n                                                                                         false) }\n              in\n              attributes_update a_2 desc\n            else a_2\n          in\n          let%bool\n             (s1, x0) = (object_define_own_prop s0 c l x (descriptor_of_attributes a_3)\n               true) in run_object_freeze s1 c l xs_2\n\n(** val run_object_is_frozen :\n    state -> execution_ctx -> object_loc -> prop_name list ->\n    result **)\n\nand run_object_is_frozen s c l _foo_ = match _foo_ with\n  | [] ->\n    let%some ext = (run_object_method object_extensible_ s l) in\n        res_ter s (res_val (Coq_value_prim (Coq_prim_bool (not ext))))\n  | x :: xs_2 ->\n    let%run (s0, d) = (run_object_get_own_prop s c l x) in\n        let  check_configurable = (fun a ->\n            if attributes_configurable a\n            then res_ter s0 (res_val (Coq_value_prim (Coq_prim_bool false)))\n            else run_object_is_frozen s0 c l xs_2) in\n            match d with\n            | Coq_full_descriptor_undef ->\n              (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                s0\n                ("[run_object_is_frozen]:  Undefined descriptor found in a place where it shouldn\\\'t.")\n            | Coq_full_descriptor_some a ->\n              (match a with\n               | Coq_attributes_data_of ad ->\n                 if attributes_writable (Coq_attributes_data_of ad)\n                 then res_ter s0 (res_val (Coq_value_prim (Coq_prim_bool false)))\n                 else check_configurable (Coq_attributes_data_of ad)\n               | Coq_attributes_accessor_of aa ->\n                 check_configurable (Coq_attributes_accessor_of aa))\n\n(** val run_get_args_for_apply :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    value list specres **)\n\nand run_get_args_for_apply s c l index n =\n  if  index < n\n  then let%string\n       (s0, sindex) = (to_string s c (Coq_value_prim (Coq_prim_number index))) in\n          let%value (s1, v) = (run_object_get s0 c l sindex) in\n              let\n                \n                tail_args = (run_get_args_for_apply s1 c l (index +. 1.) n) in\n                   let%run (s2, tail) = (tail_args) in res_spec s2 (v :: tail)\n  else res_spec s []\n\n(** val valueToStringForJoin :\n    state -> execution_ctx -> object_loc -> float -> string\n    specres **)\n\nand valueToStringForJoin s c l k =\n  let%string\n    \n    (s0, prop) = (to_string s c (Coq_value_prim (Coq_prim_number k))) in\n       let%value (s1, v) = (run_object_get s0 c l prop) in\n           match v with\n           | Coq_value_prim p ->\n             (match p with\n              | Coq_prim_undef -> res_spec s1 ""\n              | Coq_prim_null -> res_spec s1 ""\n              | Coq_prim_bool b ->\n                let%string (s2, s3) = (to_string s1 c v) in res_spec s2 s3\n              | Coq_prim_number n ->\n                let%string (s2, s3) = (to_string s1 c v) in res_spec s2 s3\n              | Coq_prim_string s2 ->\n                let%string (s3, s4) = (to_string s1 c v) in res_spec s3 s4)\n           | Coq_value_object o ->\n             let%string (s2, s3) = (to_string s1 c v) in res_spec s2 s3\n\n(** val run_array_join_elements :\n    state -> execution_ctx -> object_loc -> float -> float ->\n    string -> string -> result **)\n\nand run_array_join_elements s c l k length0 sep sR =\n  if  k < length0\n  then let  ss = (strappend sR sep) in\n      let  sE = (valueToStringForJoin s c l k) in\n          let%run (s0, element) = (sE) in\n              let  sR0 = (strappend ss element) in\n                  run_array_join_elements s0 c l (k +. 1.)\n                    length0 sep sR0\n  else res_ter s (res_val (Coq_value_prim (Coq_prim_string sR)))\n\n(** val run_call_prealloc :\n    state -> execution_ctx -> prealloc -> value -> value list ->\n    result **)\n\nand run_call_prealloc s c b vthis args =\n  match b with\n  | Coq_prealloc_global_is_finite ->\n    let  v = (get_arg 0 args) in\n        let%number (s0, n) = (to_number s c v) in\n            res_ter s0\n              (res_val (Coq_value_prim (Coq_prim_bool\n                                          (not\n                                             (   (JsNumber.isnan n)\n                                              || (n === JsNumber.infinity)\n                                              || (n === JsNumber.neg_infinity))))))\n  | Coq_prealloc_global_is_nan ->\n    let  v = (get_arg 0 args) in\n        let%number (s0, n) = (to_number s c v) in\n            res_ter s0\n              (res_val (Coq_value_prim (Coq_prim_bool\n                                          (JsNumber.isnan n))))\n  | Coq_prealloc_object ->\n    let  value0 = (get_arg 0 args) in begin\n        match value0 with\n        | Coq_value_prim p ->\n          (match p with\n           | Coq_prim_undef -> run_construct_prealloc s c b args\n           | Coq_prim_null -> run_construct_prealloc s c b args\n           | Coq_prim_bool b0 -> to_object s c value0\n           | Coq_prim_number n -> to_object s c value0\n           | Coq_prim_string s0 -> to_object s c value0)\n        | Coq_value_object o -> to_object s c value0\n    end\n  | Coq_prealloc_object_get_proto_of ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p -> run_error s c Coq_native_error_type\n        | Coq_value_object l ->\n          let%some proto = (run_object_method object_proto_ s l) in\n              res_ter s (res_val proto)\n    end\n  | Coq_prealloc_object_get_own_prop_descriptor ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p -> run_error s c Coq_native_error_type\n        | Coq_value_object l ->\n          let%string \n            (s1, x) = (to_string s c (get_arg 1 args)) in\n               let%run (s2, d) = (run_object_get_own_prop s1 c l x) in\n                   from_prop_descriptor s2 c d\n    end\n  | Coq_prealloc_object_define_prop ->\n    let  o = (get_arg 0 args) in\n        let  p = (get_arg 1 args) in\n            let \n              attr = (get_arg 2 args) in begin\n                 match o with\n                 | Coq_value_prim p0 -> run_error s c Coq_native_error_type\n                 | Coq_value_object l ->\n                   let%string (s1, name) = (to_string s c p) in\n                       let%run (s2, desc) = (run_to_descriptor s1 c attr) in\n                           let%bool \n                             (s3, x) = (object_define_own_prop s2 c l name desc true) in res_ter s3 (res_val (Coq_value_object l))\n    end\n  | Coq_prealloc_object_seal ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p -> run_error s c Coq_native_error_type\n        | Coq_value_object l ->\n          let%some \n            _x_ = (object_properties_keys_as_list_option s l) in  run_object_seal s c l _x_\n    end\n  | Coq_prealloc_object_freeze ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p -> run_error s c Coq_native_error_type\n        | Coq_value_object l ->\n          let%some \n            _x_ = (object_properties_keys_as_list_option s l) in  run_object_freeze s c l _x_\n    end\n  | Coq_prealloc_object_prevent_extensions ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p -> run_error s c Coq_native_error_type\n        | Coq_value_object l ->\n          let%some o = (object_binds_option s l) in\n              let o1 = object_with_extension o false in\n              let s_2 = object_write s l o1 in\n              res_ter s_2 (res_val (Coq_value_object l))\n    end\n  | Coq_prealloc_object_is_sealed ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p -> run_error s c Coq_native_error_type\n        | Coq_value_object l ->\n          let%some \n            _x_ = (object_properties_keys_as_list_option s l) in  run_object_is_sealed s c l _x_\n    end\n  | Coq_prealloc_object_is_frozen ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p -> run_error s c Coq_native_error_type\n        | Coq_value_object l ->\n          let%some \n            _x_ = (object_properties_keys_as_list_option s l) in  run_object_is_frozen s c l _x_\n    end\n  | Coq_prealloc_object_is_extensible ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p -> run_error s c Coq_native_error_type\n        | Coq_value_object l ->\n          let%some r = (run_object_method object_extensible_ s l) in\n              res_ter s (res_val (Coq_value_prim (Coq_prim_bool r)))\n    end\n  | Coq_prealloc_object_proto_to_string ->\n    (match vthis with\n     | Coq_value_prim p ->\n       (match p with\n        | Coq_prim_undef ->\n          result_out (Coq_out_ter (s,\n                                   (res_val (Coq_value_prim (Coq_prim_string\n                                                               ("[object Undefined]"))))))\n        | Coq_prim_null ->\n          result_out (Coq_out_ter (s,\n                                   (res_val (Coq_value_prim (Coq_prim_string\n                                                               ("[object Null]"))))))\n        | Coq_prim_bool b0 ->\n          let%object (s1, l) = (to_object s c vthis) in\n              let%some s0= (run_object_method object_class_ s1 l) in\n                  res_ter s1\n                    (res_val (Coq_value_prim (Coq_prim_string\n                                                (strappend\n                                                   ("[object ")\n                                                   (strappend s0 ("]"))))))\n        | Coq_prim_number n ->\n          let%object (s1, l) = (to_object s c vthis) in\n              let%some s0= (run_object_method object_class_ s1 l) in\n                  res_ter s1\n                    (res_val (Coq_value_prim (Coq_prim_string\n                                                (strappend\n                                                   ("[object ")\n                                                   (strappend s0 ("]"))))))\n        | Coq_prim_string s0 ->\n          let%object (s1, l) = (to_object s c vthis) in\n              let%some s2= (run_object_method object_class_ s1 l) in\n                  res_ter s1\n                    (res_val (Coq_value_prim (Coq_prim_string\n                                                (strappend\n                                                   ("[object ")\n                                                   (strappend s2 ("]")))))))\n     | Coq_value_object o ->\n       let%object (s1, l) = (to_object s c vthis) in\n           let%some s0= (run_object_method object_class_ s1 l) in\n               res_ter s1\n                 (res_val (Coq_value_prim (Coq_prim_string\n                                             (strappend\n                                                ("[object ")\n                                                (strappend s0 ("]")))))))\n  | Coq_prealloc_object_proto_value_of -> to_object s c vthis\n  | Coq_prealloc_object_proto_has_own_prop ->\n    let  v = (get_arg 0 args) in\n        let%string (s1, x) = (to_string s c v) in\n            let%object (s2, l) = (to_object s1 c vthis) in\n                let%run (s3, d) = (run_object_get_own_prop s2 c l x) in begin\n                    match d with\n                    | Coq_full_descriptor_undef ->\n                      res_ter s3 (res_val (Coq_value_prim (Coq_prim_bool false)))\n                    | Coq_full_descriptor_some a ->\n                      res_ter s3 (res_val (Coq_value_prim (Coq_prim_bool true)))\n    end\n  | Coq_prealloc_object_proto_is_prototype_of ->\n    let  v = (get_arg 0 args) in begin\n        match v with\n        | Coq_value_prim p ->\n          result_out (Coq_out_ter (s,\n                                   (res_val (Coq_value_prim (Coq_prim_bool false)))))\n        | Coq_value_object l ->\n          let%object (s1, lo) = (to_object s c vthis) in\n              object_proto_is_prototype_of s1 lo l\n    end\n  | Coq_prealloc_object_proto_prop_is_enumerable ->\n    let  v = (get_arg 0 args) in\n        let%string (s1, x) = (to_string s c v) in\n            let%object (s2, l) = (to_object s1 c vthis) in\n                let%run (s3, d) = (run_object_get_own_prop s2 c l x) in begin\n                    match d with\n                    | Coq_full_descriptor_undef ->\n                      res_ter s3 (res_val (Coq_value_prim (Coq_prim_bool false)))\n                    | Coq_full_descriptor_some a ->\n                      res_ter s3\n                        (res_val (Coq_value_prim (Coq_prim_bool\n                                                    (attributes_enumerable a))))\n    end\n  | Coq_prealloc_function_proto ->\n    result_out (Coq_out_ter (s, (res_val (Coq_value_prim Coq_prim_undef))))\n  | Coq_prealloc_function_proto_to_string ->\n    if is_callable_dec s vthis\n    then (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n        ("Function.prototype.toString() is implementation dependent.")\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_apply ->\n    let  thisArg = (get_arg 0 args) in\n        let  argArray = (get_arg 1 args) in\n            if is_callable_dec s vthis\n            then (match vthis with\n                | Coq_value_prim p ->\n                  (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                    s\n                    ("Value is callable, but isn\\\'t an object.")\n                | Coq_value_object thisobj ->\n                  (match argArray with\n                   | Coq_value_prim p ->\n                     (match p with\n                      | Coq_prim_undef ->\n                        run_call s c thisobj thisArg []\n                      | Coq_prim_null ->\n                        run_call s c thisobj thisArg []\n                      | Coq_prim_bool b0 -> run_error s c Coq_native_error_type\n                      | Coq_prim_number n -> run_error s c Coq_native_error_type\n                      | Coq_prim_string s0 -> run_error s c Coq_native_error_type)\n                   | Coq_value_object array ->\n                     let%value\n                       (s0, v) = (run_object_get s c array\n                          ("length")) in\n                          let%run (s1, ilen) = (to_uint32 s0 c v) in\n                              let%run\n                                (s2, arguments_) = (run_get_args_for_apply s1 c array 0. ilen) in\n                                   run_call s2 c thisobj thisArg arguments_))\n            else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_call ->\n    if is_callable_dec s vthis\n    then (match vthis with\n        | Coq_value_prim p ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("Value is callable, but isn\\\'t an object.")\n        | Coq_value_object thisobj ->\n          let (thisArg, a) = get_arg_first_and_rest args in\n          run_call s c thisobj thisArg a)\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_function_proto_bind ->\n    if is_callable_dec s vthis\n    then (match vthis with\n        | Coq_value_prim p ->\n          (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n            s\n            ("Value is callable, but isn\\\'t an object.")\n        | Coq_value_object thisobj ->\n          let (vthisArg, a) = get_arg_first_and_rest args in\n          let\n             o1 = (object_new (Coq_value_object (Coq_object_loc_prealloc\n                                             Coq_prealloc_object_proto))\n               ("Object")) in\n                let \n                  o2 = (object_with_get o1 Coq_builtin_get_function) in\n                     let\n                        o3 = (object_with_details o2 None None None (Some thisobj) (Some\n                                                                                vthisArg) (Some a) None) in\n                           let\n                             \n                             o4 = (object_set_class o3\n                                ("Function")) in\n                                let\n                                   o5 = (object_set_proto o4 (Coq_value_object\n                                                          (Coq_object_loc_prealloc\n                                                             Coq_prealloc_function_proto))) in\n                                      let\n                                         o6 = (object_with_invokation o5 (Some\n                                                                      Coq_construct_after_bind) (Some\n                                                                                                   Coq_call_after_bind) (Some\n                                                                                                                           Coq_builtin_has_instance_after_bind)) in\n                                            let \n                                              o7 = (object_set_extensible o6 true) in\n                                                 let (l, s_2) = object_alloc s o7 in\n                                                 let\n                                                    vlength = (let%some\n                                                      class0 = (run_object_method object_class_ s_2 thisobj) in\n                                                         if string_eq class0\n                                                             ("Function")\n                                                         then let%number\n                                                             (s10, n) = (run_object_get s_2 c thisobj\n                                                                ("length")) in\n                                                                let%run\n                                                                  (s11, ilen) = (to_int32 s10 c (Coq_value_prim\n                                                                                     (Coq_prim_number n))) in\n                                                                     if  ilen <\n                                                                         (number_of_int (LibList.length a))\n                                                                     then res_spec s11 0.\n                                                                     else res_spec s11\n                                                                         (ilen -.\n                                                                          (number_of_int (LibList.length a)))\n                                                         else res_spec s_2 0.) in\n                                                       let%run (s10, length0) = (vlength) in\n                                                           let \n                                                             a0 = ({ attributes_data_value =\n                                                                           (Coq_value_prim (Coq_prim_number  length0));\n                                                                         attributes_data_writable = false;\n                                                                         attributes_data_enumerable = false;\n                                                                         attributes_data_configurable = false }) in\n                                                                let%some\n                                                                  s11 = (object_heap_map_properties_option\n                                                                     s10 l (fun p ->\n                                                                         HeapStr.write p\n                                                                           ("length")\n                                                                           (Coq_attributes_data_of a0))) in\n                                                                     let \n                                                                       vthrower = (Coq_value_object\n                                                                                    (Coq_object_loc_prealloc\n                                                                                       Coq_prealloc_throw_type_error)) in\n                                                                          let  a1 = ({ attributes_accessor_get =\n                                                                                          vthrower; attributes_accessor_set =\n                                                                                                      vthrower;\n                                                                                        attributes_accessor_enumerable = false;\n                                                                                        attributes_accessor_configurable =\n                                                                                          false }) in\n                                                                              let%bool\n                                                                                 (s12, x) = (object_define_own_prop s11 c l\n                                                                                   ("caller")\n                                                                                   (descriptor_of_attributes\n                                                                                      (Coq_attributes_accessor_of a1))\n                                                                                   false) in\n                                                                                    let%bool\n                                                                                       (s13, x0) = (object_define_own_prop s12 c\n                                                                                         l\n                                                                                         ("arguments")\n                                                                                         (descriptor_of_attributes\n                                                                                            (Coq_attributes_accessor_of\n                                                                                               a1)) false) in\n                                                                                          res_ter s13\n                                                                                            (res_val (Coq_value_object l)))\n    else run_error s c Coq_native_error_type\n  | Coq_prealloc_bool ->\n    result_out\n      (let v = (get_arg 0 args) in Coq_out_ter (s,\n                                                           (res_val (Coq_value_prim (Coq_prim_bool\n                                                                                       (convert_value_to_boolean v))))))\n  | Coq_prealloc_bool_proto_to_string ->\n    (match vthis with\n     | Coq_value_prim p ->\n       (match p with\n        | Coq_prim_undef -> run_error s c Coq_native_error_type\n        | Coq_prim_null -> run_error s c Coq_native_error_type\n        | Coq_prim_bool b0 ->\n          res_ter s\n            (res_val (Coq_value_prim (Coq_prim_string\n                                        (convert_bool_to_string b0))))\n        | Coq_prim_number n -> run_error s c Coq_native_error_type\n        | Coq_prim_string s0 -> run_error s c Coq_native_error_type)\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n             if string_eq s0\n                 ("Boolean")\n             then ifx_some_or_default (run_object_method object_prim_value_ s l)\n                 (run_error s c Coq_native_error_type) (fun wo ->\n                     match wo with\n                     | Some v ->\n                       (match v with\n                        | Coq_value_prim p ->\n                          (match p with\n                           | Coq_prim_undef -> run_error s c Coq_native_error_type\n                           | Coq_prim_null -> run_error s c Coq_native_error_type\n                           | Coq_prim_bool b0 ->\n                             res_ter s\n                               (res_val (Coq_value_prim (Coq_prim_string\n                                                           (convert_bool_to_string b0))))\n                           | Coq_prim_number n ->\n                             run_error s c Coq_native_error_type\n                           | Coq_prim_string s1 ->\n                             run_error s c Coq_native_error_type)\n                        | Coq_value_object o -> run_error s c Coq_native_error_type)\n                     | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_bool_proto_value_of ->\n    (match vthis with\n     | Coq_value_prim p ->\n       (match p with\n        | Coq_prim_undef -> run_error s c Coq_native_error_type\n        | Coq_prim_null -> run_error s c Coq_native_error_type\n        | Coq_prim_bool b0 ->\n          res_ter s (res_val (Coq_value_prim (Coq_prim_bool b0)))\n        | Coq_prim_number n -> run_error s c Coq_native_error_type\n        | Coq_prim_string s0 -> run_error s c Coq_native_error_type)\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n             if string_eq s0\n                 ("Boolean")\n             then ifx_some_or_default (run_object_method object_prim_value_ s l)\n                 (run_error s c Coq_native_error_type) (fun wo ->\n                     match wo with\n                     | Some v ->\n                       (match v with\n                        | Coq_value_prim p ->\n                          (match p with\n                           | Coq_prim_undef -> run_error s c Coq_native_error_type\n                           | Coq_prim_null -> run_error s c Coq_native_error_type\n                           | Coq_prim_bool b0 ->\n                             res_ter s\n                               (res_val (Coq_value_prim (Coq_prim_bool b0)))\n                           | Coq_prim_number n ->\n                             run_error s c Coq_native_error_type\n                           | Coq_prim_string s1 ->\n                             run_error s c Coq_native_error_type)\n                        | Coq_value_object o -> run_error s c Coq_native_error_type)\n                     | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_number ->\n    if list_eq_nil_decidable args\n    then result_out (Coq_out_ter (s,\n                                  (res_val (Coq_value_prim (Coq_prim_number JsNumber.zero)))))\n    else let v = get_arg 0 args in to_number s c v\n  | Coq_prealloc_number_proto_value_of ->\n    (match vthis with\n     | Coq_value_prim p ->\n       (match p with\n        | Coq_prim_undef -> run_error s c Coq_native_error_type\n        | Coq_prim_null -> run_error s c Coq_native_error_type\n        | Coq_prim_bool b0 -> run_error s c Coq_native_error_type\n        | Coq_prim_number n ->\n          res_ter s (res_val (Coq_value_prim (Coq_prim_number n)))\n        | Coq_prim_string s0 -> run_error s c Coq_native_error_type)\n     | Coq_value_object l ->\n       ifx_some_or_default (run_object_method object_class_ s l)\n         (run_error s c Coq_native_error_type) (fun s0 ->\n             if string_eq s0 ("Number")\n             then ifx_some_or_default (run_object_method object_prim_value_ s l)\n                 (run_error s c Coq_native_error_type) (fun wo ->\n                     match wo with\n                     | Some v ->\n                       (match v with\n                        | Coq_value_prim p ->\n                          (match p with\n                           | Coq_prim_undef -> run_error s c Coq_native_error_type\n                           | Coq_prim_null -> run_error s c Coq_native_error_type\n                           | Coq_prim_bool b0 -> run_error s c Coq_native_error_type\n                           | Coq_prim_number n ->\n                             res_ter s\n                               (res_val (Coq_value_prim (Coq_prim_number n)))\n                           | Coq_prim_string s1 ->\n                             run_error s c Coq_native_error_type)\n                        | Coq_value_object o -> run_error s c Coq_native_error_type)\n                     | None -> run_error s c Coq_native_error_type)\n             else run_error s c Coq_native_error_type))\n  | Coq_prealloc_array ->\n    run_construct_prealloc s c Coq_prealloc_array args\n  | Coq_prealloc_array_is_array ->\n    let  arg = (get_arg 0 args) in begin\n        match arg with\n        | Coq_value_prim p ->\n          res_ter s (res_val (Coq_value_prim (Coq_prim_bool false)))\n        | Coq_value_object arg0 ->\n          let%some class0= (run_object_method object_class_ s arg0) in\n              if string_eq class0 ("Array")\n              then res_ter s (res_val (Coq_value_prim (Coq_prim_bool true)))\n              else res_ter s (res_val (Coq_value_prim (Coq_prim_bool false)))\n    end\n  | Coq_prealloc_array_proto_to_string ->\n    let%object (s0, array) = (to_object s c vthis) in\n        let%value\n          (s1, vfunc) = (run_object_get s0 c array ("join")) in\n             if is_callable_dec s1 vfunc\n             then (match vfunc with\n                 | Coq_value_prim p ->\n                   (fun s m -> Debug.impossible_with_heap_because __LOC__ s m; Coq_result_impossible)\n                     s1\n                     ("Value is callable, but isn\\\'t an object.")\n                 | Coq_value_object func ->\n                   run_call s1 c func (Coq_value_object array) [])\n             else run_call_prealloc s1 c\n                 Coq_prealloc_object_proto_to_string (Coq_value_object array)\n                 []\n  | Coq_prealloc_array_proto_join ->\n    let  vsep = (get_arg 0 args) in\n        let%object (s0, l) = (to_object s c vthis) in\n            let%value\n               (s1, vlen) = (run_object_get s0 c l\n                 ("length")) in\n                  let%run (s2, ilen) = (to_uint32 s1 c vlen) in\n                      let\n                         rsep = (if not\n                            (value_compare vsep (Coq_value_prim Coq_prim_undef))\n                         then vsep\n                         else Coq_value_prim (Coq_prim_string (","))) in\n                            let%string (s3, sep) = (to_string s2 c rsep) in\n                                if ilen = 0.0\n                                then res_ter s3\n                                    (res_val (Coq_value_prim (Coq_prim_string "")))\n                                else let \n                                    sR = (valueToStringForJoin s3 c l 0.) in\n                                       let%run (s4, sR0) = (sR) in\n                                           run_array_join_elements s4 c l 1. ilen sep sR0\n  | Coq_prealloc_array_proto_pop ->\n    let%object (s0, l) = (to_object s c vthis) in\n        let%value\n           (s1, vlen) = (run_object_get s0 c l\n             ("length")) in\n              let%run (s2, ilen) = (to_uint32 s1 c vlen) in\n                  if ilen = 0.0\n                  then let%not_throw\n                      (s3, x) = (object_put s2 c l\n                         ("length")\n                         (Coq_value_prim (Coq_prim_number JsNumber.zero)) throw_true) in\n                         result_out (Coq_out_ter (s3,\n                                                  (res_val (Coq_value_prim Coq_prim_undef))))\n                  else let%string\n                       (s3, sindx) = (to_string s2 c (Coq_value_prim (Coq_prim_number\n                                                         (ilen -. 1.)))) in\n                          let%value \n                            (s4, velem) = (run_object_get s3 c l sindx) in\n                               let%not_throw\n                                 (s5, x) = (object_delete_default s4 c l sindx throw_true) in\n                                    let%not_throw\n                                      (s6, x0) = (object_put s5 c l\n                                         ("length")\n                                         (Coq_value_prim (Coq_prim_string sindx)) throw_true) in\n                                         result_out (Coq_out_ter (s6, (res_val velem)))\n  | Coq_prealloc_array_proto_push ->\n    let%object (s0, l) = (to_object s c vthis) in\n        let%value\n           (s1, vlen) = (run_object_get s0 c l\n             ("length")) in\n              let%run (s2, ilen) = (to_uint32 s1 c vlen) in\n                  push s2 c l args ilen\n  | Coq_prealloc_string ->\n    if list_eq_nil_decidable args\n    then res_ter s (res_val (Coq_value_prim (Coq_prim_string "")))\n    else let  value0 = (get_arg 0 args) in\n        let%string (s0, s1) = (to_string s c value0) in\n            res_ter s0 (res_val (Coq_value_prim (Coq_prim_string s1)))\n  | Coq_prealloc_string_proto_to_string ->\n    (match vthis with\n     | Coq_value_prim p ->\n       if type_compare (type_of vthis) Coq_type_string\n       then res_ter s (res_val vthis)\n       else run_error s c Coq_native_error_type\n     | Coq_value_object l ->\n       let%some s0= (run_object_method object_class_ s l) in\n           if string_eq s0 ("String")\n           then run_object_prim_value s l\n           else run_error s c Coq_native_error_type)\n  | Coq_prealloc_string_proto_value_of ->\n    (match vthis with\n     | Coq_value_prim p ->\n       if type_compare (type_of vthis) Coq_type_string\n       then res_ter s (res_val vthis)\n       else run_error s c Coq_native_error_type\n     | Coq_value_object l ->\n       let%some s0= (run_object_method object_class_ s l) in\n           if string_eq s0 ("String")\n           then run_object_prim_value s l\n           else run_error s c Coq_native_error_type)\n  | Coq_prealloc_error ->\n    let  v = (get_arg 0 args) in\n        build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                           Coq_prealloc_error_proto)) v\n  | Coq_prealloc_native_error ne ->\n    let  v = (get_arg 0 args) in\n    build_error s c (Coq_value_object (Coq_object_loc_prealloc\n                                       (Coq_prealloc_native_error_proto ne))) v\n  | Coq_prealloc_throw_type_error -> run_error s c Coq_native_error_type\n  | _ ->\n    (fun s -> Debug.not_yet_implemented_because __LOC__ s; Coq_result_not_yet_implemented)\n      (strappend ("Call prealloc_") (strappend (string_of_prealloc b) (" not yet implemented")))\n\n(** val run_call :\n    state -> execution_ctx -> object_loc -> value -> value list\n    -> result **)\n\nand run_call s c l vthis args =\n  let%some co = run_object_method object_call_ s l in\n  let%some c0 = co in\n  match c0 with\n  | Coq_call_default -> entering_func_code s c l vthis args\n  | Coq_call_after_bind ->\n    let%some oarg = run_object_method object_bound_args_ s l in\n    let%some boundArgs = oarg in\n    let%some obnd = run_object_method object_bound_this_ s l in\n    let%some boundThis = obnd in\n    let%some otrg = run_object_method object_target_function_ s l in\n    let%some target = otrg in\n    let arguments_ = (LibList.append boundArgs args) in run_call s c target boundThis arguments_\n  | Coq_call_prealloc b -> run_call_prealloc s c b vthis args\n\n(** val run_javascript_from_state : state -> prog -> result **)\n\nand run_javascript_from_state s p =\n  let c = execution_ctx_initial (prog_intro_strictness p) in\n  let%void s_2 =\n    execution_ctx_binding_inst s c Coq_codetype_global None p [] in\n  run_prog s_2 c p\n\n(** val run_javascript_from_result : result -> prog -> result **)\n\nand run_javascript_from_result w p =\n  if_success w (fun s _ -> run_javascript_from_state s p)\n\n(** val run_javascript : prog -> result **)\n\nand run_javascript p =\n  run_javascript_from_state state_initial p\n'},
];
